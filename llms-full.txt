# Tanssi llms-full.txt
Tanssi. Tanssi is a decentralized infrastructure protocol designed to enable the rapid deployment of sovereign appchains.

## Generated automatically. Do not edit directly.

Documentation: https://docs.tanssi.network/

## List of doc pages:
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/ai-resources/ai-resources.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/account-management/identity.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/account-management/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/account-management/proxy-accounts.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/customize/adding-built-in-module.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/customize/adding-custom-made-module.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/customize/adding-external-module.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/customize/customizing-chain-specs.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/customize/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/customize/prerequisites.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/templates/custom-runtime.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/templates/evm.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/templates/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/templates/overview.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/build/templates/substrate.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/deploy/dapp.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/deploy/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/interoperability/built-in-bridge.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/interoperability/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/dapp/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/dapp/manage-tokens.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/dapp/register-external-assets.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/dapp/services-payment.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/dapp/xcm-channels.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/developer-portal/impersonate.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/developer-portal/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/developer-portal/maintenance.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/developer-portal/minting.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/developer-portal/pause-transactions.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/developer-portal/smart-contracts-creation-filter.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/developer-portal/sudo.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/developer-portal/upgrade.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/manage/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/tanssi-network/endpoints.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/tanssi-network/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/tanssi-network/mainnet.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/tanssi-network/tanssi-token.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/tanssi-network/testnet/dancelight.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/tanssi-network/testnet/demo-evm-network.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/tanssi-network/testnet/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/dev-env/foundry.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/dev-env/hardhat.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/dev-env/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/dev-env/remix.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/dev-env/thirdweb.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/libraries/ethersjs.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/libraries/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/libraries/viem.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/libraries/web3js.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/libraries/web3py.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/precompiles/batch.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/precompiles/call-permit.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/precompiles/erc20.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/precompiles/external-assets-erc20.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/precompiles/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/precompiles/proxy.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/rpc.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/wallets/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/wallets/ledger.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/wallets/metamask.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/wallets/subwallet.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/ethereum-api/wallets/talisman.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/indexers/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/indexers/sqd/erc20-transfers.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/indexers/sqd/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/indexers/sqd/quick-start.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/oracles/acurast.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/oracles/band.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/oracles/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/oracles/phala.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/wallet-integrations/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/integrations/wallet-integrations/rainbowkit.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/dev-env/chopsticks.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/dev-env/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/libraries/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/libraries/polkadot-js-api.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/libraries/sidecar-api.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/wallets/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/wallets/ledger.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/wallets/subwallet.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/builders/toolkit/substrate-api/wallets/talisman.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/decentralized-networks/included-templates.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/decentralized-networks/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/decentralized-networks/overview.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/decentralized-networks/runtime-features.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/decentralized-networks/tx-fees.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/framework/architecture.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/framework/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/framework/modules.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/framework/overview.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/framework/xcm.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/account-types.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/external-security-providers/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/external-security-providers/symbiotic.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/glossary.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/network-features/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/network-features/staking.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/network-services/block-production.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/network-services/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/overview.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/learn/tanssi/tanssi-ethereum-bridge.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/network-node/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/network-node/tanssi-powered-network/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/network-node/tanssi-powered-network/rpc-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/network-node/tanssi-powered-network/rpc-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/network-node/tanssi/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/network-node/tanssi/tanssi-node-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/network-node/tanssi/tanssi-node-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/offboarding/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/offboarding/opt-out-from-tanssi.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/offboarding/prerequisites.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/offboarding/vault-opt-out.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/onboarding/account-setup.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/onboarding/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/onboarding/opt-in-to-tanssi.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/onboarding/register-in-symbiotic.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/onboarding/run-an-operator/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/onboarding/run-an-operator/operators-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/onboarding/run-an-operator/operators-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/operational-tasks/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/operational-tasks/proxy-accounts.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/operational-tasks/upgrade-your-node/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/offboarding/account.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/offboarding/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/onboarding/account-setup.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/onboarding/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/onboarding/run-a-sequencer/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/operational-tasks/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/operational-tasks/proxy-accounts.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/operational-tasks/upgrade-your-node/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/ai-resources/ai-resources.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/account-management/identity.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/account-management/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/account-management/proxy-accounts.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/customize/adding-built-in-module.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/customize/adding-custom-made-module.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/customize/adding-external-module.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/customize/customizing-chain-specs.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/customize/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/customize/prerequisites.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/templates/custom-runtime.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/templates/evm.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/templates/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/templates/overview.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/build/templates/substrate.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/deploy/dapp.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/deploy/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/interoperability/built-in-bridge.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/interoperability/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/dapp/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/dapp/manage-tokens.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/dapp/register-external-assets.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/dapp/services-payment.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/dapp/xcm-channels.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/developer-portal/impersonate.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/developer-portal/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/developer-portal/maintenance.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/developer-portal/minting.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/developer-portal/pause-transactions.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/developer-portal/smart-contracts-creation-filter.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/developer-portal/sudo.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/developer-portal/upgrade.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/manage/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/tanssi-network/endpoints.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/tanssi-network/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/tanssi-network/mainnet.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/tanssi-network/tanssi-token.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/tanssi-network/testnet/dancelight.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/tanssi-network/testnet/demo-evm-network.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/tanssi-network/testnet/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/dev-env/foundry.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/dev-env/hardhat.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/dev-env/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/dev-env/remix.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/dev-env/thirdweb.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/libraries/ethersjs.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/libraries/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/libraries/viem.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/libraries/web3js.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/libraries/web3py.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/precompiles/batch.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/precompiles/call-permit.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/precompiles/erc20.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/precompiles/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/precompiles/proxy.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/rpc.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/wallets/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/wallets/ledger.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/wallets/metamask.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/wallets/subwallet.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/ethereum-api/wallets/talisman.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/indexers/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/indexers/sqd/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/indexers/sqd/quick-start.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/oracles/acurast.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/oracles/band.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/oracles/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/oracles/phala.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/wallet-integrations/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/integrations/wallet-integrations/rainbowkit.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/dev-env/chopsticks.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/dev-env/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/libraries/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/libraries/polkadot-js-api.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/libraries/sidecar-api.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/wallets/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/wallets/ledger.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/wallets/subwallet.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/builders/toolkit/substrate-api/wallets/talisman.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/decentralized-networks/included-templates.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/decentralized-networks/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/decentralized-networks/overview.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/decentralized-networks/runtime-features.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/decentralized-networks/tx-fees.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/framework/architecture.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/framework/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/framework/modules.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/framework/overview.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/framework/xcm.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/account-types.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/external-security-providers/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/external-security-providers/symbiotic.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/glossary.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/network-features/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/network-features/staking.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/network-services/block-production.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/network-services/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/overview.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/learn/tanssi/tanssi-ethereum-bridge.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/network-node/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/network-node/tanssi-powered-network/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/network-node/tanssi-powered-network/rpc-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/network-node/tanssi-powered-network/rpc-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/network-node/tanssi/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/network-node/tanssi/tanssi-node-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/network-node/tanssi/tanssi-node-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/offboarding/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/offboarding/opt-out-from-tanssi.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/offboarding/prerequisites.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/offboarding/vault-opt-out.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/onboarding/account-setup.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/onboarding/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/onboarding/opt-in-to-tanssi.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/onboarding/register-in-symbiotic.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/onboarding/run-an-operator/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/onboarding/run-an-operator/operators-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/onboarding/run-an-operator/operators-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/operational-tasks/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/operational-tasks/proxy-accounts.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/operational-tasks/upgrade-your-node/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/offboarding/account.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/offboarding/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/onboarding/account-setup.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/onboarding/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/onboarding/run-a-sequencer/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/operational-tasks/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/operational-tasks/proxy-accounts.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/operational-tasks/upgrade-your-node/index.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker.md
Doc-Page: https://raw.githubusercontent.com/moondance-labs/tanssi-docs/refs/heads/main/pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd.md

## Full content for each doc page

Doc-Content: https://docs.tanssi.network/ai-resources/ai-resources/
--- BEGIN CONTENT ---
---
title: AI Resources
description: Download LLM-optimized files of the Tanssi documentation, including full content and category-specific resources for AI agents.
---

# AI Resources

Tanssi provides `.txt` files containing the documentation content and navigation structure, optimized for use with large language models (LLMs) and AI tools. These resources help build AI assistants, power code search, or enable custom tooling trained on Tanssiâ€™s documentation.

Each category file includes foundational content from the **Basics** and **Reference** categories to ensure LLMs have the necessary context.

## Download LLM Files

| Category           | Description                                                                                                                              | File                          | Actions                                                                                                                                                                                                 |
|--------------------|------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Index              | Navigation index of all Tanssi documentation pages                                                                                       | `llms.txt`                    | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms.txt" } [:octicons-download-16:](/llms.txt){ download="llms.txt" }                                                                     |
| Full Documentation | Full content of all documentation pages                                                                                                  | `llms-full.txt`               | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-full.txt" } [:octicons-download-16:](/llms-full.txt){ download="llms-full.txt" }                                                      |
| Basics             | Tanssi's framework, architecture, and core components to help form overall general knowledge base                                        | `llms-basics.txt`             | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-basics.txt" } [:octicons-download-16:](/llms-files/llms-basics.txt){ download="llms-basics.txt" }                                     |
| Reference          | Reference material including network endpoints, JSON RPC methods, and contract or token addresses                                        | `llms-reference.txt`          | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-reference.txt"} [:octicons-download-16:](/llms-files/llms-reference.txt){ download="llms-reference.txt" }                             |
| Appchain           | How to launch and manage an appchain through the dApp or the developer portal                                                            | `llms-appchain.txt`           | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-appchain.txt" } [:octicons-download-16:](/llms-files/llms-appchain.txt){ download="llms-appchain.txt" }                               |
| Custom Runtime     | Customize your appchain runtime                                                                                                          | `llms-custom-runtime.txt`     | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-custom-runtime.txt" } [:octicons-download-16:](/llms-files/llms-custom-runtime.txt){ download="llms-custom-runtime.txt" }             |
| EVM Template       | Use the EVM template for launching complete Ethereum-compatible appchains and know their associated tooling (wallet, integrations, etc.) | `llms-evm-template.txt`       | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-evm-template.txt" } [:octicons-download-16:](/llms-files/llms-evm-template.txt){ download="llms-evm-template.txt" }                   |
| Substrate Template | Use the baseline Substrate template and associated tooling (wallets, integrations, etc.) for launching appchains                         | `llms-substrate-template.txt` | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-substrate-template.txt" } [:octicons-download-16:](/llms-files/llms-substrate-template.txt){ download="llms-substrate-template.txt" } |
| Operators          | How to set up and run a node to secure the Tanssi ecosystem                                                                              | `llms-operators.txt`          | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-operators.txt" } [:octicons-download-16:](/llms-files/llms-operators.txt){ download="llms-operators.txt" }                            |
| Sequencers         | How to run a sequencer to provide appchains with block production services                                                               | `llms-sequencers.txt`         | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-sequencers.txt" } [:octicons-download-16:](/llms-files/llms-sequencers.txt){ download="llms-sequencers.txt" }                         |

!!! note
    The `llms-full.txt` file may exceed the input limits of some language models due to its size. If you encounter limitations, consider using the files by category.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/account-management/identity/
--- BEGIN CONTENT ---
---
title: Set an Account Identity
description: Follow these instructions to establish an identity, including a display name so that you can be more easily recognizable on the Tanssi orchestrator chain.
icon: octicons-person-24
categories: Basics, Appchain
---

# Set Up an On-Chain Identity

## Introduction {: #introduction }

The [Substrate](/learn/framework/overview/#substrate-framework){target=\_blank} Identity [module](/learn/framework/modules/){target=\_blank} is an out-of-the-box solution for adding personal information to your on-chain account. Establishing an identity makes it easier for your account to be recognized by others, as your display name will automatically populate when someone pastes your address into a field on the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/accounts){target=\_blank}.

The identity you configure goes beyond a simple display name. Personal information can include default fields such as your legal name, display name, website, Twitter handle, Discord, and Riot (now known as Element) name. You can also use custom fields to include any other relevant information.

This guide will demonstrate setting up an identity with a display name and additional parameters, enhancing your visibility and recognizability.

## General Definitions {: #general-definitions }

To store your information on-chain, you must bond some funds, which will eventually be returned once the identity has been cleared. There are two categories of fields: default and custom. A basic deposit amount is reserved upon identity creation, and a storage deposit is required for each additional byte of data stored on-chain.

- **Default fields include** - your legal name, display name, website, Twitter handle, Discord, Riot (now known as Element) name

- **Custom fields include** - any other relevant information

- **Subaccounts** - You can link subaccounts underneath a primary account. As an example, a sequencer service that's running multiple different sequencer nodes can establish subaccounts to demonstrate an official link between the nodes

=== "Tanssi MainNet"

    |       Variable        |                                    Definition                                    |                                        Value                                         |
    |:---------------------:|:--------------------------------------------------------------------------------:|:------------------------------------------------------------------------------------:|
    |     Basic deposit     |                The amount held on deposit for setting an identity                |  {{ networks.mainnet.identity.basic_deposit }} {{ networks.mainnet.token_symbol }}   |
    |   Deposit per byte    | The amount held on deposit per byte of on-chain storage used setting an identity | {{ networks.mainnet.identity.per_byte_deposit }} {{ networks.mainnet.token_symbol }} |
    | Max additional fields |         Maximum number of additional fields that may be stored in an ID          |                      {{ networks.mainnet.identity.max_fields }}                      |
    |    Max subaccounts    |   Maximum number of subaccounts that can be defined under an account identity    |                   {{ networks.mainnet.identity.max_subaccounts }}                    |

=== "Dancelight TestNet"

    |       Variable        |                                    Definition                                    |                                           Value                                            |
    |:---------------------:|:--------------------------------------------------------------------------------:|:------------------------------------------------------------------------------------------:|
    |     Basic deposit     |                The amount held on deposit for setting an identity                |  {{ networks.dancelight.identity.basic_deposit }} {{ networks.dancelight.token_symbol }}   |
    |   Deposit per byte    | The amount held on deposit per byte of on-chain storage used setting an identity | {{ networks.dancelight.identity.per_byte_deposit }} {{ networks.dancelight.token_symbol }} |
    | Max additional fields |         Maximum number of additional fields that may be stored in an ID          |                       {{ networks.dancelight.identity.max_fields }}                        |
    |    Max subaccounts    |   Maximum number of subaccounts that can be defined under an account identity    |                     {{ networks.dancelight.identity.max_subaccounts }}                     |

## Checking Prerequisites { : #checking-prerequisites }

To follow along with this guide, you will need the following:

=== "Tanssi MainNet"

    - The [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/accounts){target=\_blank} open and connected to Tanssi MainNet.
    - At least one account funded with `{{ networks.mainnet.token_symbol }}` tokens.

=== "Dancelight TestNet"
    
    - The [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} open and connected to [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.
    - At least one account funded with `{{ networks.dancelight.token_symbol }}` tokens.

If you need help importing your accounts into the developer portal, please check out the [Connecting to the developer portal](/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs){target=\_blank} guide.

## Get Started {: #get-started }

Depending on the information to be included, there are a couple of different ways to set and clear an identity using the developer portal. If you intend to register your identity using only the default fields, you can follow the instructions for [Managing an Identity via the Accounts](#manage-via-accounts) page. **This is the recommended way to set and manage your identity**.

If you want to add custom fields beyond the default fields, follow the instructions for [Managing an Identity via the Extrinsics](#manage-via-extrinsics) page.

!!! note
    Please note that using the **Accounts** page on the developer portal is recommended to manage your identity as it provides an easy-to-use interface that enforces character limits. If you use the **Extrinsics** page, please be aware that your input for each field (i.e., name, email, etc.) must be 32 characters or less; otherwise, your information will be cut off.

## Manage an Identity via Accounts {: #manage-via-accounts }

### Set an Identity {: #set-identity-accounts }

To get started with setting an identity using the Accounts page, head to the [**Accounts** tab](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/accounts){target=\_blank} of the developer portal.

You should already have an account connected, so you can click on your account name to verify and note your balances. After you send the transaction to set an identity, the deposit(s) you submitted will be moved from your transferable balance to your reserved balance.

![Starting account balances](/images/builders/account-management/identity/identity-1.webp)

To set your identity, you'll need to:

1. Click on the three vertical dots next to the account you would like to set an identity for
2. A menu will pop up. Click **Set on-chain identity**

![Set on-chain identity](/images/builders/account-management/identity/identity-2.webp)

Next, the menu to register and set your identity will pop up, and you can start filling in your information. You are not required to enter information for every single field; you can choose to fill in just one field or all of them; it's up to you. For this example:

1. Set your display name
2. Click on the **include field** toggle for email and then enter in your email
3. Click on the **include field** toggle for web and then enter in your website URL
4. Click on the **include field** toggle for Twitter and then enter in your Twitter handle
5. Review the prior data fields and click **Set Identity**

![Set your identity](/images/builders/account-management/identity/identity-3.webp)

You will then be prompted to sign the transaction. If everything looks good, sign it.

You should see status notifications pop up in the top right-hand corner. Once the transaction has been confirmed, you can click on your account name again, and the panel will slide out on the right side of the page. Your balances will have changed, and you'll also see your new identity information.

![Updated account balances](/images/builders/account-management/identity/identity-4.webp)

If the identity information matches what you entered, you've successfully set an identity!

Once you clear your identity, the deposit in your reserved balance will get transferred back to your transferable balance. If you need to change your identity, you can go through the process of setting your identity again. Please note that you must ensure all fields are re-entered, even if only one field needs to be changed, or they will be overwritten. You will not need to pay another deposit unless custom fields are used, but you will need to pay gas fees.

## Manage an Identity via Extrinsics {: #manage-via-extrinsics }

### Set an Identity {: #set-identity-extrinsics }

To register an identity using the extrinsics page, navigate to the [**Extrinsics** page](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/extrinsics){target=\_blank} of the developer portal. Please ensure your input does not exceed 32 characters for each identity field. To complete your identity, take the following steps:

1. Select your account
2. Select identity from the **submit the following extrinsic** dropdown
3. Then select the **setIdentity(info)** function
4. Select **Raw** as the data format to enter your **Display Name**
5. Enter the data for **Display** in the selected format
6. Select **Raw** as the data format to enter your web address
7. Enter your website URL in the selected format
8. Select **Raw** as the data format to enter your email
9. Enter your email address in the selected format
10. Select **Raw** as the data format to enter your Twitter handle
11. Enter your Twitter in the selected format. Enter the username only, starting with the `@` symbol
12. Review the prepared fields and press **Submit Transaction**

![Set on-chain identity](/images/builders/account-management/identity/identity-5.webp)

Optionally, if you would like to enter custom fields, take the following steps:

1. Scroll to the top and click on **Add item**
2. Two fields will appear: the first for the field name and the second for the value. Select **Raw** as the data format to enter the field name
3. Enter the field name in the specified format
4. Select **Raw** as the data format to enter the custom value
5. Enter the custom value in the specified format

![Add custom fields](/images/builders/account-management/identity/identity-6.webp)

Finally, once all of your identity information has been added, you can scroll to the bottom of the page and click **Submit Transaction**.

You will then be prompted to sign the transaction. Remember, an additional deposit is required for each additional custom field. If everything looks good, sign the transaction.

You should see status notifications pop up in the top right-hand corner confirming the transaction. If successful, you've set an identity! Congratulations! To ensure everything went through and your identity information looks good, you can verify your identity.

### Confirm an Identity {: #confirm-identity-extrinsics }

To verify the addition of your identity information, you can click on the **Developer** tab and then navigate to [**Chain state**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/chainstate){target=\_blank}.

On the **Chain State** page, make sure **Storage** is selected. Then you can start to request your identity information:

1. Set **selected state query** to **identity**
2. Select the **identityOf(AccountId)** function
3. Select your account
4. Click the **+** button to get your identity information

![Request identity information](/images/builders/account-management/identity/identity-7.webp)

You can see now that you've successfully set an identity! Once you clear your identity, the deposit in your reserved balance will get transferred back to your transferable balance. If you need to change your identity, you can go through the process of setting your identity again. Please note that you must ensure all fields are re-entered, even if only one field needs to be changed, or they will be overwritten. You will not need to pay another deposit unless custom fields are used, but you will need to pay gas fees.

## Clear an Identity {: #confirm-identity-extrinsics }

To clear your identity, take the following steps from **Extrinsics** tab of the developer portal:

1. Select your account from the **using the selected account** dropdown
2. Select **identity** from the **submit the following extrinsic** dropdown
3. Then select the **clearIdentity()** function
4. Click **Submit Transaction**

![Clear an identity](/images/builders/account-management/identity/identity-8.webp)

You will then be prompted to sign the transaction. If everything looks good, sign it. You should see status notifications in the top right-hand corner confirming the transaction.

To confirm that your identity information has been successfully removed, revisit the steps outlined in the [Confirm an Identity section](#confirm-identity-extrinsics). This time, instead of displaying your identity details, the response should indicate **none**, confirming that no identity information is currently linked to your account. Additionally, when you check your balances, you will find that the deposit initially made for setting your identity has been credited back to your transferable balance. This completes the process of clearing your identity.

![Clear an identity confirmation](/images/builders/account-management/identity/identity-9.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/account-management/
--- BEGIN CONTENT ---
---
title: Account Management
description: Learn how to manage all account related activities such as the creation, maintenance, and removal of proxies and identities.
icon: octicons-person-add-24
template: index-page.html
---

# Account Management

On-chain account management gives users and developers greater flexibility and control over how their accounts interact with a decentralized network. You can fine-tune your account configurations for seamless integration within the ecosystem by managing roles, permissions, and identities directly on-chain.

This section outlines some of the tools and features related to account management.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/account-management/proxy-accounts/
--- BEGIN CONTENT ---
---
title: Set Up and Manage Proxy Accounts
description: Follow these step-by-step instructions to learn how proxies work and how to create, view, update, and remove proxy accounts from primary (proxied) accounts.
icon: octicons-shield-lock-24
categories: Basics, Appchain
---

# Proxy Accounts

## Introduction {: #introduction }

Proxy accounts can be set up to perform a limited number of actions on behalf of primary accounts and are helpful for keeping the underlying accounts safe. Your proxy account can act as a "hot wallet" to interact with the network on behalf of your "cold wallet" account. For added safety, you can regularly rotate the proxy account. 

Proxy accounts can also help you implement the principle of least privilege for access control. For example, if you have multiple team members, you can give them the minimum level of access required to carry out their duties via a specific type of proxy account. 

This tutorial will walk you through configuring a proxy account on Dancelight, the Tanssi TestNet, specifically for balance transfers. Then, it will demonstrate performing a balance transfer using the newly created proxy.

## Checking Prerequisites {: #checking-prerequisites }

To follow along with this tutorial, you will need to have:

- [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} open and connected to [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.
- Create or have two accounts accessible on the developer portal.
- At least one of the accounts will need to be funded with `{{ networks.dancelight.token_symbol }}` tokens.

If you need help importing your accounts into Polkadot.js Apps, please check out the [Connecting to Polkadot.js](/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs){target=\_blank} guide.

## General Definitions {: #general-definitions }

When setting up a proxy account, a bond for the proxy is taken out of your free balance and moved to your reserved balance. The bond is required as adding a proxy requires on-chain storage space, and it is recalculated for each proxy you add or remove. The bond is returned to your free balance after all proxies are removed from your account.

The deposit is calculated based on a deposit base and a deposit factor:

- **Deposit base** - the amount to be reserved for an account to have a proxy list.
- **Deposit factor** - the additional amount to be reserved for every proxy the primary account has.

The equation for calculating the deposit is:

```text
deposit base + deposit factor * number of proxies
```

You can find each of the relevant variables below.

=== "Tanssi MainNet"
    |    Variable    |                                      Value                                       |
    |:--------------:|:--------------------------------------------------------------------------------:|
    |  Deposit base  |  {{ networks.mainnet.proxy.deposit_base }} {{ networks.mainnet.token_symbol }}  |
    | Deposit factor | {{ networks.mainnet.proxy.deposit_factor }} {{ networks.mainnet.token_symbol }} |
    |  Max proxies   |                 {{ networks.mainnet.proxy.max_proxies }} proxies                 |

=== "Dancelight TestNet"
    |    Variable    |                                         Value                                          |
    |:--------------:|:--------------------------------------------------------------------------------------:|
    |  Deposit base  |  {{ networks.dancelight.proxy.deposit_base }} {{ networks.dancelight.token_symbol }}  |
    | Deposit factor | {{ networks.dancelight.proxy.deposit_factor }} {{ networks.dancelight.token_symbol }} |
    |  Max proxies   |                  {{ networks.dancelight.proxy.max_proxies }} proxies                   |

## Proxy Types {: #proxy-types }

When creating a proxy account, you must choose a type of proxy that will define how the proxy can be used. The available options are:

- **`Any`** - allows the proxy account to use any function supported by the proxy pallet. There is no filtering of calls.
- **`NonTransfer`** - this type of proxy account is allowed to submit any type of transaction with the exception of balance transfers.
- **`Balances`** - allows the proxy account to only make transactions related to sending funds.
- **`Governance`** - allows the proxy account to only make transactions related to the governance pallet, such as voting or creating democracy proposals. Note, governance is not yet enabled on Tanssi. You can create governance proxy accounts but they will not be able to take any actions until governance is enabled. 
- **`Registrar`** - allows the proxy account to only make transactions related to the registrar pallet.
- **`SudoRegistrar`** - allows the proxy account to only make transactions related to the registrar pallet that need to be called by Sudo.
- **`CancelProxy`** - allows the proxy account to reject and remove any announced proxy calls.
- **`Staking`** - allows the proxy account to perform staking-related transactions, such as sequencer and `session()` functions.
- **`SessionKeyManagement`** - allows the proxy account to make key management related transactions included in the session pallet.

For this guide, you will be setting up a proxy account using the balances proxy type. Since this type enables the proxy to spend funds on behalf of the primary account, you should exercise caution and only provide access to accounts you trust. The proxy will have access to transfer all of the funds within the primary account, and if not trusted, the proxy could drain the primary account. Ensure that you maintain oversight of your proxy accounts and remove any proxies that are no longer needed.

## Creating a Proxy Account {: #creating-a-proxy-account }

There are a couple of ways you can create proxy accounts in [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/accounts){target=\_blank}, either from the **Extrinsics** page or the **Accounts** page. However, to create a time-delayed proxy, you will need to use the **Extrinsics** page. A time delay provides an additional layer of security to proxies by specifying a delay period based on the number of blocks. This will prevent the proxy account from executing a transaction until the delay period ends. The delay allows time for the primary account that controls the proxy to review pending transactions, potentially for malicious actions, and cancel if necessary before execution.

The following demo will showcase configuring a Balances proxy, which allows for transferring funds, making it perfect for demonstration purposes. After configuring your Balances proxy you can try transferring funds from the primary account via proxy. 

To get started creating your proxy account, head to the **Developer** tab and select [**Extrinsics**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank} from the dropdown. Next, you will need to take the following steps:

1. Select the primary account.
2. From the **submit the following extrinsic** dropdown, select **proxy**.
3. Choose the **addProxy** extrinsic.
4. Choose **Id** from the **AccountIdLookupOf** dropdown.
5. Select the **delegate** account for the proxy.
6. From the **proxyType** dropdown, choose **Balances**.
7. Optionally, you can add a time delay using a specified number of blocks to add an additional layer of security for the primary account to review the pending transaction.
8. Click **Submit Transaction**.

![Add a proxy account from the Extrinsics page of Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-1.webp)

You will then be prompted to authorize and sign the transaction. Click **Sign and Submit** to create the proxy relationship. Once the transaction has been successfully submitted, you will receive some notifications confirming the transaction.

As previously mentioned, you can also create a proxy from the **Accounts** page. To do so, navigate to the **Accounts** page and take the following steps:

1. Select the three vertical dots next to the primary account.
2. Select **Add proxy**.

![Select the Add proxy menu item from the Accounts page of Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-2.webp)

!!! note
    If the account already has a proxy, **Manage proxies** will be displayed as an option instead of **Add proxy**.

A pop-up will appear and you can enter in the required information, such as the proxied/primary account, the proxy account, and type of proxy to create a proxy account. First click **Add Proxy**.

![Add a proxy account from the Accounts page of Polkadot.js Apps](/images/builders/account-management/proxy/proxy-3.webp)

Then, take the following steps:

1. Select the account you would like to set as a proxy.
2. Select the proxy type.
3. Click **Submit** and sign the transaction.

![Add the details of the proxy account, including the proxy account and type.](/images/builders/account-management/proxy/proxy-4.webp)

In the next section, you will learn how to verify that your proxy account was set up successfully.

## Verifying Your Proxy Account {: #verifying-your-proxy-account }

You can verify that your proxy account has been successfully set up in a couple of ways: either through the **Accounts** page or via the **Chain state** page.

To check your proxy accounts from the [**Chain state** page](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, you can take the following steps:

1. From the **selected state query** dropdown, select **proxy**.
2. Choose the **proxies** extrinsic.
3. Select your primary/proxied account.
4. Click on the **+** button to send the query.

![Verify your proxy accounts via the Extrinsics page of Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-5.webp)

The result will appear on the page showing you information about all of your proxies, including the delegate/proxy account address, the proxy type, the delay period if one was specified, and the total bond amount for all of your proxies in Planck.

You can also check your proxy accounts from the **Accounts** page. To do so, navigate to the **Accounts** page, and there should be a Proxy symbol next to the primary account. Hover over the icon and click on **Manage proxies** to review your proxies.

![Hover over the proxy icon to manage your proxies via the Accounts page of Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-6.webp)

A pop-up will appear where you can see an overview of all of your proxy accounts.

![Review your proxy accounts.](/images/builders/account-management/proxy/proxy-7.webp)

## Executing a Proxy Transaction {: #executing-a-proxy-transaction }

Now that you have created a proxy account and verified that it was successfully set up, you can execute a transaction using the proxy account on behalf of the primary account.

To execute a transaction, you can navigate back to the [**Extrinsics** page](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank} and take the following steps:

1. Select the proxy account to submit the transaction from the **using the select account** dropdown.
2. From the **submit the following extrinsic** menu, select **proxy**.
3. Choose the **proxy** extrinsic.
4. Choose **Id** from the **AccountIdLookupOf** dropdown.
5. Select the primary account from the **real** dropdown.
6. Select the **balances** call.
7. Choose the **transferKeepAlive** extrinsic.
8. Choose **Id** from the **AccountIdLookupOf** dropdown.
9. In the **dest** field, enter the address you would like to send funds to.
10. In the **value** field, enter the amount of {{ networks.dancelight.token_symbol }} tokens to send. For this example, you can send `2` {{ networks.dancelight.token_symbol }} tokens.
11. Click **Submit Transaction**.

![Execute a proxy transaction from the Extrinsics page of Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-8.webp)

A pop-up will appear for you to authorize and sign the transaction. Enter your password for the proxy account and click **Sign and Submit**.

If the transaction successfully went through, you should see a couple of notification pop-ups. If you head over to the **Accounts** page, you'll see that your primary account balance has decreased. If you check the account balance where you sent the funds, you'll notice the balance there has increased.

![Check balance on the accounts page of Polkadot.js Apps](/images/builders/account-management/proxy/proxy-9.webp)

That's it! You've successfully executed a transaction using a proxy account on behalf of your primary account.

## Removing a Proxy Account {: #removing-a-proxy-account }

Similarly to adding a proxy account, there are a couple of ways that you can remove a proxy account, either from the **Extrinsics** page or the **Accounts** page. Regardless of which page you use, you can elect to remove a single proxy account or all proxies associated with your primary account.

To remove a proxy from the [**Extrinsics** page](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, you can take the following steps:

1. From the **using the selected account** dropdown, select your primary account.
2. Then select **proxy**.
3. Choose **removeProxy** to remove a single proxy or **removeProxies** to remove all associated proxies.
4. Choose **Id** from the **AccountIdLookupOf** dropdown.
5. If removing a single proxy, enter the proxy account to remove in the **delegate** field.
6. Select the **proxyType** to remove, in this case choose **Balances**.
7. Optionally, select a delay period in block numbers.
8. Click **Submit Transaction**.

![Remove a proxy account from the Extrinsics page of Polkadot.js Apps](/images/builders/account-management/proxy/proxy-10.webp)

A pop-up will appear asking you to authorize and sign the transaction. You can sign and send the transaction from the primary or proxy account, but the call to remove the proxy must be sent from the primary account. Enter your password and click **Sign and Submit**.

To check that the proxy or proxy accounts have been removed, follow the steps in the [Verifying your Proxy Account](#verifying-your-proxy-account) section.

As previously mentioned, you can also remove a proxy from the **Accounts** page. To do so, on the **Accounts** page, select the three vertical dots next to the primary account and select **Manage Proxies**.

![Click on the Manage Proxies button to review and manage your proxy accounts.](/images/builders/account-management/proxy/proxy-11.webp)

A pop-up will appear showing an overview of your proxy accounts. To remove all proxies, you can click on **Clear all**, then you will automatically be prompted to enter your password and submit the transaction. To remove a single proxy, take the following steps:

1. Click the **X** button next to the proxy to remove
2. Press **Submit**

![Remove a proxy account from the Accounts page of Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-12.webp)

On the transaction confirmation screen, take the following steps:

1. Ensure that you do not use a proxy for this call (as this example is a balances proxy, the call to remove the proxy needs to come from the primary account rather than the proxy account).
2. Enter your password for the respective account.
3. Press **Sign and Submit**.

![Remove a proxy account from the Accounts page of Polkadot.js Apps, confirmation](/images/builders/account-management/proxy/proxy-13.webp)

Once the transaction has successfully been submitted, you can review your current proxies, or if you removed all proxies, you will notice the proxy icon is no longer being displayed next to the primary account. And that's it! You've successfully created a proxy, reviewed all proxy accounts associated with your primary account, executed a proxy transaction, and removed a proxy account!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/customize/adding-built-in-module/
--- BEGIN CONTENT ---
---
title: Adding Built-in Substrate Modules
description: Learn how to leverage Substrate's pre-built, ready-to-use modules to efficiently add new features to your network without building from scratch.
icon: octicons-package-24
categories: Custom-Runtime
---

# Adding a Built-in Module {: #adding-builtin-module }

## Introduction {: #introduction }

Substrate is a powerful and modular software development framework included in the Polkadot SDKs for building blockchains. It provides a comprehensive set of tools and libraries that abstract complex blockchain functionalities, allowing developers to focus on building innovative features and applications by focusing on the runtime, which contains the core logic and the rules of the state transition for the use case.

What sets Substrate apart is its modular architecture, which enables the seamless integration of [built-in modules](https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame){target=\_blank} and the creation of custom ones, facilitating the development of blockchain protocols.

For cases requiring only EVM (Ethereum Virtual Machine) compatibility, the template provided in the [Tanssi repository](https://github.com/moondance-labs/tanssi#container-chain-templates){target=\_blank} fulfills the requirements without further modifications. However, teams aiming to build a Substrate network must add and configure both built-in and custom modules within the runtime. This involves compiling, generating the chain specification, and deploying through the Tanssi protocol to transform it into a live Tanssi-powered network.

This article focuses on the necessary steps for adding a built-in module to the EVM template.

## Checking Prerequisites {: #checking-prerequisites }

To follow the steps in this guide, you will need to have the following:

- A healthy development environment with the Rust compiler and Cargo package manager
- The [Tanssi repository](https://github.com/moondance-labs/tanssi){target=\_blank}, cloned from GitHub

You can read more about how to install the required components in the [prerequisites article](/builders/build/customize/prerequisites/){target=\_blank}.

As this article is based on the EVM template, make sure that it compiles correctly before continuing by executing the following command:

```bash
cargo build -p container-chain-frontier-node --release
```

## Adding a Built-in Module to the Runtime {: #adding-a-built-in-module-to-runtime }

As introduced in the [modularity](/learn/framework/modules/){target=\_blank} article, the Substrate framework already includes many built-in modules addressing a wide range of functionalities, ready to be used in your runtime.

Modules are meant to provide the functionality needed in very different use cases such as DeFi, NFTs, or any other, and, therefore, they are basic building blocks that are inherently abstract and can be configured according to the specific needs of the Tanssi-powered network.

To add a module, the following steps are necessary:

1. Make the dependency available within the project by declaring it in [Cargo](https://doc.rust-lang.org/cargo){target=\_blank}, the Rust language package manager
2. Make the standard (`std`) features of the module available to the compiler
3. Configure the module
4. Add the module to the runtime
5. Add the default configuration to the chain specification

In the following example, the popular Substrate module `pallet-assets` is added to the runtime of the provided EVM template, found in the [Tanssi repository](https://github.com/moondance-labs/tanssi){target=\_blank}, specifically in the folder `container-chains/templates/frontier/`.

### Declare the Dependency {: #declare-dependency }

Every package contains a manifest file named `Cargo.toml` stating, among other things, all the dependencies the package relies on, and the Tanssi-powered network runtime is no exception.

Therefore, the first step, is to declare the dependency and make it available to the runtime, open the `Cargo.toml` file located in the folder `container-chains/templates/frontier/runtime` with a text editor and add the module, referencing the code in the Polkadot SDK:

```toml
[dependencies]
...
pallet-assets = { 
   git = "https://github.com/moondance-labs/polkadot-sdk", 
   branch = "{{ repository.tanssi.release_branch }}", 
   default-features = false 
}
...
```

!!! note
    Our engineering team actively contributes to the Substrate development by fixing issues and enhancing functionalities. As a result, the Tanssi fork repository frequently stays ahead of the official one. That is why this example references a built-in module from a Tanssi repository instead of the official one.

### Make the Standard Features Available to the Compiler {: #standard-features }

In Cargo, the â€œfeaturesâ€ flags provide a mechanism to tell the compiler to include or leave out certain portions of code, which is a useful mechanism to optimize compile time, minimize binary file sizes, or disable certain behavior (for example, not including unit testing or benchmarking functionality in the runtime intended for production).

To compile the standard features for the Assets module within the runtime, the same `Cargo.toml` file in the `runtime` folder must be edited, enabling the flag. Everything listed in this section will ensure that it is available to the compiler when building the runtime binary, which is ultimately the file containing all the information to run your Tanssi-powered network initially.

```toml
[features]
default = [
	"std",
]
std = [
	...,
	"pallet-assets/std",
   ...
]
```
### Configure the Module {: #configure-the-module }

With the dependency declared in the project, the module can now be configured and added to the runtime. To do so, you need to edit the `lib.rs` file that is located at:

```text
container-chains/templates/frontier/runtime/src/lib.rs
```

The configuration of new modules requires implementing a configuration `trait` for the module (in this example, for Assets) in the runtime, expressed in Rust as follows:

```rust
// Implements pallet_assets::Config trait in the runtime
impl pallet_assets::Config for Runtime { ... }
```

[Traits](https://doc.rust-lang.org/book/ch10-02-traits.html){target=\_blank} are a way of defining shared behavior in Rust, and in this case, they allow a new runtime to benefit from the functionality the Assets module provides only by implementing its configuration trait and parameters.

Some of the parameters the trait needs to define might be constant values, in which case, they have to be defined and enclosed within the macro `parameter_types!`, which helps us to reduce the development effort by expanding the code and converting each of the constants into the correct struct type with functions that allow the runtime to read its type and values in a standardized way.

The following code snippet shows an example of the constant definitions to be used in the configuration of the module:

```rust
parameter_types! {
   // The amount of funds that must be reserved for an asset
	pub const AssetDeposit: Balance = 100;
   // The amount of funds that must be reserved when creating 
   // a new transfer approval
	pub const ApprovalDeposit: Balance = 1;
   // The basic amount of funds that must be reserved when adding metadata 
   // to your asset
	pub const MetadataDepositBase: Balance = 10;
   // The additional funds that must be reserved for the number of bytes 
   // you store in your metadata
	pub const MetadataDepositPerByte: Balance = 1;

   // Maximum length for the asset symbol and friendly name
   pub const StringLimit: u32 = 50;
}
```

It is important to note that every built-in module has a different purpose, and, therefore, each of them has different needs in terms of the parameters that must be configured. The following code snippet implements the trait and configures the module Assets, using types and the constants defined previously in the `parameter_types!` macro:

```rust
// Implementing the Assets config trait for the runtime
impl pallet_assets::Config for Runtime {
   
   // Stores the balances in an unsigned integer of 128bits
	type Balance = u128;
   // The id of an asset can be defined as an unsigned integer of 64 bits
	type AssetId = u64;
   // Uses module Balances as mechanism for currency operations
	type Currency = Balances;

   // Configure the module by referencing the previously
   // defined constants

	type AssetDeposit = AssetDeposit;
	type MetadataDepositBase = MetadataDepositBase;
	type MetadataDepositPerByte = MetadataDepositPerByte;
	type ApprovalDeposit = ApprovalDeposit;
	type StringLimit = StringLimit;
   
   // More configuration
   ...
}
```

??? code "View the complete script"

    ```rust
    parameter_types! {
    // The amount of funds that must be reserved for an asset
    pub const AssetDeposit: Balance = 100;
    // The amount of funds that must be reserved when creating 
    // a new transfer approval
    pub const ApprovalDeposit: Balance = 1;
    // The basic amount of funds that must be reserved when adding metadata 
    // to your asset
    pub const MetadataDepositBase: Balance = 10;
    // The additional funds that must be reserved for the number of bytes 
    // you store in your metadata
    pub const MetadataDepositPerByte: Balance = 1;
    // Maximum lenght for the asset symbol and friendly name
    pub const StringLimit: u32 = 50;
}

// Implementing the Assets config trait for the runtime
impl pallet_assets::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;

    // Stores the balances in an unsigned integer of 128bits
    type Balance = u128;
    // The id of an asset can be defined as an unsigned integer of 64 bits
    type AssetId = u64;
    // Uses module Balances as mechanism for currency operations
    type Currency = Balances;

    // Configure the module by referencing the previously
    // defined constants
    type AssetDeposit = AssetDeposit;
    type MetadataDepositBase = MetadataDepositBase;
    type MetadataDepositPerByte = MetadataDepositPerByte;
    type ApprovalDeposit = ApprovalDeposit;
    type StringLimit = StringLimit;

    // More configuration
    type AssetIdParameter = u64;
    // Defines the allowed origins to create assets
    type CreateOrigin = 
        frame_support::traits::AsEnsureOriginWithArg<frame_system::EnsureSigned<AccountId>>;
    // Root can create assets
    type ForceOrigin = EnsureRoot<AccountId>;
    type AssetAccountDeposit = frame_support::traits::ConstU128<1>;
    type Freezer = ();
    type Extra = ();
    type WeightInfo = pallet_assets::weights::SubstrateWeight<Runtime>;
    type RemoveItemsLimit = frame_support::traits::ConstU32<1000>;
    #[cfg(feature = "runtime-benchmarks")]
    type BenchmarkHelper = ();
    type CallbackHandle = ();
}
    ```

The complete configuration of the module contains more parameters, to view a detailed description of each of them, refer to the [official config trait for the Assets module documentation](https://paritytech.github.io/substrate/master/pallet_assets/pallet/trait.Config.html){target=\_blank}.

### Add the Module to the Runtime {: #add-module-to-runtime }

In the same `lib.rs` file referenced in the previous section, there is a segment enclosed in the macro `construct_runtime!()`. This is where the pallet must be added to be included in the runtime. Since the example is based on the EVM template, the runtime is already configured to include many modules, including the modules for system support, the modules to add the Ethereum compatibility layer, the modules to support the Tanssi protocol, balances, and now also Assets:

```rust
construct_runtime!(
   pub enum Runtime where
      Block = Block,
      NodeBlock = opaque::Block,
      UncheckedExtrinsic = UncheckedExtrinsic,
   {
      // System support stuff.
      System: frame_system = 0,
      ParachainSystem: cumulus_pallet_parachain_system = 1,
      Timestamp: pallet_timestamp = 2,
      ParachainInfo: parachain_info = 3,
      Sudo: pallet_sudo = 4,
      Utility: pallet_utility = 5,
      ...
      Balances: pallet_balances = 10,
      // Assets module is added here
      Assets: pallet_assets = 11,
      ...
   }
```

### Configure the Module in the Chain Specification {: #configure-chain-specs }

Finally, add the configuration in the chain specification for the genesis state in the file `chain_spec.rs` located at:

```text
container-chains/templates/frontier/node/src/chain_spec.rs
```

The function `testnet_genesis`, presented in the following code snippet, defines the initial state for the modules included in the runtime (such as initial funded accounts, for example). After adding the Assets module, it is necessary to initialize it as well, and in the following example, its default values are defined.

More about the chain specification and how to configure it will be covered in the article [Customizing Chain Specifications](/builders/build/customize/customizing-chain-specs/){target=\_blank}.

```rust hl_lines="14"
fn testnet_genesis(
   endowed_accounts: Vec<AccountId>,
   id: ParaId,
   root_key: AccountId,
) -> container_chain_template_frontier_runtime::GenesisConfig {
   container_chain_template_frontier_runtime::GenesisConfig {
      system: container_chain_template_frontier_runtime::SystemConfig {
         code: container_chain_template_frontier_runtime::WASM_BINARY
               .expect("WASM binary was not build, please build it!")
               .to_vec(),
      },
      ...
      // Add the default state for this module in the genesis state
      assets: Default::default()
      ...
   }
}
```

With the module included, this new runtime version has unlocked a new set of functionalities ready to be composed with even more of the Substrate built-in modules or custom-made ones.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/customize/adding-custom-made-module/
--- BEGIN CONTENT ---
---
title: Adding a Custom-Made Module
description: Discover how to incorporate custom-made modules to add unique or specialized features to your network that go beyond the capabilities of the built-in modules.
icon: octicons-terminal-24
categories: Custom-Runtime
---

# Adding a Custom-Made Module {: #adding-custom-made-module }

## Introduction {: #introduction }

By providing a comprehensive library of pre-built modules addressing many common requirements, the framework greatly simplifies the process of building a blockchain and accelerates the deployment and evolution into a Tanssi-powered network. However, addressing an innovative use case usually requires a development effort to fully meet the requirements, and, in Substrate, adding custom logic translates into writing and integrating runtime modules.

The example presented in the [Modularity](/learn/framework/modules/#custom-module-example){target=\_blank} article shows a simple lottery module exposing two transactions:

- **Buy tickets** - this function manages a user's entry into the lottery. In essence, it verifies that the participant has a sufficient balance, is not already participating, and takes care of transferring funds to register the user for the lottery
- **Award prize** - this function that handles a user entering into the lottery. At a high level, it fetches a pseudo-random number to obtain a winner and handles the award distribution

The implementation of those transactions also uses storage, emits events, defines custom errors, and relies on other modules to handle currency (to charge for the tickets and transfer the total amount to the winner) and randomize the winner selection.

In this article, the following steps, necessary to build and add the example module to the runtime, will be covered:

1. Create the lottery module files (package)
2. Configure the module's dependencies
3. Adding custom logic
4. Configure the runtime with the new module

It is important to note that none of the code presented in this article is intended for production use.

## Checking Prerequisites {: #checking-prerequisites }

To follow the steps in this guide, you will need to have the following:

- Clone the [Tanssi repository](https://github.com/moondance-labs/tanssi){target=\_blank} from Github
- Rust compiler and Cargo package manager

You can read more about how to install Rust and Cargo is in the [prerequisites article](/builders/build/customize/prerequisites/#installing-rust){target=\_blank}.

## Creating the Lottery Module Files {: #creating-lottery-module-files }

Before starting your coding process, it's essential to create the files containing your logic. Substrate modules are abstract and intended for reuse across different runtimes with various customizations. To achieve this, you'll use Cargo, Rust's package manager, to create the module as a new package.

As mentioned in the prerequisites section, the first step is to clone the [Tanssi repository](https://github.com/moondance-labs/tanssi){target=\_blank} and, from the root folder, navigate to `pallets`, where the module will be created.

```bash
cd container-chains/pallets
```

Next, create the module package with Cargo:

```bash
cargo new lottery-example
```

By default, Cargo creates the new package in a folder with the provided name (`lottery-example`, in this case), containing a manifest file, `Cargo.toml`, and a `src` folder with a `main.rs` file. To respect the naming convention used in Substrate, the `main.rs` file is renamed to `lib.rs`:

```bash
mv lottery-example/src/main.rs lottery-example/src/lib.rs
```

Once you've executed all the commands, the module is created and ready to contain the custom logic that you'll be adding in the following sections.

## Configure the Module's Dependencies {: #configure-module-dependencies}

Since the module functions as an independent package, it has its own Cargo.toml file where you must specify the module's attributes and dependencies.

For instance, you can use attributes to specify details like the module's name, version, authors, and other pertinent information. For example, in the the `lottery-example` module, the `Cargo.toml` file can be configured as follows:

```toml
[package]
name = "module-lottery-example"
version = "4.0.0-dev"
description = "Simple module example"
authors = [""]
homepage = ""
...
```

This file also defines the module's dependencies, such as the core functionality that allows seamless integration with the runtime and other modules, access to storage, event emission, and more.

The full example of the `Cargo.toml` file sets, besides the attributes, the dependencies required by Substrate:

??? code "View the complete Cargo.toml file"

    ```rust
    [package]
name = "module-lottery-example"
version = "4.0.0-dev"
description = "Simple module example"
authors = [""]
homepage = ""
edition = "2021"
publish = false

[package.metadata.docs.rs]
targets = ["x86_64-unknown-linux-gnu"]

[dependencies]
codec = { package = "parity-scale-codec", version = "3.6.1", default-features = false, features = [
	"derive",
] }
scale-info = { version = "2.5.0", default-features = false, features = ["derive"] }
frame-benchmarking = { 
	version = "4.0.0-dev", 
	default-features = false, 
	optional = true, 
	git = "https://github.com/paritytech/substrate.git", 
	branch = "polkadot-v1.0.0" 
}
frame-support = { 
	version = "4.0.0-dev", 
	default-features = false, 
	git = "https://github.com/paritytech/substrate.git", 
	branch = "polkadot-v1.0.0" 
}
frame-system = { 
	version = "4.0.0-dev", 
	default-features = false, 
	git = "https://github.com/paritytech/substrate.git", 
	branch = "polkadot-v1.0.0" 
}

[dev-dependencies]
sp-core = { version = "21.0.0", git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v1.0.0" }
sp-io = { version = "23.0.0", git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v1.0.0" }
sp-runtime = { version = "24.0.0", git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v1.0.0" }

[features]
default = ["std"]
std = [
	"codec/std",
	"frame-benchmarking?/std",
	"frame-support/std",
	"frame-system/std",
	"scale-info/std",
]
runtime-benchmarks = ["frame-benchmarking/runtime-benchmarks"]
try-runtime = ["frame-support/try-runtime"]
    ```

## Adding Custom Logic {: #adding-custom-logic}

As presented in the [custom-made module](/learn/framework/modules/#custom-modules){target=\_blank} section of the modularity article, creating a module involves implementing the following attribute macros, of which the first three are mandatory:

- **`#[frame_support::pallet]`** - this attribute is the entry point that marks the module as usable in the runtime
- **`#[pallet::pallet]`** - applied to a structure that is used to retrieve module information easily
- **`#[pallet::config]`** - is a required attribute to define the configuration for the data types of the module
- **`#[pallet::call]`** -  this macro is used to define functions that will be exposed as transactions, allowing them to be dispatched to the runtime. It is here that the developers add their custom transactions and logic
- **`#[pallet::error]`** - as transactions may not be successful (insufficient funds, as an error example), and for security reasons, a custom module can never end up throwing an exception, all the possible errors are to be identified and listed in an enum to be returned upon an unsuccessful execution
- **`#[pallet::event]`** - events can be defined and used as a means to provide more information to the user
- **`#[pallet::storage]`** - this macro is used to define elements that will be persisted in storage. As resources are scarce in a blockchain, it should be used wisely to store only sensible information

### Implementing the Module Basic Structure {: #implementing-basic-structure }

The first two mandatory macros, `#[frame_support::pallet]` and `#[pallet::pallet]`, provide the basic structure of the module and are required to enable the module to be used in a Substrate runtime.

The following snippet shows the general structure of a custom Substrate module.

```rust
#[frame_support::pallet(dev_mode)]
pub mod pallet {
    ...
    #[pallet::pallet]
    pub struct Pallet<T>(_);
    
    // All the logic goes here
}
```

The next step would be to add the third mandatory macro (`#[pallet::config]`) and all the custom logic, as shown in the following sections.

### Implementing the Module Configuration {: #implementing-module-configuration }

To make the modules highly adaptable, their configuration is abstract enough to allow them to be adapted to the specific requirements of the use case the runtime implements.

The implementation of the `#[pallet::config]` macro is mandatory and sets the module's dependency on other modules and the types and values specified by the runtime-specific settings.

In the custom `lottery-example` module you are building, the module depends on other modules to manage the currency and the random function to select the winner. The module also reads and uses the ticket price and the maximum number of participants directly from the runtime settings.  Consequently, the configuration needs to include these dependencies:

- **Events** - the module depends on the runtime's definition of an event to be able to emit them
- **Currency** - the `lottery-example` module needs to be able to transfer funds, hence, it needs the definition of the currency system from the runtime
- **Randomness** - this module is used to fairly select the winner of the prize from the list of participants. It generates the random numbers using the past block hashes and the current block's number as seed
- **Ticket cost** - the price to charge the buyers that participate in the lottery
- **Maximum number of participants** - the top limit of participants allowed in each lottery round
- **Module Id** - the module unique identifier is required to access the module account to hold the participant's funds until transferred to the winner

The implementation of the described configuration for this example is shown in the following code snippet:

```rust
#[pallet::config]
pub trait Config: frame_system::Config {

    // Event definition
    type RuntimeEvent: From<Event<Self>> 
        + IsType<<Self as frame_system::Config>::RuntimeEvent>;

    // Currency 
    type Currency: Currency<Self::AccountId>;

    // Randomness
    type MyRandomness: Randomness<Self::Hash, BlockNumberFor<Self>>;

    // Ticket cost
    #[pallet::constant]
    type TicketCost: Get<BalanceOf<Self>>;

    // Maximum number of participants
    #[pallet::constant]
    type MaxParticipants: Get<u32>;

    // Module Id
    #[pallet::constant]
    type PalletId: Get<PalletId>;
}
```

This abstract definition of dependencies is crucial to avoid coupling to a specific use case and to enable the modules to serve as basic building blocks for Substrate networks.

### Implementing Transactions {: #implementing-transactions }

Calls represent the behavior a runtime exposes in the form of transactions that can be dispatched for processing, exposing the custom logic added to the module.

Every call is enclosed within the `#[pallet::call]` macro, and present the following elements:

- **Call Index** - is a mandatory unique identifier for every dispatchable call
- **Weight** - is a measure of computational effort an extrinsic takes when being processed. More about weights is in the [Polkadot documentation](https://docs.polkadot.com/polkadot-protocol/parachain-basics/blocks-transactions-fees/fees/#how-fees-are-calculated){target=\_blank}
- **Origin** - identifies the signing account making the call
- **Result** - the return value of the call, which might be an `Error` if anything goes wrong

The following snippet presents the general structure of the mentioned macro implementation and the call elements:

```rust
#[pallet::call]
impl<T: Config> Pallet<T> {
    
    #[pallet::call_index(0)]
    #[pallet::weight(0)]
    pub fn one_call(origin: OriginFor<T>) -> DispatchResult { }

    #[pallet::call_index(1)]
    #[pallet::weight(0)]
    pub fn another_call(origin: OriginFor<T>) -> DispatchResult { }

    // Other calls
}
```

In this `lottery-example` module, we defined two calls with the following logic:

```rust
#[pallet::call]
impl<T: Config> Pallet<T> {
    
    #[pallet::call_index(0)]
    #[pallet::weight(0)]
    pub fn buy_ticket(origin: OriginFor<T>) -> DispatchResult {

        // 1. Validates the origin signature
        // 2. Checks that the user has enough balance to afford the ticket price
        // 3. Checks that the user is not already participating
        // 4. Adds the user as a new participant for the prize
        // 5. Transfers the ticket cost to the module's account, to be hold until transferred to the winner
        // 6. Notify the event
    
    }

    #[pallet::call_index(1)]
    #[pallet::weight(0)]
    pub fn award_prize(origin: OriginFor<T>) -> DispatchResult {

        // 1. Validates the origin signature
        // 2. Gets a random number from the randomness module
        // 3. Selects the winner from the participants lit
        // 4. Transfers the total prize to the winner's account
        // 5. Resets the participants list, and gets ready for another lottery round

    }
}
```

These calls also emit events to keep the user informed and can return errors should any of the validations go wrong.

Here is the complete implementation of the calls with the custom lottery logic:

??? code "View the complete calls code"

    ```rust
    #[pallet::call]
impl<T: Config> Pallet<T> {

    #[pallet::call_index(0)]
    #[pallet::weight(0)]
    pub fn buy_ticket(origin: OriginFor<T>) -> DispatchResult {

        // 1. Validates the origin signature
        let buyer = ensure_signed(origin)?;

        // 2. Checks that the user has enough balance to afford the ticket price
        ensure!(
            T::Currency::free_balance(&buyer) >= T::TicketCost::get(),
            Error::<T>::NotEnoughCurrency
        );

        // 3. Checks that the user is not already participating
        if let Some(participants) = Self::get_participants() {
            ensure!(
                !participants.contains(&buyer),
                Error::<T>::AccountAlreadyParticipating
            );
        }

        // 4. Adds the user as a new participant for the prize
        match Self::get_participants() {
            Some(mut participants) => { 
                ensure!(
                    participants.try_push(buyer.clone()).is_ok(), 
                    Error::<T>::CanNotAddParticipant
                );
                Participants::<T>::set(Some(participants));
            }, 
            None => {
                let mut participants = BoundedVec::new();
                ensure!(
                    participants.try_push(buyer.clone()).is_ok(), 
                    Error::<T>::CanNotAddParticipant
                );
                Participants::<T>::set(Some(participants));
            }
        };

        // 5. Transfers the ticket cost to the module's account
        // to be hold until transferred to the winner
        T::Currency::transfer(
            &buyer, 
            &Self::get_pallet_account(), 
            T::TicketCost::get(), 
            ExistenceRequirement::KeepAlive)?;
        
        // 6. Notify the event
        Self::deposit_event(Event::TicketBought { who: buyer });
        Ok(())
    }

    #[pallet::call_index(1)]
    #[pallet::weight(0)]
    pub fn award_prize(origin: OriginFor<T>) -> DispatchResult {

        // 1. Validates the origin signature
        let _who = ensure_root(origin)?;

        match Self::get_participants() {
            Some(participants) => { 
                
                // 2. Gets a random number from the randomness module
                let nonce = Self::get_and_increment_nonce();
                let (random_seed, _) = T::MyRandomness::random(&nonce);
                let random_number = <u32>::decode(&mut random_seed.as_ref())
                    .expect("secure hashes should always be bigger than u32; qed");
                
                // 3. Selects the winner from the participants lit
                let winner_index = random_number as usize % participants.len();
                let winner = participants.as_slice().get(winner_index).unwrap();

                // 4. Transfers the total prize to the winner's account
                let prize = T::Currency::free_balance(&Self::get_pallet_account());
                T::Currency::transfer(
                    &Self::get_pallet_account(), 
                    &winner, 
                    prize, 
                    ExistenceRequirement::AllowDeath)?;

                // 5. Resets the participants list, and gets ready for another lottery round
                Participants::<T>::kill();

                // 6. Notify the event
                Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );
            }, 
            None => {
                // Notify the event (No participants)
                Self::deposit_event(Event::ThereAreNoParticipants);
            }
        };

        Ok(())
    }
}
    ```

### Implementing Custom Errors {: #implementing-custom-errors}

The `#[pallet::error]` macro is used to annotate an enumeration of potential errors that could occur during execution. It is crucial for security to ensure that all error situations are handled gracefully without causing the runtime to crash.

The following example of this macro implementation shows the errors that might occur in the lottery module:

```rust
// Errors inform users that something went wrong.
#[pallet::error]
pub enum Error<T> {
    NotEnoughCurrency,
    AccountAlreadyParticipating,
    CanNotAddParticipant,
}
```

### Implementing Events {: #implementing-events }

The `#[pallet::event]` macro is applied to an enumeration of events to inform the user of any changes in the state or important actions that happened during the execution in the runtime.

As an example, for the `lottery-example` module, this macro could be configured with the following events:

```rust
#[pallet::event]
#[pallet::generate_deposit(pub(super) fn deposit_event)]
pub enum Event<T: Config> {
    /// Event emitted when a ticket is bought
    TicketBought { who: T::AccountId },
    /// Event emitted when the prize is awarded
    PrizeAwarded { winner: T::AccountId },
    /// Event emitted when there are no participants
    ThereAreNoParticipants,
}
```

### Implementing Storage for State Persistence {: #implementing-storage }

The `#[pallet::storage]` macro initializes a runtime storage structure. In the heavily constrained environment of blockchains, deciding what to store and which structure to use can be critical in terms of performance. More on this topic is covered in the [Substrate documentation](https://docs.polkadot.com/develop/parachains/customize-parachain/make-custom-pallet/#pallet-storage){target=\_blank}.

In this example, the `lottery-example` module needs a basic value storage structure to persist the list of participants in a bounded capacity vector ([BoundedVec](https://crates.parity.io/frame_support/storage/bounded_vec/struct.BoundedVec.html){target=\_blank}). This can be initialized as follows:

```rust
#[pallet::storage]
#[pallet::getter(fn get_participants)]
pub(super) type Participants<T: Config> = StorageValue<
    _,
    BoundedVec<T::AccountId, T::MaxParticipants>,
    OptionQuery
>;
```

### The Complete Module {: #complete-module }

To put all the pieces together, after implementing all the required macros and adding the custom logic, the module is now complete and ready to be used in the runtime.

??? code "View the complete module file"

    ```rust
    #![cfg_attr(not(feature = "std"), no_std)]

/// Learn more about FRAME and the core library of Substrate FRAME pallets:
/// <https://docs.substrate.io/reference/frame-pallets/>
pub use pallet::*;

#[frame_support::pallet(dev_mode)]
pub mod pallet {

	use super::*;
	use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};
	use frame_system::pallet_prelude::*;
	use scale_info::prelude::vec::Vec;

	use frame_support::
	{
		sp_runtime::traits::AccountIdConversion,
		traits:: {
			Currency, ExistenceRequirement, Randomness
		},
		PalletId,
	};

	type BalanceOf<T> = 
		<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

	#[pallet::pallet]
	pub struct Pallet<T>(_);

	/// Configure the module by specifying the parameters and types on which it depends.
	#[pallet::config]
	pub trait Config: frame_system::Config {

		// Event definition
		type RuntimeEvent: From<Event<Self>> 
			+ IsType<<Self as frame_system::Config>::RuntimeEvent>;

		// Currency 
		type Currency: Currency<Self::AccountId>;

		// Randomness
		type MyRandomness: Randomness<Self::Hash, BlockNumberFor<Self>>;

		// Ticket cost
		#[pallet::constant]
		type TicketCost: Get<BalanceOf<Self>>;

		// Maximum number of participants
		#[pallet::constant]
		type MaxParticipants: Get<u32>;

		// Module Id
		#[pallet::constant]
		type PalletId: Get<PalletId>;
	}

	// The pallet's runtime storage items.
	#[pallet::storage]
	#[pallet::getter(fn get_participants)]
	pub(super) type Participants<T: Config> = StorageValue<
		_,
		BoundedVec<T::AccountId, T::MaxParticipants>,
		OptionQuery
	>;

	#[pallet::storage]
	#[pallet::getter(fn get_nonce)]
	pub(super) type Nonce<T: Config> = StorageValue<
		_,
		u64,
		ValueQuery
	>;

	// Pallets use events to inform users when important changes are made.
	// https://docs.substrate.io/main-docs/build/events-errors/
	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		/// Event emitted when a ticket is bought
		TicketBought { who: T::AccountId },
		/// Event emitted when the prize is awarded
		PrizeAwarded { winner: T::AccountId },
		/// Event emitted when the prize is to be awarded, but there are no participants
		ThereAreNoParticipants,
	}

	// Errors inform users that something went wrong
	#[pallet::error]
	pub enum Error<T> {
		NotEnoughCurrency,
		AccountAlreadyParticipating,
		CanNotAddParticipant,
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {

		#[pallet::call_index(0)]
		#[pallet::weight(0)]
		pub fn buy_ticket(origin: OriginFor<T>) -> DispatchResult {

			// 1. Validates the origin signature
			let buyer = ensure_signed(origin)?;

			// 2. Checks that the user has enough balance to afford the ticket price
			ensure!(
				T::Currency::free_balance(&buyer) >= T::TicketCost::get(),
				Error::<T>::NotEnoughCurrency
			);

			// 3. Checks that the user is not already participating
			if let Some(participants) = Self::get_participants() {
				ensure!(
					!participants.contains(&buyer),
					Error::<T>::AccountAlreadyParticipating
				);
			}

			// 4. Adds the user as a new participant for the prize
			match Self::get_participants() {
				Some(mut participants) => { 
					ensure!(
						participants.try_push(buyer.clone()).is_ok(), 
						Error::<T>::CanNotAddParticipant
					);
					Participants::<T>::set(Some(participants));
				}, 
				None => {
					let mut participants = BoundedVec::new();
					ensure!(
						participants.try_push(buyer.clone()).is_ok(), 
						Error::<T>::CanNotAddParticipant
					);
					Participants::<T>::set(Some(participants));
				}
			};

			// 5. Transfers the ticket cost to the module's account
			// to be hold until transferred to the winner
			T::Currency::transfer(
				&buyer, 
				&Self::get_pallet_account(), 
				T::TicketCost::get(), 
				ExistenceRequirement::KeepAlive)?;
			
			// 6. Notify the event
			Self::deposit_event(Event::TicketBought { who: buyer });
			Ok(())
		}

		#[pallet::call_index(1)]
		#[pallet::weight(0)]
		pub fn award_prize(origin: OriginFor<T>) -> DispatchResult {

			// 1. Validates the origin signature
			let _who = ensure_root(origin)?;

			match Self::get_participants() {
				Some(participants) => { 
					
					// 2. Gets a random number from the randomness module
					let nonce = Self::get_and_increment_nonce();
					let (random_seed, _) = T::MyRandomness::random(&nonce);
					let random_number = <u32>::decode(&mut random_seed.as_ref())
						.expect("secure hashes should always be bigger than u32; qed");
					
					// 3. Selects the winner from the participants lit
					let winner_index = random_number as usize % participants.len();
					let winner = participants.as_slice().get(winner_index).unwrap();

					// 4. Transfers the total prize to the winner's account
					let prize = T::Currency::free_balance(&Self::get_pallet_account());
					T::Currency::transfer(
						&Self::get_pallet_account(), 
						&winner, 
						prize, 
						ExistenceRequirement::AllowDeath)?;

					// 5. Resets the participants list, and gets ready for another lottery round
					Participants::<T>::kill();

					// 6. Notify the event
					Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );
				}, 
				None => {
					// Notify the event (No participants)
					Self::deposit_event(Event::ThereAreNoParticipants);
				}
			};

			Ok(())
		}
	}

	impl<T: Config> Pallet<T> {

		fn get_pallet_account() -> T::AccountId {
			T::PalletId::get().into_account_truncating()
		}

		fn get_and_increment_nonce() -> Vec<u8> {
			let nonce = Nonce::<T>::get();
			Nonce::<T>::put(nonce.wrapping_add(1));
			nonce.encode()
		}
	}
}
    ```

## Configure the Runtime {: #configure-runtime }

Finally, with the module finished, it can be included in the runtime. By doing so, the transactions `buy_tickets` and `award_prize` will be callable by the users. This also means that the [Polkadot.js API](/builders/toolkit/substrate-api/libraries/polkadot-js-api/){target=\_blank} will be decorated with this module and all the available calls that it contains.

To configure the runtime, open the `lib.rs` file, which contains the definition for the runtime of the included template and is located (in case of using the EVM-compatible) in the folder:

```text
*/container-chains/templates/frontier/runtime/src/
```

To add the lottery module, configure the modules as follows:

```rust

// Add the configuration for randomness module. No parameters needed.
impl pallet_insecure_randomness_collective_flip::Config for Runtime {
}

// Custom module id
parameter_types! {
	pub const PalletId: PalletId = PalletId(*b"loex5678");
}

// Add configuration for the lottery module
impl pallet_lottery_example::Config for Runtime {
	type RuntimeEvent = RuntimeEvent;
	type Currency = Balances;
	type TicketCost = ConstU128<1000000000000000>;
	type PalletId = PalletId;
	type MaxParticipants = ConstU32<500>;
	type MyRandomness = RandomCollectiveFlip;
}
```

With the modules configured, add the macro `construct_runtime!` (that defines the modules that will be included when building the runtime) and the randomness and lottery modules.

```rust
construct_runtime!(
	pub struct Runtime {
        ...
        // Include the custom logic from the pallet-template in the runtime.
        RandomCollectiveFlip: pallet_insecure_randomness_collective_flip,
        Lottery: pallet_lottery_example,
        ...
    }
)
```

With everything set, the network now has support for a basic implementation of a lottery.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/customize/adding-external-module/
--- BEGIN CONTENT ---
---
title: Adding External Modules
description: Learn how to resolve double reference issues of dependencies when customizing your Tanssi-powered network template with a Rust-based tool called Diener.
icon: octicons-plug-24
categories: Custom-Runtime
---

# Adding an External Module {: #adding-external-module }

## Introduction {: #introduction }

Developers building on top of the [Templates offered by Tanssi](/builders/build/templates/){target=\_blank} might want to add some external modules/dependencies into their runtime to expand certain functionality.

The Tanssi repository and the templates take all the dependencies from [a fork](https://github.com/moondance-labs/polkadot-sdk){target=\_blank} of the official Polkadot SDK repository. This fork is maintained by the Tanssi engineering team, which usually contributes actively to Substrate development by fixing issues and enhancing functionalities, and, as a result, the fork repository frequently stays temporarily ahead of the official one.

A double reference issue may arise when adding an external dependency, such as a pallet from a third party. This happens if a Tanssi module references a dependency from the Polkadot SDK fork repository, and the third party references the same dependency from the official Polkadot SDK repository. To solve this issue, the references to the dependencies must be unified.

## Solving Dependencies Conflicts with Diener {: #solving-dependencies-conflicts-diener }

To efficiently handle the dependencies and their origins, you can check out the tool [diener](https://github.com/paritytech/diener){target=\_blank}.

If the `diener` executable file, the cloned [Polkadot SDK repository](https://github.com/paritytech/polkadot-sdk){target=\_blank}, and your Tanssi fork are located in the same folder, step into the Tanssi fork folder and execute the following command:

```bash
../diener patch --crates-to-patch ../polkadot-sdk \
    --target https://github.com/paritytech/polkadot-sdk \
    --point-to-git https://github.com/moondance-labs/polkadot-sdk \
    --point-to-git-branch {{ repository.tanssi.release_branch }}
```

This command applies the changes to the `Cargo.toml` file, patching the dependencies, and solving the double reference issues.

You can visit the [diener documentation](https://docs.rs/crate/diener/latest){target=\_blank} to learn more about the tool and other extra functions it offers.

## Example of the Double Reference Issue {: #double-reference-issue }

To illustrate the situation, the following steps add a demo [external module](https://github.com/papermoonio/pallet-toggle){target=\_blank} to a custom runtime based on the [baseline Tanssi-powered network template](/builders/build/templates/substrate/){target=\_blank}. One way to follow this tutorial is to clone the [Tanssi Github repository](https://github.com/moondance-labs/tanssi){target=\_blank}, which will act as the root repository of the project.

This tutorial will generate a multiple reference compile-time error. Finally, the steps will show you how to fix the compile error by patching the dependencies with the tool `diener`, the runtime will compile successfully and work as intended.

### Add a Third-Party Dependency {: #add-third-party-dependency }

Similarly to what is described in the [built-in module](/builders/build/customize/adding-built-in-module/#adding-a-built-in-module-to-runtime){target=\_blank} article, adding a third-party module requires the following steps:

1. Declare the dependency in the root `Cargo.toml` file
2. Make the standard features available to the compiler
3. Configure and add the module to the runtime

Should the third-party module reference any dependency already referenced from a distinct source or version, compilation will fail.

The following diagram shows how two different references to the same dependency are being included in the runtime, causing the compilation to fail:

![Double reference](/images/builders/build/external-module/external-module-1.webp)

To resolve this issue, it will be necessary to apply a patch so that the references for the dependency are unified:

![Patched reference](/images/builders/build/external-module/external-module-2.webp)

### Declaring the Dependency {: #declaring-dependency }

The first step to reproduce the double reference issue is to declare the dependency in the `Cargo.toml` file located in the repository's root folder, under the section `[dependencies]`. For this example, a simple [toggle module](https://github.com/papermoonio/pallet-toggle){target=\_blank} is used.

This `toggle` module, built for testing and educational purposes, adds basic logic to the runtime, allowing users to switch a state between true and false.

```toml
[dependencies]
...
pallet-toggle = { 
    git = "https://github.com/papermoonio/pallet-toggle", 
    default-features = false 
}
...
```

### Make the Standard Features Available to the Compiler {: #add-standard-features }

Having declared the module in the workspace `Cargo.toml` file, the dependency can now be added to the specific template `Cargo.toml` file, which, for this example that uses the Tanssi GitHub repo, is located in the folder `container-chains/templates/simple/runtime`.

```toml
[dependencies]
...
pallet-toggle = { workspace = true }
...
```

In the same `Cargo.toml` file, add the following features.

```toml
[features]
default = [
	"std",
]
std = [
	...,
	"pallet-toggle/std",
   ...
]
...
runtime-benchmarks = [
	...,
	"pallet-toggle/runtime-benchmarks",
]

try-runtime = [
	...,
	"pallet-toggle/try-runtime",
]
```

### Configure and Add the Module to the Runtime {: #configure-module-in-the-runtime }

Next, add the following snippet to the `lib.rs` file inside the runtime folder. This configures the module and adds the module within the `construct_runtime!` macro.

```rust
...
impl pallet_toggle::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type WeightInfo = pallet_toggle::weights::SubstrateWeight<Runtime>;
}

construct_runtime!(
    pub enum Runtime
    {
        ...
        ...
        Toggle: pallet_toggle,
    }
);
```

### Compile Runtime {: #compile-runtime }

After completing the preceding steps, the module is declared a dependency in the project, configured, and added to the runtime.

Compile the template using the following command:

```bash
cargo build -p container-chain-simple-node --release
```

The terminal output will display an error, similar to the following, caused by different modules referencing different versions of the same dependency:

```bash
error: failed to select a version for `syn`.
```

### Patch Dependencies {: #patch-dependencies }

Finally, executing the `diener` [command](#solving-dependencies-conflicts-diener) will add a `patch` section to your workspace `Cargo.toml` file, overriding the dependencies and unifying origins and versions.

This is what the execution in the terminal looks like:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>../diener patch --crates-to-patch ../polkadot-sdk \
    <br> --target https://github.com/paritytech/polkadot-sdk \
    <br> --point-to-git https://github.com/moondance-labs/polkadot-sdk \
    <br> --point-to-git-branch tanssi-polkadot-v1.3.0
    </span>
  <span data-ty>
    <br> [2024-01-10T23:26:27Z INFO diener] Running diener v0.4.7 
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bridge-runtime-common.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-header-chain'
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-runtime'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools-derive'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core-hashing'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api-proc-macro' .
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-debug-derive'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-externalities'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-std'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-storage'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-runtime-interface'.
  </span>
</div>

As shown in the terminal output, `diener` adds a patch for the dependencies, creating a `patch` section in your `toml` overriding their origin:

```toml
[patch."https://github.com/paritytech/polkadot-sdk"]
bridge-runtime-common = { git = "https://github.com/moondance-labs/polkadot-sdk" , branch = "tanssi-polkadot-v1.3.0" }
bp-header-chain = { git = "https://github.com/moondance-labs/polkadot-sdk" , branch = "tanssi-polkadot-v1.3.0" }
bp-runtime = { git = "https://github.com/moondance-labs/polkadot-sdk" , branch = "tanssi-polkadot-v1.3.0" }
...
```

Finally, compiling will succeed, and the module will be built into your runtime.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/customize/customizing-chain-specs/
--- BEGIN CONTENT ---
---
title: Customizing Chain Specifications
description: Review the sections and attributes of a chain specification file and how to obtain it for launching your Tanssi-powered network with a customized specification.
icon: octicons-link-24
categories: Appchain
---

# Customizing Chain Specifications {: #customizing-chain-specifications }

## Introduction {: #introduction }

The chain specification refers to a set of parameters and configurations that define the characteristics and behavior of a new Tanssi-powered network. It defines the initial settings and state that all nodes participating in the network must agree on to reach consensus and produce blocks. Many initial settings cannot be changed after the network is launched without generating a completely different chain.

The specification contains two main sections:

- **The client specification** - includes the network parameters, for example, the boot nodes the client connects with when joining the network
- **The genesis state** - represents the initial state upon which all transactions and state transitions take place. It includes details like the initial registered accounts and their balances, as well as the account with administrator privileges (sudo, if applicable), among other relevant information

This information the chain specification contains can be stored in a Rust file (which can be found in the [templates](/builders/build/templates/overview/){target=\_blank} included in the Tanssi repository) or in a JSON file.

This article covers the sections and attributes within a chain specification file and explains how to obtain it, in case you want to launch your Tanssi network by uploading a customized specifications file.

!!! note "Editorâ€™s Note (2025 Update)"
    This guide explains how to customize chain specification files in Substrate-based networks. Some fields (e.g. relay chain, parachain id) come from the Substrate SDK and are included for compatibility or template purposes.
    
    These attributes do not mean that a Tanssi-powered network is a Polkadot parachain. Tanssi is an independent appchain infrastructure protocol, built with Substrate and aligned with Ethereum-backed security. You may encounter Polkadot-related terms in configuration files because of Substrateâ€™s shared origins, but Tanssi-powered appchains do not require Polkadot slots or relay chain mechanics.

## The Client Specification {: #client-specification }

The client specification contains the configuration of the network and other settings (excluding those related to the runtime state): 

- **Name** - name for the specifications
- **Id** - a unique simple id for the network used to define the storage path in the node
- **Fork Id** - optional parameter for a network fork identifier
- **Chain Type** - a parameter that can be set to define the chain type and display additional information or enable additional features (it can be set to Development, Local, Live, or a custom type)
- **Boot Nodes** - set of boot nodes that will be used when the new node joins the network and syncs
- **Telemetry Endpoints** - an optional list of endpoints to send information and monitor the operation of the network
- **Protocol Id** - a unique name defining the network protocol
- **Relay Chain** - defines the id of the orchestration chain the Tanssi network interacts with
- **Parachain Id** - sets a unique id that identifies the Tanssi network
- **Code Substitutes** - an emergency feature to replace the runtime when a Tanssi network is unable to perform a runtime upgrade
- **Properties** - key-value properties that can be customized and are useful to improve the user experience

In the `properties` attribute, the following settings are used by various front-end libraries, including the [Polkadot.js API](/builders/toolkit/substrate-api/libraries/polkadot-js-api/){target=\_blank}:

- **Token Symbol** - a name for your Tanssi network's own token symbol
- **SS58 Format** - an integer that uniquely identifies the accounts in your network. [SS58 encoding](https://docs.polkadot.com/polkadot-protocol/parachain-basics/accounts/#address-formats){target=\_blank} transforms the underlying 32-byte account to a network-specific representation. This attribute doesn't apply nor interfere with the ECDSA Ethereum accounts on EVM-compatible networks
- **Token Decimals** - represent how divisible a token can be, and what is the smallest representation of the token. It's set to `18` for EVM-compatible networks
- **Is Ethereum** - a boolean identifying the network as EVM compatible or not

## The Genesis State {: #genesis-state }

All the sequencers assigned to the Tanssi network must agree on the initial state so they can execute the incoming extrinsics, arrive at the same results, and finally reach a consensus on the new valid state.

This genesis state will define the starting point of the Tanssi network. It includes an initial value for the elements that the modules included in the runtime need to persist and the initial runtime Wasm code, which is stored on-chain.

For example, in the templates included, the chain specification defines the initial accounts and token balances in the `Balances` module. In addition, the template also has a sudo account (which **should be modified**) for the `Sudo` module, which provides unique privileges to the given account, and that can be offboarded once an on-chain democracy module is plugged in.

## Generating a JSON Chain Specification File {: #generating-json-chain-specs }

The following commands will build and generate the chain specification for the EVM-compatible template based on the configuration expressed in the `chain_spec.rs`, located in the `*/container-chains/templates/frontier/node/src/chain_spec.rs`. This example can be adapted to any other template or custom runtime.

To build and generate the chain specifications, take the following steps:

1. Clone the Tanssi code hosted on GitHub

    ```bash
    git clone https://github.com/moondance-labs/tanssi
    ```

2. Step into the project folder

    ```bash
    cd tanssi
    ```

3. Build the Tanssi EVM-compatible network template

    ```bash
    cargo build -p container-chain-frontier-node --release
    ```

    This step is quite verbose and might take a while to complete. The following screenshot shows the terminal after successfully finishing the building process (note that the completion time is above 35 minutes):

    ![Building the template](/images/builders/build/customize/customizing-chain-specs/customizing-chain-specs-1.webp)

4. Generate the chain specification

    ```bash
    ./target/release/container-chain-frontier-node \
        build-spec > chain_spec.json
    ```

After executing the last step, the terminal displays only a log line:

![Generating the chain specification](/images/builders/build/customize/customizing-chain-specs/customizing-chain-specs-2.webp)

And now the `chain_spec.json` file containing the client specification and the genesis state is created in the current folder.

!!! note
    The JSON chain specifications can be generated in two different versions: the human readable, which is the one generated following the previous steps, and the raw version, which is the one needed to deploy the network through Tanssi. More about how to generate the raw version [later](#generating-raw-specs-file) in this article.

### Editing the JSON Chain Specification File {: #editing-json-chain-specs }

The generated `chain_spec.json` file reflects the parameters set in the Rust chain specifications file. Being a JSON file, it is easy to read and, should any parameter need to be changed, easy to edit.

For example, the following code snippet shows some of the attributes of the client specifications:

```json
{
    // Set the name for the specification of this network
    "name": "Frontier network 1000",
    // Set an id for the specifications of this network
    "id": "frontier_network_1000",
    // Network will be live
    "chainType": "Live",
    "bootNodes": [
        // boot nodes will be added automatically during deployment
    ],
    // Optional attribute, defaults to null
    "telemetryEndpoints": null,
    // Set a protocol identifier for this network
    "protocolId": "network-chain-1000",
    // Set properties to define the token and the ethereum compatibility
    "properties": {
        "isEthereum": true,
        "ss58Format": 42,
        "tokenDecimals": 18,
        "tokenSymbol": "UNIT"
    },
    // Set the stagenet relay chain
    "relay_chain": "westend_moonbase_relay_stagenet",
    // Set the parachain id reserved in the relay chain
    "para_id": 3333,
    // No need
    "codeSubstitutes": {},
    "genesis": { 
        ... 
    }
}
```

The other important section of the file is within the `genesis` attribute, which contains the genesis state. In the following JSON snippet, the default values and configuration for some modules are presented as an example:

```json
{
    ...
    "genesis": {
        "runtime": {
            ...
            // Sets the account that will bear sudo privileges
            "sudo": {
                "key": "0xf24ff3a9cf04c71dbc94d0b566f7a27b94566cac"
            },
            // Sets the initial balances for some accounts
            "balances": {
                "balances": [
                [
                    "0x3cd0a705a2dc65e5b1e1205896baa2be8a07c6e0",
                    1208925819614629174706176
                ],
                [
                    "0x773539d4ac0e786233d90a233654ccee26a613d9",
                    1208925819614629174706176
                ],
                [
                    "0x798d4ba9baf0064ec19eb4f0a1a45785ae9d6dfc",
                    1208925819614629174706176
                ],
                [
                    "0xf24ff3a9cf04c71dbc94d0b566f7a27b94566cac",
                    1208925819614629174706176
                ]
                ]
            },
            // Sets balances for EVM accounts
            "evm": {
                "accounts": {
                "0x1000000000000000000000000000000000000001": {
                    "nonce": "0x1",
                    "balance": "0xd3c21bcecceda1000000",
                    "storage": {},
                    "code": [
                    0
                    ]
                },
                "0x6be02d1d3665660d22ff9624b7be0551ee1ac91b": {
                    "nonce": "0x0",
                    "balance": "0xffffffffffffffffffffffffffffffff",
                    "storage": {},
                    "code": []
                },
                "0xd43593c715fdd31c61141abd04a99fd6822c8558": {
                    "nonce": "0x0",
                    "balance": "0xffffffffffffffffffffffffffffffff",
                    "storage": {},
                    "code": []
                }
                }
            },
        }
    }
    ...
}
```

An example of a non-manually editable attribute is the Wasm runtime (in the genesis state section), which is a hexadecimal representation of a binary blob generated by the compiler. Still, apart from this, most of the properties are easy to edit before launching the network.

## Generating a Raw JSON Chain Specification File {: #generating-raw-specs-file }

One final step before deploying the Tanssi network is converting the JSON specification file to a raw format, which is a compact, less-readable version of the same file, required to initialize a node.

After going through the [steps to generate the JSON chain Specification File](#generating-json-chain-specs) and editing its values, the following command will convert the chain specs file into the required raw format:

```bash
./target/release/container-chain-frontier-node \
    build-spec --chain=chain_spec.json --raw > raw_chain_spec.json
```

Now that this file has been configured and customized and is in the correct raw JSON format, it can be uploaded to initialize a new network in Tanssi.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/customize/
--- BEGIN CONTENT ---
---
title: Customize Your Tanssi-Powered Network
description: Set up your local environment and start using the templates to build your network with Substrate, a powerful and modular blockchain framework based in Rust.
icon: octicons-code-24
template: index-page.html
---

# Customize Your Tanssi-Powered Network

Tailor your network to meet your application's unique requirements. This section provides guidance on modifying and extending your network's functionality, offering instructions and best practices to help align it with your project's goals.

## Process for Customizing Your Network

The diagram below provides a simplified outline of the essential steps to get started with building and customizing your Tanssi-powered network.

```mermaid
flowchart LR
    A[Install software prerequisites] --> B[Create and add modules]
    B --> C[Customize and generate chain specs]
```

To proceed, check out the following section where you can find detailed, step-by-step guides for each of these stages.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/customize/prerequisites/
--- BEGIN CONTENT ---
---
title: Prerequisites for Building a Network
description: Install the basic set of tools and software to set up a local development environment and be able to compile, run, and test your appchain.
icon: octicons-checkbox-24
Categories: Custom-Runtime
---

# Prerequisites for Building a Network {: #prerequisites }

## Introduction {: #introduction }

Deploying a network through Tanssi is a fairly straightforward step, where the only requirement is to have a valid [chain specification](https://docs.polkadot.com/develop/parachains/deployment/generate-chain-specs/){target=\_blank} to upload.

Even though Tanssi provides chain specifications for the [available templates](/learn/decentralized-networks/included-templates/), it could be necessary to generate a new one to match any changes the use case might need to be implemented in the runtime.

The following sections of this article will cover the minimal required software and its installation process to get a suitable development environment to compile a Substrate node and generate the chain specification.

## Installing Rust {: #installing-rust }

[Rust](/learn/framework/overview/#rust-programming-language){target=\_blank} is a modern, portable, and performant programming language that is the base of the Substrate blockchain development framework.  

To compile the Tanssi network, the rust compiler, `rustc`, and the package manager, `cargo`, must be installed on the system.

In accordance with the instructions in the [official Rust documentation](https://rust-lang.org/tools/install/){target=\_blank}, for Linux or macOS systems, run the following command:

=== "Linux"

    ```bash
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    ```

=== "MacOS"

    ```bash
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    ```

When the installation process is completed, running the following command verifies that the newly installed compiler works correctly by showing the version number:

=== "Linux"

    ```bash
    rustc --version
    ```

=== "MacOS"

    ```bash
    rustc --version
    ```

There are other methods to install Rust, such as using a package manager. Other options can be found on the [Rust official site](https://forge.rust-lang.org/infra/other-installation-methods.html){target=\_blank}.

## Installing Git {: #installing-git }

[Git](https://git-scm.com){target=\_blank} is recommended to clone the [code repository](https://github.com/moondance-labs/tanssi){target=\_blank} of Tanssi, where the node templates can be found. Git is likely shipped within the default OS installation configuration or included in other tools, such as Xcode in MacOS.

If Git is not present on the system, the following command will install it using a package manager:

=== "Linux"

    ```bash
    apt-get install git
    ```

=== "MacOS"

    ```bash
    brew install git
    ```     

To check the correct installation of Git, running the following command in a terminal should display the Git version:

=== "Linux"

    ```bash
    git --version
    ```

=== "MacOS"

    ```bash
    git --version
    ```

## Building a Tanssi Template {: #building-tanssi-template }

To build a Substrate node, such as the templates included in the [Tanssi repository](https://github.com/moondance-labs/tanssi){target=\_blank}, it is necessary to install additional development components in the system:

=== "Linux"

    ```bash
    apt-get install -y build-essential protobuf-compiler clang libssl-dev pkg-config
    ```

=== "MacOS"

    ```bash
    brew install protobuf openssl
    ```

With these essential tools installed, the development environment should be ready to work with Substrate and build the node with the following commands: 

1. Clone the Tanssi code hosted on GitHub
```bash
git clone https://github.com/moondance-labs/tanssi
```
2. Step into the project folder
```bash
cd tanssi
```
3. Build the Tanssi network template
=== "Baseline EVM"

    ```bash
    cargo build -p container-chain-frontier-node --release
    ```

=== "Baseline Substrate"

    ```bash
    cargo build -p container-chain-simple-node --release
    ```

Having a healthy development environment will be necessary to build a customized runtime and to finally generate the chain specification file that will be used to deploy your Tanssi network.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/
--- BEGIN CONTENT ---
---
title: Build Your Network
description: Install the software to compile your Tanssi-powered network, configure genesis state and core functions, test locally, and prepare for deployment.
icon: material-widgets-outline
template: index-page.html
---

# Build Your Network

Launching your Tanssi-powered network gives you the flexibility to choose between pre-configured templates or fully customized solutions. Whether you're aiming for simplicity or fine-tuned control, Tanssi provides the tools and guidance to bring your vision to life. This section covers everything from selecting a template to customizing modules, testing, and deploying your network.

## The Path to Deployment

Deploying a network with Tanssi can be straightforward or highly customizable, depending on your requirements. The diagram below provides a clear breakdown of these options to guide your decision.

```mermaid
flowchart TD
    Start[Choose a template]
    Start --> Path1[Template is sufficient]
    Start --> Path2[Template needs customization]

    Path1 --> Deploy1[Deploy via Tanssi dApp]

    Path2 --> Fork[Fork the Tanssi repository]
    Fork --> Customize[Customize your network]
    Customize --> Test[Run tests]
    Test --> Deploy2[Deploy via Tanssi dApp]
```

Now that youâ€™ve explored the deployment paths, the next step is to [learn more about each template](/builders/build/templates) so you can choose the one that best fits your needs.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/templates/custom-runtime/
--- BEGIN CONTENT ---
---
title: Custom Runtime
description: Any custom runtime can be adapted to be deployed through Tanssi, provided that specific modules are implemented and the required configurations are set.
icon: octicons-file-binary-24
categories: Custom-Runtime
---

# Custom Runtime

## Introduction {: #introduction }

For teams working on an existing Substrate framework project, it will be necessary to include some required modules and configurations into the runtime. This will ensure that the existing runtime can gracefully become a Tanssi network runtime, aligning with the [protocol rules](/builders/build/templates/overview/#base-setup-supporting-tanssi){target=\_blank}.

Failing to do so might lead to reduced interoperability and unnecessary exposure to vulnerabilities.

## Minimum Requirements

Already existing Substrate runtimes need to implement at least the [framework](#adding-cumulus-support) for communicating within the Tanssi ecosystem, along with [Tanssi-specific modules](#adding-tanssi-support).

Nevertheless, teams might have already implemented certain modules that can collide with some functionalities related to Tanssi, for example, block production, block authority assignment, and consensus.

The following modules are included by default in many popular templates and must be removed along with their configuration:

```rust
Authorship: pallet_authorship = 20,
CollatorSelection: pallet_collator_selection = 21,
Session: pallet_session = 22,
Aura: pallet_aura = 23,
AuraExt: cumulus_pallet_aura_ext = 24,
```

In any case, make sure to check your runtime and remove all the modules that might interfere with the block production as a service feature before starting the registration process.

## Integrating Your Stand-Alone Chain {: #adding-cumulus-support }

If your existing runtime is set up as a stand-alone chain, you'll need to add a consensus mechanism to integrate into the Tanssi ecosystem. Check any of the available templates in the [Tanssi repository](https://github.com/moondance-labs/tanssi){target=\_blank} for a reference setup or the [framework documentation](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/cumulus/index.html){target=\_blank}.

## Adding Tanssi Protocol Support {: #adding-tanssi-support }

To support the Tanssi protocol, it will be necessary to add two modules through the following steps:

1. Include the dependencies in the `Cargo.toml` manifesto (usually located in the root folder). Open the `Cargo.toml` file and add the modules in the `dependencies` section

    ```toml
    [dependencies]
    ...
    pallet-cc-authorities-noting = { 
        git = "https://github.com/moondance-labs/tanssi", 
        branch = "master", default-features = false 
    }
    pallet_authorities_noting = {
        git = "https://github.com/moondance-labs/moonkit",
        branch = "tanssi-polkadot-v0.9.43", default-features = false
    }
    ...
    ```

2. Configure the modules. Open the file `lib.rs` located in the folder `*/runtime/src` and add the configuration for both modules:

    ```rust
    impl pallet_author_inherent::Config for Runtime {
        type AuthorId = NimbusId;
        type AccountLookup = tp_consensus::NimbusLookUp;
        type CanAuthor = pallet_cc_authorities_noting::CanAuthor<Runtime>;
        type SlotBeacon = tp_consensus::AuraDigestSlotBeacon<Runtime>;
        type WeightInfo =
            pallet_author_inherent::weights::SubstrateWeight<Runtime>;
    }

    impl pallet_cc_authorities_noting::Config for Runtime {
        type RuntimeEvent = RuntimeEvent;
        type SelfParaId = parachain_info::Pallet<Runtime>;
        type RelayChainStateProvider =
            cumulus_pallet_parachain_system::RelaychainDataProvider<Self>;
        type AuthorityId = NimbusId;
        type WeightInfo =
            pallet_cc_authorities_noting::weights::SubstrateWeight<Runtime>;
    }
    ```

    Note that this configuration is agnostic from the use case

3. Declare the modules as part of the runtime. In the same `lib.rs` file, located in the folder `*/runtime/src`, add the modules to the construction of the runtime:

    ```rust
    construct_runtime!(
    pub enum Runtime where
        Block = Block,
        NodeBlock = opaque::Block,
        UncheckedExtrinsic = UncheckedExtrinsic,
    {
        ...
        // Tanssi network
        AuthoritiesNoting: pallet_cc_authorities_noting = 50,
        AuthorInherent: pallet_author_inherent = 51,
        ...
    }
    );
    ```

4. Make sure your Header is configured as follows:

    ```rust
    type Header = generic::Header<BlockNumber, BlakeTwo256>;
    /// An index to a block.
    pub type BlockNumber = u32; 
    ```

5. Add the block executor, to allow the operators in the Tanssi network to validate that the authors are the sequencers assigned by Tanssi (and not a malicious actor)

    ```rust
    cumulus_pallet_parachain_system::register_validate_block! {
        Runtime = Runtime,
        BlockExecutor = pallet_author_inherent::BlockExecutor::<Runtime, Executive>
        CheckInherents = CheckInherents,
    }
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/templates/evm/
--- BEGIN CONTENT ---
---
title: Baseline EVM Template
description: The Tanssi repository includes an EVM template that provides all the necessary configurations to launch a network that is fully compatible with Ethereum.
icon: material-ethereum
categories: EVM-Template
---

# Baseline EVM Template {: #baseline-evm-template }

## Introduction {: #introduction }

Tanssi's EVM (Ethereum Virtual Machine) network template is designed for teams developing their applications on top of EVM smart contracts. It includes all the essential components needed for a full Ethereum-compatible network:

- **EVM** - adds an Ethereum Virtual Machine execution layer for EVM-based smart contract applications
- **Etherum JSON RPC Support** - Tanssi-powered EVM networks are fully [Ethereum JSON RPC](https://ethereum.org/developers/docs/apis/json-rpc/){target=\_blank} compliant. Consequently, all Ethereum-based tools like [MetaMask](https://metamask.io){target=\_blank}, [Ethers.js](https://docs.ethers.org/v6/){target=\_blank}, [Viem](https://viem.sh){target=\_blank}, [Hardhat](https://hardhat.org){target=\_blank}, [Foundry](https://getfoundry.sh/){target=\_blank} and more, work seamlessly out of the box
- **Unified Accounts** - allows Tanssi-powered EVM networks to feature Ethereum-styled ECDSA accounts

## EVM Network Template {: #evm-network-template }

The template already includes the necessary configuration for seamless integration with the Tanssi protocol and the security provider of choice, for example, [Symbiotic](https://symbiotic.fi/){target=\_blank} on Ethereum. Therefore, this template requires no additional changes in the runtime if the application is built on top of the EVM.

This means that this template is ready to be deployed as-is through Tanssi, unlocking many features, such as:

- Utilize Tanssi's [block production as a service](/learn/tanssi/network-services/block-production/){target=\_blank}
- Get deterministic transaction finality in seconds
- Choose the security provider that best fits your needs. For example, leverage Ethereum-grade security from [Symbiotic](https://symbiotic.fi/){target=\_blank}
- Build dApps interacting with your network through an [API](/builders/toolkit/substrate-api/libraries/polkadot-js-api/){target=\_blank}
- Connect any Ethereum wallet, such as [Metamask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} and Ledger
- Use well-known Ethereum libraries like [Ethers.js](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}, [Web3.js](/builders/toolkit/ethereum-api/libraries/web3js/){target=\_blank}, [Web3.py](/builders/toolkit/ethereum-api/libraries/web3py/){target=\_blank}, and more
- Deploy EVM smart contracts with tools like [Remix](https://remix.ethereum.org){target=\_blank}, [Hardhat](https://hardhat.org){target=\_blank}, [Foundry](https://github.com/foundry-rs/foundry){target=\_blank}, and more

## Included Modules {: #included-modules }

Besides the modules and configurations that make the Tanssi EVM network template compatible with the Tanssi protocol, it also includes [many modules](/builders/build/templates/overview/#included-modules){target=\_blank} to provide basic functionalities.

To reach full Ethereum compatibility, these specific modules are also included:

- **[EVM](https://docs.rs/pallet-evm/latest/pallet_evm){target=\_blank}** - it adds support for unmodified EVM bytecode execution on a Tanssi-powered network. It uses the Rust-based [SputnikVM](https://github.com/rust-ethereum/evm){target=\_blank} as the underlying EVM engine
- **[Ethereum](https://docs.rs/pallet-ethereum/latest/pallet_ethereum){target=\_blank}** - it works alongside the EVM module to provide full emulation for Ethereum block processing. Among many other tasks, it is responsible for creating emulated Ethereum blocks for Ethereum-specific components such as EVM logs

Both modules are part of the [Frontier](https://github.com/polkadot-evm/frontier){target=\_blank} project, which is the backbone of Ethereum-compatible Tanssi-powered networks.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/templates/
--- BEGIN CONTENT ---
---
title: Templates for Network Development
description: Learn more about the baseline network templates (EVM and non-EVM) that support Tanssi out of the box to help you kickstart your network development.
icon: octicons-copy-24
template: index-page.html
---

# Network Templates

Kickstart your network development with our comprehensive templates. Designed for rapid deployment, these templates provide a strong foundation for both EVM and non-EVM solutions, accelerating your production journey.

## Choose a Template

Tanssi provides two templates to jumpstart the development process:

- **Baseline Tanssi network template** - a template that provides the basic platform to start adding custom logic
    <br>

    [:octicons-arrow-right-24: Learn about what this template provides](/learn/decentralized-networks/included-templates#baseline-network-template)

    [:octicons-arrow-right-24: Start building with this template](/builders/build/templates/substrate/)

- **Baseline Tanssi EVM (Ethereum Virtual Machine) network template** - a template that provides full Ethereum compatibility
    <br>

    [:octicons-arrow-right-24: Learn about what this template provides](/learn/decentralized-networks/included-templates/#baseline-evm-template)

    [:octicons-arrow-right-24: Start building with this template](/builders/build/templates/evm/)

To learn about the minimum requirements for your chain to function on Tanssi and what modules are automatically included, check out the [Template Overview](/builders/build/templates/overview/) page.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/templates/overview/
--- BEGIN CONTENT ---
---
title: Requirements and Features of Templates
description: Explore the foundational setup and key features included in each Tanssi template, designed to streamline the building and deployment of Tanssi networks.
icon: octicons-home-24
categories: Basics, Appchain
---

# Templates Overview {: #templates-overview }

## Introduction {: #introduction }

Networks deployed through Tanssi are fully customizable blockchains benefiting from a shared set of sequencers and the security of a provider of their choice. The templates presented in this article implement the necessary functionalities and configurations to support the Tanssi protocol, making development easier.

## Base Setup to Support the Tanssi Protocol {: #base-setup-supporting-tanssi }

Tanssi networks must implement the following modules to support the protocol and benefit safely from Tanssi's block production as a service:

- **Author Noting** - registers the set of sequencers assigned to the network by Tanssi
- **Author Inherent** - allows the sequencer authoring the block to include its identity to get validated and rewarded

If you don't include these modules in the Tanssi network's runtime, there won't be a method to confirm that the blocks are being generated by trustworthy sequencers designated by the Tanssi orchestrator. This could create a vulnerability for malicious actors to exploit and compromise the network. For more information about Tanssi's block production as a service please refer to the [Block Production Services](/learn/tanssi/network-services/block-production/){target=\_blank} article.

Besides block production, there are other essential aspects for any network covered in the templates, such as:

- **Consensus** - networks have the necessary functionality to allow the sequencers to produce blocks, gossip and validate them, and coordinate with the security provider to get notified about the block's finality
- **Networks Interoperability** - handles the ingestion and dispatch of incoming downward and lateral messages, allowing a Tanssi network to communicate and interoperate with the other chains within the ecosystem
- **Runtime Upgrades** - a runtime upgrade in a Tanssi network must be informed to the security provider's operators to allow them to check on the blocks produced by the sequencers of the Tanssi networks

## Included Modules {: #included-modules }

Besides the necessary modules to support the operation of a Tanssi network, many other modules provide functional behavior that the users can interact with.

These are some of the functional modules exposing a behavior to the users that are included in the templates and ready to use:

- **[Balances](https://paritytech.github.io/substrate/master/pallet_balances/index.html){target=\_blank}** - the Balances module provides functions for handling accounts and balances for the Tanssi network native currency
- **[Utility](https://paritytech.github.io/polkadot-sdk/master/pallet_utility/index.html){target=\_blank}** - the Utility module provides functions to execute multiple calls in a single dispatch. Besides batching transactions, this module also allows the execution of a call from an alternative signed origin
- **[Proxy](https://paritytech.github.io/polkadot-sdk/master/pallet_proxy/index.html){target=\_blank}** - the Proxy module provides functions to delegate to other accounts (proxies) the permission to dispatch calls from a proxied origin
- **[Maintenance Mode](https://github.com/moondance-labs/moonkit/blob/tanssi-polkadot-v1.3.0/pallets/maintenance-mode/src/lib.rs){target=\_blank}** - the Maintenance Mode module allows the Tanssi network to be set to a mode where it doesn't execute balance/asset transfers or other transactions. This could be useful when upgrading the runtime in an emergency, when executing large storage migrations, or when a security vulnerability is discovered
- **[Tx Pause](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/tx-pause/src/lib.rs){target=\_blank}** - the Tx Pause module allows a valid origin (typically Root) to pause (and unpause) an entire module or a single transaction. A paused transaction (or all the transactions included in a paused module) will fail when called until it is unpaused. This module provides a higher degree of granularity compared to maintenance mode, making it particularly useful when a faulty or vulnerable transaction is identified in the runtime
- **[Multisig](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/multisig/src/lib.rs){target=\_blank}** - the Multisig module enables transaction dispatches that require -typically- more than one signature. A multisig transaction defines a set of authorized accounts and a threshold for its approval, requiring consensus among multiple parties

## Start Building {: #getting-started }

To start building on top of the provided templates, be it the [baseline Tanssi network template](/builders/build/templates/substrate/){target=\_blank} or the [baseline EVM (Ethereum Virtual Machine) template](/builders/build/templates/evm/){target=\_blank}, the recommended approach is to fork the [Tanssi repository](https://github.com/moondance-labs/tanssi){target=\_blank} and start adding [built-in modules](/builders/build/customize/adding-built-in-module/){target=\_blank} or [custom-made modules](/builders/build/customize/adding-custom-made-module/){target=\_blank} on top of the [latest release](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank} tag.

This approach comes with some advantages, such as:

- Building on top of the latest and stable release
- Get the Tanssi protocol already configured and included in the template runtime
- Keep your fork up-to-date by syncing with the Tanssi upstream repository
- Run the included tests, ensuring that block production on your Tanssi network works as intended
- Run a complete local environment with the included [Zombienet](https://paritytech.github.io/zombienet){target=\_blank} configuration

If the templates already cover your use case needs, or after building and testing your chain, you can continue with the [Deploy Your Network via the Tanssi DApp](/builders/deploy/dapp/){target=\_blank} article to know how to use the Tanssi dApp to register and get your chain up and running.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/build/templates/substrate/
--- BEGIN CONTENT ---
---
title: Baseline Network Template
description: The Tanssi repository includes a basic template that provides the necessary configuration to support the protocol and kick-start the development of a network.
icon: simple-paritysubstrate
categories: Substrate-Template
---

# Baseline Network Template {: #baseline-network-template }

## Introduction {: #introduction }

The Tanssi repository includes a bare minimum template that provides the necessary configuration to support the Tanssi protocol and some essential modules, such as the one that allows handling the Tanssi network's currency.

This section covers this basic template, what it includes, and some aspects to consider when adding external dependencies.

## Baseline Network Template {: #baseline-network-template }

Developing a network runtime typically involves two primary steps:

1. [Incorporating pre-existing built-in modules](/builders/build/customize/adding-built-in-module/){target=\_blank} into the runtime
2. [Creating custom modules](/builders/build/customize/adding-custom-made-module/){target=\_blank} tailored to your specific application needs

Since the provided template already includes the essential configurations for seamless integration with the Tanssi protocol and the security provider (for example, [Symbiotic](https://symbiotic.fi/){target=\_blank} on Ethereum), teams interested in constructing an innovative Tanssi-powered network can use this template as a starting point for adding their custom logic.

Here are some of the features that come with this template:

- Utilize Tanssi's [block production as a service](/learn/tanssi/network-services/block-production/){target=\_blank}
- Choose the security provider that best fits your needs. For example, leverage Ethereum-grade security from [Symbiotic](https://symbiotic.fi/){target=\_blank}
- Get deterministic transaction finality in seconds
- Build dApps interacting with your network through an [API](/builders/toolkit/substrate-api/libraries/polkadot-js-api/){target=\_blank}

By leveraging these features in the template, you can kickstart your Tanssi network development and customize it to meet your specific requirements and innovations.

## Adding Extra Dependencies {: #adding-extra-dependencies }

The Substrate network template includes all the required modules and configurations that make it compatible with the Tanssi protocol, and also [many other modules](/builders/build/templates/overview/#included-modules){target=\_blank} that provide basic functionalities.

This template is designed to serve as a foundation to build upon, as most use cases require expanded capabilities, adding existing or custom modules. To learn how to add new functionalities to your runtime, check the [customize runtime](/builders/build/customize/){target=\_blank} section.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/deploy/dapp/
--- BEGIN CONTENT ---
---
title: Deploy Your Appchain via the DApp
description: Learn how to spin up and deploy an appchain on Tanssi using the Tanssi dApp, a no-code solution for onboarding and launching decentralized appchains in minutes.
icon: octicons-browser-24
categories: Appchain
---

# Deploy Your Appchain via the Tanssi DApp

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/W40oqavpZJ8' frameborder='0' allowfullscreen></iframe></div>
<style>.caption { font-family: Open Sans, sans-serif; font-size: 0.9em; color: rgba(170, 170, 170, 1); font-style: italic; letter-spacing: 0px; position: relative;}</style>

## Introduction {: #introduction }

Tanssi aims to lower the barrier to entry for building decentralized appchains by streamlining the onboarding process and abstracting away the technical details of launching a Tanssi-powered appchain. The [Tanssi dApp](https://apps.tanssi.network){target=\_blank} allows you to spin up an appchain in just minutes. This guide will walk you through the steps required to launch an appchain on Dancelight, the Tanssi TestNet, via the Tanssi dApp.

## Quick Trials vs. Dedicated appchains {: #quick-trial-vs-dedicated-appchains }
 
[The Tanssi dApp](https://apps.tanssi.network){target=\_blank} supports the creation of two different types of appchains, namely:

- Quick trial - a temporary appchain that self-destructs after 48 hours
- Dedicated - a long-lasting appchain for Tanssi ecosystem builders

Both types of Tanssi appchains behave identically, with the only difference being the ephemeral nature of the quick trials. Generally speaking, quick trial appchains are best for most builders who want to test out a Tanssi-powered appchain. However, if you require a long-lasting test environment, the Tanssi team will happily assist you with setting up a dedicated appchain. 

The screenshots and content in this guide will showcase quick trial appchains, but you can follow the same process to configure a dedicated Tanssi appchain.

![A screenshot showing the initial dashboard of apps.tanssi.network.](/images/builders/deploy/dapp/dapp-1.webp)

## Prerequisites {: #prerequisites }

### Supported Wallets {: #supported-wallets }

Since Tanssi is built with Substrate, you'll need to use a Substrate-compatible wallet to deploy and manage your Tanssi appchain. Supported wallets include:

- [Talisman](https://talisman.xyz/){target=\_blank}
- [SubWallet](https://www.subwallet.app){target=\_blank}
- [Enkrypt](https://www.enkrypt.com){target=\_blank}
- [Polkadot.js extension](https://polkadot.js.org/extension){target=\_blank}

If you deploy a Tanssi-powered EVM appchain, your users won't need a Substrate wallet. They can interact with your Tanssi appchain using Ethereum-compatible wallets like [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

![Connection screen for various Substrate wallets](/images/builders/deploy/dapp/dapp-2.webp)

### Connect Your Wallet to the DApp {: #connect-wallet }

To connect your wallet to the Tanssi dApp, click **Connect Wallet** in the upper-right corner. Select the desired wallet type. Then, take the following steps:

1. Choose your account from the dropdown
2. You'll be prompted to sign a message to log you into the Tanssi dApp. Go ahead and sign the message

![Click on the Connect Wallet button to connect your wallet to the Tanssi dApp.](/images/builders/deploy/dapp/dapp-3.webp)

Once connected, you'll see your address in the top-right corner. If you've connected multiple accounts and want to switch accounts, you can click on your address and choose an account from the dropdown menu.

## Configure Your Appchain {: #configure-your-appchain }

On the dApp [Home page](https://apps.tanssi.network/){target=\_blank}, click the **Start Building** button in the **Launch Network** block to start configuring your Tanssi appchain immediately. You have to choose between a **Quick Trial** or a **Dedicated** appchain. You can read more about [the differences between these two available types on the Tanssi Testnet](#quick-trial-vs-dedicated-appchains).

![A screenshot showing the Launch Network section of apps.tanssi.network.](/images/builders/deploy/dapp/dapp-1.webp)

Next, select a template that best fits your use case and configure your Tanssi appchain's properties accordingly. You can choose from the EVM or Substrate template or upload a raw specification file. Please refer to the [Templates](/builders/build/templates/overview/){target=\_blank} documentation to learn more about the available templates.

### EVM Template {: #evm-template }

The [EVM template](/builders/build/templates/evm/){target=\_blank} provides all the necessary components to add an Ethereum compatibility layer to your Tanssi appchain. 

As part of the setup process, you'll need a unique EVM chain ID ([EIP-155](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md){target=\_blank}) that is distinct from all other EVM chains. You can verify that another chain does not already use your EVM chain ID on [Chainlist](https://chainid.network){target=\_blank}. When launching your Tanssi appchain in production, it's critical that you open a PR to reserve your chain ID on the [`ethereum-lists/chains` GitHub repository](https://github.com/ethereum-lists/chains){target=\_blank} immediately after your RPC endpoint spins up. This is part of the validation process and is required for the PR to be accepted and merged.

!!! note
    A registered EVM chain ID is only necessary for Tanssi appchains deployed on the MainNet. When testing or deploying on the TestNet, you can choose any available ID and move forward.

To get started, select the **EVM** template from the left-side menu. Then take the following steps:

1. In the **Network Details** section, provide your project's name, your unique EVM chain ID, and select the category that best fits your use case
2. In the **Gas Token** section, enter the symbol of your appchain's native token. Decimal places are fixed to 18 digits, the same as Ether, to preserve compatibility across EVM tooling
3. (Optional) You can adjust the [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} configurations in the **Advanced** settings. You can choose to change the **Base fee per gas** and **Max base fee change**
4. In the **Accounts** section, provide the Ethereum-style address of the account you want to use as the sudo account and its corresponding initial balance. This account will be able to dispatch privileged functions that require Root permissions. There can only be one sudo account at a time. The sudo account can be changed at any time to a new one by the current sudo account. Once the Tanssi appchain is launched, you can easily migrate to a fully decentralized system using specific democracy-related modules
5. (Optional) In the **Advanced** section, click on **Add** to add genesis accounts and balances. If you choose to skip this step, you can use the sudo account to create accounts and transfer funds at a later time
6. (Optional) In the **Genesis Smart Contracts**, click on **Add** to add genesis smart contracts by providing an address to use and the bytecode for the smart contract. When providing the bytecode, you'll need to remove the `0x` from the beginning of the bytecode
7. Once you have configured the template for your Tanssi appchain, select **Continue** and proceed to the [Check Balances section](#check-balances)

![Create a Tanssi EVM Appchain with the Tanssi dApp.](/images/builders/deploy/dapp/dapp-4.webp)

### Substrate Template {: #substrate-template }

The [Substrate template](/builders/build/templates/overview/#baseline-network-template){target=\_blank} includes all the configurations for seamless integration with Tanssi. It can be used as the baseline specification to build a custom Tanssi-powered appchain leveraging the modularity and scalability of the Substrate framework.

To get started, select the **Substrate** template from the left-side menu. Then take the following steps:

1. In the **Network Details** section, enter your project's name and select the category that best fits your use case
2. In the **Gas Token** section, enter the token decimals, symbol, and the [SS58 address format](https://github.com/paritytech/ss58-registry/blob/main/ss58-registry.json){target=\_blank}
3. In the **Accounts** section, provide the Substrate-style address of the account you want to use as the sudo account and its initial balance. This account will be able to dispatch privileged functions that require Root permissions. There can only be one sudo account at a time. The sudo account can be changed at any time to a new one by the current sudo account. Once the appchain is launched, you can easily migrate to a fully decentralized system using specific democracy-related modules
4. (Optional) In the **Advanced** section, click on **Add** to add genesis accounts and balances. If you choose to skip this step, you can use the sudo account to create accounts and transfer funds at a later time
5. Once you have configured the template for your Tanssi appchain, you can select **Continue** to proceed to the [Check Balances section](#check-balances)

![Create a baseline Substrate Appchain with the Tanssi dApp.](/images/builders/deploy/dapp/dapp-5.webp)

### Custom {: #custom }

If you already have a Substrate runtime built and have chosen to upload your own custom specification file, there are some requirements you should be aware of to ensure the runtime can evolve into a Tanssi-powered appchain and run properly.

Your runtime must implement the following:

- The Cumulus SDK, as outlined in the [Base Setup to Connect to Polkadot](/builders/build/templates/overview/#base-setup-to-polkadot){target=\_blank} section of the [Templates](/builders/build/templates/overview/){target=\_blank} page
- Tanssi modules for block production, as outlined in the [Base Setup to Support the Tanssi Protocol](/builders/build/templates/overview/#base-setup-supporting-tanssi){target=\_blank} section of the [Templates](/builders/build/templates/overview/){target=\_blank} page

Other required changes in the runtime include:

- To verify the author's eligibility to produce a block, set the following type as shown in the snippet, in the `timestamp` module configuration section of the runtime:

    ```rust
    type OnTimestampSet = tp_consensus::OnTimestampSet<
        <Self as pallet_author_inherent::Config>::SlotBeacon,
        ConstU64<{ SLOT_DURATION }>,
    >;
    ```

- Remove all the modules related to block production and consensus (such as `Aura` and `Grandpa`), leaving Tanssi to take over the burden. If the starting point for your project was the parachain template, the following modules are included by default in the runtime and must be removed:

    ```rust
    // Collator support. The order of these 4 are important and shall not change.
	#[runtime::pallet_index(20)]
	pub type Authorship = pallet_authorship;
	#[runtime::pallet_index(21)]
	pub type CollatorSelection = pallet_collator_selection;
	#[runtime::pallet_index(22)]
	pub type Session = pallet_session;
	#[runtime::pallet_index(23)]
	pub type Aura = pallet_aura;
	#[runtime::pallet_index(24)]
	pub type AuraExt = cumulus_pallet_aura_ext;
    ```

Finally, [generate and edit](/builders/build/customize/customizing-chain-specs/#editing-json-chain-specs){target=\_blank} the chain specification paying special attention to:

- `para_id` - within this custom flow, a pre-registered appchain id is required. You can get an appchain ID moving forward with the registration to the **Reserve your Network ID** step. After you reserve the ID, start over the process to get back to this point
- `is_ethereum` - to `true` if exposing Ethereum compatible RPC endpoints is needed

And, depending on whether you are deploying a quick trial appchain or a dedicated one, also adjust these attributes:

=== "Quick Trial Appchain"

    ```json
    {
        ...
        "relay_chain": "rococo_flashbox_relay_testnet",
        "chainType": "Live",
        "genesis": {
            "runtime": {
                ...
                "authoritiesNoting": {
                    "orchestratorParaId": 1000
                },
                ...
            }
        }
        ...
    }
    ```

=== "Dedicated Appchain"

    ```json
    {
        ...
        "relay_chain": "rococo-local",
        "chainType": "Live",
        "genesis": {
            "runtime": {
                ...
                "authoritiesNoting": {
                    "orchestratorParaId": 0
                },
                ...
            }
        }
        ...
    }
    ```

Now, you can upload your custom raw specification file by selecting the **Custom** template and adding your JSON specification file.

![Upload a custom raw specification file to the Tanssi dApp.](/images/builders/deploy/dapp/dapp-6.webp)

!!! note
    The size of a raw chain specifications file should not exceed 2MB.

## Check Balances {: #check-balances }

Next, you'll need to verify that you have sufficient balance. If you don't, you can press **Request Tokens** and complete the following login with GitHub or Google. You'll need to complete a few quick onboarding questions, and then you'll be able to press **Request Tokens** again, and they will be delivered to your connected wallet. 

![Request tokens](/images/builders/deploy/dapp/dapp-7.webp)

If you're setting up a dedicated Tanssi appchain, you'll need to fill out an [application form](https://www.tanssi.network/dedicated-chain-testnet-form){target=\_blank}. The Tanssi team will review your application and send the necessary tokens within one business day. 

The required minimum balances to launch a Tanssi appchain are as follows:

=== "Quick Trial Appchain"
    |        Chain        | Balance Required |
    |:-------------------:|:----------------:|
    | Orchestration layer |     70 UNIT      |
    |   Tanssi TestNet    |     100 SNAP     |

=== "Dedicated Appchain"
    |            Chain             | Balance Required |
    |:----------------------------:|:----------------:|
    |  Tanssi TestNet   |    100 STAR     |

!!! note
    Quick trial appchains use an additional orchestration layer, therefore two different tokens, SNAP and UNIT, will be sent to your account. For dedicated appchains only STAR tokens are required.

## Reserve your Appchain ID {: #reserve-appchain-id }

If you haven't already done so, you must to reserve your Tanssi appchain ID, which will identify your chain within the Tanssi ecosystem.

To reserve your Tanssi appchain ID, you'll need to submit a transaction. Please make sure to use the account you plan to launch your Tanssi appchain with when submitting the transaction.

1. To initiate the transaction, click on **Reserve Network ID**
2. Your wallet will pop up, and you'll need to submit the transaction

![Reserve your Tanssi-powered Appchain ID via the Tanssi dApp.](/images/builders/deploy/dapp/dapp-8.webp)

Once the transaction has successfully gone through, your Tanssi appchain ID will be displayed on the dApp, and you'll be able to click **Continue** to proceed to the next step. You'll notice that some of your UNIT (or STAR if registering a dedicated Appchain) tokens have been removed from your transferable balance and are now reserved.

![Successfully reserved your Tanssi-powered Appchain ID via the Tanssi dApp.](/images/builders/deploy/dapp/dapp-9.webp)

## Generate Your Appchain Files {: #generate-appchain-files }

Before you can deploy your Tanssi appchain, you'll need to generate three configuration files:

- [The raw chain specification](/builders/build/customize/customizing-chain-specs/#generating-raw-specs-file){target=\_blank} - a compact version of the JSON specification file, which defines the initial settings and state that all nodes participating in the network must agree on to reach consensus and produce blocks
- [The genesis state header](/builders/build/customize/customizing-chain-specs/#genesis-state){target=\_blank} - defines the initial state upon which all transactions and state transitions are executed
- [The genesis Wasm](/learn/framework/architecture/#runtime){target=\_blank} - a WebAssembly (Wasm) blob that defines the runtime logic

These files will automatically be generated for you based on your Tanssi appchain ID and your customized template configurations. All you need to do is click **Generate**, and the dApp will generate the required files for you.

![Generate your Tanssi-powered appchain files with the click of a button on the Tanssi dApp.](/images/builders/deploy/dapp/dapp-10.webp)

Once the files have been generated, please click **Continue** to go on to the final step.

## Deploy Your appchain {: #deploy-your-appchain }

You're finally ready to take your last step towards preparing your appchain as it evolves into a Tanssi-powered appchain! For this final step, when registering a quick trial you'll need to submit two transactions: one to register your appchain on the orchestration layer and another to register your appchain on the Tanssi TestNet.

To register your appchain on the orchestration layer, take the following steps:

1. Click **Register** under the **Register Network in Relay** section
2. Confirm the transaction in your wallet

![Register your Tanssi-powered appchain on the orchestration layer.](/images/builders/deploy/dapp/dapp-11.webp)

Once the transaction has gone through successfully, the dApp will update to show that you have successfully registered your Tanssi appchain under the **Register Network in Relay** section.

Lastly, to register your appchain on Tanssi, take the following steps:

1. Click **Register** under the **Register Network in Tanssi** section
2. Confirm the transaction in your wallet

![Register your appchain on Tanssi.](/images/builders/deploy/dapp/dapp-12.webp)

Once the transaction has gone through successfully, the dApp will update to show that you have registered your Tanssi-powered appchain. Congratulations! On the dashboard, you can check the status of your deployment and view relevant information, such as the latest block information, RPC and WS endpoints, and more.

![The appchain dashboard on the Tanssi dApp.](/images/builders/deploy/dapp/dapp-13.webp)

And that's it! You've successfully registered your Tanssi appchain! The launch process will automatically begin once the Tanssi team has verified your registration. Once your appchain is live, you can return to the **Dashboard** to view the RPC URL and other pertinent chain information.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/deploy/
--- BEGIN CONTENT ---
---
title: Deploy Your Appchain
description: Learn how to deploy your appchain to Tanssi as a quick trial for short-term testing or as a dedicated one for long-term testing using the Tanssi dApp.
template: index-page.html
icon: octicons-rocket-24
---

# Deploy Your Appchain in Minutes

With Tanssi, launching your appchain is straightforward and efficient. The platform simplifies the process, so you can focus on building your application.

## Quick Overview of Deploying via the Tanssi DApp

Deploying a Tanssi-powered appchain via the [Tanssi dApp](https://apps.tanssi.network){target=\_blank} is accomplished as a single, streamlined flow consisting of five distinct steps:

1. Select a [template](/builders/build/templates/overview/){target=\_blank} and configure it
2. Satisfy the required minimum token balances
3. Reserve your Tanssi appchain ID
4. Generate your custom appchain files
5. Register your appchain on Tanssi

![A diagram mapping out the steps for deploying a Tanssi appchain with the Tanssi dApp.](/images/builders/deploy/deploy-1.webp)

!!! note
    For _Quick Trial appchains_ and _Dedicated appchains_ deployments on the Tanssi TestNet, the Tanssi team will manually complete verification. After verification, it typically takes about ten minutes for your quick trial appchain to be ready and about two hours for a dedicated one. For Tanssi MainNet, the process will be fully decentralized and permissionless.

To get started, visit [Using the Tanssi DApp](/builders/deploy/dapp/).

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/
--- BEGIN CONTENT ---
---
title: Guides for Developing Tanssi-Powered Networks
description: Start building your network, set your development environment up, test and deploy your runtime, and choose the integrations that suit your use case.
template: root-index-page.html
---

# Builders

Explore everything you need to build, deploy, and manage networks within the Tanssi ecosystem. From development tools to account management and network connectivity, the content in this section enables you to move confidently from concept to implementation.

## Build a Tanssi-Powered Network

<div class="grid cards" markdown>

-   <h2 class="title">Where to Start?</h2>
    [:octicons-arrow-right-24: Build a network from scratch using a template](/builders/build/templates/)

    [:octicons-arrow-right-24: Configure an existing Substrate-based runtime to be Tanssi compatible](/builders/build/templates/custom-runtime/)

-   <h2 class="title">Customize Your Network</h2>
    [:octicons-arrow-right-24: Leverage preexisting modules to add functionality](/builders/build/customize/adding-built-in-module/)

    [:octicons-arrow-right-24: Create your own custom module](/builders/build/customize/adding-custom-made-module/)

    [:octicons-arrow-right-24: Integrate external modules from other providers](/builders/build/customize/adding-external-module/)

</div>

## Deploy and Manage a Tanssi-Powered Network

<div class="grid cards" markdown>

-   <h2 class="title">Ready to Deploy?</h2>
    [:octicons-arrow-right-24: Deploy your network with the Tanssi dApp](/builders/deploy/dapp/)

-   <h2 class="title">Post-Deployment Actions</h2>
    [:octicons-arrow-right-24: Pay for block production services](/builders/manage/dapp/services-payment/)

    [:octicons-arrow-right-24: Mint tokens for your network's economy](/builders/manage/dapp/manage-tokens/)
    
    [:octicons-arrow-right-24: Manage the Sudo account for administrative control](/builders/manage/developer-portal/sudo/)

</div>

## Interact with a Tanssi-Powered Network

<div class="grid cards" markdown>

-   <h2 class="title">Tanssi Network References</h2>
    [:octicons-arrow-right-24: Access network endpoints](/builders/tanssi-network/endpoints/)

-   <h2 class="title">Tools for Tanssi Network Development</h2>
    [:octicons-arrow-right-24: Explore tools for Ethereum API integration](/builders/toolkit/ethereum-api/)

    [:octicons-arrow-right-24: Leverage Substrate tools for advanced network control](/builders/toolkit/substrate-api/)

    [:octicons-arrow-right-24: Enhance functionality of your app with integrations](/builders/toolkit/integrations/)

</div>

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/interoperability/built-in-bridge/
--- BEGIN CONTENT ---
---
title: Using the Built-In Tanssi Bridge
description: Learn how to use the built-in Tanssi bridge that connects Tanssi and Ethereum to convert TANSSI tokens between their native form and ERC-20 and vice versa.
icon: octicons-arrow-switch-24
categories: Basics
---

# Using the Built-In Tanssi Bridge

## Introduction {: #introduction }

The Tanssi protocol orchestrates infrastructure components, allowing developers to launch their customized appchains in minutes and providing them with out-of-the-box Ethereum-grade economic security. To make the whole process easy for developers, a [top-of-class architecture](/learn/tanssi/overview/#tanssi-architecture){target=\_blank} was designed and implemented.

The [TANSSI token](/builders/tanssi-network/tanssi-token/){target=\_blank} is the engine that enables the integration of different infrastructural components with [external security providers](/learn/tanssi/external-security-providers/symbiotic/){target=\_blank} and aligns incentives across various actors, including token holders, node operators, and appchain builders. To serve different use cases, the token has two versions: the Tanssi network's native currency, TANSSI (Substrate), and its ERC-20 version, on Ethereum.

Users can convert from one version to the other of the token using a [Tanssi built-in trustless bridge](/learn/tanssi/tanssi-ethereum-bridge/){target=\_blank}.

In this guide, you'll learn how to move your assets from Tanssi to Ethereum and vice versa through a secure and user-friendly web interface available at the [Tanssi dApp](https://apps.tanssi.network/bridge){target=\_blank}, making cross-chain transfers accessible for everyone.

## Prerequisites {: #prerequisites }

Before using the Tanssi bridge, ensure you have:

For bridging from Tanssi to Ethereum:

- A [Substrate-compatible wallet](/builders/toolkit/substrate-api/wallets/){target=\_blank}, such as [Talisman](/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank}.
- TANSSI (Substrate) balance to transfer and pay the bridging fees.
- The Ethereum-type destination account.

For bridging from Ethereum to Tanssi:

- An [Ethereum-compatible wallet](/builders/toolkit/ethereum-api/wallets/){target=\_blank}, such as [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.
- TANSSI (ERC-20) balance to transfer.
- ETH balance to pay the bridging fees.
- The Substrate-type destination account.

## Bridging TANSSI Tokens to Ethereum {: #bridge-to-ethereum }

If you want to convert your TANSSI (Substrate) tokens to TANSSI (ERC-20) on Ethereum, head to the Tanssi dApp, open the [bridge section](https://apps.tanssi.network/bridge){target=\_blank}, and then follow these steps:

1. Select **Mainnet** from the **From** dropdown.
2. Click on **Connect Wallet**. A pop-up will appear, allowing you to select your preferred Substrate wallet and choose the corresponding account.

![Select Tanssi Network and Connect the Wallet](/images/builders/interoperability/built-in-bridge/built-in-bridge-1.webp)

Now, with your wallet connected:

1. Select the destination account from the **Select recipient address** dropdown, or choose the **Enter a custom address** item and enter the account where you want to receive the ERC-20 tokens manually.
2. Enter the amount to bridge in the **Balance** field. The estimated bridge and transaction fees will be displayed along with the amount the destination account will receive.
3. Click on **Send** and sign the transaction.

![Execute the Transaction](/images/builders/interoperability/built-in-bridge/built-in-bridge-2.webp)

And that's it! Your tokens will be bridged when the next session starts. You can see how much time remains in the current session in the progress bar.

!!! note
    - You can easily add the TANSSI ERC-20 contract address to your wallet by clicking the **+** icon shown next to your balance.
    - Fees to convert your TANSSI (Substrate) tokens to TANSSI (ERC-20) might fluctuate over time and must be paid using TANSSI.

## Bridging ERC-20 TANSSI to Tanssi Network {: #bridge-to-tanssi }

If you want to convert your TANSSI (ERC-20) tokens to TANSSI (Substrate) native on the Tanssi network, head to the Tanssi dApp, open the [bridge section](https://apps.tanssi.network/bridge){target=\_blank}, and then follow these steps:

1. Select **Ethereum** from the **From** dropdown.
2. Click on **Connect Wallet**, select your preferred Ethereum wallet, and choose the account.

![Select Ethereum and Connect the Wallet](/images/builders/interoperability/built-in-bridge/built-in-bridge-3.webp)

Now, with your wallet connected:

1. Enter the Substrate destination account in the **Recipient** field.
2. Enter the amount to bridge in the **Balance** field. The estimated bridge and transaction fees will be displayed along with the amount the destination account will receive.
3. Click on **Send** and sign the transaction.

![Execute the Transaction](/images/builders/interoperability/built-in-bridge/built-in-bridge-4.webp)

And that's it! Your tokens will be bridged when the next session starts. You can see how much time remains in the current session in the progress bar.

!!! note
    Fees to convert your TANSSI (ERC-20) tokens to TANSSI (Substrate) native on the Tanssi network might fluctuate over time and must be paid using ETH.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/interoperability/
--- BEGIN CONTENT ---
---
title: Interoperability
description: Explore the built-in cross-chain solutions available within the Tanssi ecosystem, enabling asset transfers and communication between Tanssi and Ethereum.
icon: octicons-link-24
template: index-page.html
---

# Interoperability

Explore the built-in cross-chain solutions available within the Tanssi ecosystem, enabling asset transfers and communication between Tanssi and Ethereum.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/dapp/
--- BEGIN CONTENT ---
---
title: Using the Tanssi DApp to Manage Your Network
description: Learn how to use the Tanssi dApp to manage your network, including paying for block production services, managing tokens, opening XCM channels, and more.
icon: octicons-browser-24
template: index-page.html
---

# Using the Tanssi dApp To Manage Your Network

The [Tanssi dApp](https://apps.tanssi.network){target=\_blank} is your go-to platform for handling the operational aspects of your network within the Tanssi ecosystem. Designed for ease of use, the dApp allows developers to streamline everyday tasks like managing tokens, paying for block production services, and overseeing essential network operations without needing deep technical knowledge or advanced configurations.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/dapp/manage-tokens/
--- BEGIN CONTENT ---
---
title: Manage Tokens
description: Learn how the network governor can manage the token of a Tanssi-powered network using the dApp to mint them, configure the EIP-1559 fee market, and more.
icon: octicons-database-24
categories: Appchain
---

# Manage Tokens

## Introduction {: #introduction }

Any network deployed through Tanssi is sovereign and free to define the governance model that best fits its use case. The network governor has superpowers over the chain administration. Consequently, they can call privileged functions, such as updating the runtime and managing native token-related operations, among other actions.

There are some actions related to the native token management that are available to the network governor on the Tanssi dApp:

- **Mint tokens** - mints new tokens, increasing the total supply
- **Update balances** - increases or decreases the balance of an account, affecting the total supply
- **Transfer tokens** - executes a forced token transfer from one account to another
- **Configure gas dynamics** - only available on EVM-compatible networks, this action changes the [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md){target=\_blank} configuration, affecting the transaction pricing mechanism

In this guide, you'll learn how to execute the previously listed actions using the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

- A Tanssi-powered network (Quick Trial or Dedicated)
- The account you used when registering the network, imported in any of the [supported wallets](/builders/deploy/dapp/#supported-wallets){target=\_blank}
- Your network's Sudo account, also imported in any of the [supported wallets](/builders/deploy/dapp/#supported-wallets){target=\_blank}

!!! note
    The network's registration account is always a Substrate one, whereas the network's Sudo account depends on the chain type. If the chain is EVM-compatible, then the Sudo account will be an Ethereum type and, otherwise, a Substrate type.

### Retrieving the Registration Account {: #retrieving-registration-account }

If you're unsure what your registration account is, you can query it directly from the Tanssi orchestrator chain, which keeps records of every registered network. To do so, head to the **Chain state** section on the Polkadot.js Apps connected to the orchestrator chain for [quick trial networks](https://polkadot.js.org/apps/?rpc=wss://fraa-flashbox-rpc.a.stagenet.tanssi.network#/chainstate){target=\_blank} or [dedicated networks](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\_blank}, and take the following steps:

1. Select the **registrar** storage module
2. Select **registrarDeposit**
3. Insert your network ID
4. Press **+** icon

You'll see the registration account at the bottom.

![Locating your registration account](/images/builders/manage/dapp/locate-registration-account.webp)

!!! note
    The dApp will show your network in the dashboard only if you have the registration account properly set.

### Retrieving the Sudo Account {: #retrieving-sudo-account }

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Accessing the Token Management Panel {: #accesing-token-management-panel }

The Tanssi dApp implements a smooth interface, allowing the network governor to access and execute privileged functions. To do so, head to the [Tanssi dApp](https://apps.tanssi.network/){target=\_blank}, and then:

1. Click on the **Manage** button
2. Click on the **Token Management** button.

![Accessing the token management panel](/images/builders/manage/dapp/token-management/token-management-1.webp)

Now you have direct access to the actions presented in the introduction:

1. **Mint Tokens**
2. **Update Balances**
3. **Transfer Tokens**
4. Configure **Gas Dynamics** 

![The token management panel](/images/builders/manage/dapp/token-management/token-management-2.webp)

!!! note
    If you don't see your network's details on the dashboard, make sure to comply with the [prerequisites](#checking-prerequisites).

### Minting Tokens {: #minting-tokens }

The network governor can mint new tokens, increasing its total supply. To do so, in the **Token Management** panel, click on the **Mint tokens** button, and then:

1. Insert the address that will hold the newly minted tokens

    !!! note
        The destination address must be Ethereum type if the chain is EVM-compatible and a Substrate type otherwise.

2. Insert the amount of tokens to mint
3. Click on **Mint**

![Mint tokens](/images/builders/manage/dapp/token-management/token-management-3.webp)

You'll be asked to sign the transaction with the network's governor account. Once the transaction has gone through, the destination account's balance will have been increased by the desired amount.

### Updating Balances {: #updating-balances }

The network governor can increase or decrease the balance of any account, thus affecting the total supply. To do so, in the **Token Management** panel, click on the **Update Balances** button, and then:

1. Insert the address that will hold the newly minted tokens. Once you enter the address, its current balance will be displayed

    !!! note
        The destination address must be Ethereum type if the chain is EVM-compatible and a Substrate type otherwise.
    
2. Insert the new balance the address will hold
3. Click on **Update**

![Update Balances](/images/builders/manage/dapp/token-management/token-management-4.webp)

You'll be asked to sign the transaction with the network's governor account. Once the transaction has gone through, the destination account's balance will reflect exactly the desired amount, regardless of previous holdings.

### Executing Forced Transfers {: #forced-transfers }

The network governor can reassign balances, forcing a token transfer from one account to another. To do so, in the **Token Management** panel, click on the **Transfer Tokens** button, and then:

1. Insert the origin address that will transfer its tokens
2. Insert the destination address that will receive the tokens

    !!! note
        The origin and destination addresses must be Ethereum type if the chain is EVM-compatible and Substrate type otherwise.

3. Insert the amount of tokens to transfer
4. Click on **Transfer**

![Transfer Tokens](/images/builders/manage/dapp/token-management/token-management-5.webp)

You'll be asked to sign the transaction with the network's governor account. Once the transaction has gone through, the destination account will have received the number of tokens from the origin address.

### Setting Gas Dynamics {: #setting-gas }

!!! note
    This option only applies to EVM-compatible networks.

The governor of a Tanssi-powered EVM-compatible network can change its [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md){target=\_blank} configuration, affecting the transaction pricing mechanism. To do so, in the **Token Management** panel, click on the **Gas Dynamics** button, and then:

1. Insert the new base fee, expressed in Wei units (10<sup>-18</sup>)
2. Insert the elasticity value
3. Click on **Update Dynamics**

![Configure Gas Dynamics](/images/builders/manage/dapp/token-management/token-management-6.webp)

You'll be asked to sign the transaction with the network's governor account. Once the transaction has gone through, the network's fee mechanism will run with the new transaction pricing parameters.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/dapp/register-external-assets/
--- BEGIN CONTENT ---
---
title: Register External Assets
description: Tanssi networks benefit from native cross-chain communication, enabling smooth and fast token transfers between the tokenâ€™s native chain and other chains.
categories: Appchain
---

# Register External Assets

## Introduction {: #introduction }

Cross-chain asset transfer is crucial because it enables the seamless movement of digital assets across different networks, enhancing interoperability, liquidity, and user experience. To enable asset transfers to and from two networks, first, a bidirectional channel must be open between them. Thanks to the Tanssi dApp, opening a channel is an easy and quick task. Please refer to the [Manage Cross-Chain Communication Channels](/builders/manage/dapp/xcm-channels/){target=\_blank} article to know how to do it.

!!! note
    Opening a bidirectional communication channel requires approval from both networks governors.

Once your network's communication channels are established, you can register other chain's assets (external assets) to start operating. This guide will walk you through the process of registering external assets using the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

- A Tanssi-powered network (Dedicated) running [runtime 500](https://github.com/moondance-labs/tanssi/releases/tag/runtime-500){target=\_blank} or above
- The account you used when registering the network, imported in any of the [supported wallets](/builders/deploy/dapp/#supported-wallets){target=\_blank}
- Your network's Sudo account, also imported in any of the [supported wallets](/builders/deploy/dapp/#supported-wallets){target=\_blank}

!!! note
    The network's registration account is always a Substrate one, whereas the network's Sudo account depends on the chain type. If the chain is EVM-compatible, then the Sudo account will be an Ethereum type and, otherwise, a Substrate type.

### Retrieving the Registration Account {: #retrieving-registration-account }

If you're unsure what your registration account is, you can query it directly from the Tanssi orchestrator chain, which keeps records of every registered network. To do so, head to the **Chain state** section on the Polkadot.js Apps connected to the orchestrator chain for [quick trial networks](https://polkadot.js.org/apps/?rpc=wss://fraa-flashbox-rpc.a.stagenet.tanssi.network#/chainstate){target=\_blank} or [dedicated networks](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\_blank}, and take the following steps:

1. Select the **registrar** storage module
2. Select **registrarDeposit**
3. Insert your network ID
4. Press **+** icon

You'll see the registration account at the bottom.

![Locating your registration account](/images/builders/manage/dapp/locate-registration-account.webp)

!!! note
    The dApp will show your network in the dashboard only if you have the registration account properly set.

### Retrieving the Sudo Account {: #retrieving-sudo-account }

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Accessing the External Assets Registration Panel {: #accesing-external-assets-management-panel }

The Tanssi dApp makes it easy for the network governor to manage cross-chain communication configurations. It allows requesting new channels, accepting incoming channel opening requests, closing existing channels, managing external assets, and more. To access the cross-chain management panel, head to the [Tanssi dApp](https://apps.tanssi.network/){target=\_blank}, and then: 

1. Click on the **Manage** button
2. Click on the **XCM** button

![Accessing the cross-chain management panel](/images/builders/manage/dapp/access-xcm-management-panel.webp)

!!! note
    If you don't see your network's details on the dashboard, make sure to comply with the [prerequisites](#checking-prerequisites).

The panel will show your network's cross-chain configuration along with several available actions. Regarding external assets, the relevant elements you are presented with are:

1. **Registered Assets panel** - this section will group and present to you all registered assets your network already has available
2. **Registered Assets List** - already registered external assets will be displayed in this section, along with their associated information such as asset name, symbol, ID, total supply, and network ID where it is native
3. **Asset Registration** - this option allows you to select other available external assets and register them. The [following section](#register-external-asset) explains how to do it

![The cross-chain management panel](/images/builders/manage/dapp/register-external-assets/register-external-assets-1.webp)

## Register an External Asset {: #register-external-asset }

Provided your network has already established bidirectional communicaction channels with another network, the network governor can register external assets.

To do so, click on **Asset Registration** and then:

1. Select at least one of the available assets from the list
2. Click on **Register**

You'll be asked to sign the transaction, and once it's gone through, the external asset will be available locally. 

![Asset registration](/images/builders/manage/dapp/register-external-assets/register-external-assets-2.webp)

!!! note
    The dApp only presents well-known assets from well-known networks of the ecosystem. If the asset you need to register is not listed, you'll have to do it using the developer portal.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/dapp/services-payment/
--- BEGIN CONTENT ---
---
title: Block Production Services Payment
description: Networks deployed through Tanssi benefit from block production services provided by a set of node operators, which are compensated with Tanssi tokens.
icon: octicons-server-24
categories: Appchain
---

# Block Production Services Payment

## Introduction {: #introduction }

As presented in the [Block Production as a Service](/learn/tanssi/network-services/block-production/#block-production-fees){target=_\blank} article, there are two main costs associated that the network governor must cover: 

- **Sequencers assignment** - for the assignment of sequencers by the Tanssi protocol, which happens once per session
- **Block production** - for each block that is produced on the network's behalf

In this guide, you'll learn how to use the [Tanssi dApp](https://apps.tanssi.network){target=\_blank} to top-up your account and keep your network's liveness.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

- A Tanssi-powered network (Quick Trial or Dedicated)
- The account you used when registering the network, imported in any of the [supported wallets](/builders/deploy/dapp/#supported-wallets){target=\_blank}

If you're unsure what your registration account is, you can query it directly from the Tanssi orchestrator chain, which keeps records of every registered network. To do so, head to the **Chain state** section on the Polkadot.js Apps connected to the orchestrator chain for [quick trial networks](https://polkadot.js.org/apps/?rpc=wss://fraa-flashbox-rpc.a.stagenet.tanssi.network#/chainstate){target=\_blank} or [dedicated networks](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\_blank}, and take the following steps:

1. Select the **registrar** storage module
2. Select **registrarDeposit**
3. Insert your network ID
4. Press **+** icon

You'll see the registration account at the bottom.

![Locating your registration account](/images/builders/manage/dapp/locate-registration-account.webp)

!!! note
    The dApp will show your network in the dashboard only if you have the registration account properly set.

## Topping-Up Your Network's Credits {: #topping-up }

Following a pay-as-you-go model, the networks must have funds allocated to pay for the services, which, over time, will be deducted and burned by the Tanssi protocol upon every session change for the cost of the sequencer's assignment and for every block for the cost of producing the block.

You can check your network's current balance and top it up using the Tanssi dApp. To do so, head to the [Tanssi dApp](https://apps.tanssi.network/){target=\_blank} and connect the network's registration account to the dApp. The site will display a card showing your network status. This card includes the projected liveness forecast underneath the **Block Production** section and the **Top Up** button.

![Top-up action button in the dApp](/images/builders/manage/dapp/services-payment/services-payment-1.webp)

Clicking on the **Top Up** button displays a sidebar where the following information can be seen:

- **Current balance** - the current balance allocated for the network's block production service
- **Available balance** - the balance available in the network's registration account, which is connected to the dApp
- **Current cost** - current cost per sequencer's assignment and cost per block
- **Projected forecast** - the estimated day when the network runs out of funds and stops being served

To extend the network's projected runway, take the following actions:

1. Insert the amount of tokens to buy block production services
2. Click **Top Up**

![Top-up sidebar](/images/builders/manage/dapp/services-payment/services-payment-2.webp)

You will be asked to sign the transaction, and after it's gone through, your network will benefit from an extended horizon of liveness.

!!! warning
    If your network doesn't have enough funds to cover the sequencer's assignment and one session's worth of blocks, it will stall.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/dapp/xcm-channels/
--- BEGIN CONTENT ---
---
title: Manage Cross-Chain Communication Channels
description: Tanssi networks benefit from native cross-chain communication, which allows fast and secure bridging leveraging the architecture they are built on top of.
categories: Appchain
---

# Manage Cross-Chain Communication Channels

## Introduction {: #introduction }

As presented in the [Native Cross-Chain Communication](/learn/framework/xcm/){target=\_blank} article from the Learn section, all Tanssi-powered networks have an inherent capability to communicate and interoperate with any other network in the ecosystem. This native cross-chain communication feature is possible thanks to the unique infrastructure the networks are built on top of, leveraging the Cross-Consensus Message format (XCM for short), which facilitates communication between different consensus systems.

The first step to enable communication between networks is [opening a channel](/learn/framework/xcm/#channel-registration){target=\_blank}. The process of opening a channel starts by sending a request to the network you want to establish communications with. Once the request has been accepted by the destination chain's governor, a channel will be opened. 

In this guide, you'll learn how to use the [Tanssi dApp](https://apps.tanssi.network){target=\_blank} to manage your network's cross-chain communication channels.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

- A Tanssi-powered network (Dedicated) running [runtime 500](https://github.com/moondance-labs/tanssi/releases/tag/runtime-500){target=\_blank} or above
- The account you used when registering the network, imported in any of the [supported wallets](/builders/deploy/dapp/#supported-wallets){target=\_blank}
- Your network's Sudo account, also imported in any of the [supported wallets](/builders/deploy/dapp/#supported-wallets){target=\_blank}

!!! note
    The network's registration account is always a Substrate one, whereas the network's Sudo account depends on the chain type. If the chain is EVM-compatible, then the Sudo account will be an Ethereum type and, otherwise, a Substrate type.

### Retrieving the Registration Account {: #retrieving-registration-account }

If you're unsure what your registration account is, you can query it directly from the Tanssi orchestrator chain, which keeps records of every registered network. To do so, head to the **Chain state** section on the Polkadot.js Apps connected to the orchestrator chain for [quick trial networks](https://polkadot.js.org/apps/?rpc=wss://fraa-flashbox-rpc.a.stagenet.tanssi.network#/chainstate){target=\_blank} or [dedicated networks](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\_blank}, and take the following steps:

1. Select the **registrar** storage module
2. Select **registrarDeposit**
3. Insert your network ID
4. Press **+** icon

You'll see the registration account at the bottom.

![Locating your registration account](/images/builders/manage/dapp/locate-registration-account.webp)

!!! note
    The dApp will show your network in the dashboard only if you have the registration account properly set.

### Retrieving the Sudo Account {: #retrieving-sudo-account }

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Accessing the Channel Management Panel {: #accesing-channel-management-panel }

The Tanssi dApp makes it easy for the network governor to manage cross-chain communication configurations. It allows requesting new channels, accepting incoming channel opening requests, closing existing channels, managing external assets, and more. To access the cross-chain management panel, head to the [Tanssi dApp](https://apps.tanssi.network/){target=\_blank}, and then: 

1. Click on the **Manage** button
2. Click on the **XCM** button

![Accessing the cross-chain management panel](/images/builders/manage/dapp/access-xcm-management-panel.webp)

!!! note
    If you don't see your network's details on the dashboard, make sure to comply with the [prerequisites](#checking-prerequisites).

The panel will show your network's communication channels status along with several available actions. The elements you are presented with are:

1. **Sovereign account** - is a keyless account that belongs to the network in a different consensus system, the relay chain in this case. It can only be used by the network's governor. 

    Before opening a new channel, the network's sovereign account in the relay chain must be funded with enough tokens to be locked as a channel deposit.

    In this section, you can see your network's sovereign account balance, copy its address, and deposit tokens

2. **Incoming/Outgoing channel requests** - every channel request needs to be accepted by the counterpart before any message can be sent. 

    In this section, you can see the list of pending outgoing requests and cancel them. You can also see any incoming channel requests your network might have received and accept the channel

3. **Established channels** - Once the destination chain's governor has accepted the channel request, the channel becomes open and available for message transmission.

    In this section, you can see the list of accepted channels your network has, the direction in which the messages flow through the channel, and cancel the channel

4. **Request to open new channels** - this option allows you to select an existing network within the ecosystem and request a channel to be opened. The [next section](#request-new-channel) explains how to do it

![The channel management panel](/images/builders/manage/dapp/xcm-channels/xcm-channels-1.webp)

## Request to Open New Channel {: #request-new-channel }

Provided that your network has enough funds for the deposit in its relay chain's sovereign account, the network governor can request to open a new channel with any other network. 

To do so, click on **HRMP Channels** and then:

1. Select the network you want to establish a channel with
2. Click on **Request Channel**

You'll be asked to sign the transaction, and once it's gone through, the destination chain will receive the request. 

![Channel opening request](/images/builders/manage/dapp/xcm-channels/xcm-channels-2.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/developer-portal/impersonate/
--- BEGIN CONTENT ---
---
title: Impersonating Other Accounts With Sudo 
description: Learn how to use the Sudo key to dispatch calls by signing a transaction as if it came from a different account.
icon: octicons-person-add-24
categories: Appchain
---

# Using Sudo to Impersonate Other Accounts

## Introduction {: #introduction }

[Sudo](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\_blank} is a module that enables privileged runtime calls to be dispatched when called from the Sudo account. Sudo is sometimes colloquially referred to as a superuser or god-like account. This allows you to perform privileged actions while managing your network, such as impersonating other accounts.

In this guide, you'll learn how to use Sudo to impersonate other accounts. For example, this guide will use the Sudo account to pose as an arbitrary account and transfer funds from said account.

!!! warning
    The balance transfer demonstrated in this guide is dubious, and it is shown only as an example of using Sudo.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - A Tanssi-powered network (Quick Trial or Dedicated)
 - Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the [Managing Sudo guide](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} for instructions on injecting your Sudo account into Polkadot.js Apps

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Using the Sudo As Method {: #using-the-sudo-as-method }

As you know, the Sudo account can perform privileged functions, including impersonating other accounts. When submitting a call via `sudoAs`, the runtime will first authenticate the Sudo key and then dispatch the desired function call with the `Signed` origin from a given account. In the following example, the `sudoAs` method will orchestrate sending some tokens to another account. While the result is similar to using Sudo with a `forceBalanceTransfer` call, the following example uses a regular balance transfer call where the origin is the sender's account rather than the Sudo account.

To make a `sudoAs` call to impersonate another account, navigate to the **Developer** tab of Polkadot.js Apps for your Tanssi-powered network and click on **Sudo**. If you do not see **Sudo** in this menu, then you have not associated the Sudo account with Polkadot.js Apps. Ensure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps. Then, take the following steps:

1. Select the **Sudo** pallet
2. Select the **sudoAs** method
3. Select or paste in the desired account to impersonate
4. Select the desired pallet for the call to submit. In this case, it is the **balances** pallet
5. Select the **transferAllowDeath** method
6. Specify the destination account for the balance transfer
7. Specify the number of tokens to send
8. Press **SubmitSudo** and confirm the resulting pop-up

![Make a Sudo as call](/images/builders/manage/developer-portal/impersonate/impersonate-2.webp)

The other account had a starting balance of `1,000` tokens before the call, and subsequently dropped to `995` as expected.

![Check balances on Polkadot.js Apps](/images/builders/manage/developer-portal/impersonate/impersonate-3.webp)

## Using Sudo and the Dispatch As Utility {: #using-sudo-and-the-dispatch-as-utility }

The following section will demonstrate using Sudo to dispatch calls from an arbitrary origin. When submitting a call in this manner, the runtime will first authenticate the Sudo key and then dispatch the call using the `utility` pallet and the `dispatchAs` function, allowing the transaction's origin to be exactly what you'd like.  

To do so, navigate to the **Developer** tab of Polkadot.js Apps for your Tanssi-powered network and click on **Sudo**. If you do not see **Sudo** in this menu, you have not associated the Sudo account with Polkadot.js Apps. Ensure that your [Sudo account is injected by your wallet and connected to Polkadot.js Apps](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Then, take the following steps:

1. Select the **Sudo** pallet
2. Select the **Sudo** method
4. Select the desired pallet for the call to submit. In this case, it is the **utility** pallet
5. Select the **dispatchAs** method
6. Select **system** from the dropdown
7. Select the **signed** origin, which sets the origin of the transaction to be the specified account rather than root
8. Select the desired pallet for the call to submit. In this case, it is the **balances** pallet
9. Select the **transferAllowDeath** method
10. Specify the destination account for the balance transfer
11. Specify the number of tokens to send
12. Press **SubmitSudo** and confirm the resulting pop-up

![Use Sudo Dispatch As on Polkadot.js Apps](/images/builders/manage/developer-portal/impersonate/impersonate-4.webp)

The other account had a starting balance of `995` tokens prior to the call and dropped to `990` as expected.

![Check balances on Polkadot.js Apps](/images/builders/manage/developer-portal/impersonate/impersonate-5.webp)

And that's it! The [Developer Portal](/builders/manage/developer-portal/) section has plenty more guides on how to manage your Tanssi network.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/developer-portal/
--- BEGIN CONTENT ---
---
title: Using the Developer Portal to Manage Your Network
description: Learn how to use the developer portal to administer and manage your network, including upgrading your chain's runtime, rotating the Sudo keys, and more.
icon: octicons-key-24
template: index-page.html
---

# Using the Developer Portal

The developer portal empowers you to efficiently manage your Tanssi-powered network operations, security, and customization. With intuitive tools at your disposal, you can ensure smooth management and tailor your network to meet your project's unique requirements.

## How to Connect to the Developer Portal

Before getting started, you need to retrieve your network's WS URL. This information is available on your network's **Dashboard** in the Tanssi dApp underneath the **Properties** section.

![Retrieve your WS URL from the Tanssi dashboard](/images/builders/manage/developer-portal/index-1.webp)

Now you're ready to connect your Tanssi-powered network to the developer portal. Navigate to [Polkadot.js Apps](https://polkadot.js.org/apps/){target=\_blank} and click on the chain information in the top left corner to switch to your network.

![Retrieve your WS URL from the Tanssi dashboard](/images/builders/manage/developer-portal/index-2.webp)

To configure your network, take these steps:

1. Scroll down the left-side menu til you see **Development**. Click on that to expand the options
2. Click on **Local Node**
3. Enter in your RPC URL in the **custom endpoint** input field
4. Click the save button. The portal will reload and you should be connected to your network

![](/images/builders/manage/developer-portal/index-3.webp)

Now that you have your network loaded on the developer portal, you can dive into the following guides to start managing your network.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/developer-portal/maintenance/
--- BEGIN CONTENT ---
---
title: Enabling Maintenance Mode 
description: Learn how to use Sudo to turn on and off maintenance mode, which effectively pauses your network while still producing blocks and allowing select calls.
icon: octicons-stop-24
categories: Appchain
---

# Enabling Maintenance Mode

## Introduction {: #introduction }

The [Maintenance pallet](https://moonbeam.network/news/what-is-maintenance-mode/){target=\_blank} is a module that is designed for use only in emergencies that present existential threats to the network. Enabling maintenance mode on your network will suspend the processing of all regular transactions, including EVM interactions. Block production continues at a regular cadence and allows governance and staking functions to continue. 

Maintenance mode filters (ignores) all calls outside of governance and staking. Once maintenance mode is exited, your chain will process any pending transactions that queued up while your chain was in maintenance mode. Maintenance mode is intended to be used only as a temporary, emergency measure. 

For example, imagine discovering a critical exploit on your network that could result in significant financial losses if malicious actors exploit it. While you can address the issue by implementing a runtime upgrade, the process takes timeâ€”precious time during which your network remains vulnerable to attack. One potential solution is to activate maintenance mode on your network, complete the runtime upgrade, and exit maintenance mode once the fix has been verified.

!!! warning
    Enabling maintenance mode on a production network can significantly impact the contracts on your chain. While maintenance mode is enabled, no smart contract transactions are processed, so it's critical to consider the potential ramifications before activating it. 

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - A Tanssi-powered network (Quick Trial or Dedicated)
 - Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the [Managing Sudo guide](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} for instructions on injecting your Sudo account into Polkadot.js Apps

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Enabling Maintenance Mode {: #enabling-maintenance-mode }

As you know, the Sudo account can perform privileged functions, such as enabling and disabling maintenance mode. To enter maintenance mode and stop regular transaction processing, navigate to the **Developer** tab of Polkadot.js Apps for your Tanssi-powered network and click on **Sudo**. If you do not see **Sudo** in this menu, you have not associated the Sudo account with Polkadot.js Apps. Make sure that your [Sudo account is injected by your wallet and connected to Polkadot.js Apps](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Then, take the following steps:

1. Select the **maintenanceMode** pallet
2. Select the **enterMaintenanceMode** method
3. Press **Submit Sudo** and confirm the transaction in the resulting pop-up

![Enable maintenance mode](/images/builders/manage/developer-portal/maintenance/maintenance-2.webp)

To verify that maintenance mode has been enabled, you can check the **Explorer** section under the **Network** tab and review the recent events. 

![Check maintenance mode is enabled](/images/builders/manage/developer-portal/maintenance/maintenance-3.webp)

## Exiting Maintenance Mode {: #exiting-maintenance-mode }

To exit maintenance mode and return your network to normal operation, navigate to the **Developer** tab of Polkadot.js Apps for your Tanssi-powered network and click on **Sudo**. If you do not see **Sudo** in this menu, you have not associated the Sudo account with Polkadot.js Apps. Make sure that your [Sudo account is injected by your wallet and connected to Polkadot.js Apps](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Then, take the following steps:

1. Select the **maintenanceMode** pallet
2. Select the **resumeNormalOperation** method
3. Press **Submit Sudo** and confirm the transaction in the resulting pop-up

![Exit maintenance mode](/images/builders/manage/developer-portal/maintenance/maintenance-4.webp)

To verify that maintenance mode has been disabled, you can check in the **Explorer** section under the **Network** tab and review the recent events. 

![Check maintenance mode is disabled](/images/builders/manage/developer-portal/maintenance/maintenance-5.webp)

Remember that using maintenance mode is an emergency action that should only be activated when your chain is at dire risk. It may be worthwhile to establish a policy for your network that sets specific circuit breaker triggers to determine when maintenance mode will be enabled. Establishing a policy in advance will also streamline decision-making during a potential emergency.  

And that's it! The [Developer Portal](/builders/manage/developer-portal/) section has plenty more guides on how to manage your Tanssi-powered network.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/developer-portal/minting/
--- BEGIN CONTENT ---
---
title: Minting Native Tokens with Sudo 
description: Learn how to use the Sudo key to manage your Tanssi-powered network and perform the privileged action of minting native tokens, changing the total issuance.
icon: material-creation-outline
categories: Appchain
---

# Using Sudo to Mint Native Tokens

## Introduction {: #introduction }

[Sudo](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\_blank} is a module that enables privileged runtime calls to be dispatched when called from the Sudo account. Sudo is sometimes colloquially referred to as a superuser or god-like account. This enables you to perform privileged actions in the course of managing your network, such as minting new native tokens.

In this guide, you'll learn how to use Sudo to properly mint new native tokens. This comprehensive guide shows how to check the balance of an existing account prior to assigning it a new balance with Sudo access.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - A Tanssi-powered network (Quick Trial or Dedicated)
 - Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the [Managing Sudo guide](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} for instructions on injecting your Sudo account into Polkadot.js Apps

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Minting Tokens {: #minting-tokens }

As you know, the Sudo account has the ability to perform privileged functions, including minting additional tokens. When setting up your network on the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}, you can specify genesis account balances. In other words, you have the ability to endow accounts with initial balances upon launching your Tanssi network. However, you can also mint new tokens after launch with the help of the Sudo account.

!!! note
    This tutorial demonstrates assigning arbitrary token balances on a TestNet network that has no value. You should carefully consider the ramifications of creating additional tokens on your own Tanssi-powered network.

### Checking Existing Account Balance {: #checking-existing-account-balance }

The next section will demonstrate how to assign arbitrary token balances to accounts using the Sudo account. This process will overwrite the specified account's existing balance, so verifying the account is empty is a good practice before continuing. To check an account's balance, take the following steps:

1. Navigate to the **Developer** tab of [Polkadot.js Apps](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} and click on **Chain State**
2. Select the **system** pallet to query
3. Select **account**
4. Paste in the account address or select it from the dropdown
5. Press **+** icon
6. You'll see the balance information returned at the bottom, including free, reserved, and frozen balances

![Check balances on Polkadot.js Apps](/images/builders/manage/developer-portal/minting/minting-2.webp)

### Assigning Balances with Sudo {: #assigning-balances-with-sudo }  

To assign an account balance to an account, make sure to have your Sudo account accessible in [Polkadot.js Apps](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Then, take the following steps:

1. Navigate to the **Developer** Tab of Polkadot.js Apps for your Tanssi network
2. Click on **Sudo**. If you do not see **Sudo** in this menu, then you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps
3. Select the **balances** pallet
4. Select the **forceSetBalance** method
5. Paste in the account address to endow with tokens or select it from the dropdown
6. Enter the amount of tokens to endow the account with. In this example, we specify `9000000000000000000` for nine native tokens. Remember that Tanssi-powered EVM networks have 18 decimals, while Substrate or custom networks configure the decimals when launching the chain. If you're unsure how many decimals your network has, navigate to the **Settings** tab and click on **Metadata**
7. Press **Submit Sudo** and confirm the transaction in your wallet

![Force assign balances on Polkadot.js Apps](/images/builders/manage/developer-portal/minting/minting-3.webp)

And that's it! The [Developer Portal](/builders/manage/developer-portal/) section has plenty more guides on how to manage your Tanssi network.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/developer-portal/pause-transactions/
--- BEGIN CONTENT ---
---
title: Pausing Transactions
description: Learn how to use Sudo to temporarily pause hand-picked transactions, preventing their execution while allowing all other transactions to proceed as usual.
icon: octicons-stopwatch-24
categories: Appchain
---

# Pausing Transactions

## Introduction {: #introduction }

The [Transaction Pause module](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/tx-pause/src/lib.rs){target=\_blank} is one of the [built-in modules](/learn/framework/modules/#built-in-modules){target=\_blank} included in the Polkadot SDK, and it is available in any Tanssi-powered network based on the [official templates](/builders/build/templates/overview/){target=\_blank} version [400](https://github.com/moondance-labs/tanssi/releases/tag/runtime-400-templates){target=\_blank} or higher.

This module allows a network governor to temporarily avoid executing a set of hand-picked transactions while the rest of the transactions carry on as usual. This feature is helpful in several scenarios, such as disabling functionality in which a security threat has been discovered, enabling seasonal functionality only when needed, and enabling a set of transactions exactly on a launch date.

In an emergency scenario, when a critical exploit is discovered, this module allows the network to isolate and stop only the affected functionality, effectively minimizing the overall impact. 

!!! warning
    At the time of this writing, this module hasn't yet been audited; therefore, it is not recommended for production use. 

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - A Tanssi-powered network (Quick Trial or Dedicated) featuring the Transaction Pause module. Any new network deployment based on one of the templates will do; otherwise, make sure to [include the module](/builders/build/customize/adding-built-in-module/){target=\_blank} in your custom-made network runtime
 - Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the [Managing Sudo guide](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} for instructions on injecting your Sudo account into Polkadot.js Apps

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Module and Transaction Names {: #modules-transaction-names }

The [Transaction Pause module](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/tx-pause/src/lib.rs){target=\_blank} works by filtering the execution of specific transactions contained in the modules included in the network runtime. To do so, it keeps an internal list of the banned transactions identified by module and transaction name. This list is case-sensitive and works only when there is an exact match between one item in the paused transactions list and the transaction being processed. Therefore, using the exact names of the modules and the transactions is crucial.

To find out the names of the modules available in your runtime, you need to read the `construct_runtime!()` section in the `lib.rs` file of your network runtime in your project repository. If your network is based on one of the official templates, you'll find the file in the [Tanssi repository](https://github.com/moondance-labs/tanssi){target=\_blank}:

- For networks based on the EVM template: [the lib.rs file](https://github.com/moondance-labs/tanssi/blob/master/chains/container-chains/runtime-templates/frontier/src/lib.rs){target=\_blank}
- For networks based on the Substrate template: [the lib.rs file](https://github.com/moondance-labs/tanssi/blob/master/chains/container-chains/runtime-templates/simple/src/lib.rs){target=\_blank}

The following snippet is an example of how the `construct_runtime!()` section looks like. The module names are those located to the left of the colon.

```rust
construct_runtime!(
    pub enum Runtime
    {
        ...
        Migrations: pallet_migrations = 7,
        MaintenanceMode: pallet_maintenance_mode = 8,
        TxPause: pallet_tx_pause = 9,
        Balances: pallet_balances = 10,
        Multisig: pallet_multisig = 16,      
        ...
   }
```

To identify the transaction names included in a module, you need to refer to its source code. Modules built in [Substrate](/learn/framework/overview/#substrate-framework){target=\_blank} identify their transactions using a macro `#[pallet::call_index(INDEX)]`, where `INDEX` is a number. In the case of a [built-in module](/builders/build/customize/adding-built-in-module/){target=\_blank}, the code is located within the [FRAME folder](https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame){target=\_blank} of the Polkadot-SDK repository. For example, if you want to know about the transaction names in the `Balances` module, refer to its [lib.rs](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/balances/src/lib.rs){target=\_blank} file and look for the function names below the `#[pallet::call_index(INDEX)]` macros. The following snippet is the transaction `transfer_allow_death` of the module `Balances`, which is the one used as an example in this guide:

```rust
#[pallet::call_index(0)]
pub fn transfer_allow_death(
    origin: OriginFor<T>,
    dest: AccountIdLookupOf<T>,
    #[pallet::compact] value: T::Balance,
) -> DispatchResult {
    // Code
    Ok(())
}
```

### Some Frequently Used Modules and Transactions {: #frequently-used-modules-transactions }

When using any of the built-in Substrate modules, the name with which it's referenced within the runtime is entirely up to the developer, but the transaction names aren't customizable. Here is a list of some of the most commonly used modules with the most commonly used transactions they contain. Those are the transaction names to be used in this Transaction Pause module.

???+ function "[**pallet-ethereum**](https://github.com/polkadot-evm/frontier/blob/master/frame/ethereum/src/lib.rs){target=\_blank} â€” This module, along with the EVM module, provides full Ethereum compatibility to the network"

    | Transaction Name |        Description        |
    |:----------------:|:-------------------------:|
    |    `transact`    | Executes an Ethereum call |

??? function "[**pallet_balances**](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/balances/src/lib.rs){target=\_blank} â€” This module provides functionality for handling accounts and balances for the network native currency"

    |    Transaction Name    |                                                                 Description                                                                  |
    |:----------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------:|
    | `transfer_allow_death` |      Executes a balance transfer, deleting the sender's account when its final balance goes below the minimal requirement for existence      |
    | `transfer_keep_alive`  | Executes a balance transfer, keeping the sender's account alive even when its final balance goes below the minimal requirement for existence |
    |     `transfer_all`     |                                              Transfer all non-locked balances to a destination                                               |
    |         `burn`         |                                     Burns balance from the origin's account, reducing the total issuance                                     |

??? function "[**pallet_assets**](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/assets/src/lib.rs){target=\_blank} â€” This module provides functionality for handling fungible tokens"

    |   Transaction Name    |                                                                Description                                                                 |
    |:---------------------:|:------------------------------------------------------------------------------------------------------------------------------------------:|
    |       `create`        |                                                   Issues a new class of fungible assets                                                    |
    |    `start_destroy`    |                                          Starts the process of destroying a fungible asset class                                           |
    |  `destroy_accounts`   |                       Destroys all accounts associated with a given asset for which the destroy process was started                        |
    |  `destroy_approvals`  |                       Destroys all approvals associated with a given asset for which the destroy process was started                       |
    |   `finish_destroy`    |                          Completes the destroy process of a given asset for which the destroy process was started                          |
    |        `mint`         |                                                                Mints assets                                                                |
    |        `burn`         |                                                                Burns assets                                                                |
    |      `transfer`       |      Executes an asset transfer deleting the sender's account when its final balance goes below the minimal requirement for existence      |
    | `transfer_keep_alive` | Executes an asset transfer keeping the sender's account alive even when its final balance goes below the minimal requirement for existence |
    |       `freeze`        |                                          Disallows transfers of an asset from a specific account                                           |
    |        `thaw`         |                                         Allows again transfers of an asset from a specific account                                         |
    |    `freeze_asset`     |                                                      Disallows transfers of an asset                                                       |
    |     `thaw_asset`      |                                                     Allows again transfers of an asset                                                     |
    |    `set_metadata`     |                                                       Sets the metadata for an asset                                                       |
    |   `clear_metadata`    |                                                      Clears the metadata for an asset                                                      |
    
??? function "[**pallet_nfts**](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/nfts/src/lib.rs){target=\_blank} â€” This module provides functions for handling non-fungible tokens"

    |      Transaction Name       |                        Description                         |
    |:---------------------------:|:----------------------------------------------------------:|
    |          `create`           |       Issues a new collection of non-fungible items        |
    |          `destroy`          |        Destroys a collection of non-fungible items         |
    |           `mint`            |            Mints an item in an NFT collection              |
    |           `burn`            |          Destroys an item from an NFT collection           |
    |         `transfer`          |                      Transfers an NFT                      |
    |    `lock_item_transfer`     |              Disallow the transfer of an item              |
    |   `unlock_item_transfer`    |         Allows again the transfer of a locked item         |
    |       `set_attribute`       |     Sets an attribute for an NFT collection or an item     |
    |      `clear_attribute`      |    Clears an attribute for an NFT collection or an item    |
    |       `set_metadata`        |               Sets the metadata for an item                |
    |      `clear_metadata`       |              Clears the metadata for an item               |
    |  `set_collection_metadata`  |  Sets the metadata for a collection of non-fungible items  |
    | `clear_collection_metadata` | Clears the metadata for a collection of non-fungible items |
    |         `set_price`         |                 Sets the price for an item                 |
    |         `buy_item`          |        Buy an item, provided that it's up for sale         |

??? function "[**pallet_multisig**](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/multisig/src/lib.rs){target=\_blank} â€” This module provides functions for dealing with multi-signature schemas"

    |    Transaction Name    |                                                                 Description                                                                  |
    |:----------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------:|
    | `as_multi_threshold_1` |                                           Registers a multi-signature call with a single approval                                            |
    |       `as_multi`       | Registers a multi-signature call to be made from a composite account if approved by the specified minimum threshold of the other signatories |
    |   `approve_as_multi`   |              Registers approval for a multi-signature call and dispatches the call when the threshold of signatories is reached              |
    |   `cancel_as_multi`    |                                         Cancels a pre-existing, ongoing multi-signature transaction                                          |

## Pausing Transactions {: #pausing-transactions }

As you know, the Sudo account [can perform privileged actions](/builders/manage/developer-portal/sudo/){target=\_blank}, such as network upgrades, minting new tokens, and, in this case, pausing and unpausing transactions.

To pause a transaction, navigate to the **Developer** tab of Polkadot.js Apps for your Tanssi-powered network and click on **Sudo**. If you do not see **Sudo** in this menu, you have not associated the Sudo account with Polkadot.js Apps. Make sure that your [Sudo account is injected by your wallet and connected to Polkadot.js Apps](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Then, take the following steps:

1. Select the **txPause** module
2. Select the **pause** method
3. Insert the **module** name that contains the transaction that will be paused
4. Insert the **transaction** name that will be paused
5. Press **Submit Sudo** and confirm the transaction in the resulting pop-up

In this example, the transaction paused is `transfer_allow_death` from the `Balances` module:

![Pause transaction](/images/builders/manage/developer-portal/pause-transactions/pause-transactions-2.webp)

To verify that the transaction has been effectively paused, try executing it. You should get an error.

![Check that the transaction is paused](/images/builders/manage/developer-portal/pause-transactions/pause-transactions-3.webp)

!!! warning
    The `pause` transaction doesn't verify the module or transaction names and is case-sensitive, so any misspelling will go unnoticed, and the transaction will execute successfully. You should always verify that the transaction has been effectively paused.

## Unpausing Transactions {: #unpausing-transactions }

To unpause a transaction and return it to normal operation, navigate to the **Developer** tab of Polkadot.js Apps for your Tanssi-powered network and click on **Sudo**. If you do not see **Sudo** in this menu, you have not associated the Sudo account with Polkadot.js Apps. Make sure that your [Sudo account is injected by your wallet and connected to Polkadot.js Apps](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Then, take the following steps:

1. Select the **txPause** module
2. Select the **unpause** method
3. Insert the **module** name that contains the transaction that will be unpaused
4. Insert the **transaction** name that will be unpaused
5. Press **Submit Sudo** and confirm the transaction in the resulting pop-up

In this example, the transaction to unpause is `transfer_allow_death` from the `Balances` module:

![Unpause transaction](/images/builders/manage/developer-portal/pause-transactions/pause-transactions-4.webp)

The `unpause` transaction executes successfully only if the module and transaction parameters have been previously paused; otherwise, it fails. After the successful unpausing, the transaction can be called and executed again.

And that's it! The [Developer Portal](/builders/manage/developer-portal/) section has plenty more guides on how to manage your Tanssi network.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/developer-portal/smart-contracts-creation-filter/
--- BEGIN CONTENT ---
---
title: Smart EVM - Whitelist Contract Deployments
description: Learn how to use Sudo to whitelist smart contract deployers for your Smart EVM Tanssi-powered network, increasing overall security.
icon: octicons-file-binary-24
categories: Appchain, EVM-Template
---

# Smart EVM - Whitelist Contract Deployments

## Introduction {: #introduction }

EVM-compatible Tanssi-powered networks benefit from a unique feature: the network governor can define which accounts are authorized to deploy smart contracts, forbidding the action for any other non-whitelisted account.

This feature brings several key benefits that might be a great fit for different use cases or contexts. Some of those benefits are:

- **Enhanced Security** - by restricting deployment to trusted accounts, the risk of deploying malicious or vulnerable smart contracts is reduced
- **Quality Assurance** - known and vetted accounts can be required to follow specific coding standards and undergo thorough testing before deployment
- **Regulatory Compliance** - uses cases that are highly regulated can limit deployment to ensure that smart contracts meet legal and compliance requirements
- **Spam and Abuse Prevention** - prevent bad actors from deploying large numbers of unnecessary or harmful contracts

In this guide, you'll learn how to use the Sudo account to manage the whitelisted accounts that can deploy smart contracts on your network.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - An EVM-compatible Tanssi-powered network (Quick Trial or Dedicated) running [runtime 700](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank} or above. Any new network deployment based on the [EVM template](/builders/build/templates/evm/){target=\_blank} will do
 - Your network's Sudo account connected to your network's Polkadot.js Apps. You can refer to the [Managing Sudo guide](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} for instructions on injecting your Sudo account into Polkadot.js Apps

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Getting Started {: #getting-started }

To follow the next sections of this guide, head to Polkadot.js Apps for your Tanssi network. The Polkadot.js Apps link for your Tanssi network can be found in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Tooling** section.

![Locating your Polkadot.js Apps Link on apps.tanssi.network](/images/builders/manage/developer-portal/smart-contracts-creation-filter/smart-contracts-creation-filter-1.webp)

Once in Polkadot.js Apps, navigate to the **Developer** tab and click on **Sudo**.

!!! note
    If you do not see **Sudo** in this menu, then you have not associated the Sudo account with Polkadot.js Apps. Make sure that your [Sudo account is injected by your wallet and connected to Polkadot.js Apps](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}.

## Whitelisting Accounts {: #whitelist-accounts }

To define the accounts that will have authorization to deploy smart contracts, [get your Polkadot.js Apps started](#getting-started) and then take the following steps:

1. Select the **parameters** pallet. **setParameter** will be automatically selected in the functions selector and **ContractDeployFilter** in the **keyValue** parameter
2. Two options will be available in the **ContractDeployFilter** selector: **AllowedAddressesToCreate** and **AllowedAddressesToCreateInner**. Select the **AllowedAddressesToCreate** option if you want to whitelist the accounts for smart contract deployments and the latter to whitelist the accounts for indirect  (via a smart contract call) smart contract deployments
3. Toggle the **Include option** switch
4. Select the **Whitelisted** option
5. Insert the whitelisted account
6. If you need to insert more than one account, click on **Add item**
7. Press **Submit Sudo** and confirm the transaction in your wallet

![Whitelisting Accounts](/images/builders/manage/developer-portal/smart-contracts-creation-filter/smart-contracts-creation-filter-2.webp)

These same steps can be repeated at any moment to remove an account from the whitelist or to add new ones.

## Restoring Permissions to Deploy Smart Contracts {: #restoring-permission}

If you previously authorized some accounts to deploy smart contracts and want to allow any account to deploy smart contracts (as long as they can cover regular transaction fees), then [get your Polkadot.js Apps started](#getting-started) and take the following steps:

1. Select the **parameters** pallet. **setParameter** will be automatically selected in the functions selector and **ContractDeployFilter** in the **keyValue** parameter
2. Two options will be available in the **ContractDeployFilter** selector: **AllowedAddressesToCreate** and **AllowedAddressesToCreateInner**. Select the **AllowedAddressesToCreate** option if you want to clear the whitelist for smart contract deployments and the latter to clear the whitelist for indirect  (via a smart contract call) smart contract deployments
3. Toggle the **Include option** switch
4. Select the **All** option
5. Press **Submit Sudo** and confirm the transaction in your wallet

![Clearing the Whitelisted Accounts](/images/builders/manage/developer-portal/smart-contracts-creation-filter/smart-contracts-creation-filter-3.webp)

## Query the Whitelisted Accounts {: #query-whitelisted-accounts }

To get the current configuration containing the whitelisted accounts that can deploy smart contracts, go to Polkadot.js Apps (as explained in the [Getting Started](#getting-started) section), navigate to the **Developer** tab, click on **Chain state**, and take the following steps:

1. Select the **parameters** storage
2. Select the **parameters(ContainerChainTemplateFrontierRuntimeParametersKey)** option
3. Make sure that the **Include option** switch is on
4. Make sure that the **ContractDeployFilter** option is selected
5. Two options will be available in the **ContractDeployFilter** selector: **AllowedAddressesToCreate** and **AllowedAddressesToCreateInner**. Select the **AllowedAddressesToCreate** option if you want to query the whitelist for smart contract deployments and the latter to query the whitelist for indirect (via a smart contract call) smart contract deployments
6. Click the **+** button
7. The current configuration will be displayed

![Query the Whitelists](/images/builders/manage/developer-portal/smart-contracts-creation-filter/smart-contracts-creation-filter-4.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/developer-portal/sudo/
--- BEGIN CONTENT ---
---
title: Managing the Sudo Account
description: Learn how to manage the Sudo account of your network, including viewing and importing the Sudo key into Polkadot.js Apps and changing the current Sudo key.
icon: octicons-key-24
categories: Appchain
---

# Managing Your Network's Sudo Account

## Introduction {: #introduction }

[Sudo](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\_blank} is a module that enables privileged runtime calls to be dispatched when called from the Sudo account. Sudo is sometimes colloquially referred to as a superuser or god-like account. There can only be a single Sudo account at a time. However, the Sudo keys can be rotated to give Sudo privileges to a new account.

All Tanssi-powered networks come with the Sudo pallet by default, and you're required to designate an account as the Sudo address when launching your network. This enables you to perform privileged actions to manage your chain, such as upgrading your runtime or minting new native tokens. While the Sudo pallet is required to launch your Tanssi network on the TestNet, you can decommission the Sudo pallet and transition to decentralized governance after the MainNet launch.

In the following guide, you'll learn how to view the current Sudo account for your network and how to change it, alongside importing it into Polkadot.js Apps. There are similar guides in this section explaining how to use the Sudo account to perform privileged actions, such as [upgrading your runtime](/builders/manage/developer-portal/upgrade/){target=\_blank} and [minting native tokens](/builders/manage/developer-portal/minting/){target=\_blank}. 

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - A Tanssi-powered network (Quick Trial or Dedicated)
 - Your network's Sudo account connected to your network's Polkadot.js Apps

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

### Configuring Polkadot.js Apps { : #configuring-polkadotjs-apps }

After navigating to Polkadot.js Apps for your network, you'll need to add your Sudo account. Injecting your Sudo account into Polkadot.js Apps from a browser extension is considered safer than storing accounts directly in the browser. However, you can still import your Sudo account directly into the browser's cache. This method does not require the use of any extensions. To import an account into Polkadot.js in this manner, take the following steps:

1. Click on **Settings**
2. Under **in-browser account creation** select **Allow local in-browser account creation**
3. Press **Save**

![Allowing creation of in-browser storage](/images/builders/manage/developer-portal/sudo/sudo-2.webp)

Then, head back to the accounts tab and press **Account**. You'll then be able to replace the pre-generated private key with that of your Sudo account.

![Adding account on Polkadot.js Apps](/images/builders/manage/developer-portal/sudo/sudo-3.webp)

!!! warning
    In-browser key storage is not suitable for production environments. This example is provided for demonstration purposes only in a TestNet environment.

## Changing the Sudo Account {: #changing-the-sudo-account }

Changing your Tanssi-powered network's Sudo account is a straightforward process. Also known as rotating your Sudo keys, this process will remove Sudo access from the existing Sudo account and grant it to the new account. There can only be one Sudo account at any time. However, you are free to change the Sudo account as often as you would like.

Prior to getting started, make sure that you have your existing Sudo account accessible in [Polkadot.js Apps](#configuring-polkadotjs-apps). Then, take the following steps:

1. Navigate to the **Developer** Tab of Polkadot.js Apps for your network
2. Click on **Sudo**. If you do not see **Sudo** in this menu, then you have not associated the Sudo account with Polkadot.js Apps. Make sure that your Sudo account is injected by your wallet and connected to Polkadot.js Apps
3. Select the **Set Sudo key** heading
4. Select the new account you'll transfer Sudo privileges to
5. Press **Reassign** and confirm the transaction in your wallet

![Change Sudo account on Polkadot.js Apps](/images/builders/manage/developer-portal/sudo/sudo-4.webp)

!!! note
    Ensure that you have access to the new Sudo account. Once Sudo is transferred, it cannot be undone without access to the current Sudo key.

And that's it! The [Developer Portal](/builders/manage/developer-portal/) section has plenty more guides on how to manage your Tanssi network.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/developer-portal/upgrade/
--- BEGIN CONTENT ---
---
title: Upgrade Your Appchain's Runtime
description: Learn how to use the Sudo account to perform the privileged action of upgrading the runtime of your Tanssi-powered appchain through the developer portal.
icon: octicons-arrow-up-24
categories: Appchain
---

# Upgrading Your Appchain Runtime with Sudo

## Introduction {: #introduction }

[Sudo](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\_blank} is a module that enables privileged runtime calls to be dispatched when called from the Sudo account. Sudo is sometimes colloquially referred to as a superuser or god-like account. This enables you to perform privileged actions in the course of managing your appchain, such as upgrading your Tanssi-powered appchain's runtime.

In this guide, you'll learn how to use Sudo to upgrade your appchain's runtime. With Sudo access, upgrading your chain is a quick and easy process. Note that appchain teams in production will have the option to phase out Sudo access and rely on governance to process runtime upgrades.

## Checking Prerequisites {: #checking-prerequisites }

For the example in this guide, you will need to have the following:

 - A Tanssi-powered appchain (Quick Trial, Dedicated, or MainNet).
 - Your appchain's Sudo account connected to your appchain's developer portal. You can refer to the [Managing Sudo guide](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} for instructions on injecting your Sudo account into the developer portal.
 - The new [Wasm runtime](/learn/framework/architecture/#runtime){target=\_blank} binary file, built with a higher version than the current one.

If you're unsure what your Tanssi network's Sudo account is, you can find it in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section.

![Locating your Sudo address on apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    It's critical to protect your Sudo account key with the utmost security precautions, as it grants privileged access to your Tanssi network.

## Obtaining the Wasm Runtime {: #obtaining-wasm-runtime }

If your chain is based on one of the official templates, you can download the official Wasm runtime binary file from the table below. The official releases are published in the [releases section](https://github.com/moondance-labs/tanssi/releases){target\_blank} in the Tanssi repository.


|                                               Version                                                |                                                                             EVM Template                                                                              |                                                                            Substrate Template                                                                             |
|:----------------------------------------------------------------------------------------------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| [1400](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1400-templates){target=\_blank} | [Download EVM V1400 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1400-templates/frontier-template-runtime-1400.wasm){target=\_blank} | [Download Substrate V1400 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1400-templates/simple-template-runtime-1400.wasm){target=\_blank} |
| [1300](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1300-templates){target=\_blank} | [Download EVM V1300 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1300-templates/frontier-template-runtime-1300.wasm){target=\_blank} | [Download Substrate V1300 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1300-templates/simple-template-runtime-1300.wasm){target=\_blank} |
| [1201](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1201-templates){target=\_blank} | [Download EVM V1201 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1201-templates/frontier-template-runtime-1201.wasm){target=\_blank} | [Download Substrate V1201 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1201-templates/simple-template-runtime-1201.wasm){target=\_blank} |
| [1100](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1100-templates){target=\_blank} | [Download EVM V1100 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1100-templates/frontier-template-runtime-1100.wasm){target=\_blank} | [Download Substrate V1100 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1100-templates/simple-template-runtime-1100.wasm){target=\_blank} |
| [1000](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1000-templates){target=\_blank} | [Download EVM V1000 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1000-templates/frontier-template-runtime-1000.wasm){target=\_blank} | [Download Substrate V1000 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1000-templates/simple-template-runtime-1000.wasm){target=\_blank} |
|  [900](https://github.com/moondance-labs/tanssi/releases/tag/runtime-900-templates){target=\_blank}  |  [Download EVM V900 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-900-templates/frontier-template-runtime-900.wasm){target=\_blank}   |  [Download Substrate V900 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-900-templates/simple-template-runtime-900.wasm){target=\_blank}   |
|       [800](https://github.com/moondance-labs/tanssi/releases/tag/runtime-800){target=\_blank}       |       [Download EVM V800 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-800/frontier-template-runtime-800.wasm){target=\_blank}        |       [Download Substrate V800 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-800/simple-template-runtime-800.wasm){target=\_blank}        |
|       [700](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank}       |       [Download EVM V700 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-700/frontier-template-runtime-700.wasm){target=\_blank}        |       [Download Substrate V700 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-700/simple-template-runtime-700.wasm){target=\_blank}        |
|       [600](https://github.com/moondance-labs/tanssi/releases/tag/runtime-600){target=\_blank}       |       [Download EVM V600 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-600/frontier-template-runtime-600.wasm){target=\_blank}        |       [Download Substrate V600 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-600/simple-template-runtime-600.wasm){target=\_blank}        |
|       [500](https://github.com/moondance-labs/tanssi/releases/tag/runtime-500){target=\_blank}       |       [Download EVM V500 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-500/frontier-template-runtime-500.wasm){target=\_blank}        |       [Download Substrate V500 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-500/simple-template-runtime-500.wasm){target=\_blank}        |
|  [400](https://github.com/moondance-labs/tanssi/releases/tag/runtime-400-templates){target=\_blank}  |  [Download EVM V400 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-400-templates/frontier-template-runtime-400.wasm){target=\_blank}   |  [Download Substrate V400 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-400-templates/simple-template-runtime-400.wasm){target=\_blank}   |
|  [300](https://github.com/moondance-labs/tanssi/releases/tag/templates-runtime-300){target=\_blank}  |  [Download EVM V300 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/templates-runtime-300/frontier-template-runtime-300.wasm){target=\_blank}   |  [Download Substrate V300 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/templates-runtime-300/simple-template-runtime-300.wasm){target=\_blank}   |
|       [200](https://github.com/moondance-labs/tanssi/releases/tag/runtime-200){target=\_blank}       |       [Download EVM V200 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-200/frontier-template-runtime-200.wasm){target=\_blank}        |       [Download Substrate V200 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-200/simple-template-runtime-200.wasm){target=\_blank}        |
|  [101](https://github.com/moondance-labs/tanssi/releases/tag/runtime-101-templates){target=\_blank}  |  [Download EVM V101 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-101-templates/frontier-template-runtime-101.wasm){target=\_blank}   |  [Download Substrate V101 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-101-templates/simple-template-runtime-101.wasm){target=\_blank}   |
|  [100](https://github.com/moondance-labs/tanssi/releases/tag/runtime-100-templates){target=\_blank}  |  [Download EVM V100 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-100-templates/frontier-template-runtime-100.wasm){target=\_blank}   |  [Download Substrate V100 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-100-templates/simple-template-runtime-100.wasm){target=\_blank}   |

You should always upgrade the runtime following the releases in an orderly fashion, applying one release after another without skipping any of them. To do so, you need to know your appchain's current runtime version, which you'll find in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Properties** section. For example, if your runtime version is `1000`, you should upgrade first to `1100`, then `1201`, then `1300`, and so on until the latest available version.

!!! warning
    Applying the upgrades in order ensures that the changes (migrations) in the internal data structures are applied, preserving data consistency. Doing otherwise might **stall** your appchain.

!!! note
    If you are compiling the runtime manually, make sure to use the Wasm version `compact` and `compressed`, which is optimized and lighter.

## Upgrading Your Runtime {: #upgrading-your-runtime }

To get started, head to the developer portal for your Tanssi appchain, which can be found in your [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} underneath the **Tooling** section.

![Locating your Developer Portal Link on apps.tanssi.network](/images/builders/manage/developer-portal/upgrade/upgrade-1.webp)

!!! warning
    If your appchain was deployed using an official template and the intended upgrade is a custom runtime, make sure to have changed the default spec name (*frontier-template* or *container-chain-template*) to a different one before building the Wasm file. You'll also need to execute the `setCodeWithoutChecks` extrinsic instead of `setCode`.

With your [Wasm runtime](/learn/framework/architecture/#runtime){target=\_blank} ready to upload and your [Sudo account accessible in the developer portal](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}, take the following steps:

1. Navigate to the **Developer** tab of the developer portal for your Tanssi appchain.
2. Click on **Sudo**. If you do not see **Sudo** in this menu, then you have not associated the Sudo account with the developer portal. Make sure that your [Sudo account is injected by your wallet and connected to the developer portal](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}.
3. Select the **system** pallet.
4. Select **setCode**.
5. Toggle the **fileUpload** switch to enable uploading your Wasm runtime file.
6. Upload your Wasm runtime.
7. Press **Submit Sudo** and confirm the transaction in your wallet.

![Upgrading your Runtime on the Developer Portal](/images/builders/manage/developer-portal/upgrade/upgrade-2.webp)

You can verify that your runtime upgrade was successful by checking the runtime version in the upper left-hand corner. In this case, you can see that the Tanssi-powered appchain's runtime was successfully upgraded to version `400`.

![Check Runtime version on Polkadot.js Apps](/images/builders/manage/developer-portal/upgrade/upgrade-3.webp)

And that's it! The [developer portal](/builders/manage/developer-portal/) section has plenty more guides on how to manage your Tanssi appchain.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/manage/
--- BEGIN CONTENT ---
---
title: Manage Your Network
description: Learn how to use the developer portal and the Tanssi dApp to manage your network, including minting tokens, paying for block production services, and more.
icon: octicons-gear-24
template: index-page.html
---

# Managing Your Tanssi-Powered Network

The Tanssi dApp and the developer portal serve different purposes when managing your network, offering unique benefits tailored to your needs:

- **[Tanssi dApp](https://apps.tanssi.network){target=\_blank}** - simplifies the entire network lifecycle, from deployment to basic management. By removing technical complexities, it enables a faster and more streamlined experience for creating and managing networks. Some actions that can be performed via the dApp include:

    - [Paying for block production services](/builders/manage/dapp/services-payment/)
    - [Managing tokens](/builders/manage/dapp/manage-tokens/) (i.e., minting and transferring tokens, updating balances, and more)

- **Developer portal** - built on Polkadot.js Apps, the developer portal provides advanced tools for network management, including runtime upgrades, token minting, and more. It is ideal for tasks requiring precise control and customization. Some actions that can be performed via the developer portal include:

    - [Managing the Sudo account](/builders/manage/developer-portal/sudo/)
    - [Dispatching runtime upgrades](/builders/manage/developer-portal/upgrade/)
    - [Minting tokens](/builders/manage/developer-portal/minting/)
    - [Pausing transactions](/builders/manage/developer-portal/pause-transactions/) or [enabling maintenance mode](/builders/manage/developer-portal/maintenance/) in emergencies

Jump into the sections below to explore how each tool helps you manage your Tanssi-powered network efficiently.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/tanssi-network/endpoints/
--- BEGIN CONTENT ---
---
title: Network Endpoints
description: Tanssi networks have two endpoints available for users to connect to, one for HTTPS and one for WSS. This page has the RPC endpoints you need to get started.
icon: octicons-share-android-24
categories: Reference
---

## Network Endpoints

Tanssi networks have two endpoints available for users to connect to: one for HTTPS and one for WSS.

## Tanssi MainNet

The Tanssi Network MainNet HTTPS and WSS endpoints are as follows:

=== "HTTPS"

    ```text
    https://{{ networks.mainnet.dns_name }}
    ```

=== "WSS"

    ```text
    wss://{{ networks.mainnet.dns_name }}
    ```

## Dancelight

The Tanssi TestNet HTTPS and WSS endpoints are as follows:

=== "HTTPS"

    ```text
    https://{{ networks.dancelight.dns_name }}
    ```

=== "WSS"

    ```text
    wss://{{ networks.dancelight.dns_name }}
    ```

### Demo EVM Network

The demo EVM network HTTPS and WSS endpoints are as follows:

=== "HTTPS"

    ```text
    {{ networks.dancelight.demo_evm_rpc_url }}
    ```

=== "WSS"

    ```text
    {{ networks.dancelight.demo_evm_rpc_wss_url }}
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/tanssi-network/
--- BEGIN CONTENT ---
---
title: Network Essentials
description: Discover everything you need to know about the Tanssi ecosystem, its different networks, and its key aspects to get started developing and interacting with it.
icon: octicons-star-24
template: index-page.html
---

# Network Essentials

Learn about the Tanssi network, the available TestNets, and key functionalities and aspects to get started with development and interaction with it.

## Network Overview

- **TANSSI token**: the utility token native to the Tanssi networks, and its ERC-20 representation.
- **Dancelight**: the official Tanssi TestNet for rapid network deployment and experimentation.
- **Tanssi-powered networks**: networks built on the Tanssi platform, leveraging its capabilities to create custom blockchains.
- **Demo EVM network**: a sample Ethereum-compatible network that demonstrates a fully operational Tanssi-powered network.

## Explore This Section

:::INSERT_GENERATED_CARDS:::

## Additional Resources

<div class="subsection-wrapper">
  <div class="card">
    <a href="/builders/toolkit/">
      <div class="card-header">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M7.875 2.292a.114.114 0 0 0-.032.018A7.239 7.239 0 0 0 4.75 8.25a7.248 7.248 0 0 0 3.654 6.297c.57.327.982.955.941 1.682v.002l-.317 6.058a.75.75 0 1 1-1.498-.078l.317-6.062v-.004c.006-.09-.047-.215-.188-.296A8.749 8.749 0 0 1 3.25 8.25a8.738 8.738 0 0 1 3.732-7.169 1.547 1.547 0 0 1 1.709-.064c.484.292.809.835.809 1.46v4.714a.25.25 0 0 0 .119.213l2.25 1.385c.08.05.182.05.262 0l2.25-1.385a.25.25 0 0 0 .119-.213V2.478c0-.626.325-1.169.81-1.461a1.547 1.547 0 0 1 1.708.064 8.741 8.741 0 0 1 3.732 7.17 8.747 8.747 0 0 1-4.41 7.598c-.14.081-.193.206-.188.296v.004l.318 6.062a.75.75 0 1 1-1.498.078l-.317-6.058v-.002c-.041-.727.37-1.355.94-1.682A7.247 7.247 0 0 0 19.25 8.25a7.239 7.239 0 0 0-3.093-5.94.114.114 0 0 0-.032-.018l-.01-.001c-.003 0-.014 0-.031.01-.036.022-.084.079-.084.177V7.19c0 .608-.315 1.172-.833 1.49l-2.25 1.385a1.75 1.75 0 0 1-1.834 0l-2.25-1.384A1.752 1.752 0 0 1 8 7.192V2.477c0-.098-.048-.155-.084-.176a.068.068 0 0 0-.031-.011l-.01.001Z"></path></svg>
        <h2 class="title">Network Toolkit</h2>
      </div>
      <p class="description">Dive into tools and resources designed to streamline the development process when building dApps on Tanssi and Tanssi-powered networks.</p>
    </a>
  </div>
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/tanssi-network/mainnet/
--- BEGIN CONTENT ---
---
title: Get Started with Tanssi MainNet
description: The Tanssi Network MainNet is live, allowing developers to leverage the decentralized protocol to launch appchains with Ethereum-grade security in minutes.
icon: octicons-star-24
---

# Get Started with the Tanssi Network MainNet

## Introduction

Tanssi Network MainNet is live, allowing developers to swiftly onboard and launch their appchains within minutes.

This quick reference page offers all the essentials you need to get started on the Tanssi Network.

## TANSSI Token {: #tanssi-token }

{{ networks.mainnet.token_symbol }} tokens serve as the native currency within the Tanssi Network. To initiate the deployment of a network on Tanssi, you'll need to obtain {{ networks.mainnet.token_symbol }} tokens.

## Network Endpoints {: #tanssi-network-endpoints }

Tanssi MainNet has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.

=== "HTTPS"

    ```text
    https://{{ networks.mainnet.dns_name }}/
    ```

=== "WSS"

    ```text
    wss://{{ networks.mainnet.dns_name }}
    ```

## Block Explorers {: #tanssi-block-explorers }

For Tanssi MainNet, you can use the following block explorer:

- [Tanssi Network Subscan]({{ networks.mainnet.subscan_url }}){target=\_blank}
- [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/explorer){target=\_blank}

Support for additional block explorers is in the works and as more explorers support Tanssi MainNet, this section will be updated accordingly.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/tanssi-network/tanssi-token/
--- BEGIN CONTENT ---
---
title: TANSSI Token
description: Learn about the two versions of the Tanssi token - the native Substrate token and the ERC-20 representation on Ethereum, and their utilities and use cases.
icon: octicons-ruby-24
categories: Basics
---

# TANSSI Token {: #tanssi-token }

## Introduction {: #introduction }

The Tanssi network token is the utility token that powers the Tanssi protocol. Considering [Tanssi's architecture](/learn/tanssi/overview/#tanssi-architecture){target=\_blank}, the token exists in two distinct yet interconnected representations: native substrate and Ethereum ERC-20. The two versions can be bridged between each other through the [Tanssi-Ethereum bridge](/learn/tanssi/tanssi-ethereum-bridge/){target=\_blank}.

In this guide, the token's utility and the differences between its two representations are covered, which is crucial for network operators, stakers, appchain managers, and general users who want to participate in the Tanssi ecosystem.

## Token Utility {: #token-utility }

Tanssi is a decentralized infrastructure protocol that makes deploying appchains with custom logic easy. It allows developers to focus on the use case instead of diverting time and energy to manage the [numerous components required](/learn/tanssi/overview/#what-tanssi-provides){target=\_blank} for a network to run smoothly.

Running a healthy decentralized protocol not only requires a robust governance mechanism to ensure that decisions are made transparently but also aligning incentives and coordinating among several ecosystem actors, including appchain developers, node operators, sequencer operators, data availability and RPC providers, as well as general users. The Tanssi token serves as the backbone, providing the economic mechanisms necessary to coordinate, incentivize proper behavior, and secure the entire ecosystem. It enables a verifiable and code-enforced protocol evolution through a fully on-chain decision-making process.

The token has several utilities:

- **On-chain governance**: token holders can use the token to propose and vote in governance decisions, such as software upgrades, how to spend treasury funds, change protocol rules, and more.
- **Appchain deployment**: use the token to register and launch your appchain in minutes.
- **Sequencing as a service payment**: use the token to keep your appchain live.
- **Sequencing and operator services rewarding**: get tokens as rewards for your nodes' services.
- **Staking on sequencers**: token holders can stake on sequencers, getting rewards with no risk of slashing.
- **Staking on operators**: token holders can stake on operators, getting rewards for their validation services.
- **Fees payment**: use the token to pay the fees for interacting with the Tanssi network.

!!! note
    All transaction fees on Tanssi are paid using the token, with the full amount going directly to fund the protocol's treasury account. These funds can only be spent via governance.

## Token Representations {: #token-representations }

The Tanssi network is built using the Substrate framework, leveraging its modular architecture and high performance. Therefore, the native token is of a Substrate type. The protocol's minting and burning mechanisms happen on the Tanssi network side, or, in other words, happen on the Substrate token representation.

Additionally, the Tanssi protocol relies on [external security providers](/learn/tanssi/external-security-providers/){target=\_blank}, such as [Symbiotic](/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}, to secure the ecosystem through restaked assets. This restaking mechanism is implemented on Ethereum; therefore, an ERC-20 version of the token also exists to cover user cases on the Ethereum side.

Leveraging Tanssi's [built-in bridging capabilities](/learn/tanssi/tanssi-ethereum-bridge/){target=\_blank}, the token can be converted to (and from) the ERC-20  representation on Ethereum. When the token is bridged to Ethereum, the tokens are locked in the bridge's sovereign account, and a message is sent to the Ethereum contract to mint the equivalent amount in ERC-20. This lock-and-mint mechanism ensures the ERC-20 version is created through a trustless bridging mechanism, maintaining a 1:1 relationship with the native token.

```mermaid
flowchart LR
    subgraph Tanssi_Network ["Tanssi Network"]
        Tanssi_Substrate["$TANSSI (Substrate)"]
        Tanssi_Substrate_Utility["âœ“ On-chain governance
        âœ“ Appchain deployment
        âœ“ Sequencers rewarding
        âœ“ Staking on sequencers
        âœ“ Fees payment
        "]
        Tanssi_Substrate --> Tanssi_Substrate_Utility
    end

    subgraph Ethereum_Network ["Ethereum"]
        Tanssi_ERC20["$TANSSI (ERC-20)"]
        Tanssi_ERC20_Utility["âœ“ Operator services rewarding
        âœ“ Staking on operators
        <pre> </pre>
        "]
        Tanssi_ERC20 --> Tanssi_ERC20_Utility
    end

    Bridge["Trustless Bridge"]

    Tanssi_Network <--> Bridge <--> Ethereum_Network

    %% Apply custom style to utility nodes
    classDef utility_style fill: transparent, stroke: transparent, text-align: start;
    class Tanssi_Substrate_Utility,Tanssi_ERC20_Utility utility_style;
    %% Make utility arrows transparent
    linkStyle 0 stroke:transparent,fill:transparent;
    linkStyle 1 stroke:transparent,fill:transparent;
```

### Tanssi (Substrate) - Native Token {: #tanssi-substrate }

The native Tanssi token exists on the Tanssi network as a Substrate-based asset and is the original form of the token that powers the core protocol operations.

This token uses as [Sr25519 subtrate-type account](/learn/tanssi/account-types/#key-types-in-tanssi-protocol){target=\_blank}, so it requires a wallet such as [Talisman](/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank} or any other [substrate-compatible wallet](/builders/toolkit/substrate-api/wallets/){target=\_blank}.

!!! note
    The Tanssi (Substrate) native token has twelve (12) decimal places.

### Tanssi (ERC-20) - Ethereum Representation {: #tanssi-erc-20 }

Tanssi's ERC-20 version is a standard Ethereum token that represents the native token on the Ethereum network. This version is created through the trustless bridging mechanism, utilizing a lock-and-mint strategy, thereby maintaining a 1:1 relationship with the native token. 

This token, like any other Ethereum asset, uses an [ECDSA account](/learn/tanssi/account-types/#key-types-in-tanssi-protocol){target=\_blank}, so it requires a wallet such as [Metamask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} or any other [Ethereum-compatible wallet](/builders/toolkit/ethereum-api/wallets/){target=\_blank}.

!!! note
    The Tanssi (ERC-20) has twelve (12) decimal places.

### Tanssi (Substrate) and Tanssi (ERC-20) Comparison {: #substrate-erc-20-comparison }

To better understand the differences between the two token representations, the following table provides a summary of their main features:

| **Feature**            | **Tanssi (Substrate)**                                                                                                                                                                                                  | **Tanssi (ERC-20)**                                                                                                                                                                               |
|------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Network**            | Tanssi Network                                                                                                                                                                                                          | Ethereum MainNet                                                                                                                                                                                  |
| **Token Standard**     | Native Substrate asset                                                                                                                                                                                                  | ERC-20 standard token                                                                                                                                                                             |
| **Decimal Places**     | Twelve (12) decimals                                                                                                                                                                                                    | Twelve (12) decimals                                                                                                                                                                              |
| **Account Type**       | [Sr25519](https://wiki.polkadot.com/learn/learn-cryptography/#keypairs-and-signing){target=_blank}                                                                                                                  | [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm){target=_blank}                                                                                                  |
| **Compatible Wallets** | [Talisman](/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank}, [SubWallet](/builders/toolkit/substrate-api/wallets/subwallet/){target=\_blank}, and others                                              | [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}, [Talisman](/builders/toolkit/ethereum-api/wallets/talisman/){target=\_blank}, and other Ethereum-compatible wallets |
| **Primary Utilities**  | - On-chain governance participation<br/>- Appchain registration and deployment<br/>- Sequencing services payment<br/>- Transaction fees on Tanssi network<br/>- Staking on sequencers<br/>- Sequencer operation rewards | - Operator validation rewards<br/>- Staking on operators                                                                                                                                          |
| **Staking Options**    | Sequencer staking (for keeping appchain liveness)                                                                                                                                                                       | Operator staking (for validating/securing the entire Tanssi ecosystem)                                                                                                                            |
| **Bridge Conversion**  | Can be bridged to ERC-20, paying fees in $TANSSI (Substrate)                                                                                                                                                            | Can be bridged to Substrate, paying fees in $ETH                                                                                                                                                  |
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/tanssi-network/testnet/dancelight/
--- BEGIN CONTENT ---
---
title: Get Started with Dancelight
description: Dancelight is the Tanssi TestNet, and it is the easiest way to get started with the Tanssi Network to deploy your Substrate or EVM-compatible appchain.
icon: octicons-star-24
---

# Get Started with Dancelight

## Introduction

Dancelight is the first public Tanssi TestNet and is designed to streamline the deployment of decentralized networks. It allows teams to swiftly onboard and launch their appchains within minutes, providing a robust environment for testing and development.

This quick reference page offers all the essentials you need to get started on Dancelight.

## TestNet Tokens {: #testnet-tokens }

{{ networks.dancelight.token_symbol }} tokens serve as the native currency within the Dancelight Network. To initiate the deployment of a network on Dancelight, you'll need to obtain {{ networks.dancelight.token_symbol }} tokens. Follow these steps:

1. Visit the [Tanssi Network](https://www.tanssi.network/claim-dance-tokens){target=\_blank} website.
2. Complete the form by providing basic information and your Substrate-based address.
3. Within one business day of submitting the form, you'll receive {{ networks.dancelight.token_symbol }} tokens for testing.

!!! note
    {{ networks.dancelight.token_symbol }} tokens have no value. Please don't submit unnecessary requests.

## Network Endpoints {: #dancelight-network-endpoints }

Dancelight has two types of endpoints available for users to connect to: one for HTTPS and one for WSS.

=== "HTTPS"

    ```text
    https://{{ networks.dancelight.dns_name }}
    ```

=== "WSS"

    ```text
    wss://{{ networks.dancelight.dns_name }}
    ```

## Block Explorers {: #dancelight-block-explorers }

For Dancelight, you can use the following block explorer:

- [Subscan]({{ networks.dancelight.subscan_url }}){target=\_blank}.
- [The developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/explorer){target=\_blank}.

Support for additional block explorers is in the works and as more explorers support Dancelight, this section will be updated accordingly.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/tanssi-network/testnet/demo-evm-network/
--- BEGIN CONTENT ---
---
title: Demo EVM Tanssi Network
description: Test our demo EVM Tanssi network to discover the capabilities of a fully Ethereum-compatible network deployed through Tanssi in just a few minutes.
icon: material-ethereum
categories: Appchain, EVM-Template
---

## Introduction

Explore the functionalities of a fully Ethereum-compatible network deployed through Tanssi by interacting with the demo EVM network on [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.

This quick reference page offers all the essentials you need to interact with this demo network.

## Faucet for TestNet Tokens {: #faucet }

You can access {{ networks.dancelight.demo_evm_token_symbol }} tokens, the native currency of the EVM demo network, at the faucet on the [Tanssi dApp](https://apps.tanssi.network/demo){target=\_blank}. You can receive up to 100 {{ networks.dancelight.demo_evm_token_symbol }} tokens every 12 hours.

To request tokens from the faucet, head to the [Tanssi dApp](https://apps.tanssi.network/demo){target=\_blank} and press **Add to MetaMask**.

![Add to MetaMask](/images/builders/tanssi-network/testnet/demo-evm-network/demo-1.webp)

Then, take the following steps:

1. Press **Request Tokens**
2. Select the account you'd like to receive {{ networks.dancelight.demo_evm_token_symbol }} tokens and press **Next**
3. Press **Connect**

![Request tokens](/images/builders/tanssi-network/testnet/demo-evm-network/demo-2.webp)

!!! note
    {{ networks.dancelight.demo_evm_token_symbol }} tokens have no value. Please don't spam the faucet with unnecessary requests.

Your tokens will be disbursed shortly, and you can verify your {{ networks.dancelight.demo_evm_token_symbol }} token balance by looking up your address on the [explorer]({{ networks.dancelight.demo_evm_blockscout_url }}){target=\_blank}.

## Network Endpoints {: #network-endpoints }

The demo EVM network HTTPS and WSS endpoints are as follows:

=== "HTTPS"

    ```text
    {{ networks.dancelight.demo_evm_rpc_url }}
    ```

=== "WSS"

    ```text
    {{ networks.dancelight.demo_evm_rpc_wss_url }}
    ```

## Block Explorers {: #block-explorers }

For the demo EVM network, you can use any of the following explorers:

- [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc={{ networks.dancelight.demo_evm_rpc_wss_url }}){target=\_blank} (Substrate API)
- [Blockscout]({{ networks.dancelight.demo_evm_blockscout_url }}){target=\_blank} (Ethereum API)
- [Expedition](https://evmexplorer.tanssi-chains.network/?rpcUrl={{ networks.dancelight.demo_evm_rpc_url }}){target=\_blank} (Ethereum API)

## Chain ID {: #chain-id }

The demo EVM network has a [chain ID](https://chainlist.org/chain/{{ networks.dancelight.demo_evm_chain_id }}){target=\_blank} of: `{{ networks.dancelight.demo_evm_chain_id }}`, which is `{{ networks.dancelight.demo_evm_chain_hex_id }}` in hex.

## Quick Start {: #quick-start }

You can interact with a Tanssi-powered EVM network using standard Ethereum libraries, like [Ethers.js](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}, [Web3.js](/builders/toolkit/ethereum-api/libraries/web3js/){target=\_blank}, and [Web3.py](/builders/toolkit/ethereum-api/libraries/web3py/){target=\_blank}. To quickly get started, you'll need to create a provider connected to a Tanssi EVM network:

=== "Ethers.js"

    ```js
    import { ethers } from "ethers";

    const providerRPC = {
      evmNetwork: {
        name: 'dancelight-evm-network',
        // Insert your RPC URL here
        rpc: '{{ networks.dancelight.demo_evm_rpc_url }}', 
        chainId: {{ networks.dancelight.demo_evm_chain_id }}, // {{ networks.dancelight.demo_evm_chain_hex_id }} in hex,
      },
    };
    const provider = new ethers.JsonRpcProvider(
      providerRPC.evmNetwork.rpc, 
      {
        chainId: providerRPC.evmNetwork.chainId,
        name: providerRPC.evmNetwork.name,
      }
    );
    ```

=== "Web3.js"

    ```js
    const Web3 = require('web3');

    const web3 = new Web3(
      '{{ networks.dancelight.demo_evm_rpc_url }}'
    );
    ```

=== "Web3.py"

    ```python
    from web3 import Web3

    web3 = Web3(Web3.HTTPProvider('{{ networks.dancelight.demo_evm_rpc_url }}')) 
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/tanssi-network/testnet/
--- BEGIN CONTENT ---
---
title: Test Networks
description: Learn about Dancelight, the Tanssi TestNet, and the demo EVM network deployed on Dancelight and how to get started developing and interacting with each network.
icon: octicons-telescope-24
template: index-page.html
---

# TestNet

Dancelight, the official Tanssi TestNet, allows developers to experiment with blockchain applications in a controlled environment before going live. It provides the tools to configure networks, interact with test versions of protocols, and troubleshoot issues to ensure a smoother transition to production.

When you're ready to see how your project could thrive in a real-world setting, try out the demo EVM environment. Fully compatible with Ethereum, this Tanssi-powered setup showcases key features and offers an immersive experience, giving you a glimpse into the full potential of your customized solution.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/dev-env/foundry/
--- BEGIN CONTENT ---
---
title: Deploy Contracts with Foundry
description: Learn how to use Foundry, an Ethereum development environment, to compile, deploy, and interact with Solidity smart contracts on your Tanssi EVM network.
icon: octicons-code-square-24
categories: EVM-Template
---

# Using Foundry to Deploy to Your EVM Network

## Introduction {: #introduction }

[Foundry](https://github.com/foundry-rs/foundry){target=\_blank} is an Ethereum development environment written in Rust that helps developers manage dependencies, compile projects, run tests, deploy contracts, and interact with blockchains from the command line. Foundry can directly interact with the Ethereum API of Tanssi-powered EVM networks, so it can be used to deploy and interact with smart contracts on your Tanssi network.

There are four tools that make up Foundry:  

- **[Forge](https://getfoundry.sh/forge/overview/){target=\_blank}** - compiles, tests, and deploys contracts
- **[Cast](https://getfoundry.sh/cast/overview/){target=\_blank}** - a command line interface for interacting with contracts
- **[Anvil](https://getfoundry.sh/anvil/overview/){target=\_blank}** - a local TestNet node for development purposes that can fork preexisting networks
- **[Chisel](https://getfoundry.sh/chisel/overview/){target=\_blank}** - a Solidity REPL for quickly testing Solidity snippets

This guide will cover how to use Foundry to compile, deploy, and debug Ethereum smart contracts on the demo EVM network. You can follow the same steps to perform these actions on your Tanssi EVM network by replacing the RPC URL and Chain ID shown in the examples.

## Checking Prerequisites {: #checking-prerequisites }

To get started, you will need the following:

 - An account with funds
 - [Foundry installed](https://getfoundry.sh/introduction/installation/){target=\_blank}

## Creating a Foundry Project {: #creating-a-foundry-project }

You will need to create a Foundry project if you don't already have one. You can create one by completing the following steps:

1. Install Foundry with the below commands. The Windows instructions are noticeably different as you'll have to install Rust and then build Foundry from source

    === "Ubuntu"

        ```bash
        curl -L https://foundry.paradigm.xyz | bash foundryup
        ```

    === "MacOS"

        ```bash
        curl -L https://foundry.paradigm.xyz | bash foundryup
        ```

    === "Windows"

        ```bash
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh
        cargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked
        ```

     After installing, you may need to restart your terminal session or add `foundryup` to your PATH.

2. Create the project, which will create a folder with three folders within it:

    ```bash
    forge init foundry
    ```

You may get an error, such as `The target directory is a part of or on its own an already initialized git repository,
and it requires clean working and staging areas, including no untracked files.` To solve this, you can add files and make a commit if you are maintaining this project within a GitHub repository. Otherwise, you can make a dummy commit without pushing. If you run `forge init foundry` once more, you'll no longer have the error.

With the default project created, you should see three folders.  

- `lib` - all of the project's dependencies in the form of git submodules
- `src` - where to put your smart contracts (with functionality)
- `test` - where to put the forge tests for your project, which are written in Solidity

In addition to these three folders, a git project will also be created along with a prewritten `.gitignore` file with relevant file types and folders ignored.

## The Source Folder {: #the-src-folder }

The preconfigured `foundry` repo includes `Counter.sol` in the `src` folder, as well as a `Counter.s.sol` in the `script` folder and `Counter.t.sol` in the `test` folder. You should delete these files to avoid errors when trying to compile and deploy `MyToken.sol`. You can do so with the following command:

```bash
rm src/Counter.sol script/Counter.s.sol test/Counter.t.sol
```

In the following steps, you will be deploying an ERC-20 contract. In the contracts directory, you can create the `MyToken.sol` file:

```bash
cd src
touch MyToken.sol
```

Open the file and add the following contract to it:

```solidity
pragma solidity ^0.8.0;

// Import OpenZeppelin Contract
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

// This ERC-20 contract mints the specified amount of tokens to the contract creator
contract MyToken is ERC20 {
  constructor(uint256 initialSupply) ERC20("MyToken", "MYTOK") {
    _mint(msg.sender, initialSupply);
  }
}
```

Before you attempt to compile, install OpenZeppelin contracts as a dependency. You may have to commit previous changes to git beforehand. By default, Foundry uses git submodules instead of npm packages, so the traditional npm import path and command are not used. Instead, use the name of OpenZeppelin's GitHub repository:

```bash
forge install OpenZeppelin/openzeppelin-contracts
```

## Compiling Solidity {: #compiling-solidity }

Once all dependencies have been installed, you can compile the contract:

```bash
forge build
```

![Foundry Contract Compile](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-1.webp)

After compilation, two folders will be created: `out` and `cache`. The ABI and bytecode for your contracts will be contained within the `out` folder. These two folders are already ignored by the `.gitignore` included in the default Foundry project initialization.

## Deploying the Contract {: #deploying-the-contract }

Deploying the contract with Forge takes a single command, but you will need to include an RPC endpoint, a funded private key, and constructor arguments. `MyToken.sol` asks for an initial supply of tokens in its constructor, so the following command includes 100 as a constructor argument. You can deploy the `MyToken.sol` contract using the following command modified for the correct network:

```bash
forge create --rpc-url {{ networks.dancelight.demo_evm_rpc_url }} \
--constructor-args 100 \
--private-key INSERT_YOUR_PRIVATE_KEY \
src/MyToken.sol:MyToken
```

After a few seconds, the contract is deployed, and you should see the address in the terminal.

![Foundry Contract Deploy](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-2.webp)

Congratulations, your contract is live! Save the address, as you will use it to interact with this contract instance in the next step.

## Interacting with the Contract {: #interacting-with-the-contract }

Foundry includes [Cast](https://getfoundry.sh/cast/overview/){target=\_blank}, a CLI for performing Ethereum RPC calls.

Try to retrieve your token's name using Cast, where `INSERT_YOUR_CONTRACT_ADDRESS` is the address of the contract that you deployed in the previous section:

```bash
cast call INSERT_YOUR_CONTRACT_ADDRESS "name()" --rpc-url {{ networks.dancelight.demo_evm_rpc_url }}
```

You should get this data in hexadecimal format:

```text
0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000
```

This is far from readable, but you can use Cast to convert it into your desired format. In this case, the data is text, so you can convert it into ASCII characters to see "My Token":

![Foundry Contract View](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-3.webp)

```bash
cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000
```

You can also mutate data with Cast as well. Try burning tokens by sending them to the zero address.

```bash
cast send --private-key INSERT_YOUR_PRIVATE_KEY \
--rpc-url {{ networks.dancelight.demo_evm_rpc_url }} \
--chain {{ networks.dancelight.demo_evm_chain_id }} \
INSERT_YOUR_CONTRACT_ADDRESS \
"transfer(address,uint256)" 0x0000000000000000000000000000000000000001 1
```

The transaction will be signed by your EVM account and be broadcast to the network. The output should look similar to:

![Foundry Contract Interaction](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-4.webp)

Congratulations, you have successfully deployed and interacted with a contract using Foundry!

## Forking with Anvil {: #forking-with-anvil }

As previously mentioned, [Anvil](https://getfoundry.sh/anvil/overview/){target=\_blank} is a local TestNet node for development purposes that can fork preexisting networks. Forking the demo EVM network allows you to interact with live contracts deployed on the network.

To fork the demo EVM network from the command line, you can run the following command from within your Foundry project directory. You can also replace the RPC URL with the RPC URL of your Tanssi EVM network.

```bash
anvil --fork-url {{ networks.dancelight.demo_evm_rpc_url }}
```

Your forked instance will have 10 development accounts that are pre-funded with 10,000 test tokens. The forked instance is available at `http://127.0.0.1:8545/`. The output in your terminal should resemble the following:

![Forking terminal screen](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-5.webp)

To verify you have forked the network, you can query the latest block number and compare it to the current block number of the [demo EVM network]({{ networks.dancelight.demo_evm_blockscout_url }}){target=\_blank}.

```bash
curl --data '{"method":"eth_blockNumber","params":[],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545 
```

If you convert the `result` from [hex to decimal](https://www.rapidtables.com/convert/number/hex-to-decimal.html){target=\_blank}, you should get the latest block number from the time you forked the network.

From here, you can deploy new contracts to your forked instance of the demo EVM network (or any other Tanssi-powered EVM network) or interact with contracts already deployed. Building off of the previous example in this guide, you can make a call using Cast to check the balance of the minted MYTOK tokens in the account you deployed the contract with:

```bash
cast call INSERT_CONTRACT_ADDRESS  "balanceOf(address)(uint256)" \
 INSERT_YOUR_ADDRESS --rpc-url http://localhost:8545
```

## Using Chisel {: #using-chisel }

[Chisel](https://getfoundry.sh/chisel/overview/){target=\_blank} is a Solidity REPL or shell. It allows a developer to write Solidity directly in the console for testing small snippets of code, letting developers skip the project setup and contract deployment steps for what should be a quick process.  

Since Chisel is mainly useful for quick testing, it can be used outside of a Foundry project. But, if executed within a Foundry project, it will keep the configurations within `foundry.toml` when running.  

For this example, you will be testing out some of the features of `abi` within Solidity because it is complex enough to demonstrate how Chisel could be useful. To get started using Chisel, run the following in the command line to start the shell:

```bash
chisel
```

In the shell, you can write Solidity code as if it were running within a function:

```solidity
bytes memory myData = abi.encode(100, true, "Build with Tanssi");
```

Let's say you were interested in how `abi` encoded data because you're looking into how to most efficiently store data on the blockchain and thus save gas. To view how the `myData` is stored in memory, you can use the following command while in the Chisel shell:

```bash
!memdump
```

`memdump` will dump all of the data in your current session. You'll likely see something like this below. If you aren't good at reading hexadecimal or if you don't know how ABI encoding works, then you might not be able to find where the `myData` variable has been stored.

![memdump in Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-6.webp)

Fortunately, Chisel lets you easily figure out where this information is stored. Using the `!rawstack` command, you can find the location in the stack where the value of a variable is:

```bash
!rawstack myData
```

In this situation, since `myData` is over 32 bytes in length, the memory pointer is displayed instead. But that's exactly what's needed since you already know the entirety of the stack from the `!memdump` command.

![rawstack in Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-7.webp)

The `!rawstack` command shows that the `myData` variable is stored at `0x80`, so when comparing this with the memory dump retrieved from the `!memdump` command, it looks like `myData` is stored like this:  

```text
[0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0
[0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064
[0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001
[0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060
[0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000011
[0x120:0x140]: 0x4275696c6420776974682054616e737369000000000000000000000000000000
```

At first glance, this makes sense since `0xa0` has a value of `0x64`, which is equal to 100, and `0xc0` has a value of `0x01`, which is equal to true. If you want to learn more about how ABI-encoding works, the [Solidity documentation for ABI is helpful](https://docs.soliditylang.org/en/v0.8.18/abi-spec.html){target=\_blank}. In this case, there are a lot of zeros in this method of data packing, so as a smart contract developer, you might instead try to use structs or pack the data together more efficiently with bitwise code.  

Since you're done with this code, you can clear the state of Chisel so that it doesn't mess with any future logic that you want to try out (while running the same instance of Chisel):  

```bash
!clear
```

There's an even easier way to test with Chisel. When writing code that ends with a semicolon, `;`, Chisel will run it as a statement, storing its value in Chisel's runtime state. But if you only needed to see how the ABI-encoded data was represented, then you could get away with running the code as an expression. To try this out with the same `abi` example, write the following in the Chisel shell:  

```bash
abi.encode(100, true, "Build with Tanssi")
```

You should see something like the following:  

![Expressions in Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-8.webp)

While it doesn't display the data in the same way, you still get the contents of the data, and it also further breaks down how the information is coded, such as letting you know that the `0xa0` value defines the length of the data.  

By default, when you leave the Chisel shell, none of the data persists. But you can instruct Chisel to do so. For example, you can take the following steps to store a variable:

1. Store a `uint256` in Chisel

    ```bash
    uint256 myNumber = 101;
    ```

2. Store the session with `!save`. For this example, you can use the number `1` as a save ID

    ```bash
    !save 1
    ```

3. Quit the session  
    ```bash
    !quit
    ```

Then to view and interact with your stored Chisel states, you can take the following steps:

1. View a list of saved Chisel states

    ```bash
    chisel list
    ```

2. Load your stored state by providing the `chisel load` command followed by the ID of the state

    ```bash
    chisel load 1
    ```

3. View the `uint256` saved in Chisel from the previous set of steps

    ```bash
    !rawstack myNumber
    ```  

![Saving state in Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-9.webp)

You can even fork networks while using Chisel:

```bash
!fork {{ networks.dancelight.demo_evm_rpc_url }}
```

Then, for example, you can query the balance of the Alice account on the demo EVM network:  

```text
0x44236223aB4291b93EEd10E4B511B37a398DEE55.balance
```

![Forking in Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-10.webp)

If you want to learn more about Chisel, download Foundry and refer to its [official reference page](https://getfoundry.sh/chisel/reference/){target=\_blank}.

## Foundry with Hardhat {: #foundry-with-hardhat }  

Often, there will be the case where a project that you wish to integrate with has all of its setup within [Hardhat](/builders/toolkit/ethereum-api/dev-env/hardhat/){target=\_blank}, making it an arduous task to convert the entirety of the project into Foundry. This additional work is avoidable by creating a hybrid project that uses both Hardhat and Foundry features together. This is possible with Hardhat's [hardhat-foundry plugin](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-foundry){target=\_blank}.  

To convert your preexisting Foundry project to a hybrid project, you will essentially have to install a Hardhat project into the same folder:  

```bash
npm init
npm install --save-dev hardhat @nomicfoundation/hardhat-foundry
npx hardhat init
```

For more information, please refer to our documentation on [Creating a Hardhat Project](/builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project){target=\_blank}.

After initializing the new Hardhat project, a few new folders and files should appear: `contracts`, `hardhat.config.js`, `scripts`, and `test/Lock.js`. You'll need to make a few modifications to create a hybrid project:

1. Edit the `hardhat.config.js` file within your repository. Open it up, and at the top, add the following:  

    ```javascript
    require('@nomicfoundation/hardhat-foundry');
    ```

    After adding the `hardhat-foundry` plugin, the typical `contracts` folders for Hardhat will not work because now Hardhat expects all smart contracts to be stored within Foundry's `src` folder

2. Move all smart contracts within the `contracts` folder into the `src` folder, and then delete the `contracts` folder
3. Edit the `foundry.toml` file to ensure that dependencies installed via Git submodules and npm can be compiled by the Forge tool. Edit the `profile.default` to ensure that the `libs` entry has both `lib` and `node_modules`:  

    ```toml
    [profile.default]
    src = 'src'
    out = 'out'
    libs = ['lib', 'node_modules']
    solc = '0.8.20'
    evm_version = 'london'
    ```

Now both `forge build` and `npx hardhat compile` should work regardless of the dependencies.  

Both `forge test` and `npx hardhat test` should now be able to access all smart contracts and dependencies. `forge test` will only test the Solidity tests, whereas `npx hardhat test` will only test the JavaScript tests. If you would like to use them in conjunction, then you can create a new script within your `package.json` file:  

```json
"scripts": {
    "test": "npx hardhat test && forge test"
}
```

You can run this command with:  

```bash
npm run test
```

Finally, while not necessary, it could be worthwhile to move all JavaScript scripts from the `scripts` folder into Foundry's `script` folder and delete the `scripts` folder so that you don't have two folders that serve the same purpose.

Congratulations, you have successfully deployed and interacted with smart contracts on your Tanssi EVM network using Foundry! For more information, be sure to check out the [Foundry Book](https://getfoundry.sh/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/dev-env/hardhat/
--- BEGIN CONTENT ---
---
title: Deploy Contracts with Hardhat
description: Learn how to use Hardhat, an Ethereum development environment, to compile, deploy, and interact with Solidity smart contracts on your Tanssi EVM network.
icon: octicons-code-square-24
categories: EVM-Template
---

# Using Hardhat to Deploy to Your EVM Network

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/1Kbs7dxkjJQ?si=n0ipTN2nbvqISLGu' frameborder='0' allowfullscreen></iframe></div>
<style>.caption { font-family: Open Sans, sans-serif; font-size: 0.9em; color: rgba(170, 170, 170, 1); font-style: italic; letter-spacing: 0px; position: relative;}</style>

## Introduction {: #introduction }

[Hardhat](https://hardhat.org){target=\_blank} is an Ethereum development environment that helps developers manage and automate the recurring tasks inherent to building smart contracts and dApps. Hardhat can be used with any EVM network to build, compile, and deploy smart contracts, thanks to the seamless compatibility of Tanssi-powered EVM networks.

This guide will cover how to use Hardhat to compile, deploy, and interact with Ethereum smart contracts deployed to the demo Tanssi EVM network. This guide can be adapted for your own Tanssi-powered EVM network by simply adding the RPC URL of your Tanssi network to your EVM Wallet and switching networks to it.

## Checking Prerequisites {: #checking-prerequisites }

For this guide, you'll need to have MetaMask installed and configured to work with your Tanssi EVM network. You can follow [this guide to configure MetaMask for Tanssi with the demo EVM network](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

## Creating a Hardhat Project {: #creating-a-hardhat-project }

You must create a Hardhat project if you don't already have one. You can create one by completing the following steps:

1. Create a directory for your project

    ```sh
    mkdir hardhat && cd hardhat
    ```

2. Initialize the project, which will create a `package.json` file

    ```sh
    npm init -y
    ```

3. Install Hardhat

    ```sh
    npm install hardhat
    ```

4. Create a project

    ```sh
    npx hardhat init
    ```

    !!! note
        `npx` is used to run executables installed locally in your project. Although Hardhat can be installed globally, installing it locally in each project is recommended so you can control the version on a project-by-project basis.

5. A menu will appear allowing you to create a new project or use a sample project. For this example, you can choose **Create an empty hardhat.config.js**

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>npx hardhat init</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888</span>
  <span data-ty>8888888888&nbsp;&nbsp;8888b.&nbsp;&nbsp;888d888&nbsp;.d88888&nbsp;88888b.&nbsp;&nbsp;&nbsp;8888b.&nbsp;&nbsp;888888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"88b&nbsp;888P"&nbsp;&nbsp;d88"&nbsp;888&nbsp;888&nbsp;"88b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"88b&nbsp;888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;.d888888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;888&nbsp;.d888888&nbsp;888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;Y88b&nbsp;888&nbsp;888&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;888&nbsp;Y88b.</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;"Y888888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Y88888&nbsp;888&nbsp;&nbsp;888&nbsp;"Y888888&nbsp;&nbsp;"Y888</span>
    <br>
  <span data-ty>ðŸ‘· Welcome to Hardhat v2.22.2 ðŸ‘·â€</span>
    <br>
  <span data-ty="input" data-ty-prompt="?">&nbsp;What do you want to do? â€¦</span>
  <span data-ty>&nbsp;&nbsp;Create a JavaScript project </span>
  <span data-ty>&nbsp;&nbsp;Create a TypeScript project </span>
  <span data-ty>&nbsp;&nbsp;Create a TypeScript project (with Viem) </span>
  <span data-ty="input" data-ty-prompt="â¯ Create an empty hardhat.config.js"></span>
  <span data-ty>&nbsp;&nbsp;Quit </span>
</div>

This will create a Hardhat config file (`hardhat.config.js`) in your project directory.

Once you have your Hardhat project, you can also install the [Ethers plugin](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-ethers){target=\_blank}. This provides a convenient way to use the [Ethers.js](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank} library to interact with the network. To install it, run the following command:

```sh
npm install @nomicfoundation/hardhat-ethers ethers
```

Additionally, you'll need to install the `hardhat-ignition-ethers` plugin to enable deployment of smart contracts with Hardhat Ignition. You can install it with the following command:

```sh
npm install --save-dev @nomicfoundation/hardhat-ignition-ethers
```

## The Contract File {: #the-contract-file }

With your empty project created, you will create a `contracts` directory next. You can do so by running the following command:

```sh
mkdir contracts && cd contracts
```

The smart contract that you'll deploy as an example will be called `Box`, it will let you store a value that can be retrieved later. In the `contracts` directory, you can create the `Box.sol` file:

```sh
touch Box.sol
```

Open the file and add the following contract to it:

```solidity
// contracts/Box.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

contract Box {
    uint256 private value;

    // Emitted when the stored value changes
    event ValueChanged(uint256 newValue);

    // Stores a new value in the contract
    function store(uint256 newValue) public {
        value = newValue;
        emit ValueChanged(newValue);
    }

    // Reads the last stored value
    function retrieve() public view returns (uint256) {
        return value;
    }
}
```

## The Hardhat Configuration File {: #hardhat-configuration-file }

Before you can deploy the contract to your Tanssi network, you'll need to modify the Hardhat configuration file and create a secure file to store your private key in.

You can modify the `hardhat.config.js` file to use either the Tanssi demo EVM network or your own Tanssi network:

```js
// 1. Import the Ethers and Hardhat Ignition plugins required to interact with the contract
require('@nomicfoundation/hardhat-ethers');
require('@nomicfoundation/hardhat-ignition-ethers');

// 2. Add your private key that is funded with tokens of your Tanssi network
// This is for example purposes only - **never store your private keys in a JavaScript file**
const privateKey = 'INSERT_PRIVATE_KEY';

module.exports = {
  // 3. Specify the Solidity version
  solidity: '0.8.1',
  networks: {
    // 4. Add the network specification for your Tanssi EVM network
    dancelight: {
      url: '{{ networks.dancelight.demo_evm_rpc_url }}',
      chainId: {{ networks.dancelight.demo_evm_chain_id }}, // Fill in the EVM ChainID for your Tanssi network
      accounts: [privateKey]
    }
  }
};
```

Congratulations! You are now ready for deployment!

## Compiling Solidity {: #compiling-solidity }

To compile the contract you can simply run:

```sh
npx hardhat compile
```

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>npx hardhat compile</span>
    <span data-ty>Compiled 8 Solidity files successfully (evm target: paris).</span>
    <span data-ty="input"><span class="file-path"></span></span>
</div>

After compilation, an `artifacts` directory is created: it holds the bytecode and metadata of the contract, which are `.json` files. Adding this directory to your `.gitignore` is a good idea.

## Deploying the Contract {: #deploying-the-contract }

To deploy the contract, you'll use Hardhat Ignition, a declarative framework for deploying smart contracts. Hardhat Ignition is designed to make managing recurring tasks surrounding smart contract deployment and testing easy. For more information, be sure to check out the [Hardhat Ignition docs](https://hardhat.org/ignition/docs/getting-started#overview){target=\_blank}. 

To set up the proper file structure for your Ignition module, create a folder named `ignition` and a subdirectory called `modules`.  Then add a new file to it called `Box.js`. You can take all three of these steps with the following command:

```sh
mkdir ignition ignition/modules && touch ignition/modules/Box.js
```

Next, you can write your Hardhat Ignition module. To get started, take the following steps:

1. Import the `buildModule` function from the Hardhat Ignition module
2. Export a module using `buildModule`
3. Use the `getAccount` method to select the deployer account
4. Specify custom gas price and gas limit settings for the deployment
5. Deploy the `Box` contract
6. Return an object from the module. This makes the `Box` contract accessible for interaction in Hardhat tests and scripts

```js
// 1.  Import the `buildModule` function from the Hardhat Ignition module
const { buildModule } = require('@nomicfoundation/hardhat-ignition/modules');

// 2. Export a module using `buildModule`
module.exports = buildModule('BoxModule', (m) => {
  // 3. Use the `getAccount` method to select the deployer account
  const deployer = m.getAccount(0);

  // 4. Specify custom gas price and gas limit settings for the deployment
  const customGasPrice = 50000000000n;
  const customGasLimit = 1000000;

  // 5. Deploy the `Box` contract using the selected deployer account and custom gas settings
  const box = m.contract('Box', [], {
    from: deployer,
    gasPrice: customGasPrice,
    gasLimit: customGasLimit,
  });

  // 6. Return an object from the module including references to deployed contracts. This makes the deployed `Box` contract accessible for interaction in tests and scripts
  return { box };
});
```

To run the script and deploy the `Box.sol` contract, use the following command, which requires you to specify the network name as defined in your `hardhat.config.js`. Hardhat will deploy the contract to a local hardhat network by default if you don't specify a network.  

```sh
npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight
```

You'll be prompted to confirm the network you wish to deploy to. After a few seconds after you confirm, the contract is deployed, and you'll see the contract address in the terminal. If you're deploying to another Tanssi network, make sure that you specify the correct network. The network name must match how it's defined in `hardhat.config.js`. After a few seconds, the contract is deployed, and you should see the address in the terminal.

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span> npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight</span>
    <br>
    <span data-ty>âœ… Confirm deploy to network dancelight (5678)? â€¦ yes</span>
    <span data-ty>Hardhat Ignition ðŸš€</span>
    <br>
    <span data-ty>Deploying [ BoxModule ]</span>
    <br>
    <span data-ty>Batch #1</span>
    <span data-ty>Executed BoxModule#Box</span>
    <br>
    <span data-ty>[ BoxModule ] successfully deployed ðŸš€</span>
    <br>
    <span data-ty>Deployed Addresses</span>
    <br>
    <span data-ty>BoxModule#Box - 0xa84caB60db6541573a091e5C622fB79e175E17be</span>
    <span data-ty="input"><span class="file-path"></span></span>
</div>

Congratulations, your contract is live! Save the address, as you will use it to interact with this contract instance in the next step.

## Interacting with the Contract {: #interacting-with-the-contract }

To interact with your newly deployed contract on your Tanssi network, you can launch the Hardhat `console` by running:

```sh
npx hardhat console --network dancelight
```

Next, you can take the following steps, entering one line at a time:

1. Create a local instance of the `Box.sol` contract

    ```js
    const Box = await ethers.getContractFactory('Box');
    ```

2. Connect the local instance to the deployed contract, using the address of the contract

    ```js
    const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be');
    ```

3. Interact with the attached contract. For this example, you can call the `store` method and store a simple value

    ```js
    await box.store(5);
    ```

Your EVM account will sign the transaction and broadcast it to the network. The output should look similar to:

<div id="termynal" data-termynal>
    <span data-ty="input">npx hardhat console --network dancelight</span>
    <br>
    <span data-ty>Welcome to Node.js v20.9.0.</span>
    <span data-ty>Type ".help" for more information.</span>
    <span data-ty="input" data-ty-prompt=">"> const Box = await ethers.getContractFactory('Box');</span>
    <span data-ty>undefined</span>
    <br>
    <span data-ty="input" data-ty-prompt=">"> const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be');</span>
    <span data-ty>undefined</span>
    <br>
    <span data-ty="input" data-ty-prompt=">"> await box.store(5);</span>
    <span data-ty>ContractTransactionResponse {<br>
    provider: HardhatEthersProvider { ... },<br>
    blockNumber: null,<br>
    blockHash: null,<br>
    index: undefined,<br>
    hash: '0x1c49a64a601fc5dd184f0a368a91130cb49203ec0f533c6fcf20445c68e20264',<br>
    type: 2,<br>
    to: '0xa84caB60db6541573a091e5C622fB79e175E17be',<br>
    from: '0x3B939FeaD1557C741Ff06492FD0127bd287A421e',<br>
    nonce: 87,<br>
    gasLimit: 45881n,<br>
    gasPrice: 1107421875n,<br>
    maxPriorityFeePerGas: 1n,<br>
    maxFeePerGas: 1107421875n,<br>
    data: '0x6057361d0000000000000000000000000000000000000000000000000000000000000005',<br>
    value: 0n,<br>
    chainId: 5678n,<br>
    signature: Signature { r: "0x9233b9cc4ae6879b7e08b9f1a4bfb175c8216eee0099966eca4a305c7f369ecc", s: "0x7663688633006b5a449d02cb08311569fadf2f9696bd7fe65417860a3b5fc57d", yParity: 0, networkV: null },<br>
    accessList: [],<br>
    blobVersionedHashes: null<br>
    }</span>
    <span data-ty="input" data-ty-prompt=">"> await box.retrieve();</span>
    <span data-ty>5n</span>
    <br>
</div>

Notice your address labeled `from`, the contract's address, and the `data` being passed. Now, you can retrieve the value by running:

```js
await box.retrieve();
```

You should see `5` or the value you initially stored.

!!! note
    If you run the retrieve command immediately after storing the value, you may see the old value. Rerunning the retrieval command after waiting a moment will return the correct value.

Congratulations, you have successfully deployed and interacted with a contract using Hardhat!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/dev-env/
--- BEGIN CONTENT ---
---
title: Dev Environments
description: Learn how to interact with your Tanssi EVM-compatible network through the Ethereum API with different Ethereum tools like Remix, Hardhat, Foundry, and more.
icon: octicons-code-square-24
template: index-page.html
---

# Development Environments

Establishing an effective development environment is crucial for building, testing, and deploying smart contracts efficiently. Development environments simplify the process of building blockchain applications by abstracting away many of the underlying complexities involved in interacting with blockchain networks. They provide the necessary tools and frameworks to:

- Write, compile, test, and deploy Solidity smart contracts
- Simulate blockchain interactions locally for testing and debugging
- Automate workflows for faster deployments

Each development environment helps you achieve the same goal, building and deploying blockchain applications, but they do so in unique ways. For instance, browser-based IDEs like [Remix](/builders/toolkit/ethereum-api/dev-env/remix/) provide a fast and accessible way to start coding, while tools like [Foundry](/builders/toolkit/ethereum-api/dev-env/foundry/) and [Hardhat](/builders/toolkit/ethereum-api/dev-env/hardhat/) cater to developers who prefer specific workflows, such as a Solidity-first or JavaScript-integrated approach. Choose the one that aligns best with your needs and development style.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/dev-env/remix/
--- BEGIN CONTENT ---
---
title: Deploy Smart Contracts with Remix
description: Learn how to use one of the most popular Ethereum developer tools, the Remix IDE, to interact with your Tanssi-powered EVM network.
icon: octicons-code-square-24
categories: EVM-Template
---

# Using Remix to Deploy to Your Tanssi EVM Network

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/vSc80mg_L9E?si=qnIXJ6wL0iKU3mU1' frameborder='0' allowfullscreen></iframe></div>
<style>.caption { font-family: Open Sans, sans-serif; font-size: 0.9em; color: rgba(170, 170, 170, 1); font-style: italic; letter-spacing: 0px; position: relative;}</style>

## Introduction {: #introduction }

Developers building dApps on top of Tanssi-powered EVM networks can use [Remix](https://remix.ethereum.org){target=\_blank}, one of the most popular Ethereum development environments, to build, compile, and deploy their smart contracts. Remix can be used with any EVM network, thanks to the seamless compatibility of Tanssi-powered EVM networks.

This guide walks through the process of creating and deploying a Solidity-based smart contract to the Tanssi demo EVM network using the Remix IDE. This guide can be adapted for your own Tanssi EVM network by simply adding the RPC URL of your network to your EVM Wallet and switching networks to it.

## Checking Prerequisites {: #checking-prerequisites }

For this guide, you'll need to have MetaMask installed and configured to work with your Tanssi EVM network. You can follow [this guide to configure MetaMask for Tanssi with the demo EVM network](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

## Getting Started with Remix {: #getting-started-with-remix }

Now, you can head to [Remix](https://remix.ethereum.org){target=\_blank} to get started. On the main screen, navigate to the **File Explorer** tab.

![File explorer](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-1.webp)

Next, you can create a new file to save the Solidity smart contract. To do so, take the following steps:

1. Press the **Create New File** button on the left-hand side of **File Explorer**
2. Enter your desired filename, such as `MyToken.sol`

![Create a new file for your Solidity contract](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-2.webp)

Next, paste the following smart contract into the editor tab:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/audit/2023-03/contracts/token/ERC20/ERC20.sol';

// This ERC-20 contract mints the specified amount of tokens to the contract creator.
contract MyToken is ERC20 {
  constructor(uint256 initialSupply) ERC20("MyToken", "MYTOK") {
    _mint(msg.sender, initialSupply);
  }
}
```

![Paste the contract into the editor](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-3.webp)

This is a simple ERC-20 contract based on the [current OpenZeppelin ERC-20 template](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol){target=\_blank}. It creates `MyToken` with symbol `MYTOK` and mints the entirety of the initial supply to the creator of the contract.

To compile your smart contract, take the following steps:

1. Navigate to the **Solidity compiler** tab
2. Press the **Compile MyToken.sol** button

![Compile MyToken.sol](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-4.webp)

Your contract is now compiled and ready to be deployed to your Tanssi network.

## Deploying a Contract to Your Network Using Remix {: #deploying-a-contract-to-your-network-using-remix }

Now you can deploy the contract by navigating to the **Deployment** sidebar option. You need to change the topmost **ENVIRONMENT** dropdown from **JavaScript VM** to **Injected Web3**. This tells Remix to use the MetaMask injected provider, which will point it to your Tanssi-powered EVM network, so long as the selected network in your MetaMask is your Tanssi EVM network. If you need to change your network in MetaMask, you can easily do so, and Remix will update your account balances to reflect the network change.

![Change environment to injected Web3](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-5.webp)

As soon as you select **Injected Web3**, you will be prompted to allow Remix to connect to your MetaMask account. Then, take the following steps:

1. Select the account(s) that you would like to use with Remix
2. Press **Next**
3. Press **Connect**

![Select accounts to connect to Remix](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-6.webp)

Back on Remix, you should see the account you wish to use for deployment is now managed by MetaMask. To deploy your token contract, take the following steps:

1. Next to the **Deploy** button, specify an initial supply of 8 million tokens. Since this contract uses the default of 18 decimals, the value to put in the box is `8000000000000000000000000`. Once you have entered this value, press **Deploy**
2. Confirm the contract deployment transaction in MetaMask.

![Enter an token balance and deploy](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-7.webp)

After you press **Confirm** and the deployment is complete, you will see the transaction listed in MetaMask. The contract will appear under **Deployed Contracts** in Remix. You can access the address of the deployed contract by pressing the copy button.

![Confirmed label on a transaction](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-8.webp)

Once the contract is deployed, you can interact with it from within Remix. To familiarize yourself with interacting with a smart contract from Remix, take the following steps:

1. Expand the contract under the **Deployed Contracts** section
2. Paste in your address (the address that deployed the token contract) next to the balanceOf method and press **balanceOf**. You should see the entirety of the balance of the ERC-20 belonging to that address
3. Press **Decimals** to see the number of decimal points the token has
4. Press **Name** to see the name you assigned the token
5. Press **Symbol** to see the token symbol
6. Press **Initial Supply** and you should see `8000000000000000000000000`
7. Copy the contract address by clicking the button next to the contract name and address. You'll need it in the next section

![Interact with the contract from Remix](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-9.webp)

## Interacting with an ERC-20 on Your Network from MetaMask {: #interacting-with-an-erc-20-on-your-network-from-metamask }

Now, open MetaMask to add the newly deployed ERC-20 tokens. Make sure you are connected to the account that deployed the token contract. Additionally, make sure you have copied the contract's address from Remix.

To add the token to MetaMask, take the following steps:

1. Click on the **Tokens** tab as shown below
2. Press **Import tokens**

![Add a token](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-10.webp)

Then, take the following steps:

1. Paste the copied contract address into the **Token contract address** field. The **Token symbol** and **Token decimal** fields should be automatically populated
2. Press **Next**

![Paste the copied contract address](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-11.webp)

After clicking **Next**, you will need to confirm that you want to add these tokens to your MetaMask account. Click **Import** and you should see a balance of 8 million MyTokens in MetaMask:

![Add the tokens to your MetaMask account](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-12.webp)

Now you can send some of these ERC-20 tokens to the other account that you have set up in MetaMask. Click **Send** to initiate the transfer of 500 MyTokens and select the destination account.

After clicking **Next**, you will be asked to confirm (similar to what is pictured below).

![Confirmation of the token transfer](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-13.webp)

Click **Confirm** and, after the transaction is complete, you will see a confirmation and a reduction of the MyToken account balance from the sender account in MetaMask.

![Verify the reduction in account balance](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-14.webp)

You can also look up the transaction on [your Tanssi network's explorer](https://tanssi-evmexplorer.netlify.app){target=\_blank} to verify the transaction status.

![Check transaction status on block explorer for your Tanssi network](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-15.webp)

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/dev-env/thirdweb/
--- BEGIN CONTENT ---
---
title: How to use thirdweb
description: This guide will show you some of thirdweb's features, including building, testing, and deploying smart contract templates to launch dApps on Tanssi.
icon: octicons-code-square-24
categories: EVM-Template
---

# Using thirdweb on Tanssi

## Introduction {: #introduction }

[thirdweb](https://thirdweb.com){target=\_blank} is a complete Web3 development framework that provides everything you need to develop smart contracts, build dApps, and more.

With thirdweb, you can access tools to help you through every phase of the dApp development cycle. You can create your own custom smart contracts or use any of thirdweb's prebuilt contracts to get started quickly. From there, you can use thirdweb's CLI to deploy your smart contracts. Then you can interact with your smart contracts by creating a Web3 application using the language of your choice, including but not limited to React and TypeScript. 

This guide will show you some of the thirdweb features you can use to develop smart contracts and dApps on Tanssi EVM networks. To check out all of the features thirdweb has to offer, please refer to the [thirdweb documentation site](https://portal.thirdweb.com){target=\_blank}. 

## Create Contract {: #create-contract }

To create a new smart contract using the [thirdweb CLI](https://portal.thirdweb.com/cli){target=\_blank}, follow these steps:

1. In your CLI, run the following command:

    ```bash
    npx thirdweb create contract
    ```

2. Input your preferences for the command line prompts:
    1. Give your project a name
    2. Choose your preferred framework: **Hardhat** or **Foundry**
    3. Name your smart contract
    4. Choose the type of base contract: **Empty**, **ERC20**, **ERC721**, or **ERC1155**
    5. Add any desired [extensions](https://portal.thirdweb.com/contracts/extensions){target=\_blank}
3. Once created, navigate to your projectâ€™s directory and open in your preferred code editor
4. If you open the `contracts` folder, you will find your smart contract; this is your smart contract written in Solidity

    The following is code for an `ERC721Base` contract without specified extensions. It implements all of the logic inside the [`ERC721Base.sol`](https://github.com/thirdweb-dev/contracts/blob/main/contracts/base/ERC721Base.sol){target=\_blank} contract; which implements the [`ERC721A`](https://github.com/thirdweb-dev/contracts/blob/main/contracts/eip/ERC721A.sol){target=\_blank} standard.

    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    import '@thirdweb-dev/contracts/base/ERC721Base.sol';

    contract Contract is ERC721Base {
        constructor(
            string memory _name,
            string memory _symbol,
            address _royaltyRecipient,
            uint128 _royaltyBps
        ) ERC721Base(_name, _symbol, _royaltyRecipient, _royaltyBps) {}
    }
    ```

    This contract inherits the functionality of `ERC721Base` through the following steps:

    - Importing the `ERC721Base` contract
    - Inheriting the contract by declaring that your contract is an `ERC721Base` contract
    - Implementing any required methods, such as the constructor

5. After modifying your contract with your desired custom logic, you can deploy it to a Tanssi EVM network using [Deploy](#deploy-contract). That will be covered in the next section!

Alternatively, you can deploy a prebuilt contract for NFTs, tokens, or marketplace directly from the thirdweb Explore page:

1. Go to the [thirdweb Explore page](https://thirdweb.com/explore){target=\_blank}

    ![thirdweb Explore](/images/builders/toolkit/ethereum-api/dev-environments/thirdweb/thirdweb-1.webp)

2. Choose the type of contract you want to deploy from the available options: NFTs, tokens, marketplace, and more
3. Follow the on-screen prompts to configure and deploy your contract

For more information on different contracts available on Explore, check out [thirdwebâ€™s documentation on prebuilt contracts](https://portal.thirdweb.com/contracts){target=\_blank}.

## Deploy Contract {: #deploy-contract }

Deploy is thirdweb's tool that allows you to easily deploy a smart contract to any EVM compatible network without configuring RPC URLs, exposing your private keys, writing scripts, and other additional setup such as verifying your contract.

1. To deploy your smart contract using deploy, navigate to the `contracts` directory of your project and execute the following command:

    ```bash
    npx thirdweb deploy
    ```

    Executing this command will trigger the following actions:

    - Compiling all the contracts in the current directory
    - Providing the option to select which contract(s) you wish to deploy
    - Uploading your contract source code (ABI) to IPFS

2. When it is completed, it will open a dashboard interface to finish filling out the parameters

    - `_name` - contract name
    - `_symbol` - symbol or "ticker"
    - `_royaltyRecipient` - wallet address to receive royalties from secondary sales
    - `_royaltyBps` - basis points (bps) that will be given to the royalty recipient for each secondary sale, e.g. 500 = 5%

3. Select the desired network, e.g., the Tanssi demo EVM network or your own network
4. Manage additional settings on your contractâ€™s dashboard as needed such as uploading NFTs, configuring permissions, and more

    ![thirdweb deploy](/images/builders/toolkit/ethereum-api/dev-environments/thirdweb/thirdweb-2.webp)

For additional information on Deploy, please reference [thirdwebâ€™s documentation](https://portal.thirdweb.com/contracts/){target=\_blank}.

## Create Application {: #create-application }

thirdweb offers SDKs for a range of programming languages, such as React, React Native, TypeScript, and Unity. You'll start off by creating an application and then you can choose which SDK to use:

1. In your CLI run the following command:

    ```bash
    npx thirdweb create --app
    ```

2. Input your preferences for the command line prompts:

    1. Give your project a name
    2. Choose your preferred framework: **Next.js**, **Vite**, or **React Native**. For this example, select **Vite**

3. Use the React or TypeScript SDK to interact with your applicationâ€™s functions. This will be covered in the following section on interacting with a contract

### Specify Client ID {: #specify-client-id }

Before you launch your dApp (locally or publicly deployed), you must have a thirdweb Client ID associated with your project. A thirdweb Client ID is synonymous with an API key. You can create a free API key by [signing into your thirdweb account, navigating to **Settings**, and clicking on **API Keys**](https://thirdweb.com/dashboard/settings/api-keys){target=\_blank}.

Press **Create API Key** then take the following steps:

1. Give your API key a name
2. Enter the allowed domains that the API key should accept requests from. It's recommended that you allow only necessary domains, but for development purposes, you can select **Allow all domains**
3. Press **Next** and confirm the prompt on the next page

![thirdweb create API key](/images/builders/toolkit/ethereum-api/dev-environments/thirdweb/thirdweb-3.webp)

!!! note
    The respective name for your Client ID variable will vary with the framework you've chosen, e.g., Vite will be `VITE_TEMPLATE_CLIENT_ID`, Next.js will be `NEXT_PUBLIC_TEMPLATE_CLIENT_ID`, and React Native will be `EXPO_PUBLIC_THIRDWEB_CLIENT_ID`.

Finally, specify your Client ID (API Key) in your `.env` file. Your `.env` file must be located at the root directory of the project (e.g., not the `src` folder).

If you generated your thirdweb app with Vite, you'll have a `client.ts` file that looks like the below. As long you've created a `.env` file with your thirdweb API Key (Client ID) defined in `VITE_TEMPLATE_CLIENT_ID`, you can leave the `client.ts` as is and proceed to the next section.

```typescript title="client.ts"
import { createThirdwebClient } from 'thirdweb';

// Replace this with your client ID string.
// Refer to https://portal.thirdweb.com/typescript/v5/client on how to get a client ID
const clientId = import.meta.env.VITE_TEMPLATE_CLIENT_ID;

export const client = createThirdwebClient({
  clientId: clientId,
});
```

!!! note
    If you don't create a Client ID and specify is correctly in your `.env` file, you'll get a blank screen when trying to build the web app. There is no error message shown without digging into the console, so ensure you've set your Client ID correctly first and foremost.

### Run Locally {: #run-locally }

To run your dApp locally for testing and debugging purposes, use the command: 

```bash
yarn dev
```

The app will compile and specify the localhost and port number for you to visit in your browser.

![thirdweb run locally](/images/builders/toolkit/ethereum-api/dev-environments/thirdweb/thirdweb-4.webp)

### Configure Chain {: #configure-chain }

thirdweb offers a small number of chains from `@thirdweb/chains` and does not include Tanssi networks in that list, so you'll need to specify the network details including chain ID and RPC URL. You can create a custom chain with [`defineChain`](https://portal.thirdweb.com/references/typescript/v5/defineChain){target=\_blank} as follows:

```typescript title="chains.ts"
    import { defineChain } from 'thirdweb';
    const tanssi = defineChain({
      id: {{ networks.dancelight.demo_evm_chain_id }},
      rpc: '{{ networks.dancelight.demo_evm_rpc_url }}',
    });
```

## thirdweb SDK {: #thirdweb-sdk }

The following sections will provide an overview of fundamental methods of the thirdweb SDK and how to interact with them. Each code snippet will showcase the relevant import statements and demonstrate using the method in a typical scenario. This guide is intended to be a quick reference guide to the most common thirdweb methods that dApp developers will use. However, it does not include information on each and every thirdweb offering. For details on the entirety of thirdweb's offerings, be sure to visit the [thirdweb documentation site](https://portal.thirdweb.com/){target=\_blank}.

### Accounts and Wallets {: #accounts-and-wallets }

thirdweb distinguishes between accounts and wallets in the SDK. In the eyes of the thirdweb SDK, an account always has a single blockchain address and can sign messages, transactions, and typed data, but it cannot be "connected" or "disconnected." In contrast, a wallet contains one or more accounts, can be connected or disconnected, and delegates the signing tasks to its accounts. 

The below code snippet demonstrates how to initialize and connect a MetaMask wallet using the thirdweb SDK, then sign and send a transaction, retrieving the transaction hash. This process is applicable to any of the 300+ wallet connectors supported by the SDK.

???+ code "initialize.ts"
    ```typescript
    import { sendTransaction } from 'thirdweb';
// MetaMask wallet used for example, the pattern is the same for all wallets
import { createWallet } from 'thirdweb/wallets';

// Initialize the wallet. thirdweb supports 300+ wallet connectors
const wallet = createWallet('io.metamask');

// Connect the wallet. This returns a promise that resolves to the connected account
const account = await wallet.connect({
  // Pass the client you created with `createThirdwebClient()`
  client,
});

// Sign and send a transaction with the account. Returns the transaction hash
const { transactionHash } = await sendTransaction({
  // Assuming you have called `prepareTransaction()` or `prepareContractCall()` before, which returns the prepared transaction to send
  transaction,
  // Pass the account to sign the transaction with
  account,
});
    ```

### Get Contract {: #get-contract }

To connect to your contract, use the SDKâ€™s [`getContract`](https://portal.thirdweb.com/references/typescript/v5/getContract){target=\_blank} method. As an example, you could fetch data from an [incrementer contract on the Tanssi demo EVM network]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D?tab=contract){target=\_blank}.

```typescript
import { getContract } from 'thirdweb';
import { client } from './client';

const myContract = getContract({
  client,
  chain: tanssi,
  address: 0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D, // Incrementer contract address on demo EVM network
  abi: '[{"inputs":[],"name":"increment","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"number","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"timestamp","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]';
});
```

### Calling Contract Functions {: #calling-contract-functions }

To call a contract in the latest version of the SDK, you can use [`prepareContractCall`](https://portal.thirdweb.com/typescript/v5/transactions/prepare){target=\_blank}.

```typescript
import { prepareContractCall, toWei } from 'thirdweb';

const tx = prepareContractCall({
  contract,
  // Pass the method signature that you want to call
  method: 'function mintTo(address to, uint256 amount)',
  // Pass the params for that method.
  // Their types are automatically inferred based on the method signature
  params: ['0x123...', toWei('100')],
});
```

Returning to our [incrementer contract]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D?tab=contract){target=\_blank}, preparing a call to increment the contract looks like the following:

```typescript
import { prepareContractCall } from 'thirdweb';

const tx = prepareContractCall({
  contract,
  // Pass the method signature that you want to call
  method: 'function increment()',
  // Increment takes no params so we are leaving an empty array
  params: [],
});
```

### Preparing Raw Transactions {: #preparing-raw-transactions }

You can also prepare a transaction directly with encoded data. To do so, you'll use thirdweb's [`prepareTransaction` method](https://portal.thirdweb.com/typescript/v5/transactions/prepare){target=\_blank} and specify the `to`, `value`, `chain`, and `client` values directly. 

```typescript
import { prepareTransaction, toWei } from 'thirdweb';

const transaction = prepareTransaction({
  // The account that will be the receiver
  to: '0x456...',
  // The value is the amount of ether you want to send with the transaction
  value: toWei('1'),
  // The chain to execute the transaction on. This assumes you already set up
  // the Tanssi demo EVM network as a custom chain, as shown in the configure chain section
  chain: tanssi,
  // Your thirdweb client
  client,
});
```

### Reading Contract State {: #read-contract-state }

Use the [`readContract` function](https://portal.thirdweb.com/typescript/v5/transactions/read){target=\_blank} to call any read functions on your contract by passing in the Solidity method signature and any parameters.

```typescript
import { readContract } from 'thirdweb';

const balance = await readContract({
  contract: contract,
  method: 'function balanceOf(address) view returns (uint256)',
  params: ['0x123...'],
});
```

For a function that takes no parameters, such as the number function that returns the current number stored in the [incrementer contract]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D?tab=contract){target=\_blank}, you simply need to provide the function name as follows: 

```typescript
import { readContract } from 'thirdweb';

const number = await readContract({
  contract: contract,
  method: 'number',
  params: [],
});
```

Did you know? With the [thirdweb CLI](https://portal.thirdweb.com/cli){target=\_blank}, you can easily generate functions for all of the possible calls to a contract. To do so, run the following command in the command line: 

```bash
npx thirdweb generate INSERT_CHAIN_ID/INSERT_CONTRACT_ADDRESS
```

Both the chain ID and the contract address are required. As an example, if you wanted to generate the functions for the [incrementer contract on the Tanssi demo EVM network]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D?tab=contract){target=\_blank} , you would use the following command:

```bash
npx thirdweb generate {{ networks.dancelight.demo_evm_chain_id }}/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D
```

The file generated with all of the corresponding methods will be placed in a directory labelled `thirdweb/CHAIN_ID/CONTRACT_ADDRESS`. In the example shown above, the output file is located at `thirdweb/{{ networks.dancelight.demo_evm_chain_id }}/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D.ts`. For more information, see the [thirdweb's docs on the CLI](https://portal.thirdweb.com/cli/generate){target=\_blank}.

### Sending a Transaction {: #sending-a-transaction }

Every transaction sent using the SDK must first be prepared. This preparation process is synchronous and lightweight, requiring no network requests. Additionally, it provides type-safe definitions for your contract calls.

You can prepare a transaction as follows:

```typescript title="Prepare a transaction"
import { prepareTransaction, toWei } from 'thirdweb';

const transaction = prepareTransaction({
  to: '0x1234567890123456789012345678901234567890',
  chain: tanssi,
  client: thirdwebClient,
  value: toWei('1.0'),
  gasPrice: 150n,
});
```

After the transaction is prepared, you can send it as follows:

```typescript title="Send a transaction"
import { sendTransaction } from 'thirdweb';

const { transactionHash } = await sendTransaction({
  account,
  transaction,
});
```

You can optionally use `sendAndConfirmTransaction` to wait for the transaction to be mined. This is relevant if you want to block the user from continuing until the transaction is confirmed. 

```typescript title="Send and Confirm a Transaction"
import { sendAndConfirmTransaction } from 'thirdweb';
import { createWallet } from 'thirdweb/wallets';

const wallet = createWallet('io.metamask');
const account = await wallet.connect({ client });

const receipt = await sendAndConfirmTransaction({
  transaction,
  account,
});
```

### Transaction Utilities {: #transaction-utilites }

thirdweb provides a number of helpful utility methods surrounding preparing and sending transactions. 

You can estimate the gas used by a transaction as follows: 

```typescript title="Estimating gas"
import { estimateGas } from 'thirdweb';

const gasEstimate = await estimateGas({ transaction });
console.log('estmated gas used', gasEstimate);
```

You can estimate the gas cost in Ether and Wei as follows: 

```typescript title="Estimating gas cost"
import { estimateGas } from 'thirdweb';

const gasCost = await estimateGasCost({ transaction });
console.log('cost in ether', gasCost.ether);
```

thirdweb also provides a handy way to simulate transactions and verify their integrity before actually submitting it to the blockchain. You can simulate a transaction as follows:

```typescript title="Simulate a transaction"
import { simulateTransaction } from 'thirdweb';

const result = await simulateTransaction({ transaction });
console.log('simulation result', result);
```

You can encode transaction data to act on later by taking the following steps: 

```typescript title="Encode transaction data"
import { encode } from 'thirdweb';

const data = await encode(transaction);
console.log('encoded data', data);
```

### ConnectButton {: #connect-button }

Perhaps the first and most important interaction users will have with your dApp is connecting their wallet. thirdweb provides an easy and highly customizable way for you to enable this. thirdweb provides a highly customizable [`ConnectButton`](https://portal.thirdweb.com/react/v5/components/ConnectButton){target=\_blank} to tailor it to your desired wallets. The `ConnectButton` accepts an optional `wallets` parameter with an array of wallets. You can add or remove wallets from the `wallets` array to change the options available to users. thirdweb also offers a [`ConnectButton` Playground](https://thirdweb.com/dashboard/connect/playground){target=\_blank} to customize and view changes for the `ConnectButton` in real-time, given the button's high degree of flexibility.

```typescript title="ConnectButton"
import { ConnectButton } from 'thirdweb/react';
import { createWallet, inAppWallet } from 'thirdweb/wallets';
 
const wallets = [
  inAppWallet(),
  createWallet('io.metamask'),
  createWallet('com.coinbase.wallet'),
  createWallet('me.rainbow'),
];
 
function Example() {
  return (
    <div>
      <ConnectButton client={client} wallets={wallets} />
    </div>
  );
}
```

## Deploy Application {: #deploy-application }

As a reminder, you can build your example project locally by running:
 
```bash
yarn dev
```

To host your static web application on decentralized storage, run:

```bash
npx thirdweb deploy --app
```

Running this command builds your application for production and stores it using [Storage](https://portal.thirdweb.com/references/typescript/v5/functions#storage){target=\_blank}, thirdweb's decentralized file management solution. It uploads your built application to IPFS, a decentralized storage network, and generates a unique URL that provides a persistent hosting location for your application on the web.

If you have any further questions or encounter any issues during the process, please reach out to thirdweb support at [support.thirdweb.com](http://support.thirdweb.com){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/
--- BEGIN CONTENT ---
---
title: Ethereum API
description: Learn how to interact with your Tanssi EVM-compatible network through the Ethereum API with different development environments, libraries, and more.
icon: material-ethereum
template: index-page.html
---

# Ethereum Tools

Developing on Tanssi-powered EVM-compatible chains requires understanding how to interact with the blockchain effectively. Whether you're building decentralized applications (dApps), deploying smart contracts, or querying blockchain data, using the right tools and workflows is essential.

This section offers an overview of the key tools and workflows that developers use to interact with these networks, helping to enhance your development workflow.

Ready to dive in? Check out some of the following tools:

- **Development environments** - [Remix](/builders/toolkit/ethereum-api/dev-env/remix/), [Foundry](/builders/toolkit/ethereum-api/dev-env/foundry/), and [Hardhat](/builders/toolkit/ethereum-api/dev-env/hardhat/)
- **Libraries** - [Ethers.js](/builders/toolkit/ethereum-api/libraries/ethersjs/), [viem](/builders/toolkit/ethereum-api/libraries/viem/), and [Web3.js](/builders/toolkit/ethereum-api/libraries/web3js/)
- **Wallets** - [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/), [SubWallet](/builders/toolkit/ethereum-api/wallets/subwallet/), and [Talisman](/builders/toolkit/ethereum-api/wallets/talisman/)

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/libraries/ethersjs/
--- BEGIN CONTENT ---
---
title: EVM Transactions & Contracts with Ethers.js
description: Learn how to use the Ethereum EtherJS Library to send transactions and deploy Solidity smart contracts to your Tanssi-powered Ethereum compatible network.
icon: octicons-code-24
categories: EVM-Template
---

# Ethers.js JavaScript Library

<style>.video-container{display:flex;justify-content:space-between;max-width:1000px;margin:0 auto;}.video-column{width:49%;}.embed-container{position:relative;padding-bottom:56.25%;height:0;overflow:hidden;max-width:100%;margin-bottom:10px;}.embed-container iframe,.embed-container object,.embed-container embed{position:absolute;top:0;left:0;width:100%;height:100%;}</style><div class="video-container"><div class="video-column"><div class='embed-container'><iframe src='https://www.youtube.com/embed/bXtknNifO78?si=Hjiah5yhKvBcsE7f' frameborder='0' allowfullscreen></iframe></div></div><div class="video-column"><div class='embed-container'><iframe src='https://www.youtube.com/embed/m9iVeCP7owI?si=krm6z9AsFCDrjlJh' frameborder='0' allowfullscreen></iframe></div></div></div>

## Introduction {: #introduction }

The [Ethers.js](https://docs.ethers.org/v6/){target=\_blank} library provides a set of tools to interact with Ethereum nodes with JavaScript, similar to [Web3.js](/builders/toolkit/ethereum-api/libraries/web3js/){target=\_blank}. Tanssi-powered EVM networks have an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the Ethers.js library to interact with a Tanssi EVM network node as if they were doing so on Ethereum. For more information on Ethers.js, check their [documentation site](https://docs.ethers.org/v6){target=\_blank}.

In this guide, you'll learn how to use the Ethers.js library for your Tanssi EVM network. Next, to showcase the library in action, you'll use Ethers.js to send a transaction and deploy a contract on a Tanssi demo EVM appchain running on [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}. This guide can be adapted for your own Tanssi EVM appchain by simply changing the endpoint. 

If you prefer video tutorials, you can follow along with the corresponding videos at the top of this page for [Sending Transactions with Ethers.js](#send-a-transaction) and [Deploying Contracts with Ethers.js](#deploy-a-contract).

!!! note
    The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.
    
    Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their [official documentation](https://nodejs.org/en/download){target=\blank}.
    
    Also, make sure you've initialized a `package.json` file for ES6 modules. You can initialize a default `package.json` file using npm by running the following command `npm init --yes`.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - An account with funds in the Tanssi EVM network you are testing with

## Installing Ethers.js {: #install-ethersjs }

For this guide, you'll need to install the Ethers.js library and the Solidity compiler. To install both NPM packages, you can run the following command:

=== "npm"

    ```bash
    npm install ethers solc@0.8.0
    ```

=== "yarn"

    ```bash
    yarn add ethers solc@0.8.0
    ```

## Setting up the Ethers Provider {: #setting-up-the-ethers-provider }

Throughout this guide, you'll create several scripts that provide various functionalities, such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to create an [Ethers provider](https://docs.ethers.org/v6/api/providers/){target=\_blank} to interact with the network.

To create a provider, you can take the following steps:

1. Import the `ethers` library
2. Define the `providerRPC` object, which can include the network configurations for any of the networks you want to send a transaction on. You'll include the `name`, `rpc`, and `chainId` for each network
3. Create the `provider` using the `ethers.JsonRpcProvider` method

```js
// 1. Import ethers
import { ethers } from "ethers";

// 2. Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    // Insert your RPC URL here
    rpc: '{{ networks.dancelight.demo_evm_rpc_url }}',
    chainId: {{ networks.dancelight.demo_evm_chain_id }}, // {{ networks.dancelight.demo_evm_chain_hex_id }} in hex,
  },
};
// 3. Create ethers provider
const provider = new ethers.JsonRpcProvider(
  providerRPC.evmNetwork.rpc, 
  {
    chainId: providerRPC.evmNetwork.chainId,
    name: providerRPC.evmNetwork.name,
  }
);
```

Save this code snippet as you'll need it for the scripts that are used in the following sections.

## Send a Transaction {: #send-a-transaction }

During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.

You can also use the balance script to check the account balances after the transaction has been sent.

### Check Balances Script {: #check-balances-script }

You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a `balances.js` file by running:

```bash
touch balances.js
```

Next, you will create the script for this file and complete the following steps:

1. [Set up the Ethers provider](#setting-up-the-ethers-provider)
2. Define the `addressFrom` and `addressTo` variables
3. Create the asynchronous `balances` function which wraps the `provider.getBalance` method
4. Use the `provider.getBalance` function to fetch the balances for the `addressFrom` and `addressTo` addresses. You can also leverage the `ethers.formatEther` function to transform the balance into a more readable number in ETH
5. Lastly, run the `balances` function

```js
// 1. Add the Ethers provider logic here:
// {...}

// 2. Create address variables
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// 3. Create balances function
const balances = async () => {
  // 4. Fetch balances
  const balanceFrom = ethers.formatEther(await provider.getBalance(addressFrom));
  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} {{ networks.dancelight.demo_evm_token_symbol }}`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} {{ networks.dancelight.demo_evm_token_symbol }}`);
};

// 5. Call the balances function
balances();
```

??? code "View the complete script"

    ```js
    // Import ethers
import { ethers } from 'ethers';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};
// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Define addresses
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// Create balances function
const balances = async () => {
  // Fetch balances
  const balanceFrom = ethers.formatEther(
    await provider.getBalance(addressFrom)
  );
  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);
};

// Call the balances function
balances();
    ```

To run the script and fetch the account balances, you can run the following command:

```bash
node balances.js
```

If successful, the balances for the origin and receiving address will be displayed in your terminal in {{ networks.dancelight.demo_evm_token_symbol }}.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node balances.js</span>
  <span data-ty>The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 20.0 TANGO
    <br> The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 1.0 TANGO
  </span>
</div>

### Send Transaction Script {: #send-transaction-script }

You'll only need one file for executing a transaction between accounts. For this example, you'll be transferring 1 {{ networks.dancelight.demo_evm_token_symbol }} token from an origin address (from which you hold the private key) to another address. To get started, you can create a `transaction.js` file by running:

```bash
touch transaction.js
```

Next, you will create the script for this file and complete the following steps:

1. [Set up the Ethers provider](#setting-up-the-ethers-provider)
2. Define the `privateKey` and the `addressTo` variables. The private key is required to create a wallet instance. **Note: This is for example purposes only. Never store your private keys in a JavaScript file**
3. Create a wallet using the `privateKey` and `provider` from the previous steps. The wallet instance is used to sign transactions
4. Create the asynchronous `send` function, which wraps the transaction object and the `wallet.sendTransaction` method
5. Create the transaction object, which only requires the recipient's address and the amount to send. Note that `ethers.parseEther` can be used, which handles the necessary unit conversions from Ether to Wei - similar to using `ethers.parseUnits(value, 'ether')`
6. Send the transaction using the `wallet.sendTransaction` method and then use `await` to wait until the transaction is processed and the transaction receipt is returned
7. Lastly, run the `send` function

```js
// 1. Add the Ethers provider logic here:
// {...}

// 2. Create account variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const addressTo = 'INSERT_ADDRESS_TO';

// 3. Create wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// 4. Create send function
const send = async () => {
  console.log(`Attempting to send transaction from ${wallet.address} to ${addressTo}`);

  // 5. Create tx object
  const tx = {
    to: addressTo,
    value: ethers.parseEther('1'),
  };

  // 6. Sign and send tx - wait for receipt
  const createReceipt = await wallet.sendTransaction(tx);
  await createReceipt.wait();
  console.log(`Transaction successful with hash: ${createReceipt.hash}`);
};

// 7. Call the send function
send();
```

??? code "View the complete script"

    ```js
    // Import ethers
import { ethers } from 'ethers';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Define accounts and wallet
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const addressTo = 'INSERT_ADDRESS_TO';
const wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// Create send function
const send = async () => {
  console.log(
    `Attempting to send transaction from ${wallet.address} to ${addressTo}`
  );

  // Create transaction
  const tx = {
    to: addressTo,
    value: ethers.parseEther('1'),
  };

  // Send transaction and get hash
  const createReceipt = await wallet.sendTransaction(tx);
  await createReceipt.wait();
  console.log(`Transaction successful with hash: ${createReceipt.hash}`);
};

// Call the send function
send();
    ```

To run the script, you can run the following command in your terminal:

```bash
node transaction.js
```

If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.

You can also use the `balances.js` script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node transaction.js</span>
  <span data-ty>Attempting to send transaction from 0x44236223aB4291b93EEd10E4B511B37a398DEE55 to 0x8841701 Dba3639B254D9CEe712E49D188A1e941e
    <br> Transaction successful with hash: 0x29d87c00704b949cb4cc04fdc6c98d53b3c0ec4fb3ffe0c52864a73 b586f563c
  </span>
  <span data-ty="input"><span class="file-path"></span>node balances.js</span>
  <span data-ty>The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 18.999958 TANGO
    <br> The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 2.0 TANGO
  </span>
</div>

## Deploy a Contract {: #deploy-a-contract }

The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named `Incrementer.sol`. You can get started by creating a file for the contract:

```
touch Incrementer.sol
```

Next, you can add the Solidity code to the file:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
```

The `constructor` function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (default is 0). The `increment` function adds the `_value` provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the `reset` function resets the stored value to zero.

!!! note
    This contract is a simple example for illustration purposes only.

### Compile Contract Script {: #compile-contract-script }

In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the `Incrementer.sol` contract. To get started, you can create a `compile.js` file by running:

```
touch compile.js
```

Next, you will create the script for this file and complete the following steps:

1. Import the `fs` and `solc` packages
2. Using the `fs.readFileSync` function, you'll read and save the file contents of `Incrementer.sol` to `source`
3. Build the `input` object for the Solidity compiler by specifying the `language`, `sources`, and `settings` to be used
4. Using the `input` object, you can compile the contract using `solc.compile`
5. Extract the compiled contract file and export it to be used in the deployment script

```js
// 1. Import packages
import fs from 'fs';
import solc from 'solc';

// 2. Get path and load contract
const source = fs.readFileSync('Incrementer.sol', 'utf8');

// 3. Create input object
const input = {
  language: 'Solidity',
  sources: {
    'Incrementer.sol': {
      content: source,
    },
  },
  settings: {
    outputSelection: {
      '*': {
        '*': ['*'],
      },
    },
  },
};
// 4. Compile the contract
const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));
const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];

// 5. Export contract data
export default contractFile;
```

### Deploy Contract Script {: #deploy-contract-script }

With the script for compiling the `Incrementer.sol` contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called `deploy.js`:

```bash
touch deploy.js
```

Next, you will create the script for this file and complete the following steps:

1. Import the contract file from `compile.js`
2. [Set up the Ethers provider](#setting-up-the-ethers-provider)
3. Define the `privateKey` for the origin account. The private key is required to create a wallet instance. **Note: This is for example purposes only. Never store your private keys in a JavaScript file**
4. Save the `bytecode` and `abi` for the compiled contract
5. Create a wallet using the `privateKey` and `provider` from the previous steps. The wallet instance is used to sign transactions
6. Create a contract instance with signer using the `ethers.ContractFactory` function, providing the `abi`, `bytecode`, and `wallet` as parameters
7. Create the asynchronous `deploy` function that will be used to deploy the contract
8. Within the `deploy` function, use the `incrementer` contract instance to call `deploy` and pass in the initial value. For this example, you can set the initial value to `5`. This will send the transaction for contract deployment. To wait for a transaction receipt you can use the `deployed` method of the contract deployment transaction
9. Lastly, run the `deploy` function

```js
// 1. Import the contract file
import contractFile from './compile';

// 2. Add the Ethers provider logic here:
// {...}

// 3. Create account variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};

// 4. Save the bytecode and ABI
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// 5. Create wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// 6. Create contract instance with signer
const incrementer = new ethers.ContractFactory(abi, bytecode, wallet);

// 7. Create deploy function
const deploy = async () => {
  console.log(`Attempting to deploy from account: ${wallet.address}`);

  // 8. Send tx (initial value set to 5) and wait for receipt
  const contract = await incrementer.deploy(5);
  const txReceipt = await contract.deploymentTransaction().wait();

  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);
};

// 9. Call the deploy function
deploy();
```

??? code "View the complete script"

    ```js
    // Import ethers and compile
import { ethers } from 'ethers';
import contractFile from './compile.js';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Define accounts and wallet
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// Load contract info
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// Create contract instance with signer
const incrementer = new ethers.ContractFactory(abi, bytecode, wallet);

// Create deploy function
const deploy = async () => {
  console.log(`Attempting to deploy from account: ${wallet.address}`);

  // Send tx (initial value set to 5) and wait for receipt
  const contract = await incrementer.deploy(5);
  const txReceipt = await contract.deploymentTransaction().wait();

  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);
};

// Call the deploy function
deploy();
    ```

To run the script, you can enter the following command into your terminal:

```bash
node deploy.js
```

If successful, the contract's address will be displayed in the terminal.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node deploy.js</span>
  <span data-ty>Attempting to deploy from account: 0x44236223aB4291b93EEd10E4B511B37a398DEE55
    <br> Contract deployed at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2
  </span>
</div>

### Read Contract Data (Call Methods) {: #read-contract-data }

Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.

To get started, you can create a file and name it `get.js`:

```bash
touch get.js
```

Then you can take the following steps to create the script:

1. Import the `contractFile` from the `compile.js` file, where the ABI of the contract is
2. [Set up the Ethers provider](#setting-up-the-ethers-provider)
3. Create the `contractAddress` variable using the address of the deployed contract
4. Create an instance of the contract using the `ethers.Contract` function and passing in the `contractAddress`, `abi`, and `provider`
5. Create the asynchronous `get` function
6. Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you'll call the `number` method, which requires no inputs, and `await`, which will return the requested value once the request promise resolves
7. Lastly, call the `get` function

```js
// 1. Import the ABI
import contractFile from './compile';

// 2. Add the Ethers provider logic here:
// {...}

// 3. Contract address variable
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// 4. Create contract instance
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  provider
);

// 5. Create get function
const get = async () => {
  console.log(`Making a call to contract at address: ${contractAddress}`);

  // 6. Call contract 
  const data = await incrementer.number();

  console.log(`The current number stored is: ${data}`);
};

// 7. Call get function
get();
```

??? code "View the complete script"

    ```js
    // Import ethers and compile
import { ethers } from 'ethers';
import contractFile from './compile.js';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Contract address variable
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// Create contract instance
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  provider
);

// Create get function
const get = async () => {
  console.log(`Making a call to contract at address: ${contractAddress}`);

  // Call contract
  const data = await incrementer.number();

  console.log(`The current number stored is: ${data}`);
};

// Call get function
get();
    ```

To run the script, you can enter the following command in your terminal:

```bash
node get.js
```

If successful, the value will be displayed in the terminal.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node get.js</span>
  <span data-ty>Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2
    <br> The current number stored is: 5
  </span>
</div>

### Interact with Contract (Send Methods) {: #interact-with-contract }

Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them `increment.js` and `reset.js`:

```bash
touch increment.js reset.js
```

Open the `increment.js` file and take the following steps to create the script:

1. Import the `contractFile` from the `compile.js` file, where the ABI of the contract is
2. [Set up the Ethers provider](#setting-up-the-ethers-provider)
3. Define the `privateKey` for the origin account, the `contractAddress` of the deployed contract, and the `_value` to increment by. The private key is required to create a wallet instance. **Note: This is for example purposes only. Never store your private keys in a JavaScript file**
4. Create a wallet using the `privateKey` and `provider` from the previous steps. The wallet instance is used to sign transactions
5. Create an instance of the contract using the `ethers.Contract` function and passing in the `contractAddress`, `abi`, and `provider`
6. Create the asynchronous `increment` function
7. Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you'll call the `increment` method, providing the value to increment by as an input, and `await`, which will return the requested value once the request promise resolves
8. Lastly, call the `increment` function

```js
// 1. Import the contract ABI
import contractFile from './compile';

// 2. Add the Ethers provider logic here:
// {...}

// 3. Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const _value = 3;

// 4. Create wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// 5. Create contract instance with signer
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  wallet
);

// 6. Create increment function
const increment = async () => {
  console.log(
    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
  );

  // 7. Sign and send tx and wait for receipt
  const createReceipt = await incrementer.increment(_value);
  await createReceipt.wait();

  console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

// 8. Call the increment function
increment();
```

??? code "View the complete script"

    ```js
    // Import ethers and compile
import { ethers } from 'ethers';
import contractFile from './compile.js';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const _value = 3;

// Create wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// Create contract instance with signer
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  wallet
);

// Create increment function
const increment = async () => {
  console.log(
    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
  );

  // Sign and send tx and wait for receipt
  const createReceipt = await incrementer.increment(_value);
  await createReceipt.wait();

  console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

// Call the increment function
increment();
    ```

To run the script, you can enter the following command in your terminal:

```bash
node increment.js
```

If successful, the transaction hash will be displayed in the terminal. You can use the `get.js` script alongside the `increment.js` script to make sure that the value is changing as expected:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node increment.js</span>
  <span data-ty>Calling the increment by 3 function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2
    <br> Tx successful with hash: 0x8aa7ccb4613ac92713bcc6ff064f1b0c978e24b3f6acb6d6bfa730a10af522bb
  </span>
  <span data-ty="input"><span class="file-path"></span>node get.js</span>
  <span data-ty>Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2
    <br> The current number stored is: 8
  </span>
</div>

Next you can open the `reset.js` file and take the following steps to create the script:

1. Import the `contractFile` from the `compile.js` file, where the ABI of the contract is
2. [Set up the Ethers provider](#setting-up-the-ethers-provider)
3. Define the `privateKey` for the origin account and the `contractAddress` of the deployed contract. The private key is required to create a wallet instance. **Note: This is for example purposes only. Never store your private keys in a JavaScript file**
4. Create a wallet using the `privateKey` and `provider` from the previous steps. The wallet instance is used to sign transactions
5. Create an instance of the contract using the `ethers.Contract` function and passing in the `contractAddress`, `abi`, and `provider`
6. Create the asynchronous `reset` function
7. Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the `reset` method which doesn't require any inputs. You can use `await` which will return the value requested once the request promise resolves
8. Lastly, call the `reset` function

```js
// 1. Import the contract ABI
import contractFile from './compile';

// 2. Add the Ethers provider logic here:
// {...}

// 3. Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// 4. Create wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// 5. Create contract instance with signer
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  wallet
);

// 6. Create reset function
const reset = async () => {
  console.log(`Calling the reset function in contract at address: ${contractAddress}`);

  // 7. sign and send tx and wait for receipt
  const createReceipt = await incrementer.reset();
  await createReceipt.wait();

  console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

// 8. Call the reset function
reset();
```

??? code "View the complete script"

    ```js
    // Import ethers and compile
import { ethers } from 'ethers';
import contractFile from './compile.js';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// Create wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// Create contract instance with signer
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  wallet
);

// Create reset function
const reset = async () => {
  console.log(
    `Calling the reset function in contract at address: ${contractAddress}`
  );

  // Sign and send tx and wait for receipt
  const createReceipt = await incrementer.reset();
  await createReceipt.wait();

  console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

// Call the reset function
reset();
    ```

To run the script, you can enter the following command in your terminal:

```bash
node reset.js
```

If successful, the transaction hash will be displayed in the terminal. You can use the `get.js` script alongside the `reset.js` script to make sure that value is changing as expected:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node increment.js</span>
  <span data-ty>Calling the reset function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2
    <br> Tx successful with hash: 0xb689da50a43e98b5a83ff64757afbf100be12e2db6ff4d0504168f262cc08fb0
  </span>
  <span data-ty="input"><span class="file-path"></span>node get.js</span>
  <span data-ty>Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2
    <br> The current number stored is: 0
  </span>
</div>

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/libraries/
--- BEGIN CONTENT ---
---
title: Ethereum Libraries
description: Learn how to use Ethereum libraries such as Ethers.js, Web3.js, or Web3.py to send transactions or deploy contracts on your Tanssi EVM network.
icon: octicons-code-24
template: index-page.html
---

# Libraries

Libraries are essential tools for interacting with blockchain networks. They provide pre-built functions and abstractions that simplify tasks like reading and writing chain data. These libraries eliminate the need to handle raw blockchain requests, making it easier for developers to build and deploy decentralized applications while ensuring compatibility with Ethereum and other EVM-compatible networks.

Some key capabilities of working with libraries include:

- **Transaction management** - create, sign, and broadcast transactions
- **Smart contract interactions** - simplify calling contract functions, decoding responses, and handling contract events
- **Wallet integration** - facilitate secure wallet integrations for transacting with the network
- **Blockchain data parsing** - decode and interpret complex data structures returned by smart contracts
- **Event monitoring** - listen to events emitted by contracts and trigger specific application actions

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/libraries/viem/
--- BEGIN CONTENT ---
---
title: How to use viem Ethereum Library
description: In this tutorial use the viem TypeScript interface for Ethereum to send transactions and deploy Solidity smart contracts to your Tanssi-powered EVM network.
icon: octicons-code-24
categories: EVM-Template
---

# viem TypeScript Ethereum Library

## Introduction {: #introduction }

[viem](https://viem.sh){target=\_blank} is a modular TypeScript library that allows developers to interact with abstractions over the JSON-RPC API, making it easy to interact with Ethereum nodes. Since Tanssi-powered EVM networks have an Ethereum API available that is fully compatible with Ethereum-style JSON-RPC invocations, developers can leverage this compatibility to interact with any Tanssi EVM network. For more information on viem, check out their [documentation site](https://viem.sh/docs/getting-started){target=\_blank}.

In this guide, you'll learn how to use viem to send a transaction and deploy a contract on the demo EVM network. This guide can be adapted for use with any Tanssi-powered EVM network.

!!! note
    The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.
    
    Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their [official documentation](https://nodejs.org/en/download){target=\blank}.
    
    Also, make sure you've initialized a `package.json` file for ES6 modules. You can initialize a default `package.json` file using npm by running the following command `npm init --yes`.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - An account with funds in the Tanssi EVM network you are testing with

## Installing viem {: #installing-viem }

To get started, you'll need to create a basic TypeScript project. First, create a directory to store all of the files you'll be creating throughout this guide, and initialize the project with the following command:

```bash
mkdir viem-examples && cd viem-examples && npm init --y
```

For this guide, you'll need to install the viem library and the Solidity compiler. To install both packages, you can run the following command:

=== "npm"

    ```bash
    npm install typescript ts-node viem solc@0.8.0
    ```

=== "yarn"

    ```bash
    yarn add typescript ts-node viem solc@0.8.0
    ```

You can create a TypeScript configuration file by running:

```bash
npx tsc --init
```

!!! note
    This tutorial was created using Node.js v18.18.0.

## Set Up a viem Client (Provider) {: #setting-up-a-viem-provider }

Throughout this guide, you'll be creating a bunch of scripts that provide different functionality, such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts, you'll need to create a [viem client](https://docs.ethers.org/v6/api/providers/){target=\_blank} to interact with the network.

You can create a viem client for reading chain data, like balances or contract data, using the `createPublicClient` function, or you can create a viem client for writing chain data, like sending transactions, using the `createWalletClient` function.

Creating a viem client to interact with your Tanssi EVM network is a two-step process. First, you'll need to import the `defineChain` function from viem. This will allow you to specify the details of your Tanssi EVM network (or any arbitrary EVM chain). You'll then need to provide all of the chain details, as shown in the next section.

### For Reading Chain Data {: #for-reading-chain-data }

To create a client for reading chain data, you can take the following steps:

1. Import the `createPublicClient`, `http`, and `defineChain`functions from `viem`
2. Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both `public` and `default` RPC URLs are required to be listed, even if they are the same
3. Create the `client` using the `createPublicClient` function and pass in the network and the HTTP RPC endpoint

```ts
// 1. Import the necessary components from viem
import { createPublicClient, http, defineChain } from 'viem';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a public client for reading chain data
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});
```

### For Writing Chain Data {: #for-writing-chain-data }

To create a client for writing chain data, you can take the following steps:

1. Import the `createWalletClient`, `http`, and `defineChain` functions from `viem`, and the `privateKeyToAccount` function from `viem/accounts`
2. Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both `public` and `default` RPC URLs are required to be listed, even if they are the same
3. Create your account using the `privateKeyToAccount` function
4. Create the `client` using the `createWalletClient` function and pass in the account, network, and the HTTP RPC endpoint

!!! remember
    This is for demo purposes only. Never store your private key in a TypeScript file.



```ts
// 1. Import the necessary components from viem and viem/accounts
import { createWalletClient, http, defineChain } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create your account using the privateKeyToAccount function
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';

//4. Create a wallet client for writing chain data
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});
```

!!! note
    To interact with browser-based wallets, you can use the following code to create an account. In this snippet, `demo` refers to the demo EVM network created with `defineChain`.
    ```ts
    const [account] = await window.ethereum.request({
  method: 'eth_requestAccounts',
});
const walletClient = createWalletClient({
  account,
  chain: demo,
  transport: custom(window.ethereum),
});
    ```

## Send a Transaction {: #send-transaction }

During this section, you'll be creating a couple of scripts. The first one will check the balances of your accounts before trying to send a transaction. The second script will send the transaction. You can also use the balance script to check the account balances after the transaction has been sent.

### Check Balances Script {: #check-balances-script }

You'll only need one file to check the balances of both addresses before and after the transaction is sent. To get started, you can create a `balances.ts` file by running:

```bash
touch balances.ts
```

Next, you will create the script for this file and complete the following steps:

1. Update your imports to include the `createPublicClient`, `http`,`formatEther`, and `defineChain `functions from `viem` 
2. Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both `public` and `default` RPC URLs are required to be listed, even if they are the same
3. [Set up a public viem client](#for-reading-chain-data), which can be used for reading chain data, such as account balances
4. Define the `addressFrom` and `addressTo` variables
5. Create the asynchronous `balances` function that wraps the `publicClient.getBalance` method
6. Use the `publicClient.getBalance` function to fetch the balances for the `addressFrom` and `addressTo` addresses. You can also leverage the `formatEther` function to transform the balance into a more readable number (in {{ networks.dancelight.demo_evm_token_symbol }} for the demo EVM network)
7. Lastly, run the `balances` function

???+ code "View balances.ts"

    ```ts
    // 1. Import the necessary components from viem
import { createPublicClient, http, formatEther, defineChain } from 'viem';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'UNIT',
    symbol: 'UNIT',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a public client for reading chain data
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create address variables
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// 5. Create balances function
const balances = async () => {
  // 6. Fetch balances
  const balanceFrom = formatEther(
    await publicClient.getBalance({ address: addressFrom })
  );
  const balanceTo = formatEther(
    await publicClient.getBalance({ address: addressTo })
  );

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);
};

// 7. Call the balances function
balances();
    ```

To run the script and fetch the account balances, you can run the following command:

```bash
npx ts-node balances.ts
```

If successful, the balances for the origin and receiving address will be displayed in your terminal in {{ networks.dancelight.demo_evm_token_symbol }}.

![The result of running the balances script in the terminal](/images/builders/toolkit/ethereum-api/libraries/viem/viem-1.webp)

### Send Transaction Script {: #send-transaction-script }

You'll only need one file to execute a transaction between accounts. For this example, you'll be transferring 1 {{ networks.dancelight.demo_evm_token_symbol }} token from an origin address on the demo EVM network (from which you hold the private key) to another address. To get started, you can create a `transaction.ts` file by running:

```bash
touch transaction.ts
```

Next, you will create the script for this file and complete the following steps:

1. Update your imports to include `createPublicClient`, `createWalletClient`, `http`, `parseEther`, and `defineChain` functions from `viem`, as well as the `privateKeyToAccount` function from `viem/accounts`
2. Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both `public` and `default` RPC URLs are required to be listed, even if they are the same
3. [Set up a viem wallet client](#for-writing-chain-data) for writing chain data, which can be used along with your private key to send transactions. **Note: This is for example purposes only. Never store your private keys in a TypeScript file**
4. [Set up a public viem client](#for-reading-chain-data) for reading chain data, which will be used to wait for the transaction receipt
5. Define the `addressTo` variable
6. Create the asynchronous `send` function, which wraps the transaction object and the `walletClient.sendTransaction` method
7. Use the `walletClient.sendTransaction` function to sign and send the transaction. You'll need to pass in the transaction object, which only requires the recipient's address and the amount to send. Note that `parseEther` can be used, which handles the necessary unit conversions from Ether to Wei, similar to using `parseUnits(value, decimals)`. Use `await` to wait until the transaction is processed and the transaction hash is returned
8. Use the `publicClient.waitForTransactionReceipt` function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the `balances.ts` script directly after this one to check if the balances have been updated as expected
9. Lastly, run the `send` function

???+ code "View transaction.ts"

    ```ts
    // 1. Import the necessary components from viem and viem/accounts
import {
  createPublicClient,
  createWalletClient,
  http,
  parseEther,
  defineChain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a wallet client for writing chain data
// The private key must be prepended with `0x` to avoid errors
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create a public client for reading chain data
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 5. Create to address variable
const addressTo = 'INSERT_ADDRESS_TO';

// 6. Create send function
const send = async () => {
  console.log(
    `Attempting to send transaction from ${account.address} to ${addressTo}`
  );

  // 7. Sign and send transaction
  const hash = await walletClient.sendTransaction({
    to: addressTo,
    value: parseEther('1'),
  });

  // 8. Wait for the transaction receipt
  await publicClient.waitForTransactionReceipt({
    hash,
  });

  console.log(`Transaction successful with hash: ${hash}`);
};

// 9. Call the send function
send();
    ```

To run the script, you can run the following command in your terminal:

```bash
npx ts-node transaction.ts
```

If the transaction was successful, in your terminal, you'll see the transaction hash has been printed out. You can also use the `balances.ts` script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:

![The result of running the transaction and balances scripts in the terminal](/images/builders/toolkit/ethereum-api/libraries/viem/viem-2.webp)

## Deploy a Contract {: #deploy-contract }

The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named `Incrementer.sol`. You can get started by creating a file for the contract:

```
touch Incrementer.sol
```

Next, you can add the Solidity code to the file:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
```

The `constructor` function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (default is 0). The `increment` function adds the `_value` provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the `reset` function resets the stored value to zero.

!!! note
    This contract is a simple example for illustration purposes only.

### Compile Contract Script {: #compile-contract-script }

In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the `Incrementer.sol` contract. To get started, you can create a `compile.ts` file by running:

```bash
touch compile.ts
```

Next, you will create the script for this file and complete the following steps:

1. Import the `fs` and `solc` packages
2. Using the `fs.readFileSync` function, you'll read and save the file contents of `Incrementer.sol` to `source`
3. Build the `input` object for the Solidity compiler by specifying the `language`, `sources`, and `settings` to be used
4. Using the `input` object, you can compile the contract using `solc.compile`
5. Extract the compiled contract file and export it to be used in the deployment script

```js
// 1. Import packages
const fs = require('fs');
const solc = require('solc');

// 2. Get path and load contract
const source = fs.readFileSync('Incrementer.sol', 'utf8');

// 3. Create input object
const input = {
  language: 'Solidity',
  sources: {
    'Incrementer.sol': {
      content: source,
    },
  },
  settings: {
    outputSelection: {
      '*': {
        '*': ['*'],
      },
    },
  },
};
// 4. Compile the contract
const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));
const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];

// 5. Export contract data
export default contractFile;
```

### Deploy Contract Script {: #deploy-contract-script }

With the script for compiling the `Incrementer.sol` contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called `deploy.ts`:

```bash
touch deploy.ts
```

Next, you will create the script for this file and complete the following steps:

1. Update your imports to include the `createPublicClient`, `createWalletClient`, `http`, and `defineChain` functions from `viem`, the `privateKeyToAccount` function from `viem/accounts`, and the `contractFile` from the `compile.ts` file you created in the [Compile Contract Script](#compile-contract-script) section
2. Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both `public` and `default` RPC URLs are required to be listed, even if they are the same
3. [Set up a viem wallet client](#for-writing-chain-data) for writing chain data, which will be used along with your private key to deploy the `Incrementer` contract. **Note: This is for example purposes only. Never store your private keys in a TypeScript file**
4. [Set up a public viem client](#for-reading-chain-data) for reading chain data, which will be used to read the transaction receipt for the deployment
5. Load the contract `bytecode` and `abi` for the compiled contract
6. Create the asynchronous `deploy` function that will be used to deploy the contract via the `walletClient.deployContract` method
7. Use the `walletClient.deployContract` function to sign and send the transaction. You'll need to pass in the contract's ABI and bytecode, the account to deploy the transaction from, and the initial value for the incrementer. Use `await` to wait until the transaction is processed and the transaction hash is returned
8. Use the `publicClient.readContract` function to get the transaction receipt for the deployment. Use `await` to wait until the transaction is processed and the contract address is returned
9. Lastly, run the `deploy` function

???+ code "View deploy.ts"

    ```ts
    // 1. Update import
import {
  createPublicClient,
  createWalletClient,
  http,
  defineChain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import contractFile from './compile';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a wallet client for writing chain data
// The private key must be prepended with `0x` to avoid errors
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create a public client for reading chain data
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 5. Load contract information
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;
const _initialNumber = 5;

// 6. Create deploy function
const deploy = async () => {
  console.log(`Attempting to deploy from account: ${account.address}`);

  // 7. Send transaction (initial value set to 5)
  const contract = await walletClient.deployContract({
    abi,
    account,
    bytecode,
    args: [_initialNumber],
  });

  // 8. Get the transaction receipt for the deployment
  const transaction = await publicClient.waitForTransactionReceipt({
    hash: contract,
  });

  console.log(`Contract deployed at address: ${transaction.contractAddress}`);
};

// 9. Call the deploy function
deploy();
    ```


To run the script, you can enter the following command into your terminal:

```bash
npx ts-node deploy.ts
```

If successful, the contract's address will be displayed in the terminal.

![The result of running the deploy script in the terminal](/images/builders/toolkit/ethereum-api/libraries/viem/viem-3.webp)

### Read Contract Data (Call Methods) {: #read-contract-data }

Call methods are the type of interaction that doesn't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.

To get started, you can create a file and name it `get.ts`:

```bash
touch get.ts
```

Then you can take the following steps to create the script:

1. Update your imports to include the `createPublicClient`, `http`, and `defineChain` functions from `viem`, and the `contractFile` from the `compile.ts` file you created in the [Compile Contract Script](#compile-contract-script) section
2. Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both `public` and `default` RPC URLs are required to be listed, even if they are the same
3. [Set up a public viem client](#for-reading-chain-data) for reading chain data, which will be used to read the current number of the `Incrementer` contract
4. Create the `contractAddress` variable using the address of the deployed contract and the `abi` variable using the `contractFile` from the `compile.ts` file
5. Create the asynchronous `get` function
6. Call the contract using the `publicClient.readContract` function, passing in the `abi`, the name of the function, the `contractAddress`, and any arguments (if needed). You can use `await`, which will return the value requested once the request promise resolves
7. Lastly, call the `get` function

???+ code "View get.ts"

    ```ts
    // 1. Update import
import { createPublicClient, http, defineChain } from 'viem';
import contractFile from './compile';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a public client for reading chain data
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});
// 4. Create contract variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const abi = contractFile.abi;

// 5. Create get function
const get = async () => {
  console.log(`Making a call to contract at address: ${contractAddress}`);

  // 6. Call contract
  const data = await publicClient.readContract({
    abi,
    functionName: 'number',
    address: contractAddress,
    args: [],
  });

  console.log(`The current number stored is: ${data}`);
};

// 7. Call get function
get();
    ```

To run the script, you can enter the following command in your terminal:

```bash
npx ts-node get.ts
```

If successful, the value will be displayed in the terminal.

![The result of running the get script in the terminal](/images/builders/toolkit/ethereum-api/libraries/viem/viem-4.webp)

### Interact with Contract (Send Methods) {: #interact-with-contract }

Send methods are the type of interactions that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them `increment.ts` and `reset.ts`:

```bash
touch increment.ts reset.ts
```

Open the `increment.ts` file and take the following steps to create the script:

1. Update your imports to include the `createPublicClient`, `createWalletClient` `http`, and `defineChain` functions from `viem`, the  `privateKeyToAccount` from `viem/accounts'` and the `contractFile` from the `compile.ts` file you created in the [Compile Contract Script](#compile-contract-script) section
2. Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both `public` and `default` RPC URLs are required to be listed, even if they are the same
3. [Set up a viem wallet client](#for-writing-chain-data) for writing chain data, which will be used along with your private key to send a transaction. **Note: This is for example purposes only. Never store your private keys in a TypeScript file**
4. [Set up a public viem client](#for-reading-chain-data) for reading chain data, which will be used to wait for the transaction receipt
5. Create the `contractAddress` variable using the address of the deployed contract, the `abi` variable using the `contractFile` from the `compile.ts` file, and the `_value` to increment the contract by
6. Create the asynchronous `increment` function
7. Call the contract using the `walletClient.writeContract` function, passing in the `abi`, the name of the function, the `contractAddress`, and the `_value`. You can use `await`, which will return the transaction hash once the request promise resolves
8. Use the `publicClient.waitForTransactionReceipt` function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the `get.ts` script directly after this one to check that the current number has been updated as expected
9. Lastly, call the `increment` function

???+ code "View increment.ts"

    ```ts
    // 1. Update import
import {
  createPublicClient,
  createWalletClient,
  http,
  defineChain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import contractFile from './compile';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a wallet client for writing chain data
// The private key must be prepended with `0x` to avoid errors
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create a public client for reading chain data
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 5. Create contract variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const abi = contractFile.abi;
const _value = 3;

// 6. Create increment function
const increment = async () => {
  console.log(
    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
  );
  // 7. Call contract
  const hash = await walletClient.writeContract({
    abi,
    functionName: 'increment',
    address: contractAddress,
    args: [_value],
  });

  // 8. Wait for the transaction receipt
  await publicClient.waitForTransactionReceipt({
    hash,
  });

  console.log(`Transaction successful with hash: ${hash}`);
};

// 9. Call increment function
increment();
    ```


To run the script, you can enter the following command in your terminal:

```bash
npx ts-node increment.ts
```

If successful, the transaction hash will be displayed in the terminal. You can use the `get.ts` script alongside the `increment.ts` script to make sure that value is changing as expected.

![The result of running the increment and get scripts in the terminal](/images/builders/toolkit/ethereum-api/libraries/viem/viem-5.webp)

Next, you can open the `reset.ts` file and take the following steps to create the script:

1. Update your imports to include the `createPublicClient`, `createWalletClient` `http`, and `defineChain` functions from `viem`, the  `privateKeyToAccount` from `viem/accounts'` and the `contractFile` from the `compile.ts` file you created in the [Compile Contract Script](#compile-contract-script) section
2. Define the chain details of your Tanssi EVM network, making sure to include all fields shown below. Both `public` and `default` RPC URLs are required to be listed, even if they are the same
3. [Set up a viem wallet client](#for-writing-chain-data) for writing chain data, which will be used along with your private key to send a transaction. **Note: This is for example purposes only. Never store your private keys in a TypeScript file**
4. [Set up a public viem client](#for-reading-chain-data) for reading chain data, which will be used to wait for the transaction receipt
5. Create the `contractAddress` variable using the address of the deployed contract and the `abi` variable using the `contractFile` from the `compile.ts` file to increment the contract by
6. Create the asynchronous `reset` function
7. Call the contract using the `walletClient.writeContract` function, passing in the `abi`, the name of the function, the `contractAddress`, and an empty array for the arguments. You can use `await`, which will return the transaction hash once the request promise resolves
8. Use the `publicClient.waitForTransactionReceipt` function to wait for the transaction receipt, signaling that the transaction has been completed. This is particularly helpful if you need the transaction receipt or if you're running the `get.ts` script directly after this one to check that the current number has been reset to `0`
9. Lastly, call the `reset` function

???+ code "View reset.ts"

    ```ts
    // 1. Update import
import {
  createPublicClient,
  createWalletClient,
  http,
  defineChain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import contractFile from './compile';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a wallet client for writing chain data
// The private key must be prepended with `0x` to avoid errors
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create a public client for reading chain data
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 5. Create contract variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const abi = contractFile.abi;

// 6. Create reset function
const reset = async () => {
  console.log(
    `Calling the reset function in contract at address: ${contractAddress}`
  );

  // 7. Call contract
  const hash = await walletClient.writeContract({
    abi,
    functionName: 'reset',
    address: contractAddress,
    args: [],
  });

  // 8. Wait for the transaction receipt
  await publicClient.waitForTransactionReceipt({
    hash,
  });

  console.log(`Transaction successful with hash: ${hash}`);
};

// 9. Call reset function
reset();
    ```


To run the script, you can enter the following command in your terminal:

```bash
npx ts-node reset.ts
```

If successful, the transaction hash will be displayed in the terminal. You can use the `get.ts` script alongside the `reset.ts` script to make sure that value is changing as expected.

![The result of running the reset and get scripts in the terminal](/images/builders/toolkit/ethereum-api/libraries/viem/viem-6.webp)

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/libraries/web3js/
--- BEGIN CONTENT ---
---
title: EVM Transactions & Contracts with Web3.js
description: Learn how to use the Ethereum Web3 JavaScript Library to send transactions and deploy Solidity smart contracts to your Tanssi-powered EVM-compatible network.
icon: octicons-code-24
categories: EVM-Template
---

# Web3.js JavaScript Library

## Introduction {: #introduction }

[Web3.js](https://web3js.readthedocs.io){target=\_blank} is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with JavaScript. Tanssi-powered EVM networks have an Ethereum-like API that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the Web3.js library to interact with a Tanssi EVM network node as if they were doing so on Ethereum. For more information on Web3.js, check out their [documentation site](https://web3js.readthedocs.io/en/v1.10.0){target=\_blank}.

In this guide, you'll learn how to set up the Web3.js library for your Tanssi EVM network. Next, to showcase the library in action, you'll use the Web3.js library to send a transaction and deploy a contract on a Tanssi demo EVM network running on [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}. This guide can be adapted for your own Tanssi EVM network by simply changing the endpoint.

!!! note
    The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.
    
    Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their [official documentation](https://nodejs.org/en/download){target=\blank}.
    
    Also, make sure you've initialized a `package.json` file for ES6 modules. You can initialize a default `package.json` file using npm by running the following command `npm init --yes`.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

- An account with funds in the Tanssi EVM network you are testing with

## Installing Web3Js {: #installing-web3js }

For this guide, you'll need to install the Web3.js library and the Solidity compiler. To install both NPM packages, you can run the following command:

=== "npm"

    ```bash
    npm install web3 solc@0.8.0
    ```

=== "yarn"

    ```bash
    yarn add web3 solc@0.8.0
    ```

## Setting up the Web3 Provider {: #setting-up-the-web3-provider }

Throughout this guide, you'll be creating a bunch of scripts that provide different functionality such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to create an Web3.js provider to interact with the network.

To set up a Web3 provider, you can take the following steps:

1. Import the `Web3` library.
2. Create the Web3 provider and specify the RPC url. You can configure Web3.js to work with the Tanssi demo EVM network running on Dancelight, or your own Tanssi EVM network by simply changing the endpoint.

```js
// 1. Import Web3
const Web3 = require('web3');

// 2. Create Web3 provider and insert your RPC url
const web3 = new Web3(
  '{{ networks.dancelight.demo_evm_rpc_url }}'
);
```

Save this code snippet as you'll need it for the scripts that are used in the following sections.

## Send a Transaction {: #send-a-transaction }

During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.

You can also use the balance script to check the account balances after the transaction has been sent.

### Check Balances Script {: #check-balances-script }

You'll only need one file to check the balances of both addresses before and after the transaction is sent. To get started, you can create a `balances.js` file by running:

```bash
touch balances.js
```

Next, you will create the script for this file and complete the following steps:

1. [Set up the Web3 provider](#setting-up-the-web3-provider)
2. Define the `addressFrom` and `addressTo` variables
3. Create the asynchronous `balances` function which wraps the `web3.eth.getBalance` method
4. Use the `web3.eth.getBalance` function to fetch the balances for the `addressFrom` and `addressTo` addresses. You can also leverage the `web3.utils.fromWei` function to transform the balance into a more readable number in `{{ networks.dancelight.demo_evm_token_symbol }}`
5. Lastly, run the `balances` function

```js
// 1. Add the Web3 provider logic here:
// {...}

// 2. Create address variables
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// 3. Create balances function
const balances = async () => {
  // 4. Fetch balance info
  const balanceFrom = web3.utils.fromWei(
    await web3.eth.getBalance(addressFrom),
    'ether'
  );
  const balanceTo = web3.utils.fromWei(
    await web3.eth.getBalance(addressTo),
    'ether'
  );

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} {{ networks.dancelight.demo_evm_token_symbol }}`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} {{ networks.dancelight.demo_evm_token_symbol }}`);
};

// 5. Call balances function
balances();
```

??? code "View the complete script"

    ```js
    // Import Web3
const Web3 = require('web3');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create address variables
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// Create balances function
const balances = async () => {
  // Fetch balance info
  const balanceFrom = web3.utils.fromWei(
    await web3.eth.getBalance(addressFrom),
    'ether'
  );
  const balanceTo = web3.utils.fromWei(
    await web3.eth.getBalance(addressTo),
    'ether'
  );

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);
};

// Call balances function
balances();
    ```

To run the script and fetch the account balances, you can run the following command:

```bash
node balances.js
```

If successful, the balances for the origin and receiving address will be displayed in your terminal in ETH.

![Check balance Web3js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-1.webp)

### Send Transaction Script {: #send-transaction-script }

You'll only need one file to execute a transaction between accounts. For this example, you'll be transferring 1 {{ networks.dancelight.demo_evm_token_symbol }} token from an origin address (from which you hold the private key) to another address. To get started, you can create a `transaction.js` file by running:

```bash
touch transaction.js
```

Next, you will create the script for this file and complete the following steps:

1. [Set up the Web3 provider](#setting-up-the-web3-provider)
2. Define the `addressFrom`, including the `privateKey`, and the `addressTo` variables. The private key is required to create a wallet instance. **Note: This is for example purposes only. Never store your private keys in a JavaScript file**
3. Create the asynchronous `send` function, which wraps the transaction object, and the sign and send transaction functions
4. Create and sign the transaction using the `web3.eth.accounts.signTransaction` function. Pass in the `gas`, `addressTo`, and `value` for the transaction along with the sender's `privateKey`
5. Send the signed transaction using the `web3.eth.sendSignedTransaction` method and pass in the raw transaction. Then use `await` to wait until the transaction is processed and the transaction receipt is returned
6. Lastly, run the `send` function

```js
// 1. Add the Web3 provider logic here:
// {...}

// 2. Create account variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',
};
const addressTo = 'INSERT_ADDRESS_TO'; // Change to address

// 3. Create send function
const send = async () => {
  console.log(
    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`
  );

  // 4. Sign tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      gas: 21000,
      to: addressTo,
      value: web3.utils.toWei('1', 'ether'),
    },
    accountFrom.privateKey
  );

  // 5. Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(
    `Transaction successful with hash: ${createReceipt.transactionHash}`
  );
};

// 6. Call send function
send();
```

??? code "View the complete script"

    ```js
    // Import Web3
const Web3 = require('web3');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create account variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',
};
const addressTo = 'INSERT_ADDRESS_TO';

// Create send function
const send = async () => {
  console.log(
    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`
  );

  // Sign tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      gas: 21000,
      to: addressTo,
      value: web3.utils.toWei('1', 'ether'),
    },
    accountFrom.privateKey
  );

  // Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(
    `Transaction successful with hash: ${createReceipt.transactionHash}`
  );
};

// Call send function
send();
    ```

To run the script, you can run the following command in your terminal:

```bash
node transaction.js
```

If the transaction was successful, in your terminal, you'll see the transaction hash has been printed out.

You can also use the `balances.js` script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:

![Send Tx Web3js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-2.webp)

## Deploy a Contract {: #deploy-a-contract }

The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named `Incrementer.sol`. You can get started by creating a file for the contract:

```
touch Incrementer.sol
```

Next, you can add the Solidity code to the file:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
```

The `constructor` function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (default is 0). The `increment` function adds the `_value` provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the `reset` function resets the stored value to zero.

!!! note
    This contract is a simple example for illustration purposes only.

### Compile Contract Script {: #compile-contract-script }

In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the `Incrementer.sol` contract. To get started, you can create a `compile.js` file by running:

```
touch compile.js
```

Next, you will create the script for this file and complete the following steps:

1. Import the `fs` and `solc` packages
2. Using the `fs.readFileSync` function, you'll read and save the file contents of `Incrementer.sol` to `source`
3. Build the `input` object for the Solidity compiler by specifying the `language`, `sources`, and `settings` to be used
4. Using the `input` object, you can compile the contract using `solc.compile`
5. Extract the compiled contract file and export it to be used in the deployment script

```js
// 1. Import packages
import fs from 'fs';
import solc from 'solc';

// 2. Get path and load contract
const source = fs.readFileSync('Incrementer.sol', 'utf8');

// 3. Create input object
const input = {
  language: 'Solidity',
  sources: {
    'Incrementer.sol': {
      content: source,
    },
  },
  settings: {
    outputSelection: {
      '*': {
        '*': ['*'],
      },
    },
  },
};
// 4. Compile the contract
const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));
const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];

// 5. Export contract data
export default contractFile;
```

### Deploy Contract Script {: #deploy-contract-script }

With the script for compiling the `Incrementer.sol` contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called `deploy.js`:

```bash
touch deploy.js
```

Next, you will create the script for this file and complete the following steps:

1. Import the contract file from `compile.js`
2. [Set up the Web3 provider](#setting-up-the-web3-provider)
3. Define the `addressFrom`, including the `privateKey`, and the `addressTo` variables. The private key is required to create a wallet instance. **Note: This is for example purposes only. Never store your private keys in a JavaScript file**
4. Save the `bytecode` and `abi` for the compiled contract
5. Create the asynchronous `deploy` function that will be used to deploy the contract
6. Create the contract instance using the `web3.eth.Contract` function
7. Create the constructor and pass in the `bytecode` and the initial value for the incrementer. For this example, you can set the initial value to `5`
8. Create and sign the transaction using the `web3.eth.accounts.signTransaction` function. Pass in the `data` and the `gas` for the transaction along with the sender's `privateKey`
9. Send the signed transaction using the `web3.eth.sendSignedTransaction` method and pass in the raw transaction. Then use `await` to wait until the transaction is processed and the transaction receipt is returned
10. Lastly, run the `deploy` function

```js
// 1. Import the contract file
const contractFile = require('./compile');

// 2. Add the Web3 provider logic here:
// {...}

// 3. Create address variables
const accountFrom = {
  privateKey: 'INSERT_PRIVATE_KEY',
  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',
};

// 4. Get the bytecode and API
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// 5. Create deploy function
const deploy = async () => {
  console.log(`Attempting to deploy from account ${accountFrom.address}`);

  // 6. Create contract instance
  const incrementer = new web3.eth.Contract(abi);

  // 7. Create constructor tx
  const incrementerTx = incrementer.deploy({
    data: bytecode,
    arguments: [5],
  });

  // 8. Sign transacation and send
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      data: incrementerTx.encodeABI(),
      gas: await incrementerTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // 9. Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);
};

// 10. Call deploy function
deploy();
```

??? code "View the complete script"

    ```js
    // Import web3 and the contract file
const Web3 = require('web3');
const contractFile = require('./compile');

// Add the Web3 provider logic here
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create address variables
const accountFrom = {
  privateKey: 'INSERT_PRIVATE_KEY',
  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',
};

// Get the bytecode and API
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// Create deploy function
const deploy = async () => {
  console.log(`Attempting to deploy from account ${accountFrom.address}`);

  // Create contract instance
  const incrementer = new web3.eth.Contract(abi);

  // Create constructor tx with initial value of 5
  const incrementerTx = incrementer.deploy({
    data: bytecode,
    arguments: [5],
  });

  // Sign transacation and send
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      data: incrementerTx.encodeABI(),
      gas: await incrementerTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);
};

// Call deploy function
deploy();
    ```

To run the script, you can enter the following command into your terminal:

```bash
node deploy.js
```

If successful, the contract's address will be displayed in the terminal.

![Deploy Contract Web3js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-3.webp)

### Read Contract Data (Call Methods) {: #read-contract-data }

Call methods are the type of interactions that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.

To get started, you can create a file and name it `get.js`:

```bash
touch get.js
```

Then you can take the following steps to create the script:

1. Import the `abi` from the `compile.js` file
2. [Set up the Web3 provider](#setting-up-the-web3-provider)
3. Create the `contractAddress` variable using the address of the deployed contract
4. Create an instance of the contract using the `web3.eth.Contract` function and passing in the `abi` and `contractAddress`
5. Create the asynchronous `get` function
6. Use the contract instance to call one of the contract's methods and pass in any inputs if necessary. For this example, you will call the `number` method, which doesn't require any inputs. You can use `await`, which will return the value requested once the request promise resolves
7. Lastly, call the `get` function

```js
// 1. Import the contract abi
const { abi } = require('./compile');

// 2. Add the Web3 provider logic here:
// {...}

// 3. Create address variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// 4. Create contract instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// 5. Create get function
const get = async () => {
  console.log(`Making a call to contract at address: ${contractAddress}`);

  // 6. Call contract
  const data = await incrementer.methods.number().call();

  console.log(`The current number stored is: ${data}`);
};

// 7. Call get function
get();
```

??? code "View the complete script"

    ```js
    // Import web3 and the contract file
const Web3 = require('web3');
const { abi } = require('./compile');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create address variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// Create contract instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// Create get function
const get = async () => {
  console.log(`Making a call to contract at address: ${contractAddress}`);

  // Call contract
  const data = await incrementer.methods.number().call();

  console.log(`The current number stored is: ${data}`);
};

// Call get function
get();
    ```

To run the script, you can enter the following command in your terminal:

```bash
node get.js
```

If successful, the value will be displayed in the terminal.

![Get contract variable value Web3js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-4.webp)

### Interact with Contract (Send Methods) {: #interact-with-contract }

Send methods are the type of interactions that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them `increment.js` and `reset.js`:

```bash
touch increment.js reset.js
```

Open the `increment.js` file and take the following steps to create the script:

1. Import the `abi` from the `compile.js` file
2. [Set up the Web3 provider](#setting-up-the-web3-provider)
3. Define the `privateKey` for the origin account, the `contractAddress` of the deployed contract, and the `_value` to increment by. The private key is required to create a wallet instance. **Note: This is for example purposes only. Never store your private keys in a JavaScript file**
4. Create an instance of the contract using the `web3.eth.Contract` function and passing in the `abi` and `contractAddress`
5. Use the contract instance to build the increment transaction using the `methods.increment` function and passing in the `_value` as an input
6. Create the asynchronous `increment` function
7. Use the contract instance and the increment transaction you previously created to sign the transaction with the sender's private key. You'll use the `web3.eth.accounts.signTransaction` function and specify the `to` address, the `data`, and the `gas` for the transaction
8. Send the signed transaction using the `web3.eth.sendSignedTransaction` method and pass in the raw transaction. Then use `await` to wait until the transaction is processed and the transaction receipt is returned
9. Lastly, call the `increment` function

```js
// 1. Import the contract abi
const { abi } = require('./compile');

// 2. Add the Web3 provider logic here:
// {...}

// 3. Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const _value = 3;

// 4. Create contract instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// 5. Build increment tx
const incrementTx = incrementer.methods.increment(_value);

// 6. Create increment function
const increment = async () => {
  console.log(
    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
  );

  // 7. Sign Tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data: incrementTx.encodeABI(),
      gas: await incrementTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // 8. Send Tx and Wait for Receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);
};

// 9. Call increment function
increment();
```

??? code "View the complete script"

    ```js
    // Import Web3 and the contract abi
const Web3 = require('web3');
const { abi } = require('./compile');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const _value = 3;

// Create contract instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// Build increment tx
const incrementTx = incrementer.methods.increment(_value);

// Create increment function
const increment = async () => {
  console.log(
    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
  );

  // Sign Tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data: incrementTx.encodeABI(),
      gas: await incrementTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // Send Tx and Wait for Receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);
};

// Call increment function
increment();
    ```

To run the script, you can enter the following command in your terminal:

```bash
node increment.js
```

If successful, the transaction hash will be displayed in the terminal. You can use the `get.js` script alongside the `increment.js` script to make sure that the value is changing as expected.

![Increment and check value Web3js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-5.webp)

Next you can open the `reset.js` file and take the following steps to create the script:

1. Import the `abi` from the `compile.js` file
2. [Set up the Web3 provider](#setting-up-the-web3-provider)
3. Define the `privateKey` for the origin account and the `contractAddress` of the deployed contract. The private key is required to create a wallet instance. **Note: This is for example purposes only. Never store your private keys in a JavaScript file**
4. Create an instance of the contract using the `web3.eth.Contract` function and passing in the `abi` and `contractAddress`
5. Use the contract instance to build the reset transaction using the `methods.reset` function
6. Create the asynchronous `reset` function
7. Use the contract instance and the reset transaction you previously created to sign the transaction with the sender's private key. You'll use the `web3.eth.accounts.signTransaction` function and specify the `to` address, the `data`, and the `gas` for the transaction
8. Send the signed transaction using the `web3.eth.sendSignedTransaction` method and pass in the raw transaction. Then use `await` to wait until the transaction is processed and the transaction receipt is returned
9. Lastly, call the `reset` function

```js
// 1. Import the contract abi
const { abi } = require('./compile');

// 2. Add the Web3 provider logic here:
// {...}

// 3. Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// 4. Create Contract Instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// 5. Build reset tx
const resetTx = incrementer.methods.reset();

// 6. Create reset function
const reset = async () => {
  console.log(
    `Calling the reset function in contract at address: ${contractAddress}`
  );

  // 7. Sign tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data: resetTx.encodeABI(),
      gas: await resetTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // 8. Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);
};

// 9. Call reset function
reset();
```

??? code "View the complete script"

    ```js
    // Import Web3 and the contract abi
const Web3 = require('web3');
const { abi } = require('./compile');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// Create Contract Instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// Build reset tx
const resetTx = incrementer.methods.reset();

// Create reset function
const reset = async () => {
  console.log(
    `Calling the reset function in contract at address: ${contractAddress}`
  );

  // Sign tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data: resetTx.encodeABI(),
      gas: await resetTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);
};

// Call reset function
reset();
    ```

To run the script, you can enter the following command in your terminal:

```bash
node reset.js
```

If successful, the transaction hash will be displayed in the terminal. You can use the `get.js` script alongside the `reset.js` script to make sure that the value is changing as expected.

![Reset contract Web3js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-6.webp)

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/libraries/web3py/
--- BEGIN CONTENT ---
---
title: EVM Transactions & Contracts with Web3.py
description: Learn how to use the Ethereum Web3 Python Library to send transactions and deploy Solidity smart contracts to your Tanssi-powered Ethereum compatible network.
icon: octicons-code-24
categories: EVM-Template
---

# Web3.py Python Library

## Introduction {: #introduction }

[Web3.py](https://web3py.readthedocs.io/en/stable/){target=\_blank} is a set of libraries that allow developers to interact with Ethereum nodes using HTTP, IPC, or WebSocket protocols with Python. Tanssi EVM networks have an Ethereum-like API available that is fully compatible with Ethereum-style JSON RPC invocations. Therefore, developers can leverage this compatibility and use the Ethers.js library to interact with a Tanssi EVM network node as if they were doing so on Ethereum. For more information on Web3.py, check their [documentation site](https://web3py.readthedocs.io/en/stable/){target=\_blank}.

In this guide, you'll learn how to use setup the Web3.py library for your Tanssi-powered EVM network. Next, to showcase the library in action, you'll use Web3.py to send a transaction and deploy a contract on a Tanssi demo EVM appchain running on [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}. This guide can be adapted for your own Tanssi EVM appchain by simply changing the endpoint.

!!! note
    The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.
    
    Furthermore, please ensure that you have Python3 and a package manager like pip installed.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - An account with funds in the Tanssi EVM network you are testing with

## Installing Web3.py {: #install-web3py }

For this guide, you'll need to install the Web3.py library and the Solidity compiler. To install both packages, you can run the following command:

```bash
pip3 install web3 py-solc-x
```

## Setting up the Web3.py Provider {: #setting-up-the-web3py-provider }

Throughout this guide, you'll be creating a bunch of scripts that provide different functionality such as sending a transaction, deploying a contract, and interacting with a deployed contract. In most of these scripts you'll need to create an [Web3.py provider](https://web3py.readthedocs.io/en/stable/providers.html){target=\_blank} to interact with the network.

To create a provider, you can take the following steps:

1. Import the `web3` library
2. Create the `web3` provider suing using the `Web3(Web3.HTTPProvider()))` method and providing the Tanssi EVM network URL

```python
# 1. Import web3.py
from web3 import Web3

# 2. Create web3.py provider
# Insert your RPC URL here
web3 = Web3(Web3.HTTPProvider('{{ networks.dancelight.demo_evm_rpc_url }}')) 
```

Save this code snippet, as you'll need it for the scripts that are used in the following sections.

## Send a Transaction {: #send-a-transaction }

During this section, you'll be creating a couple of scripts. The first one will be to check the balances of your accounts before trying to send a transaction. The second script will actually send the transaction.

You can also use the balance script to check the account balances after the transaction has been sent.

### Check Balances Script {: #check-balances-script }

You'll only need one file to check the balances of both addresses before and after the transaction is sent.  To get started, you can create a `balances.py` file by running:

``` bash
touch balances.py
```

Next, you will create the script for this file and complete the following steps:

1. [Set up the Web3 provider](#setting-up-the-web3py-provider)
2. Define the `address_from` and `address_to` variables
3. Get the balance for the accounts using the `web3.eth.get_balance` function and format the results using the `web3.from_wei`

```python
# 1. Import web3.py
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 2. Create address variables
address_from = "INSERT_ADDRESS_FROM"
address_to = "INSERT_ADDRESS_TO"

# 4. Fetch balance data
balance_from = web3.from_wei(
    web3.eth.get_balance(Web3.to_checksum_address(address_from)), "ether"
)
balance_to = web3.from_wei(
    web3.eth.get_balance(Web3.to_checksum_address(address_to)), "ether"
)

print(f"The balance of { address_from } is: { balance_from } TANGO")
print(f"The balance of { address_to } is: { balance_to } TANGO")
```

To run the script and fetch the account balances, you can run the following command:

```bash
python3 balances.py
```

If successful, the balances for the origin and receiving address will be displayed in your terminal in {{ networks.dancelight.demo_evm_token_symbol }}.

![Check Balance Ethers.js](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-1.webp)


### Send Transaction Script {: #send-transaction-script }

You'll only need one file for executing a transaction between accounts. For this example, you'll be transferring 1 DEV token from an origin address (from which you hold the private key) to another address. To get started, you can create a `transaction.py` file by running:

```bash
touch transaction.py
```

Next, you will create the script for this file and complete the following steps:

1. Add imports, including Web3.py and the `rpc_gas_price_strategy`, which will be used in the following steps to get the gas price used for the transaction
2. [Set up the Web3 provider](#setting-up-the-web3py-provider)
3. Define the `account_from`, including the `private_key`, and the `address_to` variables. The private key is required to sign the transaction. **Note: This is for example purposes only. Never store your private keys in a Python file**
4. Use the [Web3.py Gas Price API](https://web3py.readthedocs.io/en/stable/gas_price.html){target=\_blank} to set a gas price strategy. For this example, you'll use the imported `rpc_gas_price_strategy`
5. Create and sign the transaction using the `web3.eth.account.sign_transaction` function. Pass in the `nonce` `gas`, `gasPrice`, `to`, and `value` for the transaction along with the sender's `private_key`. To get the `nonce` you can use the `web3.eth.get_transaction_count` function and pass in the sender's address. To predetermine the `gasPrice` you'll use the `web3.eth.generate_gas_price` function. For the `value`, you can format the amount to send from an easily readable format to Wei using the `web3.to_wei` function
6. Using the signed transaction, you can then send it using the `web3.eth.send_raw_transaction` function and wait for the transaction receipt by using the `web3.eth.wait_for_transaction_receipt` function

```python
# 1. Add imports
from web3 import Web3
from web3.gas_strategies.rpc import rpc_gas_price_strategy

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create address variables
account_from = {
    "private_key": "INSERT_ YOUR_PRIVATE_KEY",
    "address": "INSERT_ PUBLIC_ADDRESS_OF_PK",
}
address_to = "INSERT_ ADDRESS_TO"

print(
    f'Attempting to send transaction from { account_from["address"] } to { address_to }'
)

# 4. Set the gas price strategy
web3.eth.set_gas_price_strategy(rpc_gas_price_strategy)

# 5. Sign tx with PK
tx_create = web3.eth.account.sign_transaction(
    {
        "nonce": web3.eth.get_transaction_count(
            Web3.to_checksum_address(account_from["address"])
        ),
        "gasPrice": web3.eth.generate_gas_price(),
        "gas": 21000,
        "to": Web3.to_checksum_address(address_to),
        "value": web3.to_wei("1", "ether"),
    },
    account_from["private_key"],
)

# 6. Send tx and wait for receipt
tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Transaction successful with hash: { tx_receipt.transactionHash.hex() }")
```

To run the script, you can run the following command in your terminal:

```bash
python3 transaction.py
```

 If the transaction was successful, in your terminal you'll see the transaction hash has been printed out.

You can also use the `balances.py` script to check that the balances for the origin and receiving accounts have changed. The entire workflow would look like this:

![Send Tx Web3.py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-2.webp)

## Deploy a Contract {: #deploy-a-contract }

The contract you'll be compiling and deploying in the next couple of sections is a simple incrementer contract, arbitrarily named `Incrementer.sol`. You can get started by creating a file for the contract:

```
touch Incrementer.sol
```

Next, you can add the Solidity code to the file:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
```

The `constructor` function, which runs when the contract is deployed, sets the initial value of the number variable stored on-chain (default is 0). The `increment` function adds the `_value` provided to the current number, but a transaction needs to be sent, which modifies the stored data. Lastly, the `reset` function resets the stored value to zero.

!!! note
    This contract is a simple example for illustration purposes only.

### Compile Contract Script {: #compile-contract-script }

In this section, you'll create a script that uses the Solidity compiler to output the bytecode and interface (ABI) for the `Incrementer.sol` contract. To get started, you can create a `compile.py` file by running:

```bash
touch compile.py
```

Next, you will create the script for this file and complete the following steps:

1. Import the `solcx` package
2. **Optional** - If you haven't already installed the Solidity compiler, you can do so with by using the `solcx.install_solc` function
3. Compile the `Incrementer.sol` function using the `solcx.compile_files` function
4. Export the contract's ABI and bytecode

```python
# 1. Import solcx
import solcx

# 2. If you haven't already installed the Solidity compiler, uncomment the following line
# solcx.install_solc()

# 3. Compile contract
temp_file = solcx.compile_files(
    "Incrementer.sol",
    output_values=["abi", "bin"],
    # solc_version='0.8.19'
)

# 4. Export contract data
abi = temp_file["Incrementer.sol:Incrementer"]["abi"]
bytecode = temp_file["Incrementer.sol:Incrementer"]["bin"]
```

!!! note
    If you see an error stating that `Solc is not installed`, uncomment the step 2 described in the code snippet.

### Deploy Contract Script {: #deploy-contract-script }

With the script for compiling the `Incrementer.sol` contract in place, you can then use the results to send a signed transaction that deploys it. To do so, you can create a file for the deployment script called `deploy.py`:

```bash
touch deploy.py
```

Next, you will create the script for this file and complete the following steps:

1. Add imports, including Web3.py and the ABI and bytecode of the `Incrementer.sol` contract
2. [Set up the Web3 provider](#setting-up-the-web3py-provider)
3. Define the `account_from`, including the `private_key`. The private key is required to sign the transaction. **Note: This is for example purposes only. Never store your private keys in a Python file**
4. Create a contract instance using the `web3.eth.contract` function and passing in the ABI and bytecode of the contract
5. Build a constructor transaction using the contract instance and passing in the value to increment by. For this example, you can use `5`. You'll then use the `build_transaction` function to pass in the transaction information including the `from` address and the `nonce` for the sender. To get the `nonce` you can use the `web3.eth.get_transaction_count` function
6. Sign the transaction using the `web3.eth.account.sign_transaction` function and pass in the constructor transaction and the `private_key` of the sender
7. Using the signed transaction, you can then send it using the `web3.eth.send_raw_transaction` function and wait for the transaction receipt by using the `web3.eth.wait_for_transaction_receipt` function

```python
# 1. Add imports
from compile import abi, bytecode
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create address variable
account_from = {
    "private_key": "INSERT_YOUR_PRIVATE_KEY",
    "address": "INSERT_PUBLIC_ADDRESS_OF_PK",
}

print(f'Attempting to deploy from account: { account_from["address"] }')

# 4. Create contract instance
Incrementer = web3.eth.contract(abi=abi, bytecode=bytecode)

# 5. Build constructor tx
construct_txn = Incrementer.constructor(5).build_transaction(
    {
        "from": Web3.to_checksum_address(account_from["address"]),
        "nonce": web3.eth.get_transaction_count(
            Web3.to_checksum_address(account_from["address"])
        ),
    }
)

# 6. Sign tx with PK
tx_create = web3.eth.account.sign_transaction(
    construct_txn, account_from["private_key"]
)

# 7. Send tx and wait for receipt
tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Contract deployed at address: { tx_receipt.contractAddress }")
```

To run the script, you can enter the following command into your terminal:

```bash
python3 deploy.py
```

If successful, the contract's address will be displayed in the terminal.

![Deploy Contract Web3py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-3.webp)

### Read Contract Data (Call Methods) {: #read-contract-data }

Call methods are the type of interaction that don't modify the contract's storage (change variables), meaning no transaction needs to be sent. They simply read various storage variables of the deployed contract.

To get started, you can create a file and name it `get.py`:

```bash
touch get.py
```

Then you can take the following steps to create the script:

1. Add imports, including Web3.py and the ABI of the `Incrementer.sol` contract
2. [Set up the Web3 provider](#setting-up-the-web3py-provider)
3. Define the `contract_address` of the deployed contract
4. Create a contract instance using the `web3.eth.contract` function and passing in the ABI and address of the deployed contract
5. Using the contract instance, you can then call the `number` function

```python
# 1. Import the ABI
from compile import abi
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create address variable
contract_address = "INSERT_CONTRACT_ADDRESS"

print(f"Making a call to contract at address: { contract_address }")

# 4. Create contract instance
Incrementer = web3.eth.contract(address=contract_address, abi=abi)

# 5. Call Contract
number = Incrementer.functions.number().call()
print(f"The current number stored is: { number } ")
```

To run the script, you can enter the following command in your terminal:

```bash
python3 get.py
```

If successful, the value will be displayed in the terminal.

![Read from Contract Web3py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-4.webp)

### Interact with Contract (Send Methods) {: #interact-with-contract }

Send methods are the type of interaction that modify the contract's storage (change variables), meaning a transaction needs to be signed and sent. In this section, you'll create two scripts: one to increment and one to reset the incrementer. To get started, you can create a file for each script and name them `increment.py` and `reset.py`:

```bash
touch increment.py reset.py
```

Open the `increment.py` file and take the following steps to create the script:

1. Add imports, including Web3.py and the ABI of the `Incrementer.sol` contract
2. [Set up the Web3 provider](#setting-up-the-web3py-provider)
3. Define the `account_from`, including the `private_key`, the `contract_address` of the deployed contract, and the `value` to increment by. The private key is required to sign the transaction. **Note: This is for example purposes only. Never store your private keys in a Python file**
4. Create a contract instance using the `web3.eth.contract` function and passing in the ABI and address of the deployed contract
5. Build the increment transaction using the contract instance and passing in the value to increment by. You'll then use the `build_transaction` function to pass in the transaction information including the `from` address and the `nonce` for the sender. To get the `nonce` you can use the `web3.eth.get_transaction_count` function
6. Sign the transaction using the `web3.eth.account.sign_transaction` function and pass in the increment transaction and the `private_key` of the sender
7. Using the signed transaction, you can then send it using the `web3.eth.send_raw_transaction` function and wait for the transaction receipt by using the `web3.eth.wait_for_transaction_receipt` function

```python
# 1. Add imports
from compile import abi
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create variables
account_from = {
    "private_key": "INSERT_YOUR_PRIVATE_KEY",
    "address": "INSERT_PUBLIC_ADDRESS_OF_PK",
}
contract_address = "INSERT_CONTRACT_ADDRESS"
value = 3

print(
    f"Calling the increment by { value } function in contract at address: { contract_address }"
)

# 4. Create contract instance
Incrementer = web3.eth.contract(address=contract_address, abi=abi)

# 5. Build increment tx
increment_tx = Incrementer.functions.increment(value).build_transaction(
    {
        "from": Web3.to_checksum_address(account_from["address"]),
        "nonce": web3.eth.get_transaction_count(
            Web3.to_checksum_address(account_from["address"])
        ),
    }
)

# 6. Sign tx with PK
tx_create = web3.eth.account.sign_transaction(increment_tx, account_from["private_key"])

# 7. Send tx and wait for receipt
tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Tx successful with hash: { tx_receipt.transactionHash.hex() }")
```

To run the script, you can enter the following command in your terminal:

```bash
python3 increment.py
```

If successful, the transaction hash will be displayed in the terminal. You can use the `get.py` script alongside the `increment.py` script to make sure that value is changing as expected:

![Increment Contract Web3py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-5.webp)

Next you can open the `reset.py` file and take the following steps to create the script:

1. Add imports, including Web3.py and the ABI of the `Incrementer.sol` contract
2. [Set up the Web3 provider](#setting-up-the-web3py-provider)
3. Define the `account_from`, including the `private_key`, and the `contract_address` of the deployed contract. The private key is required to sign the transaction. **Note: This is for example purposes only. Never store your private keys in a Python file**
4. Create a contract instance using the `web3.eth.contract` function and passing in the ABI and address of the deployed contract
5. Build the reset transaction using the contract instance. You'll then use the `build_transaction` function to pass in the transaction information including the `from` address and the `nonce` for the sender. To get the `nonce` you can use the `web3.eth.get_transaction_count` function
6. Sign the transaction using the `web3.eth.account.sign_transaction` function and pass in the reset transaction and the `private_key` of the sender
7. Using the signed transaction, you can then send it using the `web3.eth.send_raw_transaction` function and wait for the transaction receipt by using the `web3.eth.wait_for_transaction_receipt` function

```python
# 1. Add imports
from compile import abi
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create variables
account_from = {
    "private_key": "INSERT_YOUR_PRIVATE_KEY",
    "address": "INSERT_PUBLIC_ADDRESS_OF_PK",
}
contract_address = "INSERT_CONTRACT_ADDRESS"

print(f"Calling the reset function in contract at address: { contract_address }")

# 4. Create contract instance
Incrementer = web3.eth.contract(address=contract_address, abi=abi)

# 5. Build reset tx
reset_tx = Incrementer.functions.reset().build_transaction(
    {
        "from": Web3.to_checksum_address(account_from["address"]),
        "nonce": web3.eth.get_transaction_count(
            Web3.to_checksum_address(account_from["address"])
        ),
    }
)

# 6. Sign tx with PK
tx_create = web3.eth.account.sign_transaction(reset_tx, account_from["private_key"])

# 7. Send tx and wait for receipt
tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Tx successful with hash: { tx_receipt.transactionHash.hex() }")
```

To run the script, you can enter the following command in your terminal:

```bash
python3 reset.py
```

If successful, the transaction hash will be displayed in the terminal. You can use the `get.py` script alongside the `reset.py` script to make sure that value is changing as expected:

![Reset Contract Web3py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-6.webp)

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/precompiles/batch/
--- BEGIN CONTENT ---
---
title: Batch Precompile
description: Learn how to combine multiple transfers and contract interactions together via a Solidity interface with Tanssi's Batch Precompile for your EVM network.
keywords: solidity, ethereum, batch, transaction, moonbeam, precompiled, contracts
icon: octicons-stack-24
categories: EVM-Template
---

# Interacting with the Batch Precompile

## Introduction {: #introduction }

The Batch Precompile contract on Tanssi-powered EVM networks allows developers to combine multiple EVM calls into one.

Currently, having users interact with multiple contracts would require multiple transaction confirmations in the user's wallet. An example would be approving a smart contract's access to a token and then immediately transferring it. With the Batch Precompile, developers can enhance user experience with batched transactions as it minimizes the number of transactions a user is required to confirm. Additionally, the gas fees paid by a user can be reduced since batching avoids multiple base gas fees (the initial 21000 units of gas spent to begin a transaction).

The precompile interacts directly with [Substrate's EVM pallet](https://polkadot-evm.github.io/frontier){target=\_blank}. The caller of the batch function will have their address act as the `msg.sender` for all subtransactions, but unlike [delegate calls](https://docs.soliditylang.org/en/v0.8.15/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries){target=\_blank}, the target contract will still affect its own storage. It is effectively the same as if the user signed multiple transactions but with only one confirmation.

The Batch Precompile is located at the following address:

```text
{{ networks.demo_evm.precompiles.batch }}
```

!!! note
    There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with [Moonbeam's Precompile Security Considerations](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## The Batch Solidity Interface {: #the-batch-interface }

[`Batch.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/Batch.sol){target=\_blank} is a Solidity interface that allows developers to interact with the precompile's three methods.

??? code "Batch.sol"

    ```solidity
    // SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The Batch contract's address.
address constant BATCH_ADDRESS = 0x0000000000000000000000000000000000000801;

/// @dev The Batch contract's instance.
Batch constant BATCH_CONTRACT = Batch(BATCH_ADDRESS);

/// @author The Moonbeam Team
/// @title Batch precompile
/// @dev Allows to perform multiple calls throught one call to the precompile.
/// Can be used by EOA to do multiple calls in a single transaction.
/// @custom:address 0x0000000000000000000000000000000000000801
interface Batch {
    /// @dev Batch multiple calls into a single transaction.
    /// All calls are performed from the address calling this precompile.
    ///
    /// In case of one subcall reverting following subcalls will still be attempted.
    ///
    /// @param to List of addresses to call.
    /// @param value List of values for each subcall. If array is shorter than "to" then additional
    /// calls will be performed with a value of 0.
    /// @param callData Call data for each `to` address. If array is shorter than "to" then
    /// additional calls will be performed with an empty call data.
    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.
    /// If array is shorter than "to" then the remaining gas available will be used.
    /// @custom:selector 79df4b9c
    function batchSome(
        address[] memory to,
        uint256[] memory value,
        bytes[] memory callData,
        uint64[] memory gasLimit
    ) external;

    /// @dev Batch multiple calls into a single transaction.
    /// All calls are performed from the address calling this precompile.
    ///
    /// In case of one subcall reverting, no more subcalls will be executed but
    /// the batch transaction will succeed. Use batchAll to revert on any subcall revert.
    ///
    /// @param to List of addresses to call.
    /// @param value List of values for each subcall. If array is shorter than "to" then additional
    /// calls will be performed with a value of 0.
    /// @param callData Call data for each `to` address. If array is shorter than "to" then
    /// additional calls will be performed with an empty call data.
    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.
    /// If array is shorter than "to" then the remaining gas available will be used.
    /// @custom:selector cf0491c7
    function batchSomeUntilFailure(
        address[] memory to,
        uint256[] memory value,
        bytes[] memory callData,
        uint64[] memory gasLimit
    ) external;

    /// @dev Batch multiple calls into a single transaction.
    /// All calls are performed from the address calling this precompile.
    ///
    /// In case of one subcall reverting, the entire batch will revert.
    ///
    /// @param to List of addresses to call.
    /// @param value List of values for each subcall. If array is shorter than "to" then additional
    /// calls will be performed with a value of 0.
    /// @param callData Call data for each `to` address. If array is shorter than "to" then
    /// additional calls will be performed with an empty call data.
    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.
    /// If array is shorter than "to" then the remaining gas available will be used.
    /// @custom:selector 96e292b8
    function batchAll(
        address[] memory to,
        uint256[] memory value,
        bytes[] memory callData,
        uint64[] memory gasLimit
    ) external;

    /// Emitted when a subcall succeeds.
    event SubcallSucceeded(uint256 index);

    /// Emitted when a subcall fails.
    event SubcallFailed(uint256 index);
}
    ```

The interface includes the following functions:

???+ function "**batchSome**(*address[]* to, *uint256[]* value, *bytes[]* callData, *uint64[]* gasLimit) â€” performs multiple calls, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, following subcalls will still be attempted"

    === "Parameters"

        - `to` - an array of addresses to direct subtransactions to, where each entry is a subtransaction
        - `value` - an array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. If this array is shorter than the *to* array, all the following subtransactions will default to a value of 0
        - `callData` - an array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. If this array is shorter than the *to* array, all of the following subtransactions will include no call data
        - `gasLimit` - an array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the *to* array, all of the following subtransactions will have all remaining gas forwarded

??? function "**batchSomeUntilFailure**(*address[]* to, *uint256[]* value, *bytes[]* callData, *uint64[]* gasLimit) â€” performs multiple calls, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, no following subcalls will be executed"

    === "Parameters"

        - `to` - an array of addresses to direct subtransactions to, where each entry is a subtransaction
        - `value` - an array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. If this array is shorter than the *to* array, all the following subtransactions will default to a value of 0
        - `callData` - an array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. If this array is shorter than the *to* array, all of the following subtransactions will include no call data
        - `gasLimit` - an array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the *to* array, all of the following subtransactions will have all remaining gas forwarded

??? function "**batchAll**(*address[]* to, *uint256[]* value, *bytes[]* callData, *uint64[]* gasLimit) â€” performs multiple calls atomically, where the same index of each array combine into the information required for a single subcall. If a subcall reverts, all subcalls will revert"

    === "Parameters"

        - `to` - an array of addresses to direct subtransactions to, where each entry is a subtransaction
        - `value` - an array of native currency values to send in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. If this array is shorter than the *to* array, all the following subtransactions will default to a value of 0
        - `callData` - an array of call data to include in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. If this array is shorter than the *to* array, all of the following subtransactions will include no call data
        - `gasLimit` - an array of gas limits in the subtransactions, where the index corresponds to the subtransaction of the same index in the *to* array. Values of 0 are interpreted as unlimited and will have all remaining gas of the batch transaction forwarded. If this array is shorter than the *to* array, all of the following subtransactions will have all remaining gas forwarded

The interface also includes the following required events:

- **SubcallSucceeded**(*uint256* index) - emitted when a subcall of the given index succeeds
- **SubcallFailed**(*uint256* index) - emitted when a subcall of the given index fails

## Interact with the Solidity Interface {: #interact-with-the-solidity-interface }

### Checking Prerequisites {: #checking-prerequisites }

To follow along with this tutorial, you will need to have your wallet configured to work with your EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}. Or, you [configure MetaMask for Tanssi with the demo EVM network](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

### Example Contract {: #example-contract}

The contract `SimpleContract.sol` will be used as an example of batching contract interactions, but in practice, any contract can be interacted with.

```solidity
// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.0;

contract SimpleContract {
    mapping(uint256 => string) public messages;

    function setMessage(uint256 id, string calldata message) external {
        messages[id] = message;
    }
}
```

### Remix Set Up {: #remix-set-up }

You can interact with the Batch Precompile using [Remix](https://remix.ethereum.org){target=\_blank}. You'll need a copy of [`Batch.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/Batch.sol){target=\_blank} and `SimpleContract.sol`. To add the precompile to Remix and follow along with the tutorial, you will need to:

1. Click on the **File explorer** tab
2. Paste the `Batch.sol` contract into a Remix file named **Batch.sol**
3. Paste the `SimpleContract.sol` contract into a Remix file named **SimpleContract.sol**

### Compile the Contract {: #compile-the-contract }

Next, you will need to compile both files in Remix:

1. Make sure that you have the **Batch.sol** file open
2. Click on the **Compile** tab, second from top
3. To compile the contract, click on **Compile Batch.sol**

![Compiling Batch.sol](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-1.webp)

If the interface was compiled successfully, you will see a green checkmark next to the **Compile** tab.

### Access the Precompile {: #access-the-precompile }

Instead of deploying the Batch Precompile, you will access the interface given the address of the precompiled contract:

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix. Please note that the precompiled contract is already deployed
2. Make sure **Injected Provider - MetaMask** is selected in the **ENVIRONMENT** dropdown. Once you select **Injected Provider - MetaMask**, you might be prompted by MetaMask to connect your account to Remix
3. Make sure the correct account is displayed under **ACCOUNT**
4. Ensure **Batch.sol** is selected in the **CONTRACT** dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead, we are going to provide the address of the precompile in the **At Address** field
5. Provide the address of the Batch Precompile: `{{networks.demo_evm.precompiles.batch}}` and click **At Address**

![Access the address](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-2.webp)

The **BATCH** precompile will appear in the list of **Deployed Contracts**.

### Deploy Example Contract {: #deploy-example-contract }

On the other hand, `SimpleContract.sol` will be deployed as a new contract. Before starting this section, repeat the [compilation step](#compile-the-contract) with the `SimpleContract.sol` file.

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix
2. Make sure **Injected Provider - MetaMask** is selected in the **ENVIRONMENT** dropdown. Once you select **Injected Provider - MetaMask**, you might be prompted by MetaMask to connect your account to Remix
3. Make sure the correct account is displayed under **ACCOUNT**
4. Ensure **SimpleContract** is selected in the **CONTRACT** dropdown
5. Click **Deploy**
6. Confirm the MetaMask transaction that appears by clicking **Confirm**

![Deploy SimpleContract](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-3.webp)

The **SIMPLECONTRACT** contract will appear in the list of **Deployed Contracts**.

### Send Native Currency via Precompile {: #send-native-currency-via-precompile }

Sending native currency with the Batch Precompile involves more than pressing a few buttons in Remix or MetaMask. For this example, you will be using the **batchAll** function to send native currency atomically.

Transactions have a value field to specify the amount of native currency sent. In Remix, this is determined by the **VALUE** input in the **DEPLOY & RUN TRANSACTIONS** tab. However, for the Batch Precompile, this data is provided within the **value** array input of the batch functions.

Try transferring the native token of your network to two wallets of your choice via the Batch Precompile:

1. Expand the batch contract under **Deployed Contracts**
2. Expand the **batchAll** function
3. For the **to** input, insert your addresses in the following format: `["INSERT_ADDRESS_1", "INSERT_ADDRESS_2"]`, where the first address corresponds to the first wallet of your choice and the second address corresponds to the second wallet of your choice
4. For the **value** input, insert the amount you wish to transfer in Wei for each address. For example, `["1000000000000000000", "2000000000000000000"]` will transfer 1 native token to the first address and 2 native tokens to the second address
5. For **callData**, insert `[]`. Call data is not relevant for simply transferring the native token
6. For the **gasLimit** inputs, insert `[]`
7. Press **transact**
8. Press **Confirm** in the MetaMask extension to confirm the transaction

![Send Batch Transfer](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-4.webp)

Once the transaction is complete, you can check both of the accounts' balances, either in MetaMask or in your network's block explorer, a link to which can be found on the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}. Congratulations! You've now sent a batched transfer via the Batch Precompile.

!!! note
     Typically if you wanted to send the native currency to or through a contract, you would have to set the value within the overall transaction object and interact with a payable function. However, since the Batch Precompile interacts directly with Substrate code, this is not a typical Ethereum transaction and is thus not necessary.

### Find a Contract Interaction's Call Data {: #find-a-contract-interactions-call-data }

Visual interfaces like [Remix](/builders/toolkit/ethereum-api/dev-env/remix/){target=\_blank} and handy libraries like [Ethers.js](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank} hide the way that Ethereum transactions interact with Solidity smart contracts. The name and input types of a function are hashed into a [function selector](https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector-and-argument-encoding){target=\_blank} and the input data is encoded. These two pieces are then combined and sent as the transaction's call data. To send a subtransaction within a batch transaction, the sender needs to know its call data beforehand.

Try finding a transaction's call data using Remix:

1. Expand the `SimpleContract.sol` contract under **Deployed Contracts**
2. Expand the **setMessage** function
3. Enter the desired **id**, such as `1`
4. Enter the desired **message**, such as `"tanssi"`
5. Instead of sending the transaction, click the copy button next to the **transact** button to copy the call data

![Transaction Call Data](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-5.webp)

Now you have the transaction's call data! Considering the example values of `1` and `"tanssi"`, we can keep an eye out for their encoded values in the call data:

```text
0x648345c8                                                        // function selector
0000000000000000000000000000000000000000000000000000000000000001  // 1 id
0000000000000000000000000000000000000000000000000000000000000040  // 32 byte offset
000000000000000000000000000000000000000000000000000000000000000   // 32 byte length
674616e7373690000000000000000000000000000000000000000000000000000 // "tanssi" in bytes
```

The call data can be broken into five lines where:

 - The first line is the function selector
 - The second line is equal to 1, which is the **id** that was provided
 - What's left involves the **message** input. These last three lines are tricky since strings are a [dynamic type](https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#use-of-dynamic-types){target=\_blank} with a dynamic length. The third line refers to an offset to define where the string's data starts. The fourth line refers to the length of the message in the following line, which is 32 bytes total - the "tanssi" message plus padding
 
You can repeat the above steps to capture the call data for values of `2` and `"hello"` such that multiple subcalls can be submitted atomically with the Batch Precompile in the next section. 

### Function Interaction via Precompile {: #function-interaction-via-precompile }

This section's example will be using the **batchAll** function that will ensure the transactions are resolved atomically. Keep in mind that there are also two other batch functions that can either continue subtransactions despite errors or halt subsequent subtransactions but not revert previous ones.

Interacting with a function is very similar to [sending a native currency](#send-native-currency-via-precompile), since they are both transactions. However, call data is required to provide input to functions properly and a sender may desire to limit the amount of gas spent in each subtransaction.

The `callData` and `gasLimit` fields are more relevant for subtransactions that interact with contracts. For each function in the batch interface, the `callData` input is an array where each index corresponds to the call data for each recipient of the subtransaction, that is, each `to` input. If the size of the `callData` array is less than the `to` array, the remaining subtransactions will have no call data (functions with no inputs). The `gasLimit` input is an array that corresponds to the amount of gas that each can spend for each subtransaction. If its value at an index is 0 or the index is the size of the array or greater (and smaller than the `to` array's size), all of the remaining gas from the previous subtransaction is forwarded.

To use the precompile to send an atomic batch transaction combining two contract interactions, take the following steps:

1. Copy the `SimpleContract.sol` contract's address with the copy button on the right side of its header. Be sure also to have the [call data from the previous section](#find-a-contract-interactions-call-data)
2. Expand the batch contract under **Deployed Contracts**
3. Expand the **batchAll** function
4. For the **to** input, paste the address `SimpleContract.sol` as follows: `["INSERT_SIMPLE_CONTRACT_ADDRESS","INSERT_SIMPLE_CONTRACT_ADDRESS"]`. Note that you'll need to repeat the address for as many transactions you are batching together, even if the contract address is the same
5. For the value input, since `SimpleContract.sol` does not require any native currency to be paid to it, insert `[0,0]` for 0 Wei
6. For the **callData** input, insert your call data from the previous section in the following format: `["INSERT_FIRST_CALL_DATA","INSERT_SECOND_CALL_DATA"]`
7. For the **gasLimit** input, insert `[]`. You can put in a gas limit value for each subcall, or leave it as an empty array
8. Press **transact**
9. Press **Confirm** in the MetaMask extension to confirm the transaction

![Batch Function Interaction](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-6.webp)

If you used the same call data as the tutorial, you can check to make sure that the transaction has been successful as follows:

1. Expand the `SimpleContract.sol` contract under **Deployed Contracts**
2. To the right of the **messages** button, insert `1`
3. Press the blue **messages** button

![SimpleContract Confirmation](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-7.webp)

The phrase **"tanssi"** should appear underneath it. You can repeat the above steps with an id of "2", and you should see **"hello"**. Congratulations! You have interacted with a function with the Batch Precompile.

### Combining Subtransactions {: combining-subtransactions }

So far, transferring native currency and interacting with functions have been separate, but they can be intertwined.

The following four strings can be combined as inputs for a batch transaction. They will send 1 native token to the public Gerald (`0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b`) account and interact with a predeployed `SimpleContract.sol` contract twice. Here is a break-down:

There are three subtransactions which correspond to three addresses in the `to` input array. The first is the public Gerald account and the following two are a `SimpleContract.sol` contract. You can replace the last two with your own instance of `SimpleContract.sol` if you wish. Or, replace only one: you can interact with multiple contracts in a single message.

```text
[
  "0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b",
  "0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39", 
  "0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39"
]
```

There will also be three values for the `value` array. The first address in the `to` input array indicates `1000000000000000000` wei or `1` UNIT of the native token. Remember that the native tokens of Tanssi-powered EVM networks have [18 decimal points just like Ethereum](https://eth-converter.com){target=\_blank}. The following two values are `0` because the function that their subtransactions are interacting with does not accept or require native currency.  

```text
["1000000000000000000", "0", "0"]
```

You will need three values for the `callData` array. Since transferring native currency does not require call data, the string is simply blank. The second and third values in the array correspond to invocations of **setMessage** that set messages to IDs 5 and 6.

```text
[
  "0x", 
  "0x648345c8000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000009796f752061726520610000000000000000000000000000000000000000000000", 
  "0x648345c800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000e61206d6f6f6e6265616d2070726f000000000000000000000000000000000000"
]
```

The final input is for `gas_input`. This array will be left empty to forward all remaining gas to each subtransaction.

```text
[]
```

Try sending a batched transaction with these inputs in Remix the same way [you batched a function call](#function-interaction-via-precompile).

And that's it! You've successfully interacted with the ERC-20 precompile using MetaMask and Remix!

## Ethereum Development Libraries {: #ethereum-development-libraries }

If you have followed the [Ethers.js tutorial](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}, you may find it difficult to find the call data for a function. The answer is hidden within Ether's `Interface` object, where the [encodeFunctionData](https://docs.ethers.org/v6/api/abi/#Interface-encodeFunctionData){target=\_blank} function allows you to input your function name and inputs to receive the resultant call data. [Web3.js](/builders/toolkit/ethereum-api/libraries/web3js/){target=\_blank} has a similar function, [encodeFunctionCall](https://web3js.readthedocs.io/en/v1.2.11/web3-eth-abi.html#encodefunctioncall){target=\_blank}.

!!! note
    The code snippets presented in the following sections are not meant for production environments. Please make sure you adapt it for each use case.

=== "Ethers.js"

     ```js
     // Import the contract ABI
const { abi } = require('./INSERT_ABI_PATH');

// Use ABI to create an interface
const yourContractInterface = new ethers.Interface(abi);

// Find call data for the setMessage function
const callData = yourContractInterface.encodeFunctionData(
  'INSERT_FUNCTION_NAME',
  [
    'INSERT_INPUT_1',
    'INSERT_INPUT_2',
    // ...
  ]
);
     ```

=== "Web3.js"

     ```js
     // Import the contract ABI
const { abi } = require('./INSERT_ABI_PATH');

// Find call data for the setMessage function
const callData = web3.eth.abi.encodeFunctionCall(abi, [
  'INSERT_INPUT_1',
  'INSERT_INPUT_2',
  // ...
]);
     ```

=== "Web3.py"

     ```py
     # Import the ABI and bytecode
from compile import abi, bytecode

# Create contract instance
your_contract = web3.eth.contract(abi=abi, bytecode=bytecode)

# Encode the contract call
call_data = your_contract.encodeABI(
    fn_name="INSERT_FUNCTION_NAME", args=["INSERT_INPUT_1", "INSERT_INPUT_2", ...]
)
     ```

Afterwards, you should be all set to interact with the Batch Precompile as one typically would with a contract in [Ethers](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/precompiles/call-permit/
--- BEGIN CONTENT ---
---
title:  Call Permit
description: Learn how to use the Call Permit Precompile on Tanssi EVM networks to sign a permit for any EVM call that can be dispatched by anyone or any smart contract.
keywords: solidity, ethereum, call permit, permit, gasless transaction, moonbeam, precompiled, contracts, tanssi
icon: octicons-arrow-up-right-24
categories: EVM-Template
---

# Interacting with the Call Permit Precompile

## Introduction {: #introduction }

The Call Permit Precompile on Tanssi-powered EVM networks allows a user to sign a permit, an [EIP-712](https://eips.ethereum.org/EIPS/eip-712){target=\_blank} signed message, for any EVM call and it can be dispatched by anyone or any smart contract. It is similar to the Permit Signing of ERC-20 approvals introduced in [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612){target=\_blank}, except it applies to any EVM call instead of only approvals.

When the call permit is dispatched, it is done so on behalf of the user who signed the permit and the user or contract that dispatches the permit is responsible for paying transaction fees. As such, the precompile can be used to perform gas-less transactions.

For example, Alice signs a call permit and Bob dispatches it and performs the call on behalf of Alice. Bob pays for the transaction fees and as such, Alice doesn't need to have any of the native currency to pay for the transaction, unless the call includes a transfer.

The Call Permit Precompile is located at the following address:

```text
{{ networks.demo_evm.precompiles.call_permit }}
```

!!! note
    There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with [Moonbeam's Precompile Security Considerations](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## The Call Permit Solidity Interface {: #the-call-permit-interface }

[`CallPermit.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/CallPermit.sol){target=\_blank} is a Solidity interface that allows developers to interact with the precompile's three methods.

??? code "CallPermit.sol"

    ```solidity
    // SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The CallPermit contract's address.
address constant CALL_PERMIT_ADDRESS = 0x0000000000000000000000000000000000000802;

/// @dev The CallPermit contract's instance.
CallPermit constant CALL_PERMIT_CONTRACT = CallPermit(CALL_PERMIT_ADDRESS);

/// @author The Moonbeam Team
/// @title Call Permit Interface
/// @dev The interface aims to be a general-purpose tool to perform gas-less transactions. It uses the EIP-712 standard,
/// and signed messages can be dispatched by another network participant with a transaction
/// @custom:address 0x0000000000000000000000000000000000000802
interface CallPermit {
    /// @dev Dispatch a call on the behalf of an other user with a EIP712 permit.
    /// Will revert if the permit is not valid or if the dispatched call reverts or errors (such as
    /// out of gas).
    /// If successful the EIP712 nonce is increased to prevent this permit to be replayed.
    /// @param from Who made the permit and want its call to be dispatched on their behalf.
    /// @param to Which address the call is made to.
    /// @param value Value being transferred from the "from" account.
    /// @param data Call data
    /// @param gaslimit Gaslimit the dispatched call requires.
    ///     Providing it prevents the dispatcher to manipulate the gaslimit.
    /// @param deadline Deadline in UNIX seconds after which the permit will no longer be valid.
    /// @param v V part of the signature.
    /// @param r R part of the signature.
    /// @param s S part of the signature.
    /// @return output Output of the call.
    /// @custom:selector b5ea0966
    function dispatch(
        address from,
        address to,
        uint256 value,
        bytes memory data,
        uint64 gaslimit,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (bytes memory output);

    /// @dev Returns the current nonce for given owner.
    /// A permit must have this nonce to be consumed, which will
    /// increase the nonce by one.
    /// @custom:selector 7ecebe00
    function nonces(address owner) external view returns (uint256);

    /// @dev Returns the EIP712 domain separator. It is used to avoid replay
    /// attacks across assets or other similar EIP712 message structures.
    /// @custom:selector 3644e515
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}
    ```

The interface includes the following functions:

???+ function "**dispatch**(*address* from, *address* to, *uint256* value, *bytes* data, *uint64[]* gaslimit, *uint256* deadline, *uint8* v, *bytes32* r, *bytes32* s) â€” dispatches a call on the behalf of another user with a EIP-712 permit. This function can be called by anyone or any smart contract. The transaction will revert if the permit is not valid or if the dispatched call reverts or errors (such as out of gas). If successful, the nonce of the signer is increased to prevent this permit to be replayed"

    === "Parameters"

        - `from` - the signer of the permit. The call will be dispatched on behalf of this address
        - `to` - the address the call is made to
        - `value` - the value being transferred from the `from` account
        - `data` - the call data, or action to be executed
        - `value` - the value being transferred from the `from` account
        - `gasLimit` - the gas limit the dispatched call requires. Providing an argument for this parameter prevents the dispatcher from manipulating the gas limit
        - `deadline` - the time in UNIX seconds after which the permit will no longer be valid. In JavaScript, you can get the current time in UNIX seconds by running `console.log(Date.now())` in a JavaScript script or a browser console
        - `v` - the recovery ID of the signature. The last one byte of the concatenated signature
        - `r` - the first 32 bytes of the concatenated signature
        - `s` - the second 32 bytes of the concatenated signature


??? function "**nonces**(*address* owner) â€” returns the current nonce for given owner"

    === "Parameters"

        - `owner` - the address of the account to check

??? function "**DOMAIN_SEPARATOR**() â€” returns the EIP-712 domain separator which is used to avoid replay attacks. It follows the [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612#specification){target=\_blank} implementation"

    === "Parameters"

        None

    === "Returns"
        The EIP-712 domain separator which is used to avoid replay attacks.


The domain separator is defined in the [EIP-712 standard](https://eips.ethereum.org/EIPS/eip-712){target=\_blank} and is calculated as:

```text
keccak256(PERMIT_DOMAIN, name, version, chain_id, address)
```

The parameters of the hash can be broken down as follows:

 - **PERMIT_DOMAIN** - is the `keccak256` of `EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)`
 - **name** - is the name of the signing domain and must be `'Call Permit Precompile'` exactly
 - **version** - is the version of the signing domain. For this case **version** is set to `1`
 - **chainId** - is the chain ID of your network
 - **verifyingContract** - is the address of the contract that will verify the signature. In this case, the Call Permit Precompile address

When `dispatch` is called, the permit needs to be verified before the call is dispatched. The first step is to [compute the domain separator](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L138){target=\_blank}. The calculation can be seen in [Moonbeam's implementation](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L112-L126){target=\_blank} or you can check out a practical example in [OpenZeppelin's EIP712 contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/cryptography/draft-EIP712.sol#L70-L84){target=\_blank}.

From there, a [hash of the signature and the given arguments](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L140-L151){target=\_blank} is generated which guarantees that the signature can only be used for the call permit. It uses a given nonce to ensure the signature is not subject to a replay attack. It is similar to [OpenZeppelin's `ERC20Permit` contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/token/ERC20/extensions/draft-ERC20Permit.sol#L52){target=\_blank}, except the `PERMIT_TYPEHASH` is for a call permit, and the arguments match that of the dispatch function plus the nonce.

The domain separator and the hash struct can be used to build the [final hash](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L153-L157){target=\_blank} of the fully encoded message. A practical example is shown in [OpenZeppelin's EIP712 contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/cryptography/draft-EIP712.sol#L101){target=\_blank}.

With the final hash and the v, r, and s values, the signature can be [verified and recovered](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L211-L223){target=\_blank}. If successfully verified, the nonce will increase by one and the call will be dispatched.

## Setup the Contracts {: #setup-the-example-contract }

For this example, you'll learn how to sign a call permit that updates a message in a simple example contract, [`SetMessage.sol`](#example-contract). Before you can generate the call permit signature, you'll need to deploy the contract and define the `dispatch` function arguments for the call permit.

Once you've set up the example contract, then you can set up the Call Permit Precompile contract.

### Checking Prerequisites {: #checking-prerequisites }

To follow along with this tutorial, you will need to have your wallet configured to work with your EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the [Tanssi dApp](https://apps.tanssi.network/){target=\_blank}. Or, you can [configure MetaMask for Tanssi with the demo EVM network](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

### Example Contract {: #example-contract }

The `SetMessage.sol` contract is a perfect example to demonstrate use of the Call Permit Precompile.

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.7;

contract SetMessage {
    string storedMessage;

    function set(string calldata x) public {
        storedMessage = x;
    }

    function get() public view returns (string memory) {
        return storedMessage;
    }
}
```

### Remix Set Up {: #remix-set-up }

You can use [Remix](https://remix.ethereum.org/){target=\_blank} to compile the example contract and deploy it. You'll need a copy of [`SetMessage.sol`](#example-contract){target=\_blank} and [`CallPermit.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/CallPermit.sol){target=\_blank}. To add the contracts to Remix, you can take the following steps:

1. Click on the **File explorer** tab 
2. Paste the `CallPermit.sol` contract into a Remix file named `CallPermit.sol`
3. Paste the `SetMessage.sol` contract into a Remix file named `SetMessage.sol`

![Copying and pasting the example contract into Remix](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-1.webp)

### Compile & Deploy the Example Contract {: #compile-deploy-example-contract }

First, you'll need to compile the example contract:

1. Click on the **Compile** tab
2. Then to compile the interface, click on **Compile SetMessage.sol**

![Compiling SetMessage.sol](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-2.webp)

Then you can deploy it:

1. Click on the **Deploy and Run** tab, directly below the **Compile** tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed
2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** drop down
3. Ensure **SetMessage.sol** is selected in the **CONTRACT** dropdown
4. Click **Deploy**
5. MetaMask will pop up and you'll need to **Confirm** the transaction

![Provide the address](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-3.webp)

The contract will appear under the list of **Deployed Contracts** on the left side panel. Copy the contract address as you will need to use it to generate the call permit signature in the next section.

### Compile & Access the Call Permit Precompile {: #compile-access-call-permit }

First you'll need to compile the Call Permit Precompile contract:

1. Click on the **Compile** tab
2. Then to compile the interface, click on **Compile CallPermit.sol**

![Compiling SetMessage.sol](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-4.webp)

Then, instead of deploying the contract, you'll just need to access it given the address of the precompile:

1. Click on the **Deploy and Run** tab, directly below the **Compile** tab in Remix. Note: you are not deploying a contract here, instead you are accessing a precompiled contract that is already deployed
2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** drop down
3. Ensure **CallPermit.sol** is selected in the **CONTRACT** dropdown. Since this is a precompiled contract, there is no deployment step. Rather you'll provide the address of the precompile in the **At Address** field
4. Provide the address of the Call Permit Precompile for Tanssi-powered EVM networks: `{{networks.demo_evm.precompiles.call_permit}}` and click **At Address**
5. The Call Permit Precompile will appear in the list of **Deployed Contracts**

![Provide the address](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-5.webp)

## Generate Call Permit Signature {: #generate-call-permit-signature}

In order to interact with the Call Permit Precompile, you have to have or generate a signature to dispatch the call permit. There are several ways you can generate the signature. This guide will show how to generate the signature using [Ethers.js](https://docs.ethers.org/v6/){target=\_blank}.

Here's an overview of the steps that you'll need to take to obtain the signature:

1. The `message` will be created and includes some of the data that is needed to create the call permit. It includes the arguments that will be passed into the `dispatch` function and the nonce of the signer
2. A JSON structure of the data the user needs to sign will be assembled for the call permit and include all of the types for the `dispatch` arguments and the nonce. This will result in the `CallPermit` type and will be saved as the `primaryType`
3. The domain separator will be created using `"Call Permit Precompile"` exactly for the name, the version of your dApp or platform, the chain ID of the network the signature is to be used on, and the address of the contract that will verify the signature. Note that you'll need to specify the chain ID of your network in the script to generate the correct signature
4. All of the assembled data will be signed using Ethers.js
5. The signature will be returned and you can use [Ethers.js](https://docs.ethers.org/v6/){target=\_blank} [`Signature.from` method](https://docs.ethers.org/v6/api/crypto/#Signature_from){target=\_blank} to return the `v`, `r`, and `s` values of the signature

### The Call Permit Arguments {: #call-permit-arguments }

As seen in the [Call Permit Interface](#the-call-permit-interface) section, the `dispatch` function takes the following parameters: `from`, `to`, `value`, `data`, `gasLimit`, `deadline`, `v`, `r`, and `s`.

In order to get the signature arguments (`v`, `r`, and `s`), you'll need to sign a message containing the arguments for the remainder of the aforementioned parameters, plus the nonce of the signer.

- `from` - the address of the account you want to sign the call permit with
- `to` - the contract address for the `SetMessage.sol` contract
- `value` - can be `0` for this example as you'll just be setting a message instead of transferring any funds
- `data` - you can send any message you would like. You'll just need the hex representation of the message you want to set using the `SetMessage.sol` contract. This will contain the function selector of the `set` function and the string of the message. For this example, you can send `hello world`. To do so, you can use this hex representation:
     ```text
     0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000
     ```
- `gasLimit` - `100000` will be enough to send the dispatched call
- `deadline` - you can get the current time in UNIX seconds by running `console.log(Date.now())` in a JavaScript script or a browser console. Once you have the current time, you should generously add additional seconds to represent when the call permit will expire

The nonce of the signer will also be needed. If this is your first time signing a call permit the nonce will be `0`. You can also check the nonce in Remix:

1. Expand the call permit contract
2. Next to the **nonces** function, enter the address of the signer and click on **nonces**
3. The result will be returned directly under the function

![Get the nonce](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-6.webp)

### Use Ethers to Create the Signature {: #use-ethers-to-create-the-signature }

To generate the call permit signature using JavaScript and Ethers, you'll first need to create a project locally. You can do so with the following commands:

```bash
mkdir call-permit-example && cd call-permit-example && touch getSignature.js
npm init -y
```

You should now have a file where you can create the script to get the signature along with a `package.json` file. Open the `package.json` file, and below the `"dependencies"` section, add:

```json
"type": "module"
```

Next, you can install [Ethers.js](https://docs.ethers.org/v6/){target=\_blank}:

```bash
npm i ethers
```

!!! remember
    Never reveal your private keys, as they give direct access to your funds. The following steps are for demonstration purposes only.

In the `getSignature.js` file, you can copy and edit the following code snippet. In addition to the fields discussed above in the [Call Permit arguments section](#call-permit-arguments), you'll need to insert the Chain ID of your network in the Domain Separator component to properly generate the signature. If you use an incorrect Chain ID, the generated signature will be invalid and no transaction can be dispatched.

???+ code "getSignature.js"

    ```js
    import { ethers } from 'ethers';

const from = 'INSERT_FROM_ADDRESS';
const to = 'INSERT_TO_ADDRESS';
const value = 0;
const data =
  '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';
const gaslimit = 100000;
const nonce = 'INSERT_SIGNERS_NONCE';
const deadline = 'INSERT_DEADLINE';

const createPermitMessageData = () => {
  const message = {
    from: from,
    to: to,
    value: value,
    data: data,
    gaslimit: gaslimit,
    nonce: nonce,
    deadline: deadline,
  };

  const typedData = {
    types: {
      CallPermit: [
        { name: 'from', type: 'address' },
        { name: 'to', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'data', type: 'bytes' },
        { name: 'gaslimit', type: 'uint64' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
      ],
    },
    primaryType: 'CallPermit',
    domain: {
      name: 'Call Permit Precompile',
      version: '1',
      chainId: INSERT-CHAIN-ID,
      verifyingContract: '0x0000000000000000000000000000000000000802',
    },
    message: message,
  };

  return {
    typedData,
    message,
  };
};

const messageData = createPermitMessageData();

// For demo purposes only. Never store your private key in a JavaScript/TypeScript file
const privateKey = 'INSERT_PRIVATE_KEY';
const wallet = new ethers.Wallet(privateKey);

const signature = await wallet.signTypedData(messageData.typedData.domain, messageData.typedData.types, messageData.message);

console.log(`Transaction successful with hash: ${signature}`);

const ethersSignature = ethers.Signature.from(signature);
const formattedSignature = {
  r: ethersSignature.r,
  s: ethersSignature.s,
  v: ethersSignature.v,
};

console.log(formattedSignature);
    ```

To run the script, use the following command:

```bash
node getSignature.js
```

In the console, you should see the concatenated signature along with the values for the signature including the `v`, `r`, and `s` values. Copy these values as you'll need them when interacting with the Call Permit Precompile in the following sections.

![Signature values in the console](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-7.webp)

!!! note
    Take care when copying the `v`, `r`, and `s` values to the `dispatch` method of the precompile. The ordering of `v`, `r`, and `s` values in the precompile may not be the same as output by the script. 

## Interact with the Solidity Interface {: #interact-with-the-solidity-interface }

Now that you have generated the call permit signature, you will be able to test out calling the `dispatch` function of the Call Permit Precompile.

### Dispatch a Call {: #dispatch-a-call }

When you send the `dispatch` function, you'll need the same arguments as you used to sign the call permit. To get started, go back to the **Deploy and Run** tab in Remix, and under the **Deployed Contracts** section, expand the call permit contract. Make sure that you're connected to the account that you want to consume the call permit and pay the transaction fees. Then take the following steps:

1. For the **from** field, enter the account address you used to sign the call permit with
2. Copy and paste the contract address of `SetMessage.sol`
3. Enter `0` for the **value** field
4. Enter the hex representation of the function selector for the `set` function and the string you want to set as the message for the `SetMessage.sol` contract. For this example, `hello world` can be used:
     ```text
     0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000
     ```
5. Enter `100000` for the **gasLimit** field
6. Enter the `deadline` you used when signing the call permit
7. Copy the `v` value you should have retrieved while generating the call permit signature and paste it into the **v** field
8. Copy the `r` value you should have retrieved while generating the call permit signature and paste it into the **r** field
9. Copy the `s` value you should have retrieved while generating the call permit signature and paste it into the **s** field
10. Click **transact** to send the transaction
11. MetaMask should pop up and you can confirm the transaction

![Dispatch the call permit](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-8.webp)

Once the transaction goes through, you can verify that the message was updated to `hello world`. To do so, you can:

1. Expand the `SetMessage.sol` contract
2. Click on **get**
3. The result will appear below the function, and it should show `hello world`

![Verify the dispatch was executed as intended](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-9.webp)

Congratulations! You've successfully generated a call permit signature and used it to dispatch a call on behalf of the call permit signer.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/
--- BEGIN CONTENT ---
---
title: Native Cross-Chain Token Transfers
description: Learn how to use the XCM interface precompile to transfer tokens from any Tanssi-powered EVM network, leveraging their inherent native cross-chain capabilities.
categories: EVM-Template
---

# Native Cross-Chain Token Transfers

## Introduction {: #introduction }

As presented in the [Native Cross-Chain Communication](/learn/framework/xcm/){target=\_blank} article from the Learn section, Tanssi-powered networks benefit from an inherent capability to communicate and interoperate with any other network in the ecosystem. This native cross-chain communication allows safe and fast token transfers leveraging the Cross-Consensus Message format (XCM for short), which facilitates communication between different consensus systems.

The communication protocol enabling token transfers is built on [Substrate](/learn/framework/overview/#substrate-framework){target=\_blank} and runs on a lower level than the EVM, making it harder for EVM developers to access.

Nevertheless, EVM networks have an XCM precompile that fills the gap between execution layers, exposing a smart contract interface that abstracts away the underlying complexities, making the execution of cross-chain token transfers as easy as any other smart contract call.

This guide will show you how to interact with the [XCM Interface](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\_blank} precompile to execute cross-chain token transfers through the Ethereum API.

The XCM precompile is located at the following address:

```text
{{networks.demo_evm.precompiles.xcm_interface }}
```

!!! note
    There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with [Moonbeam's Precompile Security Considerations](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## The XCM Solidity Interface {: #the-xcm-solidity-interface }

The [`XCMInterface.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\_blank} interface on Tanssi EVM networks is a Solidity interface that allows developers to interact with the precompile's functions.

??? code "XCMInterface.sol"

    ```solidity
    // SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The XCM contract's address.
address constant XCM_CONTRACT_ADDRESS = 0x0000000000000000000000000000000000000804;

/// @dev The XCM contract's instance.
XCM constant XCM_CONTRACT = XCM(XCM_CONTRACT_ADDRESS);

/// @author The Moonbeam Team
/// @title XCM precompile Interface
/// @dev The interface that Solidity contracts use to interact with the substrate pallet-xcm.
interface XCM {
    // A location is defined by its number of parents and the encoded junctions (interior)
    struct Location {
        uint8 parents;
        bytes[] interior;
    }

    // Support for Weights V2
    struct Weight {
        uint64 refTime;
        uint64 proofSize;
    }

    // A way to represent fungible assets in XCM using Location format
    struct AssetLocationInfo {
        Location location;
        uint256 amount;
    }

    // A way to represent fungible assets in XCM using address format
    struct AssetAddressInfo {
        address asset;
        uint256 amount;
    }

    /// @dev Function to send assets via XCM using transfer_assets() pallet-xcm extrinsic.
    /// @custom:selector 59df8416
    /// @param dest The destination chain.
    /// @param beneficiary The actual account that will receive the tokens on dest.
    /// @param assets The combination (array) of assets to send.
    /// @param feeAssetItem The index of the asset that will be used to pay for fees.
    /// @param weight The weight to be used for the whole XCM operation.
    /// (uint64::MAX in refTime means Unlimited weight) 
    function transferAssetsLocation(
        Location memory dest,
        Location memory beneficiary,
        AssetLocationInfo[] memory assets,
        uint32 feeAssetItem,
        Weight memory weight
    ) external;

    /// @dev Function to send assets via XCM to a 20 byte-like parachain 
    /// using transfer_assets() pallet-xcm extrinsic.
    /// @custom:selector b489262e
    /// @param paraId The para-id of the destination chain.
    /// @param beneficiary The actual account that will receive the tokens on paraId destination.
    /// @param assets The combination (array) of assets to send.
    /// @param feeAssetItem The index of the asset that will be used to pay for fees.
    /// @param weight The weight to be used for the whole XCM operation.
    /// (uint64::MAX in refTime means Unlimited weight)
    function transferAssetsToPara20(
        uint32 paraId,
        address beneficiary,
        AssetAddressInfo[] memory assets,
        uint32 feeAssetItem,
        Weight memory weight
    ) external;

    /// @dev Function to send assets via XCM to a 32 byte-like parachain 
    /// using transfer_assets() pallet-xcm extrinsic.
    /// @custom:selector 4461e6f5
    /// @param paraId The para-id of the destination chain.
    /// @param beneficiary The actual account that will receive the tokens on paraId destination.
    /// @param assets The combination (array) of assets to send.
    /// @param feeAssetItem The index of the asset that will be used to pay for fees.
    /// @param weight The weight to be used for the whole XCM operation.
    /// (uint64::MAX in refTime means Unlimited weight)
    function transferAssetsToPara32(
        uint32 paraId,
        bytes32 beneficiary,
        AssetAddressInfo[] memory assets,
        uint32 feeAssetItem,
        Weight memory weight
    ) external;

    /// @dev Function to send assets via XCM to the relay chain 
    /// using transfer_assets() pallet-xcm extrinsic.
    /// @custom:selector d7c89659
    /// @param beneficiary The actual account that will receive the tokens on the relay chain.
    /// @param assets The combination (array) of assets to send.
    /// @param feeAssetItem The index of the asset that will be used to pay for fees.
    /// @param weight The weight to be used for the whole XCM operation.
    /// (uint64::MAX in refTime means Unlimited weight)
    function transferAssetsToRelay(
        bytes32 beneficiary,
        AssetAddressInfo[] memory assets,
        uint32 feeAssetItem,
        Weight memory weight
    ) external;
}
    ```

The interface includes the necessary data structures along with the following functions:

???+ function "**transferAssetsToPara20**(_paraId, beneficiary, assets, feeAssetItem, weight_) â€” sends assets to another EVM-compatible network using the underlying `transfer_assets()` transaction included in the XCM pallet module"

    === "Parameters"

        - `paraId` ++"uint32"++ - the destination's network ID
        - `beneficiary` ++"address"++ - the ECDSA-type account in the destination chain that will receive the tokens
        - `assets` ++"AssetAddressInfo[] memory"++ - an array of assets to send
        - `feeAssetItem` ++"uint32"++ - the index of the asset that will be used to pay fees
        - `weight` ++"Weight memory"++- the maximum gas to use in the whole operation. Setting uint64::MAX to `refTime` acts in practice as *unlimited weight*

    === "Example"

        - `paraId` - 888
        - `beneficiary` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217
        - `assets` - [["0x0000000000000000000000000000000000000800", 1000000000000000000]]
        - `feeAssetItem` - 0
        - `weight` - [9223372036854775807, 9223372036854775807]

??? function "**transferAssetsToPara32**(_paraId, beneficiary, assets,feeAssetItem, weight_) â€” sends assets to a Substrate network using the underlying `transfer_assets()` transaction included in the XCM pallet module"

    === "Parameters"

        - `paraId` ++"uint32"++ - the destination's network ID
        - `beneficiary` ++"bytes32"++ - the Substrate's SR25519-type account in the destination chain that will receive the tokens
        - `assets` ++"AssetAddressInfo[] memory"++ - an array of assets to send
        - `feeAssetItem` ++"uint32"++ - the index of the asset that will be used to pay fees
        - `weight` ++"Weight memory"++ - the maximum gas to use in the whole operation. Setting uint64::MAX to `refTime` acts in practice as *unlimited weight*

    === "Example"

        - `paraId` - 888
        - `beneficiary` - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06
        - `assets` - [["0x0000000000000000000000000000000000000800", 1000000000000000000]]
        - `feeAssetItem` - 0
        - `weight` - [9223372036854775807, 9223372036854775807]

??? function "**transferAssetsToRelay**(_beneficiary, assets, feeAssetItem, weight_) â€” sends assets to the relay chain using the underlying `transfer_assets()` transaction included in the XCM pallet module"

    === "Parameters"

        - `beneficiary` ++"bytes32"++ - the Substrate's sr25519-type account in the relay chain that will receive the tokens
        - `assets` ++"AssetAddressInfo[] memory"++ - an array of assets to send
        - `feeAssetItem` ++"uint32"++ - the index of the asset that will be used to pay fees
        - `weight` ++"Weight memory"++ - the maximum gas to use in the whole operation. Setting uint64::MAX to `refTime` acts in practice as *unlimited weight*

    === "Example"

        - `beneficiary` - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06
        - `assets` - [["0x0000000000000000000000000000000000000800", 1000000000000000000]]
        - `feeAssetItem` - 0
        - `weight` - [9223372036854775807, 9223372036854775807]

??? function "**transferAssetsLocation**(_dest, beneficiary, assets, feeAssetItem, weight_) â€” sends assets using the underlying `transfer_assets()` transaction included in the XCM pallet module"

    === "Parameters"
        - `dest` ++"Location memory"++ - the destination chain
        - `beneficiary` ++"Location memory"++ - the account in the destination chain that will receive the tokens
        - `assets` ++"AssetLocationInfo[] memory"++ - an array of assets to send
        - `feeAssetItem` ++"uint32"++ - the index of the asset that will be used to pay fees
        - `weight` ++"Weight memory"++ - the maximum gas to use in the whole operation. Setting uint64::MAX to `refTime` acts in practice as *unlimited weight*

    === "Example"
        - `dest` - ["1",[]]
        - `beneficiary` - [0, ["0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600"]]
        - `assets` - [[[1, ["0x010000000000000000000000000000000000000800"]], 1000000000000000000]]
        - `feeAssetItem` - 0
        - `weight` - [9223372036854775807, 9223372036854775807]
    
## Interact with the Solidity Interface {: #interact-with-the-solidity-interface }

### Checking Prerequisites {: #checking-prerequisites }

To follow along with this tutorial, you will need to have your wallet configured to work with your EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}. Or, you can [configure MetaMask for Tanssi with the demo EVM network](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

!!! note
    It is necessary to have previously established communication channels with the destination chain before using this precompile's functionality. To do so, refer to the [Manage Cross-Chain Communication Channels](/builders/manage/dapp/xcm-channels/){target=\_blank} guide.
    Also, if the token being transferred is native to your network, the destination chain must have registered the foreign asset.

### Remix Set Up {: #remix-set-up }

You can interact with the XCM Interface precompile using [Remix](https://remix.ethereum.org){target=\_blank}. To add the precompile to Remix, you will need to:

1. Get a copy of [`XCMInterface.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\_blank}
2. Paste the file contents into a Remix file named `XcmInterface.sol`

### Compile the Contract {: #compile-the-contract }

Next, you will need to compile the interface in Remix:

1. Click on the **Compile** tab, second from top
2. Compile the interface by clicking on **Compile XCMInterface.sol**

![Compiling XcmInterface.sol](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-1.webp)

When the compilation is completed, you will see a green checkmark next to the **Compile** tab.

### Access the Contract {: #access-the-contract }

Instead of deploying the precompile, you will access the interface given the address of the precompiled contract:

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step
2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** dropdown. Once you select **Injected Provider - Metamask**, you may be prompted by MetaMask to connect your account to Remix if it's not already connected
3. Make sure the correct account is displayed under **ACCOUNT**
4. Ensure **XCM - XCMInterface.sol** is selected in the **CONTRACT** dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the **At Address** field
5. Provide the address of the precompile: `{{networks.demo_evm.precompiles.xcm_interface}}` and click **At Address**

![Access the address](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-2.webp)

The **XCM Interface** precompile will appear in the list of **Deployed Contracts**.

### Send Tokens Over to Another EVM-Compatible Network {: #transfer-to-evm-chains }

To send tokens over to an account in another EVM-compatible network, please follow these steps:

1. Expand the **transferAssetsToPara20** function
2. Enter the network ID (paraId)
3. Enter the 20-bytes (Ethereum-like) destination account (beneficiary)
4. Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer

    !!! note
    Tokens are specified by their ERC-20 address. If the token you want to transfer is the network's native one, the [Native Token ERC-20 Precompile](/builders/toolkit/ethereum-api/precompiles/erc20/){target=\_blank} will help you reference it through an ERC-20 interface.

5. Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is `0`, the second is `1`, and so on 
6. Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (`refTime`) and the proof size (`proofSize`). In practice, setting refTime to `uint64::MAX` is equal to *unlimited weight*
7. Click **transact**
8. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-3.webp)

After the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.

### Send Tokens Over to a Substrate Network {: #transfer-to-substrate-chains }

To send tokens over to an account in a Substrate network, please follow these steps:

1. Expand the **transferAssetsToPara32** function
2. Enter the network ID (`paraId`)
3. Enter the sr25519-type destination account (beneficiary)
4. Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer
    
    !!! note
    Tokens are specified by their ERC-20 address. If the token you want to transfer is the network's native one, the [Native Token ERC-20 Precompile](/builders/toolkit/ethereum-api/precompiles/erc20/){target=\_blank} will help you reference it through an ERC-20 interface.

5. Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is `0`, the second is `1`, and so on 
6. Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to `uint64::MAX` is equal to *unlimited weight*
7. Click **transact**
8. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-4.webp)

After the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.

### Send Tokens Over to the Relay Chain {: #transfer-to-relay-chain }

To send tokens over to an account in the relay chain, please follow these steps:

1. Expand the **transferAssetsToRelay** function
2. Enter the sr25519-type destination account (beneficiary)
3. Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer
    
    !!! note
    Tokens are specified by their ERC-20 address. If the token you want to transfer is the network's native one, the [Native Token ERC-20 Precompile](/builders/toolkit/ethereum-api/precompiles/erc20/){target=\_blank} will help you reference it through an ERC-20 interface.

4. Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is `0`, the second is `1`, and so on 
5. Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to `uint64::MAX` is equal to *unlimited weight*
6. Click **transact**
7. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-5.webp)

After the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.

### Send Tokens Over Specific Locations {: #transfer-locations }

This function is more generic than the others, allowing the destination chain, destination account, and assets to be specified using [XCM Multilocations](/learn/framework/xcm/#message-destinations){target=\_blank}.
To send tokens to specific locations, please follow these steps:

1. Expand the **transferAssetsLocation** function
2. Enter the multilocation that specifies the destination chain. Note that any chain can be specified, regardless of its configuration or type
3. Enter the Multilocation that specifies the destination account. Note that any account can be specified, regardless of its type (ECDSA, sr25519, or any other)
4. Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset and each asset is specified by its Multilocation and the total amount to transfer
    
    !!! note
    Tokens are specified by their ERC-20 address. If the token you want to transfer is the network's native one, the [Native Token ERC-20 Precompile](/builders/toolkit/ethereum-api/precompiles/erc20/){target=\_blank} will help you reference it through an ERC-20 interface.

5. Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is `0`, the second is `1`, and so on 
6. Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to `uint64::MAX` is equal to *unlimited weight*
7. Click **transact**
8. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-6.webp)

After the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/precompiles/erc20/
--- BEGIN CONTENT ---
---
title:  Native Token ERC-20 Precompile
description: Learn how to access and interact with an ERC-20 representation of the native token on Tanssi-powered EVM networks through the precompiled ERC-20 Interface.
keywords: solidity, ethereum, native, token, moonbeam, precompiled, contracts
icon: material-circle-outline
categories: EVM-Template
---

#  Native Token ERC-20 Precompile

## Introduction {: #introduction }

The native token ERC-20 precompiled contract on Tanssi-powered EVM networks allows developers to interact with the native protocol token through an ERC-20 interface. Although your network's native token is not an ERC-20 token, now you can interact with it as if it was a vanilla ERC-20.

One of the main benefits of this precompile is that it removes the necessity of having a wrapped representation of the protocol token as an ERC-20 smart contract, such as WETH on Ethereum. Furthermore, it minimizes the need for multiple wrapped representations of the same protocol token. Consequently, dApps that need to interact with the protocol token via an ERC-20 interface can do so without needing a separate smart contract.

Under the hood, the [ERC-20 precompile](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank} executes specific Substrate actions related to the Substrate balances module, which is coded in Rust. The balances module provides functionality for handling the various types of balances.

This guide will show you how to interact with UNIT tokens, the native protocol tokens for quick trial networks on [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}, via the ERC-20 precompile. You can follow along and adapt this guide to interacting with your own network.

The precompile is located at the following address:

```text
{{networks.demo_evm.precompiles.erc20 }}
```

!!! note
    There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with [Moonbeam's Precompile Security Considerations](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## The ERC-20 Solidity Interface {: #the-erc20-interface }

The [`ERC20.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank} interface on Tanssi EVM networks follows the [EIP-20 Token Standard](https://eips.ethereum.org/EIPS/eip-20){target=\_blank}, which is the standard API interface for tokens within smart contracts. The standard defines the required functions and events a token contract must implement to be interoperable with different applications.

??? code "ERC20.sol"

    ```solidity
    / SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The IERC20 contract's address.
address constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;

/// @dev The IERC20 contract's instance.
IERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);

/// @title ERC20 interface
/// @dev see https://github.com/ethereum/EIPs/issues/20
/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts
/// @custom:address 0x0000000000000000000000000000000000000800
interface IERC20 {
    /// @dev Returns the name of the token.
    /// @custom:selector 06fdde03
    function name() external view returns (string memory);

    /// @dev Returns the symbol of the token.
    /// @custom:selector 95d89b41
    function symbol() external view returns (string memory);

    /// @dev Returns the decimals places of the token.
    /// @custom:selector 313ce567
    function decimals() external view returns (uint8);

    /// @dev Total number of tokens in existence
    /// @custom:selector 18160ddd
    function totalSupply() external view returns (uint256);

    /// @dev Gets the balance of the specified address.
    /// @custom:selector 70a08231
    /// @param owner The address to query the balance of.
    /// @return An uint256 representing the amount owned by the passed address.
    function balanceOf(address owner) external view returns (uint256);

    /// @dev Function to check the amount of tokens that an owner allowed to a spender.
    /// @custom:selector dd62ed3e
    /// @param owner address The address which owns the funds.
    /// @param spender address The address which will spend the funds.
    /// @return A uint256 specifying the amount of tokens still available for the spender.
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /// @dev Transfer token for a specified address
    /// @custom:selector a9059cbb
    /// @param to The address to transfer to.
    /// @param value The amount to be transferred.
    /// @return true if the transfer was succesful, revert otherwise.
    function transfer(address to, uint256 value) external returns (bool);

    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    /// Beware that changing an allowance with this method brings the risk that someone may use both the old
    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    /// @custom:selector 095ea7b3
    /// @param spender The address which will spend the funds.
    /// @param value The amount of tokens to be spent.
    /// @return true, this cannot fail
    function approve(address spender, uint256 value) external returns (bool);

    /// @dev Transfer tokens from one address to another
    /// @custom:selector 23b872dd
    /// @param from address The address which you want to send tokens from
    /// @param to address The address which you want to transfer to
    /// @param value uint256 the amount of tokens to be transferred
    /// @return true if the transfer was succesful, revert otherwise.
    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    /// @dev Event emited when a transfer has been performed.
    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
    /// @param from address The address sending the tokens
    /// @param to address The address receiving the tokens.
    /// @param value uint256 The amount of tokens transfered.
    event Transfer(address indexed from, address indexed to, uint256 value);

    /// @dev Event emited when an approval has been registered.
    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
    /// @param owner address Owner of the tokens.
    /// @param spender address Allowed spender.
    /// @param value uint256 Amount of tokens approved.
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

/// @title Native currency wrapper interface.
/// @dev Allow compatibility with dApps expecting this precompile to be
/// a WETH-like contract.
interface WrappedNativeCurrency {
    /// @dev Provide compatibility for contracts that expect wETH design.
    /// Returns funds to sender as this precompile tokens and the native tokens are the same.
    /// @custom:selector d0e30db0
    function deposit() external payable;

    /// @dev Provide compatibility for contracts that expect wETH design.
    /// Does nothing.
    /// @custom:selector 2e1a7d4d
    /// @param value uint256 The amount to withdraw/unwrap.
    function withdraw(uint256 value) external;

    /// @dev Event emited when deposit() has been called.
    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c
    /// @param owner address Owner of the tokens
    /// @param value uint256 The amount of tokens "wrapped".
    event Deposit(address indexed owner, uint256 value);

    /// @dev Event emited when withdraw(uint256) has been called.
    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65
    /// @param owner address Owner of the tokens
    /// @param value uint256 The amount of tokens "unwrapped".
    event Withdrawal(address indexed owner, uint256 value);
}
    ```

!!! note
    The ERC-20 precompile does not include `deposit` and `withdraw` functions and subsequent events expected from a wrapped token contract, such as WETH.

## Interact with the Solidity Interface {: #interact-with-the-solidity-interface }

### Checking Prerequisites {: #checking-prerequisites }

To follow along with this tutorial, you will need to have your wallet configured to work with your Tanssi-powered EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}. Or, you can [configure MetaMask for Tanssi with the demo EVM network](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

### Add Token to an EVM Wallet {: #add-token-to-evm-wallet }

If you want to interact with your network's native token like you would with an ERC-20, you can add a custom token to your EVM-compatible wallet using the precompile address. This section will walk you through adding an external asset to [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

To get started, open up MetaMask and make sure you are connected to your network and:

1. Switch to the **Assets** tab
2. Click on **Import tokens**

![Import Tokens from Assets Tab in MetaMask](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-1.webp)

Now, you can create a custom token:

1. Enter the precompile address for the token contract address - `{{networks.demo_evm.precompiles.erc20 }}`. When you enter the address, the **Token Symbol** and **Token Decimal** fields should automatically populate. If they do not, you can enter `UNIT` for the symbol and `18` for the decimal places. Recall that the default number of decimals for Tanssi EVM networks is `18`, the same as Ethereum's token decimals
2. Click **Next**

![Add Custom Token](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-2.webp)

MetaMask will prompt you to confirm the import. You can review the token details and click **Import Tokens** to import UNIT tokens into your wallet.

![Confirm and Import Tokens](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-3.webp)

And that's it! You've successfully added the UNIT token as a custom ERC-20 token on your Tanssi EVM network.

### Remix Set Up {: #remix-set-up }

You can interact with the ERC-20 precompile using [Remix](https://remix.ethereum.org){target=\_blank}. To add the precompile to Remix, you will need to:

1. Get a copy of [`ERC20.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank}
2. Paste the file contents into a Remix file named `IERC20.sol`

### Compile the Contract {: #compile-the-contract }

Next, you will need to compile the interface in Remix:

1. Click on the **Compile** tab, second from top
2. Compile the interface by clicking on **Compile IERC20.sol**

![Compiling IERC20.sol](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-4.webp)

When compilation is completed, you will see a green checkmark next to the **Compile** tab.

### Access the Contract {: #access-the-contract }

Instead of deploying the ERC-20 precompile, you will access the interface given the address of the precompiled contract:

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step
2. Make sure **Injected Web3** is selected in the **ENVIRONMENT** dropdown. Once you select **Injected Web3**, you may be prompted by MetaMask to connect your account to Remix if it's not already connected
3. Make sure the correct account is displayed under **ACCOUNT**
4. Ensure **IERC20 - IERC20.sol** is selected in the **CONTRACT** dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the **At Address** field
5. Provide the address of the ERC-20 precompile: `{{networks.demo_evm.precompiles.erc20}}` and click **At Address**

![Access the address](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-5.webp)

The **IERC20** precompile will appear in the list of **Deployed Contracts**.

### Get Basic Token Information {: #get-basic-token-information }

The ERC-20 interface lets you quickly obtain token information, including the token's total supply, name, symbol, and decimal places. You can retrieve this information by following these steps:

1. Expand the **IERC20** contract under **Deployed Contracts**
2. Click **decimals** to get the decimal places of your network's native protocol token
3. Click **name** to get the name of the token
4. Click **symbol** to get the symbol of the token
5. Click **totalSupply** to obtain the total supply of native tokens on your network

![Total Supply](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-6.webp)

The results of each function call are displayed under the respective functions.

### Get Account Balance {: #get-account-balance }

You can check the balance of any address on your network by calling the `balanceOf` function and passing in an address:

1. Expand the **balanceOf** function
2. Enter an address you would like to check the balance of for the **owner**
2. Click **call**

![Get Balance of an Account](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-7.webp)

Your balance will be displayed under the `balanceOf` function.

### Approve a Spend {: #approve-a-spend }

To approve a token spend allowance, you'll need to provide an address for the spender and the number of tokens the spender is allowed to spend. The spender can be an externally owned account (EOA) or a smart contract. For this example, you can approve the spender with an allowance of 1 UNIT token. To get started, please follow these steps:

1. Expand the **approve** function
2. Enter the address of the spender. You should have created two accounts before starting, so you can use the second account as the spender
3. Enter the amount of tokens the spender can spend for the **value**. For this example, you can allow the spender to spend 1 UNIT token in Wei units (`1000000000000000000`)
4. Click **transact**
5. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-8.webp)

After the transaction is confirmed, you'll notice that the balance of your account has stayed the same. This is because you have only approved the allowance for the given amount, and the spender hasn't spent the funds. In the next section, you will use the `allowance` function to verify that the spender can spend 1 UNIT token on your behalf.

### Get Allowance of Spender {: #get-allowance-of-spender }

To check that the spender received the allowance approved in the [Approve a Spend](#approve-a-spend) section, you can:

1. Expand the **allowance** function
2. Enter your address for the **owner**
3. Enter the address of the **spender** that you used in the previous section
4. Click **call**

![Get Allowance of Spender](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-9.webp)

Once the call is complete, the allowance of the spender will be displayed, which should be equivalent to 1 UNIT token (`1000000000000000000`).

### Send Transfer {: #send-transfer }

To send tokens from your account directly to another account, you can call the `transfer` function by following these steps:

1. Expand the **transfer** function
2. Enter the address to send UNIT tokens to
3. Enter the amount of UNIT tokens to send. For this example, you can send 1 UNIT token (`1000000000000000000`)
4. Click **transact**
5. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction

![Send Standard Transfer](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-10.webp)

Once the transaction is complete, you can [check your balance](#get-account-balance) using the `balanceOf` function or by looking at MetaMask. You'll notice that your balance has decreased by 1 UNIT token. You can also use the `balanceOf` function to ensure that the recipients balance has increased by 1 UNIT token as expected.

### Send Transfer From Specific Account {: #send-transferfrom }

So far, you have approved an allowance of 1 UNIT token for the spender and sent 1 UNIT token via the standard `transfer` function. The `transferFrom` function varies from the standard `transfer` function as it allows you to define the address to which you want to send the tokens. So you can specify an address with an allowance or your address as long as you have funds. For this example, you will use the spender's account to initiate a transfer of the allowed funds from the owner to the spender. The spender can send the funds to any account, but you can send the funds from the owner to the spender for this example.

First, you need to switch to the spender's account in MetaMask. Once you switch to the spender's account, you'll notice that the selected address in Remix under the **Accounts** tab is now the spender's.

![Switch accounts Remix](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-11.webp)

Next, you can initiate and send the transfer. To do so, take the following steps:

1. Expand the **transferFrom** function
2. Enter your address as the owner in the **from** field
3. Enter the recipient address, which should be the spender's address, in the **to** field
4. Enter the amount of UNIT tokens to send. Again, the spender is currently only allowed to send 1 UNIT token, so enter `1000000000000000000`
5. Click **transact**

![Send Standard Transfer](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-12.webp)

Once the transaction is complete, you can [check the balance](#get-account-balance) of the owner and spender using the `balanceOf` function. The spender's balance should have increased by 1 UNIT token, and their allowance should now be depleted. To verify that the spender no longer has an allowance, you can call the `allowance` function by passing in the owner and spender's addresses. You should receive a result of 0.

![Zero Allowance](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-13.webp)

And that's it! You've successfully interacted with the ERC-20 precompile using MetaMask and Remix!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/
--- BEGIN CONTENT ---
---
title: External Assets as ERC-20
description: Learn how to access and interact with an ERC-20 representation of any external assets on Tanssi EVM networks through the precompiled ERC-20 Interface.
keywords: solidity, ethereum, native, token, moonbeam, precompiled, contracts, assets, erc20
categories: EVM-Template
---

# External Assets as ERC-20

## Introduction {: #introduction }

As presented in the [Native Cross-Chain Communication](/learn/framework/xcm/){target=\_blank} article, networks deployed through Tanssi can communicate and interoperate with any other network in the ecosystem. This multi-chain environment leads to a multi-asset world, where seamless transfer of assets, data, and value across different networks widens the possibilities to build use cases across diverse industries such as finance (DeFi), real-world assets (RWAs), and others.

External assets are tokens native to another blockchain, or, in other words, assets whose reserve chain is not the chain you are interacting with. Tanssi networks can register external assets to enable their inflow. To do so, it is necessary to [establish an XCM channel](/learn/framework/xcm/#channel-registration){target=\_blank} with the other chain and then register one of its native assets as an external asset. Registered external assets behave, to some extent, the same way as local ones.

The [ERC-20 assets precompile](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20Instance.sol){target=\_blank} allows networks based on the [Tanssi EVM template](/builders/build/templates/evm/){target=\_blank} to access any registered external asset through the standard ERC-20 interface. Consequently, smart contracts deployed to the network can interact with such assets as they would with any other regular ERC-20.

The address representing the ERC-20 contract is formed with the first thirty-six positions (eighteen bytes) set to the maximum value and the last four positions (two bytes) replaced with the hexadecimal representation of the registered asset identifier:

```text
{{networks.demo_evm.precompiles.external_assets_erc20}}
```

For example, for the asset whose ID is `1`, the last four positions must be replaced with `0001`, and for an asset with an ID of `10`, those four positions must be replaced with `000A`.

!!! note
    There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with [Moonbeam's Precompile Security Considerations](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## Prerequisites {: #prerequisites }

 Tto follow along with the contents in this guide, you'll need:
 
- Access to a Tanssi EVM network running [runtime 500](https://github.com/moondance-labs/tanssi/releases/tag/runtime-500){target=\_blank} or above
- An established bidirectional XCM channel to another chain. To manage your network's channels, refer to the [Manage Cross-Chain Communication Channels](/builders/manage/dapp/xcm-channels/){target=\_blank} article
- A registered external asset. Once the XCM channels are open, asset registration can be easily done using the [dApp](https://apps.tanssi.network/){target=\_blank} as explained in the [Register External Assets](/builders/manage/dapp/register-external-assets/){target=\_blank} guide
- Finally, you'll need an [EVM-compatible wallet](/builders/toolkit/ethereum-api/wallets/){target=\_blank} configured to work with your network. You can also connect your wallet to the [demo EVM network](https://apps.tanssi.network/demo){target=\_blank}.

The examples in this guide are based on the Tanssi demo EVM network, which already has open channels to other networks and registered external assets, as the following picture shows:

1. The registered external asset (UNIT) which will be used in the following sections
2. Other available external assets not yet registered

![Tanssi EVM demo network registered external Assets](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-1.webp)

## The ERC-20 Solidity Interface {: #the-erc20-interface }

The [`ERC20.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank} interface on Tanssi EVM networks follows the [EIP-20 Token Standard](https://eips.ethereum.org/EIPS/eip-20){target=\_blank}, which is the standard API interface for tokens within smart contracts. The standard defines the required functions and events a token contract must implement to be interoperable with different applications.

??? code "ERC20.sol"

    ```solidity
    / SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The IERC20 contract's address.
address constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;

/// @dev The IERC20 contract's instance.
IERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);

/// @title ERC20 interface
/// @dev see https://github.com/ethereum/EIPs/issues/20
/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts
/// @custom:address 0x0000000000000000000000000000000000000800
interface IERC20 {
    /// @dev Returns the name of the token.
    /// @custom:selector 06fdde03
    function name() external view returns (string memory);

    /// @dev Returns the symbol of the token.
    /// @custom:selector 95d89b41
    function symbol() external view returns (string memory);

    /// @dev Returns the decimals places of the token.
    /// @custom:selector 313ce567
    function decimals() external view returns (uint8);

    /// @dev Total number of tokens in existence
    /// @custom:selector 18160ddd
    function totalSupply() external view returns (uint256);

    /// @dev Gets the balance of the specified address.
    /// @custom:selector 70a08231
    /// @param owner The address to query the balance of.
    /// @return An uint256 representing the amount owned by the passed address.
    function balanceOf(address owner) external view returns (uint256);

    /// @dev Function to check the amount of tokens that an owner allowed to a spender.
    /// @custom:selector dd62ed3e
    /// @param owner address The address which owns the funds.
    /// @param spender address The address which will spend the funds.
    /// @return A uint256 specifying the amount of tokens still available for the spender.
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /// @dev Transfer token for a specified address
    /// @custom:selector a9059cbb
    /// @param to The address to transfer to.
    /// @param value The amount to be transferred.
    /// @return true if the transfer was succesful, revert otherwise.
    function transfer(address to, uint256 value) external returns (bool);

    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    /// Beware that changing an allowance with this method brings the risk that someone may use both the old
    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    /// @custom:selector 095ea7b3
    /// @param spender The address which will spend the funds.
    /// @param value The amount of tokens to be spent.
    /// @return true, this cannot fail
    function approve(address spender, uint256 value) external returns (bool);

    /// @dev Transfer tokens from one address to another
    /// @custom:selector 23b872dd
    /// @param from address The address which you want to send tokens from
    /// @param to address The address which you want to transfer to
    /// @param value uint256 the amount of tokens to be transferred
    /// @return true if the transfer was succesful, revert otherwise.
    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    /// @dev Event emited when a transfer has been performed.
    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
    /// @param from address The address sending the tokens
    /// @param to address The address receiving the tokens.
    /// @param value uint256 The amount of tokens transfered.
    event Transfer(address indexed from, address indexed to, uint256 value);

    /// @dev Event emited when an approval has been registered.
    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
    /// @param owner address Owner of the tokens.
    /// @param spender address Allowed spender.
    /// @param value uint256 Amount of tokens approved.
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

/// @title Native currency wrapper interface.
/// @dev Allow compatibility with dApps expecting this precompile to be
/// a WETH-like contract.
interface WrappedNativeCurrency {
    /// @dev Provide compatibility for contracts that expect wETH design.
    /// Returns funds to sender as this precompile tokens and the native tokens are the same.
    /// @custom:selector d0e30db0
    function deposit() external payable;

    /// @dev Provide compatibility for contracts that expect wETH design.
    /// Does nothing.
    /// @custom:selector 2e1a7d4d
    /// @param value uint256 The amount to withdraw/unwrap.
    function withdraw(uint256 value) external;

    /// @dev Event emited when deposit() has been called.
    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c
    /// @param owner address Owner of the tokens
    /// @param value uint256 The amount of tokens "wrapped".
    event Deposit(address indexed owner, uint256 value);

    /// @dev Event emited when withdraw(uint256) has been called.
    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65
    /// @param owner address Owner of the tokens
    /// @param value uint256 The amount of tokens "unwrapped".
    event Withdrawal(address indexed owner, uint256 value);
}
    ```

!!! note
    The external assets ERC-20 precompile does not include `deposit` and `withdraw` functions and subsequent events expected from a wrapped token contract, such as WETH.

## Add Token to an EVM Wallet {: #add-token-to-evm-wallet }

If you want to interact with your network's registered external assets like you would with an ERC-20, you can add them to your wallet using the precompile address prefix and the asset ID. This section will walk you through adding an external asset to [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

To get started, open up MetaMask and make sure you are connected to your network and:

1. Switch to the **Tokens** tab
2. Click on **Import tokens**

    ![Import Tokens from Tokens Tab in MetaMask](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-2.webp)

Before continuing, you'll need the token's address, which, considering that in this example the external asset has an ID of `1`, will be:

```text
{{networks.demo_evm.precompiles.external_assets_erc20_example}}
```

1. Enter the precompile address for the token contract address. When you enter the address, the **Token Symbol** and **Token Decimal** fields should automatically populate. If they do not, you can enter `UNIT` for the symbol and `12` for the decimal places
2. Click **Next**

![Add External Asset](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-3.webp)

MetaMask will prompt you to confirm the import. You can review the token details and click **Import Tokens** to import UNIT tokens into your wallet.

![Confirm and Import Tokens](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-4.webp)

And that's it! You've successfully added the UNIT token external asset as a custom ERC-20 token on the Tanssi demo EVM network.

## Interact with the Solidity Interface via Remix {: #interact-with-the-solidity-interface-via-remix }

### Remix Set Up {: #remix-set-up }

You can interact with the external assets ERC-20 precompile using [Remix](https://remix.ethereum.org){target=\_blank}. To add the precompile to Remix, you will need to:

1. Get a copy of [`ERC20.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank}
2. Paste the file contents into a Remix file named `IERC20.sol`

### Compile the Contract {: #compile-the-contract }

Next, you will need to compile the interface in Remix:

1. Click on the **Compile** tab, second from top
2. Compile the interface by clicking on **Compile IERC20.sol**

![Compiling IERC20.sol](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-5.webp)

When compilation is completed, you will see a green checkmark next to the **Compile** tab.

### Access the Contract {: #access-the-contract }

Instead of deploying the smart contract, you will access the interface through the address of external asset precompile:

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step
2. Make sure **Injected Web3** is selected in the **ENVIRONMENT** dropdown. Once you select **Injected Web3**, you may be prompted by MetaMask to connect your account to Remix if it's not already connected
3. Make sure the correct account is displayed under **ACCOUNT**
4. Ensure **IERC20 - IERC20.sol** is selected in the **CONTRACT** dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the **At Address** field
5. Provide the address of the ERC-20 precompile (which is `{{networks.demo_evm.precompiles.external_assets_erc20_example}}` in this example) and click **At Address**
6. The **IERC20** precompile will appear in the list of **Deployed Contracts**

![Access the address](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-6.webp)

### Get Basic Token Information {: #get-basic-token-information }

The ERC-20 interface lets you quickly obtain token information, including the token's total supply, name, symbol, and decimal places. You can retrieve this information by following these steps:

1. Expand the **IERC20** contract under **Deployed Contracts**
2. Click **decimals** to get the decimal places of your network's native protocol token
3. Click **name** to get the name of the token
4. Click **symbol** to get the symbol of the token
5. Click **totalSupply** to obtain the total supply of native tokens on your network

![Get basic token information](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-7.webp)

The results of each function call are displayed under the respective functions.

### Get Account Balance {: #get-account-balance }

You can check the balance of any address on your network by calling the `balanceOf` function and passing in an address:

1. Expand the **balanceOf** function
2. Enter an address you would like to check the balance of for the **owner**
2. Click **call**

![Get Balance of an Account](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-8.webp)

Your balance will be displayed under the `balanceOf` function.

### Send Transfer {: #send-transfer }

To send tokens from your account directly to another account, you can call the `transfer` function by following these steps:

1. Expand the **transfer** function
2. Enter the address to send UNIT tokens to
3. Enter the amount of UNIT tokens to send. For this example, you can send 1 UNIT token (`1000000000000`)
4. Click **transact**
5. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction

![Send Standard Transfer](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-9.webp)

Once the transaction is complete, you can [check your balance](#get-account-balance) using the `balanceOf` function or by looking at MetaMask. You'll notice that your balance has decreased by 1 UNIT token. You can also use the `balanceOf` function to ensure that the recipients balance has increased by 1 UNIT token as expected.

And that's it! You've successfully interacted with the external assets ERC-20 precompile using MetaMask and Remix!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/precompiles/
--- BEGIN CONTENT ---
---
title: Solidity Precompiles
description: These guides demonstrate how to interact with precompiles to access Substrate features through the familiar Ethereum API on Tanssi's EVM-compatible networks.
icon: octicons-file-code-24
template: index-page.html
---

# Precompiles

Precompiles are built-in blockchain modules designed to handle specific tasks more efficiently than standard smart contracts. These modules are pre-deployed at fixed addresses and provide optimized solutions for operations like cryptographic functions, transaction batching, and token management.

Since Tanssi-powered networks are Substrate-based, precompiled contracts can support both Ethereum-compatible functions and operations specific to the underlying Substrate chain. This dual approach ensures that developers can interact with familiar Ethereum tools while also taking advantage of the unique performance and flexibility offered by Substrate.

## Flow of Interacting with Precompiles

The flow below illustrates how user requests pass through the Ethereum interface, interact with precompiles, and ultimately access Substrate functionality, simplifying complex operations for seamless integration.

```mermaid
graph LR
    
    A[User]
    B[Ethereum Interface]
    C[Precompile]
    D[Substrate Interface]

    A -->|Interacts through| B
    B -->|Calls| C
    C -->|Accesses| D
```

## Precompile Addresses Quick Reference

| Precompile          | Address                                                      |
|---------------------|--------------------------------------------------------------|
| Native Token ERC-20 | <pre>```0x0000000000000000000000000000000000000800```</pre>  |
| Call Permit         | <pre>```0x0000000000000000000000000000000000000802```</pre>  |
| Proxy               | <pre>```0x0000000000000000000000000000000000000805```</pre>  |
| Batch Transactions  | <pre>```0x0000000000000000000000000000000000000801```</pre>  |

To find out more about each precompile, check out the guides listed in the following section.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/precompiles/proxy/
--- BEGIN CONTENT ---
---
title: The Proxy Precompile
description: Learn how to interact with the Proxy precompile to add and remove proxy accounts that can execute specific transactions on behalf of other account.
keywords: solidity, ethereum, proxy, moonbeam, precompiled, contracts, substrate
icon: octicons-shield-lock-24
categories: EVM-Template
---

# Interacting with the Proxy Precompile

## Introduction {: #introduction }

The Proxy Precompile allows accounts to set proxy accounts via the Ethereum API. Proxy accounts can perform limited actions on behalf of the proxied account, such as governance, balance transfers, management or privileged transactions, and others.

If a user wanted to provide another user access to a limited number of actions on their behalf, traditionally, the only method to do so would be to share that account's private key. However, Tanssi-powered EVM networks include the proxy module, providing an additional layer of security. With proxies, many accounts can perform actions for a primary account, and such permissions can be revoked at any time. This is best if, for example, a user wants to keep their wallet safe in cold storage but still wants to access parts of the wallet's functionality, like governance or staking.  

!!! note
    The Proxy Precompile can only be called from an Externally Owned Account (EOA) or by the [Batch Precompile](/builders/toolkit/ethereum-api/precompiles/batch/){target=\_blank}.

To learn more about proxy accounts and how to set them up for your own purposes without use of the Proxy Precompile, visit the [Proxy Accounts](/builders/account-management/proxy-accounts/){target=\_blank} page.

The Proxy Precompile is located at the following address:

```text
{{networks.demo_evm.precompiles.proxy}}
```

!!! note
    There can be some unintended consequences when using precompiles. Tanssi's precompiles are derived from Moonbeam's, and as such, please familiarize yourself with [Moonbeam's Precompile Security Considerations](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## Prerequisites {: #prerequisites }

 Tto follow along with the contents in this guide, you'll need:
 
- Access to a Tanssi-powered EVM network running [runtime 700](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank} or above
- An [EVM-compatible wallet](/builders/toolkit/ethereum-api/wallets/){target=\_blank} configured to work with your network. You can also connect your wallet to the [demo EVM network](https://apps.tanssi.network/demo){target=\_blank}
- An account with enough funds to pay the required fees and deposits
- A second account that you control to use as a proxy

## The Proxy Solidity Interface {: #the-proxy-solidity-interface }

[`Proxy.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/Proxy.sol){target=\_blank} is an interface that allows developers to interact with the precompile's functions.

??? code "Proxy.sol"

    ```solidity
    // SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @author The Moonsong Labs Team
/// @title Pallet Proxy Interface
/// @title The interface through which solidity contracts will interact with the Proxy pallet
interface Proxy {
    /// @dev Defines the proxy permission types.
    /// The values start at `0` (most permissive) and are represented as `uint8`
    enum ProxyType {
        Any,
        NonTransfer,
        Governance,
        Staking,
        CancelProxy,
        Balances,
        AuthorMapping,
        IdentityJudgement
    }

    /// @dev Register a proxy account for the sender that is able to make calls on its behalf
    /// @custom:selector 74a34dd3
    /// @param delegate The account that the caller would like to make a proxy
    /// @param proxyType The permissions allowed for this proxy account
    /// @param delay The announcement period required of the initial proxy, will generally be zero
    function addProxy(
        address delegate,
        ProxyType proxyType,
        uint32 delay
    ) external;

    /// @dev Removes a proxy account from the sender
    /// @custom:selector fef3f708
    /// @param delegate The account that the caller would like to remove as a proxy
    /// @param proxyType The permissions currently enabled for the removed proxy account
    /// @param delay The announcement period required of the initial proxy, will generally be zero
    function removeProxy(
        address delegate,
        ProxyType proxyType,
        uint32 delay
    ) external;

    /// @dev Unregister all proxy accounts for the sender
    /// @custom:selector 14a5b5fa
    function removeProxies() external;

    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender
    /// is authorised for through `addProxy`
    /// @custom:selector 0d3cff86
    /// @param real The account that the proxy will make a call on behalf of
    /// @param callTo Recipient of the call to be made by the `real` account
    /// @param callData Data of the call to be made by the `real` account
    function proxy(
        address real,
        address callTo,
        bytes memory callData
    ) external payable;

    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender
    /// is authorised for through `addProxy`
    /// @custom:selector 685b9d2f
    /// @param real The account that the proxy will make a call on behalf of
    /// @param forceProxyType Specify the exact proxy type to be used and checked for this call
    /// @param callTo Recipient of the call to be made by the `real` account
    /// @param callData Data of the call to be made by the `real` account
    function proxyForceType(
        address real,
        ProxyType forceProxyType,
        address callTo,
        bytes memory callData
    ) external payable;

    /// @dev Checks if the caller has an account proxied with a given proxy type
    /// @custom:selector e26d38ed
    /// @param real The real account that maybe has a proxy
    /// @param delegate The account that the caller has maybe proxied
    /// @param proxyType The permissions allowed for the proxy
    /// @param delay The announcement period required of the initial proxy, will generally be zero
    /// @return exists True if a proxy exists, False otherwise
    function isProxy(
        address real,
        address delegate,
        ProxyType proxyType,
        uint32 delay
    ) external view returns (bool exists);
}
    ```

The interface includes the necessary data structures along with the following functions:

???+ function "**addProxy**(delegate, proxyType, delay) â€” registers a proxy account for the sender after a specified number of `delay` blocks (generally zero). Will fail if a proxy for the caller already exists"

    === "Parameters"

        - `delegate` ++"address"++ - the proxy address
        - `proxyType` ++"ProxyType"++ - the delegation type that defines the specific functions the proxy will be granted permission to execute
        - `delay` ++"uint32"++ - number of blocks to wait until the proxy is enabled

    === "Example"

        - `delegate` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217
        - `proxyType` - "Any"
        - `delay` - 0

??? function "**removeProxy**(delegate, proxyType, delay) â€” removes a registered proxy for the sender"

    === "Parameters"

        - `delegate` ++"address"++ - the proxy address to remove
        - `proxyType` ++"ProxyType"++ - the delegation type to remove
        - `delay` ++"uint32"++ - number of blocks to wait until the removal is in effect

    === "Example"

        - `delegate` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217
        - `proxyType` - "Any"
        - `delay` - 0

??? function "**removeProxies**() â€” removes all of the proxy accounts delegated to the sender"

??? function "**isProxy**(real, delegate, proxyType, delay) â€” returns `true` if the delegate address is a proxy of type `proxyType`, for address `real`, with the specified `delay`"

    === "Parameters"

        - `real` ++"address"++ - the account granting permissions to the proxy
        - `delegate` ++"address"++ - the proxy address
        - `proxyType` ++"ProxyType"++ - the delegation type
        - `delay` ++"uint32"++ - number of blocks to wait

    === "Example"

        - `delegate` - 0xbB8919d5DDfc85F4D15820a9e58018f1cfB39a2F
        - `delegate` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217
        - `proxyType` - "Any"
        - `delay` - 0

[The `proxyType` parameter](#proxy-types) is defined by the following `ProxyType` enum, where the values start at `0` with the most permissive proxy type and are represented as `uint8` values:

```solidity
enum ProxyType {
    Any,
    NonTransfer,
    Governance,
    Staking,
    CancelProxy,
    Balances,
    AuthorMapping,
    IdentityJudgement
}
```

### Proxy Types {: #proxy-types }

There are multiple types of proxy roles that can be delegated to accounts, represented in `Proxy.sol` through the `ProxyType` enum. The following list includes all of the possible proxies and the type of transactions they can make on behalf of the primary account:

- **Any** â€” the any proxy will allow the proxy account to make any type of transaction. Note that balance transfers are only allowed to EOAs, not contracts or Precompiles
- **NonTransfer** â€” the non-transfer proxy allows the proxy account to make any type of transaction where the `msg.value` is checked to be zero
- **Governance** - the governance proxy will allow the proxy account to make any type of governance related transaction
- **CancelProxy** - the cancel proxy will allow the proxy account to reject and remove delayed proxy announcements (of the primary account). Currently, this is not an action supported by the Proxy Precompile
- **Balances** - the balances proxy will allow the proxy account to only make balance transfers to EOAs
 
!!! note
    The Solidity interface contains more proxy types than those listed above. The previous list includes only those proxy types implemented in the [baseline EVM Template](/builders/build/templates/evm/){target=\_blank}.

## Interact with the Solidity Interface via Remix {: #interact-with-the-solidity-interface-via-remix }

This section will walk you through the steps to create a proxy, verify its creation, and revoke the proxy privileges. These examples are based on the [Tanssi demo EVM Network](https://apps.tanssi.network/demo){target=\_blank} and use [Metamask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}. This guide can be adapted for your own Tanssi-powered EVM network by adding the RPC URL of your network to the EVM Wallet of your choosing.

### Remix Set Up {: #remix-set-up }

You can interact with the Proxy precompile using [Remix](https://remix.ethereum.org){target=\_blank}. To add the precompile to Remix, you will need to:

1. Get a copy of [`Proxy.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/Proxy.sol){target=\_blank}
2. Paste the file contents into a Remix file named `Proxy.sol`

### Compile the Contract {: #compile-the-contract }

Next, you will need to compile the interface in Remix:

1. Click on the **Compile** tab, second from top
2. Then to compile the interface, click on **Compile Proxy.sol**

![Compiling Proxy.sol](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-1.webp)

When compilation is completed, you will see a green checkmark next to the **Compile** tab.

### Access the Contract {: #access-the-contract }

Instead of deploying the smart contract, you will access the interface through its address:

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix
2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** dropdown. You may be prompted by MetaMask to connect your account to Remix if it's not already connected
3. Make sure the priimary account is displayed under **ACCOUNT**
4. Ensure **Proxy - Proxy.sol** is selected in the **CONTRACT** dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the **At Address** field
5. Provide the address of the Proxy precompile (which is `{{networks.demo_evm.precompiles.proxy}}` in this example) and click **At Address**
6. The **Proxy** precompile will appear in the list of **Deployed Contracts**

![Access the address](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-2.webp)

### Add a Proxy {: #add-proxy }

You can add a proxies for your account calling the precompile functions. In the following example, you will add a proxy allowed to execute any transaction on your behalf:

1. Expand the Proxy Precompile contract to see the available functions
2. Find the **addProxy** function and press the button to expand the section
3. Insert your second account's address as the **delegate**, `0` as **proxyType**, meaning `any`, and `0` as **delay**
4. Click **transact**
5. MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to execute the transaction

!!! note
     When constructing the transaction in Remix, the **proxyType** is represented as a `uint8`, instead of the expected enum `ProxyType`. In Solidity, enums are compiled as `uint8`, so when you pass in `0` for **proxyType**, you indicate the first element in the `ProxyType` enum, which is the `any` proxy.

![Call the addProxy function](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-3.webp)

### Check a Proxy Existence {: #check-proxy }

The function `isProxy` checks if a proxy account exists. After creating a proxy in the [previous step](#add-proxy), use the same parameters to verify that the proxy was successfully added:

1. Expand the **isProxy** function
2. Insert your primary account as **real**, your second account (proxy) as **delegate**, `0` as **proxyType**, and `0` as **delay**
3. Click **call**
4. The functions returns whether there is a proxy or not. In this example, the proxy exists, hence the function returns `true`

![Call the isProxy function](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-4.webp)

### Remove a Proxy {: #remove-proxy }

You can revoke a proxy permission when it's no longer needed. After creating a proxy in the [Add Proxy](#add-proxy), step, it can be removed following these steps:

1. Expand the **removeProxy** function
2. Insert the proxy account as the **delegate**, `0` as **proxyType**, `0` and as **delay**
3. Click **transact** 
4. MetaMask will pop up, and you will be prompted to review the transaction details. Click Confirm to execute the transaction

After the transaction is confirmed, if you repeat the steps to [check for a proxy existence](#check-proxy), the result should be `false`.

![Call the removeProxy function](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-5.webp)

And that's it! You've successfully interacted with the Proxy precompile using MetaMask and Remix!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/rpc/
--- BEGIN CONTENT ---
---
title: JSON-RPC API Methods
description: Learn about the supported JSON-RPC API methods for querying your Tanssi EVM network, including standard Ethereum methods and custom methods unique to Tanssi.
icon: material-code-json
categories: Reference
---

# JSON-RPC API Methods

## Standard Ethereum JSON-RPC Methods {: #standard-rpc-methods }

As Tanssi's EVM Compatibility is derived from [Frontier](https://github.com/polkadot-evm/frontier){target=\_blank} and closely modeled after Moonbeam's Ethereum compatibility, Tanssi nodes support a wide variety of standard supported Ethereum JSON-RPC methods.

Nevertheless, not all Ethereum JSON-RPC methods are supported; some of those supported return default values (those related to Ethereum's PoW consensus mechanism in particular). This guide provides a comprehensive list of supported Ethereum JSON-RPC methods on Tanssi. Developers can quickly reference this list to understand the available functionality for interfacing with Tanssi EVM networks.

The basic JSON-RPC methods from the Ethereum API supported by Tanssi are:

- **[eth_protocolVersion](https://ethereum.org/developers/docs/apis/json-rpc/#eth_protocolversion){target=\_blank}** â€” returns `1` by default
- **[eth_syncing](https://ethereum.org/developers/docs/apis/json-rpc/#eth_syncing){target=\_blank}** â€” returns an object with data about the sync status or `false`
- **[eth_hashrate](https://ethereum.org/developers/docs/apis/json-rpc/#eth_hashrate){target=\_blank}** â€” returns `"0x0"` by default
- **[eth_coinbase](https://ethereum.org/developers/docs/apis/json-rpc/#eth_coinbase){target=\_blank}** â€” returns the latest block author. Not necessarily a finalized block
- **[eth_mining](https://ethereum.org/developers/docs/apis/json-rpc/#eth_mining){target=\_blank}** â€” returns `false` by default
- **[eth_chainId](https://ethereum.org/developers/docs/apis/json-rpc/#eth_chainid){target=\_blank}** â€” returns the chain ID used for signing at the current block
- **[eth_gasPrice](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gasprice){target=\_blank}** â€” returns the base fee per unit of gas used. This is currently the minimum gas price for each network
- **[eth_accounts](https://ethereum.org/developers/docs/apis/json-rpc/#eth_accounts){target=\_blank}** â€” returns a list of addresses owned by the client
- **[eth_blockNumber](https://ethereum.org/developers/docs/apis/json-rpc/#eth_blocknumber){target=\_blank}** â€” returns the highest available block number
- **[eth_getBalance](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getbalance){target=\_blank}** â€” returns the balance of the given address
- **[eth_getStorageAt](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getstorageat){target=\_blank}** â€” returns the content of the storage at a given address
- **[eth_getBlockByHash](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getblockbyhash){target=\_blank}** â€” returns information about the block of the given hash, including `baseFeePerGas` on post-London blocks
- **[eth_getBlockByNumber](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getblockbynumber){target=\_blank}** â€” returns information about the block specified by block number, including `baseFeePerGas` on post-London blocks
- **[eth_getBlockReceipts](https://www.alchemy.com/docs/chains/ethereum/ethereum-api-endpoints/eth-get-block-receipts){target=\_blank}** â€” returns all transaction receipts for a given block
- **[eth_getTransactionCount](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactioncount){target=\_blank}** â€” returns the number of transactions sent from the given address (nonce)
- **[eth_getBlockTransactionCountByHash](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash){target=\_blank}** â€” returns the number of transactions in a block with a given block hash
- **[eth_getBlockTransactionCountByNumber](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber){target=\_blank}** â€” returns the number of transactions in a block with a given block number
- **[eth_getUncleCountByBlockHash](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getunclecountbyblockhash){target=\_blank}** â€”  returns `"0x0"` by default
- **[eth_getUncleCountByBlockNumber](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getunclecountbyblocknumber){target=\_blank}** â€” returns `"0x0"` by default
- **[eth_getCode](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getcode){target=\_blank}** â€” returns the code at the given address at the given block number
- **[eth_sendTransaction](https://ethereum.org/developers/docs/apis/json-rpc/#eth_sendtransaction){target=\_blank}** â€” creates a new message call transaction or a contract creation, if the data field contains code. Returns the transaction hash or the zero hash if the transaction is not yet available
- **[eth_sendRawTransaction](https://ethereum.org/developers/docs/apis/json-rpc/#eth_sendrawtransaction){target=\_blank}** â€” creates a new message call transaction or a contract creation for signed transactions. Returns the transaction hash or the zero hash if the transaction is not yet available
- **[eth_call](https://ethereum.org/developers/docs/apis/json-rpc/#eth_call){target=\_blank}** â€” executes a new message call immediately without creating a transaction on the blockchain, returning the value of the executed call
- **[eth_estimateGas](https://ethereum.org/developers/docs/apis/json-rpc/#eth_estimategas){target=\_blank}** â€” returns an estimated amount of gas necessary for a given transaction to succeed. You can optionally specify a `gasPrice` or `maxFeePerGas` and `maxPriorityFeePerGas`
- **[eth_feeHistory](https://www.alchemy.com/docs/chains/ethereum/ethereum-api-endpoints/eth-fee-history){target=\_blank}** â€” returns `baseFeePerGas`, `gasUsedRatio`, `oldestBlock`, and `reward` for a specified range of up to 1024 blocks
- **[eth_getTransactionByHash](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactionbyhash){target=\_blank}** â€” returns the information about a transaction with a given hash. EIP-1559 transactions have `maxPriorityFeePerGas` and `maxFeePerGas` fields
- **[eth_getTransactionByBlockHashAndIndex](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactionbyblockhashandindex){target=\_blank}** â€” returns information about a transaction at a given block hash and a given index position. EIP-1559 transactions have `maxPriorityFeePerGas` and `maxFeePerGas` fields
- **[eth_getTransactionByBlockNumberAndIndex](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactionbyblocknumberandindex){target=\_blank}** â€” returns information about a transaction at a given block number and a given index position. EIP-1559 transactions have `maxPriorityFeePerGas` and `maxFeePerGas` fields
- **[eth_getTransactionReceipt](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactionreceipt){target=\_blank}** â€” returns the transaction receipt of a given transaction hash
- **[eth_getUncleByBlockHashAndIndex](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getunclebyblockhashandindex){target=\_blank}** â€” returns `null` by default
- **[eth_getUncleByBlockNumberAndIndex](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getunclebyblocknumberandindex){target=\_blank}** â€” returns `null` by default
- **[eth_getLogs](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getlogs){target=\_blank}** â€” returns an array of all logs matching a given filter object
- **[eth_newFilter](https://ethereum.org/developers/docs/apis/json-rpc/#eth_newfilter){target=\_blank}** â€” creates a filter object based on the input provided. Returns a filter ID
- **[eth_newBlockFilter](https://ethereum.org/developers/docs/apis/json-rpc/#eth_newblockfilter){target=\_blank}** â€” creates a filter in the node to notify when a new block arrives. Returns a filter ID
- **[eth_getFilterChanges](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getfilterchanges){target=\_blank}** â€” polling method for filters (see methods above). Returns an array of logs that occurred since the last poll
- **[eth_getFilterLogs](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getfilterlogs){target=\_blank}** â€” returns an array of all the logs matching the filter with a given ID
- **[eth_uninstallFilter](https://ethereum.org/developers/docs/apis/json-rpc/#eth_uninstallfilter){target=\_blank}** â€” uninstall a filter with a given ID. It should be used when polling is no longer needed. Filters timeout when they are not requested using `eth_getFilterChanges` after some time

## Custom JSON-RPC Methods {: #custom-json-rpc-methods }

Tanssi nodes support two custom JSON-RPC endpoints: `frnt_isBlockFinalized` and `frnt_isTxFinalized`. Tanssi features deterministic finality (as opposed to probabilistic like Bitcoin's finality), which means that at any point of time, the answer to whether a block or transaction is finalized or not can be answered with a definitive yes or no. Tanssi has built these two custom endpoints to provide valuable functionality for checking the finality of on-chain events.

???+ function "frnt_isBlockFinalized - checks for the finality of the block given by its block hash"

    === "Parameters"

        - `block_hash` ++"string"++ - the hash of the block, accepts either Substrate-style or Ethereum-style block hash as its input

    === "Returns"

        ++"boolean"++ - `true` if the block is finalized, `false` if the block is not finalized or not found

    === "Example"

        ```bash
        curl -H "Content-Type: application/json" -X POST --data '{
          "jsonrpc": "2.0",
          "id": "1",
          "method": "frnt_isBlockFinalized",
          "params": ["INSERT_BLOCK_HASH"]
        }' {{ networks.dancelight.demo_evm_rpc_url }}
        ```

???+ function "frnt_isTxFinalized - checks for the finality of a transaction given its EVM transaction hash"

    === "Parameters"

        - `tx_hash` ++"string"++ - the EVM transaction hash of the transaction 

    === "Returns"

        ++"boolean"++ - `true` if the transaction is finalized, `false` if the transaction is not finalized or not found

    === "Example"

        ```bash
        curl -H "Content-Type: application/json" -X POST --data '{
          "jsonrpc": "2.0",
          "id": "1",
          "method": "frnt_isTxFinalized",
          "params": ["INSERT_TRANSACTION_HASH"]
        }' {{ networks.dancelight.demo_evm_rpc_url }}
        ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/wallets/
--- BEGIN CONTENT ---
---
title: Ethereum API Wallets
description: Learn how to interact with your Tanssi-powered EVM network through the Ethereum API including configuring wallets, adding RPC Urls, and sending funds.
icon: material-wallet-outline
template: index-page.html
---

# Wallets

Wallets are digital tools that allow users to securely store, manage, and transact with their digital assets. They store the cryptographic keys required to access digital assets and enable one to execute transactions on blockchain networks.

For EVM-compatible networks, you can use any wallet that supports EVM, with the flexibility to add custom network configurations, enabling seamless connection and interaction with your network.

The pages in this section provide an overview of getting started with various wallet providers. It covers how to create and import accounts, connect to your network, and begin interacting with it.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/wallets/ledger/
--- BEGIN CONTENT ---
---
title: Using Ledger With Your EVM Appchain
description: Learn to set up and use Ledger hardware wallets with Tanssi-powered EVM appchains for secure offline key storage and transaction signing.
icon: material-wallet-outline 
categories: EVM-Template
---

# Interacting with Tanssi-powered EVM appchains Using Ledger

## Introduction {: #introduction }

Developers and users of Tanssi-powered EVM appchains, such as the [Tanssi demo](https://apps.tanssi.network/demo){target=\_blank} EVM appchain, have a variety of options when it comes to wallets. Regarding cold wallets, which store your private keys in a secure, offline environment, [Ledger](https://www.ledger.com/){target=\_blank} is one of the most popular options. Ledger provides full support for Substrate blockchains, such as the Tanssi network.

Ledger devices are hardware wallets designed to store the private keys offline. They are used to verify and sign the transactions, but they still need a software layer to provide the UI that interacts with the networks, builds the transactions, and sends the signed transactions back to the network once the user has verified them.

This guide takes you through all the necessary steps to use your Ledger device with Tanssi-powered EVM appchains.

## Setting Up Your Ledger Device {: #setting-up-ledger-device }

If you have a brand new Ledger device, refer to the [official website](https://support.ledger.com/article/4404389503889-zd){target=\_blank} for a guide on getting it started with the initial setup.

Now, with your Ledger already initiated, install the _Ethereum_ app taking the following steps:

1. Open the Ledger Live App on your computer.
2. Go to My Ledger.
3. Connect and unlock the device.

Finally, search for the **Ethereum (ETH)** app in Ledger Live and install it on your device.

![Install Ethereum in Ledger Live](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-1.webp)

And that's it. Your device now has an Ethereum account and is able to sign transactions on any Tanssi-powered EVM appchain.

## Adding the Ledger to a Hot Wallet {: #adding-Ledger-hot-wallet }

As presented in the [introduction](#introduction), a Ledger hardware wallet provides secure, offline storage for private keys, allowing users to verify and sign transactions. However, by design, it can't interact with blockchains or dApps by itself, nor does it offer a UI for managing assets. To complement the device, a hot wallet is required. The user can choose any Ethereum-compatible wallet.

For demonstration purposes, we'll show how to configure [Metamask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} to work with your hardware wallet, but these steps are generally applicable to any other wallet that supports Ledger. To follow along with the steps, make sure you have Metamask installed in your browser, then open the extension and click on the dropdown icon next to the account name.

![Connect Ledger](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-2.webp)

Now click on the **+ Add account or hardware wallet** button.

![Connect Ledger](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-3.webp)

Select **Hardware wallet** from the available options.

![Connect Ledger](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-4.webp)

On the following screen:

1. Select the **LEDGER** box. You'll be prompted to connect your Ledger, unlock it, and open the Ethereum app.
2. Click on **Continue**.

![Connect Ledger](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-5.webp)

Finally, you will be presented with a list of derived accounts. Select the one you want to import, click **Unlock**, and that's all! Your Metamask wallet can now sign transactions using your Ledger device.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/wallets/metamask/
--- BEGIN CONTENT ---
---
title: How to Connect MetaMask
description: This guide walks you through how to connect MetaMask, a browser-based Ethereum wallet, to your Tanssi-powered EVM-compatible network and how to transfer funds.
icon: material-wallet-outline
categories: EVM-Template
---

# Interacting with your Tanssi EVM Network Using MetaMask

## Introduction {: #introduction }

Developers building dApps on top of Tanssi-powered EVM networks can leverage their Ethereum compatibility features by integrating known Ethereum wallets, such as [MetaMask](https://metamask.io){target=\_blank}. By doing so, they can use the injected library MetaMask provides to interact with the Tanssi EVM network.

This guide takes you through all the necessary steps: from installing Metamask, to setting up a wallet, and finally connecting it to your Tanssi EVM network.

!!! note
    You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.

## Install the MetaMask Extension {: #install-the-metamask-extension }

First, you'll start with a fresh and default [MetaMask](https://metamask.io){target=\_blank} installation from the Chrome store. After downloading, installing, and initializing the extension, follow the **Get Started** steps to [setup the wallet](#setup-a-wallet). In there, you need to create a wallet, set a password, and store your secret backup phrase (this gives direct access to your funds, so make sure to store these in a secure place).

!!! note
    The Metamask browser extension is compatible with Chrome, Chromium based browsers (such as Microsoft Edge and Opera), and Firefox. Metamask is also available as a mobile app for iOS and Android devices.

## Setup a Wallet {: #setup-a-wallet }

After installing [MetaMask](https://metamask.io){target=\_blank}, the setup will automatically open a new task with a welcome screen. Here, you are offered two options:

- **Create a new wallet** - you'll go through some steps to get a new seed phrase. Ensure you store this phrase securely and you don't share it publicly
- **Import an existing wallet** - you already have a seed phrase stored, and you want to restore an account from that recovery phrase

![Metamask Setup Interface](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-1.webp)

Once you've clicked on the option that adapts to your needs, follow the steps, and you should be all setup.

!!! note
    Multiple accounts can be derived from a seed phrase by changing what is known as the address index. By default, when creating or importing an account from the seed phrase, you get the account with the address index 0. You can get the other indexes by just adding new accounts in the main Metamask screen.

## Import Accounts {: #import-accounts }

Once you've created a wallet or imported an existing one, you can also import any account into MetaMask if you hold the private keys.

For this example, you'll use private keys from the development account. Click the account switcher button to import an account using its private keys. That is where it says **Account 1**.

![Importing account from private key metamask menu](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-2.webp)

Next, click on **Import Account**.

![Importing account from private key account switcher menu](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-3.webp)

Finally, enter the private keys of the account you are trying to import. Once you've entered the private key, click on **Import**.

![Paste your account key into MetaMask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-4.webp)

You should end up with an imported **Account 2** that looks like this:

![MetaMask displaying your new Account 2](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-5.webp)

## Connect MetaMask to your Tanssi EVM Network {: #connect-metamask-to-evm-network }

Once you have [MetaMask](https://metamask.io){target=\_blank} installed and have created or imported an account, you can connect it to your Tanssi EVM network. To do so, take the following steps:

1. Click in the upper left network selector menu
2. Select **Add Network**

![Add new network in Metamask menu](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-6.webp)

Next, go to the bottom of the page and click on **Add network manually**:

![Add network manually in Metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-7.webp)

Here, you can configure MetaMask for the following networks:

|         Variable          |                        Value                        |
|:-------------------------:|:---------------------------------------------------:|
|       Network Name        |             `Tanssi demo EVM appchain`              |
|          RPC URL          |    `{{ networks.dancelight.demo_evm_rpc_url }}`     |
|         Chain ID          |    `{{ networks.dancelight.demo_evm_chain_id }}`    |
|     Symbol (Optional)     |  `{{ networks.dancelight.demo_evm_token_symbol }}`  |
| Block Explorer (Optional) | `{{ networks.dancelight.demo_evm_blockscout_url }}` |

To do so, fill in the following information:

1. **Network name** - name that represents the network you are connecting to
2. **RPC URL** - RPC endpoint of the network
3. **Chain ID** - chain ID of the Ethereum compatible network
4. **Symbol** - (optional) symbol of the native token of the network
5. **Block Explorer** - (optional) URL of the block explorer
6. Once you've verified all the information, click on **Save**

![Add network in Metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-8.webp)

Once you've added the network, you'll be redirected to a screen stating that you've successfully added a network. Furthermore, you'll be prompted to **Switch to Tanssi demo EVM appchain**, the network added in this example.

![Successfully added a network in Metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-9.webp)

## Interact with the Network {: #interact-with-network }

Once you've [connected Metamask](#connect-metamask-to-evm-network) to your Tanssi EVM network, you can start using your wallet by:

- Requesting {{ networks.dancelight.demo_evm_token_symbol }} tokens from the [demo EVM network faucet](/builders/tanssi-network/testnet/demo-evm-network/#faucet)
- Sending a token transfer to another address
- Adding ERC-20s to Metamask and interacting with them
- Adding ERC-721s to Metamask and interacting with them

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/wallets/subwallet/
--- BEGIN CONTENT ---
---
title: How to Connect SubWallet to Tanssi
description: This guide walks you through how to connect SubWallet, a comprehensive Polkadot, Substrate, and Ethereum wallet, to your Tanssi-powered EVM-compatible network.
icon: material-wallet-outline
categories: EVM-Template
---

# Interacting with Your Tanssi EVM Network Using SubWallet

## Introduction {: #introduction }

Developers and users of Tanssi-powered EVM networks have a variety of options when it comes to wallets. Thanks to their seamless Ethereum compatibility, Tanssi EVM networks support a great variety of popular wallets, including SubWallet.

SubWallet is a comprehensive Web3 wallet that natively supports Substrate (Polkadot) and Ethereum accounts. This tutorial centers on the Ethereum API, but you can check out a similar [tutorial for interacting with SubWallet using the Substrate API](/builders/toolkit/substrate-api/wallets/subwallet/){target=\_blank}. The SubWallet wallet browser extension [can be downloaded](https://www.subwallet.app/download.html){target=\_blank} for all supported browsers, including Chrome, Brave, Firefox, and MS Edge. SubWallet also has a mobile app for both iOS and Android, but that is beyond the scope of this guide. A complete online asset dashboard is accessible at [web.subwallet.app](https://web.subwallet.app){target=\_blank}.

This guide takes you through all the necessary steps, from installing SubWallet to setting up a wallet, connecting it to your Tanssi EVM network, and sending funds.

## Creating Your First Ethereum Account {: #creating-your-first-ethereum-account }

First, download and install the [SubWallet extension](https://www.subwallet.app/download.html){target=\_blank}. Creating a new account will generate a seed phrase that can derive multiple Ethereum and Substrate accounts. By default, SubWallet will generate a single Ethereum and a single Substrate account, but you can easily derive more from the same seed phrase. Click **Create a new account** to get started.

![Get started with SubWallet](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-1.webp)

On the following screen, you'll be prompted to create a password to secure your new wallet.

![Create a password for SubWallet](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-2.webp)

You'll then be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.

![Back up your seed phrase in SubWallet](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-3.webp)

!!! note
    You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.

## Importing an Existing EVM Account {: #importing-an-existing-evm-account }

Of course, you can import an existing EVM account into SubWallet. To get started, take the following steps:

1. Press the **All accounts** button at the top
2. Press the **Import account** icon

![Import account part 1](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-4.webp)

On the following screen, select the method by which you would like to import the existing account.

![Import existing account part 2](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-5.webp)

On the following screen, you'll be able to provide the relevant seed phrase, private key, JSON file, or QR code, and you can begin using your new account right away.

## Configuring SubWallet for Your EVM Network {: #configuring-subwallet-for-your-evm-network }

To configure SubWallet for your Tanssi-powered EVM network, press the **More Options** icon in the upper left corner. Then click **Manage networks**. Press the **+** icon. On the following page, you'll then be prompted to enter the network details for your Tanssi network. For demonstration purposes, the demo EVM network is used here, but you can substitute these details for your own Tanssi network. To add your Tanssi network to SubWallet, take the following steps:

1. Paste in the HTTPS RPC URL of your Tanssi network. The demo EVM network's RPC URL is `{{ networks.dancelight.demo_evm_rpc_url }}`. Other parameters will be auto-populated
2. Paste in the block explorer URL of your Tanssi network. The demo EVM network's block explorer URL is `{{ networks.dancelight.demo_evm_blockscout_url }}`
3. Press **Save**

![Add your Tanssi-Powered Network Details in SubWallet](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-6.webp)

By default, all balances are hidden in SubWallet, but if you press the eye icon, you can toggle balance visibility.

## Sending Assets on Your EVM Network {: #sending-assets-on-your-evm-network }

To transfer the native token of your Tanssi network, take the following steps:

1. Specify the asset to send
2. Specify the destination chain (in this case, the same chain that you're sending from)
3. Enter the destination address
4. Enter the number of tokens to send
5. Look over the transaction details, then press **Transfer** and subsequently **Approve**

![Send funds on your Tanssi EVM Network](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-7.webp)

This guide focused specifically on configuring SubWallet to work with your Tanssi EVM network, but SubWallet is also a full-featured wallet for Substrate (Polkadot) accounts. Under the Substrate API section, you'll find a [similar guide for configuring SubWallet for use with your Substrate network](/builders/toolkit/substrate-api/wallets/subwallet/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/ethereum-api/wallets/talisman/
--- BEGIN CONTENT ---
---
title: How to Connect Talisman to Tanssi
description: This guide walks you through how to connect Talisman, a comprehensive Polkadot, Substrate, and Ethereum wallet, to your Tanssi-powered EVM-compatible network.
icon: material-wallet-outline
categories: EVM-Template
---

# Interacting with Your Tanssi EVM Network Using Talisman

## Introduction {: #introduction }

Developers and users of Tanssi-powered EVM networks have a variety of options when it comes to wallets. Thanks to their seamless Ethereum compatibility, Tanssi EVM networks support a great variety of popular wallets, such as Talisman.

Talisman is a Web3 wallet that natively supports Substrate (Polkadot) and Ethereum accounts. This tutorial centers on the Ethereum API, but you can check out a similar [tutorial for interacting with Talisman using the Substrate API](/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank}. The Talisman wallet browser extension is available on [Google Chrome](https://chromewebstore.google.com/detail/talisman-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld){target=\_blank} and [Brave](https://chromewebstore.google.com/detail/talisman-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld){target=\_blank}, and a corresponding asset dashboard is accessible at [app.talisman.xyz](https://app.talisman.xyz){target=\_blank}

This guide takes you through all the necessary steps, from installing Talisman to setting up a wallet, connecting it to your Tanssi EVM network, and sending funds.

## Setting Up Talisman {: #setting-up-talisman }

First, download and install the [Talisman extension](https://talisman.xyz/){target=\_blank}. This guide will first cover creating a new wallet and later address importing an existing one. Review the terms and conditions, then press **Get Started**.

![Get started with Talisman](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-1.webp)

On the following screen, you'll be prompted to create a password to secure your new wallet.

![Enter password for Talisman Wallet](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-2.webp)

## Creating an Ethereum Account {: #creating-an-ethereum-account }

To create your first Ethereum account, take the following steps:

1. Select the **Ethereum** option
2. Give your account a name
3. Press **Create**

![Create your first Ethereum account in Talisman](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-3.webp)

After creating your first account, you'll be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.

![Back up your seed phrase](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-4.webp)

!!! note
    You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.

## Importing an Existing EVM Account {: #importing-an-existing-evm-account }

Of course, you can import an existing EVM account into Talisman. To do so, take the following steps:

1. Press **Add Account**
2. Press **Import**
3. Select **Import via Recovery Phrase** (note, this works for both seeds and private keys)

![Import existing account setup](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-9.webp)

On the following screen, take the following steps:

1. Select the **Ethereum** account type
2. Provide a name for your account
3. Paste in your seed or private key
4. If you imported a mnenomic seed phrase in the prior step, select which accounts you'd like to import
5. Press **Import**

![Import existing account final steps](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-10.webp)

## Configuring Talisman for Your EVM Network {: #configuring-talisman-for-your-evm-network }

To configure Talisman for your Tanssi EVM network, open the Talisman extension and click on the **More Options** tab. Then, take the following steps:

1. Select **Settings**
2. Check the **Enable testnets** box
3. Press **Add Network**

![Add Network in Talisman](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-6.webp)

On the following page, you'll then be prompted to enter the network details for your Tanssi-powered network. For demonstration purposes, the demo EVM network is used here, but you can substitute these details for your own network. To add your network to Talisman, take the following steps:

1. Paste in the RPC URL of your Tanssi-powered network. The demo EVM network's RPC URL is `{{ networks.dancelight.demo_evm_rpc_url }}`. Other parameters will be autopopulated
2. Paste in the block explorer URL of your Tanssi-powered network. The demo EVM network's block explorer URL is `{{ networks.dancelight.demo_evm_blockscout_url }}`
3. Check the **This is a testnet** box if applicable
4. Press **Add Network**

![Add your Tanssi-Powered Network Details](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-7.webp)

If you hold a balance of tokens in your newly created account for your network, you'll see the balance in the Talisman dashboard.

## Sending Assets on Your EVM Network {: #sending-assets-on-your-evm-network }

To transfer the native token of your Tanssi network, take the following steps:

1. Click on the **Send** icon
2. Click the desired **Send from** account
3. Enter the destination address
4. Enter the amount of tokens to send
5. Look over the transaction details, then press **Review** and subsequently **Confirm**

![Send funds on your EVM network](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-8.webp)

This guide focused specifically on configuring Talisman to work with your Tanssi-powered EVM network, but Talisman is also a full-featured wallet for Substrate (Polkadot) accounts. Under the Substrate API section, you'll find a similar tutorial for configuring Talisman to work with Substrate-based chains.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/
--- BEGIN CONTENT ---
---
title: Guides for Developing DApps
description: Dive into tutorials, tools, and resources designed to streamline the development process when building dApps on Tanssi and Tanssi-powered networks.
icon: octicons-tools-24
template: index-page.html
---

# Toolkit

The Toolkit section is your all-in-one resource hub for building, deploying, and managing Tanssi-powered networks. It brings together Ethereum and Substrate tools, such as libraries, development environments, precompiles, JSON-RPC methods, and more. Whether you're enhancing an existing network or implementing new features, this toolkit gives you everything you need to simplify the development and operation of your network.

!!! tip
    If you are working with an EVM-compatible network, you can use Substrate tools to interact with the lower-level functionalities of your network. Using this, you can interact with custom runtime modules, query storage, manage governance, or work with features unique to Substrate.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/
--- BEGIN CONTENT ---
---
title: Integrations
description: Uncover some of the available integrations, ready to seamlessly integrate with and extend the functionality of your apps on Tanssi EVM or Substrate networks.
icon: octicons-package-24
template: index-page.html
---

# Integrations

Discover integrations that enable you to extend the functionality of your Tanssi-powered dApps. These integrations enable seamless interaction with external data sources, enhance user experience, and enable advanced features such as on-chain data feeds, analytics, and wallet support.

Ready to start building? Check out the following integrations:

- **Oracles** - [Acurast](/builders/toolkit/integrations/oracles/acurast/), [Band](/builders/toolkit/integrations/oracles/band/), and [Phala](/builders/toolkit/integrations/oracles/phala/)
- **Indexers** - [SQD](/builders/toolkit/integrations/indexers/sqd/quick-start/)
- **Wallets** - [RainbowKit](/builders/toolkit/integrations/wallet-integrations/rainbowkit/)

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/indexers/
--- BEGIN CONTENT ---
---
title: EVM Blockchain Data Indexers
description: Learn how to use blockchain indexers to ingest, process, refine, and query Ethereum (EVM) data on Your Tanssi-powered EVM-compatible network.
icon: octicons-codescan-24
template: index-page.html
---

# Indexers 

Indexers enable efficient ingestion, processing, and querying of blockchain data, providing developers with powerful tools to create responsive and data-rich applications on Tanssi-powered networks.

Main features of indexers include:

- **Improved data access speed** - faster querying of on-chain data by organizing and indexing it, enabling quicker retrieval times
- **Data aggregation** - ingest and transform data that is easier to query and work with large amounts of data
- **Enhanced querying capabilities** - use sophisticatd querying methods, such as filtering, sorting, and pagination
- **Real-time data updates** - synchronization with the blockchain enables applications to access the latest information as soon as its available

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/indexers/sqd/erc20-transfers/
--- BEGIN CONTENT ---
---
title: Index ERC-20 Transfers on an EVM Network
description: Learn how to use the Squid SDK, a query node framework that can index both Substrate and EVM data, to process blockchain data for your Tanssi-powered network.
icon: octicons-arrow-switch-24
categories: EVM-Template
---

# Indexing ERC-20 Transfers on a Tanssi EVM Network

## Introduction {: #introduction }

[SQD](https://www.sqd.ai/){target=\_blank} is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using SQDâ€™s decentralized data lake and open-source SDK. In very simple terms, SQD can be thought of as an ETL (extract, transform, and load) tool with a [GraphQL](https://graphql.org){target=\_blank} server included. It enables comprehensive filtering, pagination, and even full-text search capabilities.

SQD has native and full support for both EVM and Substrate data. SQD offers a Substrate Archive and Processor and an EVM Archive and Processor. The Substrate Archive and Processor can be used to index both Substrate and EVM data. This allows developers to extract on-chain data from any Tanssi-powered network and process EVM logs as well as Substrate entities (events, extrinsics, and storage items) in one single project and serve the resulting data with one single GraphQL endpoint. If you exclusively want to index EVM data, it is recommended to use the EVM Archive and Processor.

This tutorial is a step-by-step guide to building a Squid to index EVM data from start to finish. It's recommended that you follow along, taking each step described on your own, but you can also find a [complete version of the Squid built in this tutorial in the tanssiSquid GitHub repository](https://github.com/themacexpert/tanssiSquid){target=\_blank}.

## Check Prerequisites {: #check-prerequisites }

To follow along with this tutorial, you'll need to have:

- [Docker installed](https://docs.docker.com/get-started/get-docker/){target=\_blank}
- [Docker Compose installed](https://docs.docker.com/compose/install){target=\_blank}
- An empty Hardhat project. For step-by-step instructions, please refer to the [Creating a Hardhat Project](/builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project){target=\_blank} section of our Hardhat documentation page

!!! note
    The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.
    
    Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their [official documentation](https://nodejs.org/en/download){target=\blank}.
    
    Also, make sure you've initialized a `package.json` file for ES6 modules. You can initialize a default `package.json` file using npm by running the following command `npm init --yes`.

## Deploy an ERC-20 with Hardhat {: #deploy-an-erc20-with-hardhat }

Before we can index anything with SQD we need to make sure we have something to index! This section will walk through deploying an ERC-20 token to your Tanssi-powered network so you can get started indexing it. However, you can feel free to skip to [Create a Squid Project](#create-a-squid-project) if either of the two scenarios apply:

- You have already deployed an ERC-20 token to your network (and made several transfers)
- You would prefer to use an existing ERC-20 token deployed to the demo EVM network (of which there are already several transfer events)

If you'd like to use an existing ERC-20 token on the demo EVM network, you can use the below `MyTok.sol` contract. The hashes of the token transfers are provided as well to assist with any debugging.

In this section, we'll show you how to deploy an ERC-20 to your EVM network and we'll write a quick script to fire off a series of transfers that will be picked up by our SQD indexer. Ensure that you have initialized an empty Hardhat project via the instructions in the [Creating a Hardhat Project](/builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project){target=\_blank} section of our Hardhat documentation page.

Before we dive into creating our project, let's install a couple of dependencies that we'll need: the [Hardhat Ethers plugin](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-ethers){target=\_blank} and [OpenZeppelin contracts](https://docs.openzeppelin.com/contracts/4.x){target=\_blank}. The Hardhat Ethers plugin provides a convenient way to use the [Ethers](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank} library to interact with the network. We'll use OpenZeppelin's base ERC-20 implementation to create an ERC-20. To install both of these dependencies, you can run:

=== "npm"

    ```bash
    npm install @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts
    ```

=== "yarn"

    ```bash
    yarn add @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts
    ```

Now we can edit `hardhat.config.js` to include the following network and account configurations for our network. You can replace the demo EVM network values with the respective parameters for your own Tanssi-powered EVM network which can be found at [apps.tanssi.network](https://apps.tanssi.network){target=\_blank}.

???+ code "hardhat.config.js"

    ```js
    // 1. Import the Ethers plugin required to interact with the contract
require('@nomicfoundation/hardhat-ethers');

// 2. Add your private key that is funded with tokens of your Tanssi-powered network
// This is for example purposes only - **never store your private keys in a JavaScript file**
const privateKey = 'INSERT_PRIVATE_KEY';

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  // 3. Specify the Solidity version
  solidity: '0.8.20',
  networks: {
    // 4. Add the network specification for your Tanssi EVM network
    demo: {
      url: 'https://services.tanssi-testnet.network/dancelight-2001/',
      chainId: 5678, // Fill in the EVM ChainID for your Tanssi-powered network
      accounts: [privateKey],
    },
  },
};
    ```

!!! remember
    You should never store your private keys in a JavaScript or Python file. It is done in this tutorial for ease of demonstration only. You should always manage your private keys with a designated secret manager or similar service.

### Create an ERC-20 Contract {: #create-an-erc-20-contract }

For the purposes of this tutorial, we'll be creating a simple ERC-20 contract. We'll rely on OpenZeppelin's ERC-20 base implementation. We'll start by creating a file for the contract and naming it `MyTok.sol`:

```bash
mkdir -p contracts && touch contracts/MyTok.sol
```

Now we can edit the `MyTok.sol` file to include the following contract, which will mint an initial supply of MYTOKs and allow only the owner of the contract to mint additional tokens:

???+ code "MyTok.sol"

    ```solidity
    // SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyTok is ERC20, Ownable {
    constructor() ERC20("MyToken", "MTK") Ownable(msg.sender) {
        _mint(msg.sender, 50000 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
    ```

### Deploy an ERC-20 Contract {: #deploy-erc-20-contract }

Now that we have our contract set up, we can compile and deploy our contract.

To compile the contract, you can run:

```bash
npx hardhat compile
```

![Compile contracts using Hardhat](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-1.webp)

This command will compile our contract and generate an `artifacts` directory containing the ABI of the contract.

To deploy our contract, we'll need to create a deployment script that deploys our ERC-20 contract and mints an initial supply of MYTOKs. We'll use Alith's account to deploy the contract, and we'll specify the initial supply to be 1000 MYTOK. The initial supply will be minted and sent to the contract owner, which is Alith.

Let's take the following steps to deploy our contract:

1. Create a directory and file for our script:

    ```bash
    mkdir -p scripts && touch scripts/deploy.js
    ```

2. In the `deploy.js` file, go ahead and add the following script:

    ???+ code "deploy.js"

        ```ts
        // scripts/deploy.js
const hre = require('hardhat');
require('@nomicfoundation/hardhat-ethers');

async function main() {
  // Get ERC-20 contract
  const MyTok = await hre.ethers.getContractFactory('MyTok');

  // Define custom gas price and gas limit
  // This is a temporary stopgap solution to a bug
  const customGasPrice = 50000000000; // example for 50 gwei
  const customGasLimit = 5000000; // example gas limit

  // Deploy the contract providing a gas price and gas limit
  const myTok = await MyTok.deploy({
    gasPrice: customGasPrice,
    gasLimit: customGasLimit,
  });

  // Wait for the deployment
  await myTok.waitForDeployment();

  console.log(`Contract deployed to ${myTok.target}`);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
        ```

3. Run the script using the `dev` network configurations we set up in the `hardhat.config.js` file:

    ```bash
    npx hardhat run scripts/deploy.js --network demo
    ```

The address of the deployed contract should be printed to the terminal. Save the address, as we'll need it to interact with the contract in the following section.

### Transfer ERC-20s {: #transfer-erc-20s }

Since we'll be indexing `Transfer` events for our ERC-20, we'll need to send a few transactions that transfer some tokens from Alith's account to our other test accounts. We'll do this by creating a simple script that transfers 10 MYTOKs to Baltathar, Charleth, Dorothy, and Ethan. We'll take the following steps:

Create a new file script to send transactions:

```bash
touch scripts/transactions.js
```

In the `transactions.js` file, add the following script and insert the contract address of your deployed MyTok contract (output in the console in the prior step):

???+ code "transactions.js"

    ```ts
    // We require the Hardhat Runtime Environment explicitly here. This is optional
// but useful for running the script in a standalone fashion through `node <script>`.
//
// You can also run a script with `npx hardhat run <script>`. If you do that, Hardhat
// will compile your contracts, add the Hardhat Runtime Environment's members to the
// global scope, and execute the script.
const hre = require('hardhat');

async function main() {
  // Get Contract ABI
  const MyTok = await hre.ethers.getContractFactory('MyTok');

  // Define custom gas price and gas limit
  // Gas price is typically specified in 'wei' and gas limit is just a number
  // You can use Ethers.js utility functions to convert from gwei or ether if needed
  const customGasPrice = 50000000000; // example for 50 gwei
  const customGasLimit = 5000000; // example gas limit

  // Plug ABI to address
  const myTok = await MyTok.attach('INSERT_CONTRACT_ADDRESS');

  const value = 100000000000000000n;

  let tx;
  // Transfer to Baltathar
  tx = await myTok.transfer(
    '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',
    value,
    {
      gasPrice: customGasPrice,
      gasLimit: customGasLimit,
    }
  );
  await tx.wait();
  console.log(`Transfer to Baltathar with TxHash ${tx.hash}`);

  // Transfer to Charleth
  tx = await myTok.transfer(
    '0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc',
    value,
    {
      gasPrice: customGasPrice,
      gasLimit: customGasLimit,
    }
  );
  await tx.wait();
  console.log(`Transfer to Charleth with TxHash ${tx.hash}`);

  // Transfer to Dorothy
  tx = await myTok.transfer(
    '0x773539d4Ac0e786233D90A233654ccEE26a613D9',
    value,
    {
      gasPrice: customGasPrice,
      gasLimit: customGasLimit,
    }
  );
  await tx.wait();
  console.log(`Transfer to Dorothy with TxHash ${tx.hash}`);

  // Transfer to Ethan
  tx = await myTok.transfer(
    '0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB',
    value,
    {
      gasPrice: customGasPrice,
      gasLimit: customGasLimit,
    }
  );
  await tx.wait();
  console.log(`Transfer to Ethan with TxHash ${tx.hash}`);
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
    ```

Run the script to send the transactions:

```bash
npx hardhat run scripts/transactions.js --network demo
```

As each transaction is sent, you'll see a log printed to the terminal.

![Send transactions using Hardhat](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-2.webp)

Now we can move on to creating our Squid to index the data on our local development node.

## Create a Squid Project {: #create-a-squid-project }

Now we're going to create our Subquid project. First, we'll need to install the [Squid CLI](https://docs.sqd.ai/squid-cli/){target=\_blank}:

```bash
npm i -g @subsquid/cli@latest
```

To verify successful installation, you can run:

```bash
sqd --version
```

Now we'll be able to use the `sqd` command to interact with our Squid project. To create our project, we're going to use the `--template` (`-t`) flag, which will create a project from a template. We'll be using the EVM Squid template, which is a starter project for indexing EVM chains.

You can run the following command to create an EVM Squid named `tanssi-squid`:

```bash
sqd init tanssi-squid --template evm
```

This will create a Squid with all of the necessary dependencies. You can go ahead and install the dependencies:

```bash
cd tanssi-squid && npm ci
```

Now that we have a starting point for our project, we'll need to configure our project to index ERC-20 `Transfer` events taking place on our Tanssi network.

##  Set Up the Indexer for ERC-20 Transfers {: #set-up-the-indexer-for-erc-20-transfers}

In order to index ERC-20 transfers, we'll need to take a series of actions:

1. Define the database schema and generate the entity classes
2. Use the `ERC20` contract's ABI to generate TypeScript interface classes
3. Configure the processor by specifying exactly what data to ingest
4. Transform the data and insert it into a TypeORM database in `main.ts`
5. Run the indexer and query the squid

As mentioned, we'll first need to define the database schema for the transfer data. To do so, we'll edit the `schema.graphql` file, which is located in the root directory, and create a `Transfer` entity and `Account` entity. You can copy and paste the below schema, ensuring that any existing schema is first removed.

???+ code "schema.graphql"

    ```graphql
    type Account @entity {
  "Account address"
  id: ID!
  transfersFrom: [Transfer!] @derivedFrom(field: "from")
  transfersTo: [Transfer!] @derivedFrom(field: "to")
}

type Transfer @entity {
  id: ID!
  blockNumber: Int!
  timestamp: DateTime!
  txHash: String!
  from: Account!
  to: Account!
  amount: BigInt!
}
    ```

Now we can generate the entity classes from the schema, which we'll use when we process the transfer data. This will create new classes for each entity in the `src/model/generated` directory.

```bash
sqd codegen
```

In the next step, we'll use the ERC-20 ABI to automatically generate TypeScript interface classes. Below is a generic ERC-20 standard ABI. Copy and paste it into a file named `erc20.json` in the `abi` folder at the root level of the project.

??? code "ERC-20 ABI"

    ```json
    [
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_spender",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_from",
        "type": "address"
      },
      {
        "name": "_to",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "name": "",
        "type": "uint8"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "name": "balance",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_to",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      },
      {
        "name": "_spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "payable": true,
    "stateMutability": "payable",
    "type": "fallback"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  }
]
    ```

Next, we can use our contract's ABI to generate TypeScript interface classes. We can do this by running:

```bash
sqd typegen
```

![Run Squid commands](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-3.webp)

This will generate the related TypeScript interface classes in the `src/abi/erc20.ts` file. For this tutorial, we'll be accessing the `events` specifically.

### Configure the Processor {: #configure-the-processor}

The `processor.ts` file tells SQD exactly what data you'd like to ingest. Transforming that data into the exact desired format will take place at a later step. In `processor.ts`, we'll need to indicate a data source, a contract address, the event(s) to index, and a block range.

Open up the `src` folder and head to the `processor.ts` file. First, we need to tell the SQD processor which contract we're interested in. Create a constant for the address in the following manner:

```ts
export const CONTRACT_ADDRESS = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();
```

The `.toLowerCase()` is critical because the SQD processor is case-sensitive, and some block explorers format contract addresses with capitalization. Next, you'll see the line `export const processor = new EvmBatchProcessor()`, followed by `.setDataSource`. We'll need to make a few changes here. SQD has [available archives for many chains](https://docs.sqd.ai/subsquid-network/reference/networks/){target=\_blank} that can speed up the data retrieval process, but it's unlikely your network has a hosted archive already. But not to worry, SQD can easily get the data it needs via your network's RPC URL. Go ahead and comment out or delete the archive line. Once done, your code should look similar to the below:

```ts
.setDataSource({
  chain: {
    url: assertNotNull(
      '{{ networks.dancelight.demo_evm_rpc_url }}'
    ),
    rateLimit: 300,
  },
})
```

The Squid template comes with a variable for your RPC URL defined in your `.env` file. You can replace that with the RPC URL for your network. For demonstration purposes, the RPC URL for the demo EVM network is hardcoded directly, as shown above. If you're setting the RPC URL in your `.env`, the respective line will look like this:

```text
RPC_ENDPOINT={{ networks.dancelight.demo_evm_rpc_url }}
```

Now, let's define the event that we want to index by adding the following:

```ts
.addLog({
  address: [contractAddress],
  topic0: [erc20.events.Transfer.topic],
  transaction: true,
})
```

The `Transfer` event is defined in `erc20.ts`, which was auto-generated when `sqd typegen` was run. The import `import * as erc20 from './abi/erc20'` is already included as part of the Squid EVM template.

Block range is an important value to modify to narrow the scope of the blocks you're indexing. For example, if you launched your ERC-20 at block `650000`, there is no need to query the chain before that block for transfer events. Setting an accurate block range will improve the performance of your indexer. You can set the earliest block to begin indexing in the following manner:

```ts
.setBlockRange({from: 632400,})
```

The chosen start block here corresponds to the relevant block to begin indexing on the demo EVM network, but you should change it to one relevant to your Tanssi-powered network and indexer project.

Change the `setFields` section to specify the following data for our processor to ingest:

```ts
.setFields({
  log: {
    topics: true,
    data: true,
  },
  transaction: {
    hash: true,
  },
})
```

We also need to add the following imports to our `processor.ts` file:

```ts
import { Store } from '@subsquid/typeorm-store';
import * as erc20 from './abi/erc20';
```

Once you've completed the prior steps, your `processor.ts` file should look similar to this:

???+ code "processor.ts"

    ```ts
    import { assertNotNull } from '@subsquid/util-internal';
import {
  BlockHeader,
  DataHandlerContext,
  EvmBatchProcessor,
  EvmBatchProcessorFields,
  Log as _Log,
  Transaction as _Transaction,
} from '@subsquid/evm-processor';
import { Store } from '@subsquid/typeorm-store';
import * as erc20 from './abi/erc20';

// Here you'll need to import the contract
export const contractAddress = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();

export const processor = new EvmBatchProcessor()
  .setDataSource({
    chain: {
      url: assertNotNull(
        'https://services.tanssi-testnet.network/dancelight-2001'
      ),
      rateLimit: 300,
    },
  })
  .setFinalityConfirmation(10)
  .setFields({
    log: {
      topics: true,
      data: true,
    },
    transaction: {
      hash: true,
    },
  })
  .addLog({
    address: [contractAddress],
    topic0: [erc20.events.Transfer.topic],
    transaction: true,
  })
  .setBlockRange({
    from: INSERT_START_BLOCK, // Note the lack of quotes here
  });

export type Fields = EvmBatchProcessorFields<typeof processor>;
export type Block = BlockHeader<Fields>;
export type Log = _Log<Fields>;
export type Transaction = _Transaction<Fields>;
    ```

### Transform and Save the Data {: #transform-and-save-the-data}

While `processor.ts` determines the data being consumed, `main.ts` determines the bulk of actions related to processing and transforming that data. In the simplest terms, we are processing the data that was ingested via the SQD processor and inserting the desired pieces into a TypeORM database. For more detailed information on how SQD works, be sure to check out the [SQD docs on Developing a Squid](https://docs.sqd.ai/sdk/how-to-start/squid-development/){target=\_blank}.

Our `main.ts` file is going to scan through each processed block for the `Transfer` event and decode the transfer details, including the sender, receiver, and amount. The script also fetches account details for involved addresses and creates transfer objects with the extracted data. The script then inserts these records into a TypeORM database, enabling them to be easily queried. Let's break down the code that comprises `main.ts` in order:

1. The job of `main.ts` is to run the processor and refine the collected data. In `processor.run`, the processor will iterate through all selected blocks and look for `Transfer` event logs. Whenever it finds a `Transfer` event, it's going to store it in an array of transfer events where it awaits further processing
2. The `transferEvent` interface is the type of structure that stores the data extracted from the event logs
3. `getTransfer` is a helper function that extracts and decodes ERC-20 `Transfer` event data from a log entry. It constructs and returns a `TransferEvent` object, which includes details such as the transaction ID, block number, sender and receiver addresses, and the amount transferred. `getTransfer` is called at the time of storing the relevant transfer events into the array of transfers
4. `processTransfers` enriches the transfer data and then inserts these records into a TypeORM database using the `ctx.store` methods. The account model, while not strictly necessary, allows us to introduce another entity in the schema to demonstrate working with multiple entities in your Squid
5. `getAccount` is a helper function that manages the retrieval and creation of account objects. Given an account ID and a map of existing accounts, it returns the corresponding account object. If the account doesn't exist in the map, it creates a new one, adds it to the map, and then returns it

We'll demo a sample query in a later section. You can copy and paste the below code into your `main.ts` file:

???+ code "main.ts"

    ```ts
    import { In } from 'typeorm';
import { assertNotNull } from '@subsquid/evm-processor';
import { TypeormDatabase } from '@subsquid/typeorm-store';
import * as erc20 from './abi/erc20';
import { Account, Transfer } from './model';
import {
  Block,
  contractAddress,
  Log,
  Transaction,
  processor,
} from './processor';

// 1. Iterate through all selected blocks and look for transfer events,
// storing the relevant events in an array of transfer events
processor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) => {
  let transfers: TransferEvent[] = [];

  for (let block of ctx.blocks) {
    for (let log of block.logs) {
      if (
        log.address === contractAddress &&
        log.topics[0] === erc20.events.Transfer.topic
      ) {
        transfers.push(getTransfer(ctx, log));
      }
    }
  }

  await processTransfers(ctx, transfers);
});

// 2. Define an interface to hold the data from the transfer events
interface TransferEvent {
  id: string;
  block: Block;
  transaction: Transaction;
  from: string;
  to: string;
  amount: bigint;
}

// 3. Extract and decode ERC-20 transfer event data from a log entry
function getTransfer(ctx: any, log: Log): TransferEvent {
  let event = erc20.events.Transfer.decode(log);

  let from = event.from.toLowerCase();
  let to = event.to.toLowerCase();
  let amount = event.value;

  let transaction = assertNotNull(log.transaction, `Missing transaction`);

  return {
    id: log.id,
    block: log.block,
    transaction,
    from,
    to,
    amount,
  };
}

// 4. Enrich and insert data into typeorm database
async function processTransfers(ctx: any, transfersData: TransferEvent[]) {
  let accountIds = new Set<string>();
  for (let t of transfersData) {
    accountIds.add(t.from);
    accountIds.add(t.to);
  }

  let accounts = await ctx.store
    .findBy(Account, { id: In([...accountIds]) })
    .then((q: any[]) => new Map(q.map((i: any) => [i.id, i])));

  let transfers: Transfer[] = [];

  for (let t of transfersData) {
    let { id, block, transaction, amount } = t;

    let from = getAccount(accounts, t.from);
    let to = getAccount(accounts, t.to);

    transfers.push(
      new Transfer({
        id,
        blockNumber: block.height,
        timestamp: new Date(block.timestamp),
        txHash: transaction.hash,
        from,
        to,
        amount,
      })
    );
  }

  await ctx.store.upsert(Array.from(accounts.values()));
  await ctx.store.insert(transfers);
}

// 5. Helper function to get account object
function getAccount(m: Map<string, Account>, id: string): Account {
  let acc = m.get(id);
  if (acc == null) {
    acc = new Account();
    acc.id = id;
    m.set(id, acc);
  }
  return acc;
}
    ```

Now we've taken all of the steps necessary and are ready to run our indexer!

### Run the Indexer {: #run-the-indexer }

To run our indexer, we're going to run a series of `sqd` commands:

Build our project:

   ```bash
   sqd build
   ```

Launch the database:

   ```bash
   sqd up
   ```

Remove the database migration file that comes with the EVM template and generate a new one for our new database schema:

   ```bash
   sqd migration:generate
   ```

   ```bash
   sqd migration:apply
   ```

Launch the processor:

   ```bash
   sqd process
   ```

In your terminal, you should see your indexer starting to process blocks!

![Get Squid running](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-4.webp)

## Query Your Squid {: #query-your-squid }

To query your squid, open up a new terminal window within your project and run the following command:

```bash
sqd serve
```

And that's it! You can now run queries against your Squid on the GraphQL playground at `http://localhost:4350/graphql`. Try crafting your own GraphQL query, or use the below one:

???+ code "Example query"

    ```ts
    query {
  accounts {
    id
    transfersFrom {
      id
      blockNumber
      timestamp
      txHash
      to {
        id
      }
      amount
    }
    transfersTo {
      id
      blockNumber
      timestamp
      txHash
      from {
        id
      }
      amount
    }
  }
}
    ```

![Running queries in GraphQL playground](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-5.webp)

## Debug Your Squid {: #debug-your-squid }

It may seem tricky at first to debug errors when building your Squid, but fortunately, there are several techniques you can use to streamline this process. First and foremost, if you're facing errors with your Squid, you should enable debug mode in your `.env` file by uncommenting the debug mode line. This will trigger much more verbose logging and will help you locate the source of the error.

```text
# Uncommenting the below line enables debug mode
SQD_DEBUG=*
```

You can also add logging statements directly to your `main.ts` file to indicate specific parameters like block height and more. For example, see this version of `main.ts`, which has been enhanced with detailed logging:

??? code "main.ts"

    ```ts
    import { In } from 'typeorm';
import { assertNotNull } from '@subsquid/evm-processor';
import { TypeormDatabase } from '@subsquid/typeorm-store';
import * as erc20 from './abi/erc20';
import { Account, Transfer } from './model';
import {
  Block,
  contractAddress,
  Log,
  Transaction,
  processor,
} from './processor';

processor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) => {
  ctx.log.info('Processor started');
  let transfers: TransferEvent[] = [];

  ctx.log.info(`Processing ${ctx.blocks.length} blocks`);
  for (let block of ctx.blocks) {
    ctx.log.debug(`Processing block number ${block.header.height}`);
    for (let log of block.logs) {
      ctx.log.debug(`Processing log with address ${log.address}`);
      if (
        log.address === contractAddress &&
        log.topics[0] === erc20.events.Transfer.topic
      ) {
        ctx.log.info(`Transfer event found in block ${block.header.height}`);
        transfers.push(getTransfer(ctx, log));
      }
    }
  }

  ctx.log.info(`Found ${transfers.length} transfers, processing...`);
  await processTransfers(ctx, transfers);
  ctx.log.info('Processor finished');
});

interface TransferEvent {
  id: string;
  block: Block;
  transaction: Transaction;
  from: string;
  to: string;
  amount: bigint;
}

function getTransfer(ctx: any, log: Log): TransferEvent {
  let event = erc20.events.Transfer.decode(log);

  let from = event.from.toLowerCase();
  let to = event.to.toLowerCase();
  let amount = event.value;

  let transaction = assertNotNull(log.transaction, `Missing transaction`);

  ctx.log.debug(
    `Decoded transfer event: from ${from} to ${to} amount ${amount.toString()}`
  );
  return {
    id: log.id,
    block: log.block,
    transaction,
    from,
    to,
    amount,
  };
}

async function processTransfers(ctx: any, transfersData: TransferEvent[]) {
  ctx.log.info('Starting to process transfer data');
  let accountIds = new Set<string>();
  for (let t of transfersData) {
    accountIds.add(t.from);
    accountIds.add(t.to);
  }

  ctx.log.debug(`Fetching accounts for ${accountIds.size} addresses`);
  let accounts = await ctx.store
    .findBy(Account, { id: In([...accountIds]) })
    .then((q: any[]) => new Map(q.map((i: any) => [i.id, i])));
  ctx.log.info(
    `Accounts fetched, processing ${transfersData.length} transfers`
  );

  let transfers: Transfer[] = [];

  for (let t of transfersData) {
    let { id, block, transaction, amount } = t;

    let from = getAccount(accounts, t.from);
    let to = getAccount(accounts, t.to);

    transfers.push(
      new Transfer({
        id,
        blockNumber: block.height,
        timestamp: new Date(block.timestamp),
        txHash: transaction.hash,
        from,
        to,
        amount,
      })
    );
  }

  ctx.log.debug(`Upserting ${accounts.size} accounts`);
  await ctx.store.upsert(Array.from(accounts.values()));
  ctx.log.debug(`Inserting ${transfers.length} transfers`);
  await ctx.store.insert(transfers);
  ctx.log.info('Transfer data processing completed');
}

function getAccount(m: Map<string, Account>, id: string): Account {
  let acc = m.get(id);
  if (acc == null) {
    acc = new Account();
    acc.id = id;
    m.set(id, acc);
  }
  return acc;
}
    ```

See the [SQD guide to logging](https://docs.sqd.ai/sdk/reference/logger/){target=\_blank} for more information on debug mode.

### Common Errors {: #common-errors }

Below are some common errors you may face when building a project and how you can solve them.

```text
Error response from daemon: driver failed programming external connectivity on endpoint my-awesome-squid-db-1
(49df671a7b0531abbb5dc5d2a4a3f5dc7e7505af89bf0ad1e5480bd1cdc61052):
Bind for 0.0.0.0:23798 failed: port is already allocated
```

This error indicates that you have another instance of SQD running somewhere else. You can stop that gracefully with the command `sqd down` or by pressing the **Stop** button next to the container in Docker Desktop.

```text
Error: connect ECONNREFUSED 127.0.0.1:23798
     at createConnectionError (node:net:1634:14)
     at afterConnectMultiple (node:net:1664:40) {
     errno: -61,code: 'ECONNREFUSED',syscall: 'connect',
     address: '127.0.0.1',port: 23798}
```

To resolve this, run `sqd up` before you run `sqd migration:generate`

Is your Squid error-free, yet you aren't seeing any transfers detected? Make sure your log events are consistent and identical to the ones your processor is looking for. Your contract address also needs to be lowercase, which you can be assured of by defining it as follows:

```ts
export const contractAddress = '0x37822de108AFFdd5cDCFDaAa2E32756Da284DB85'.toLowerCase();
```

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/indexers/sqd/
--- BEGIN CONTENT ---
---
title: SQD
description: Explore comprehensive tutorials covering the fundamentals and advanced techniques for indexing data on your Tanssi Substrate or EVM network with SQD.
icon: octicons-codescan-24
template: index-page.html
---

# SQD

SQD is a blockchain indexing and query service designed to make it easier for developers to build data-rich applications on Substrate-based chains, such as Tanssi-powered networks. It provides an efficient and scalable solution for processing, indexing, and querying on-chain data, allowing developers to easily interact with the blockchain data they need without dealing with the complexities of raw blockchain data directly.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/indexers/sqd/quick-start/
--- BEGIN CONTENT ---
---
title: Index a Tanssi Network with SQD
description: Learn how to use the Squid SDK, a query node framework for Substrate-based chains, to index and process data on a Tanssi-powered EVM or Substrate network.
icon: octicons-rocket-24
categories: EVM-Template, Substrate-Template
---

# Indexing a Tanssi Network with SQD

## Introduction {: #introduction }

[SQD](https://www.sqd.ai/){target=\_blank} is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using SQD's decentralized data lake and open-source SDK. In simple terms, SQD can be thought of as an ETL (extract, transform, and load) tool with a GraphQL server included. It enables comprehensive filtering, pagination, and even full-text search capabilities. SQD has native and full support for both EVM and Substrate data, even within the same project.

This quick-start guide will show you how to create a Squid project and configure it to index data on a Tanssi-powered network. There is one section catered towards [Substrate networks](#index-substrate-networks) and another towards [EVM networks](#index-evm-networks). However, if you're building on an EVM network, you may also reference the Substrate section, if you also need to index Substrate data.

For a more comprehensive end-to-end tutorial for EVM networks, be sure to check out the [Indexing ERC-20 Transfers on a Tanssi EVM Network](/builders/toolkit/integrations/indexers/sqd/erc20-transfers/){target=\_blank} tutorial.

## Checking Prerequisites {: #checking-prerequisites }

For the examples in this guide, you will need to have the following:

 - [Node.js](https://nodejs.org/en/download){target=\_blank} version 16 or newer
 - [Docker](https://docs.docker.com/get-started/get-docker/){target=\_blank}
 - [Squid CLI](https://docs.sqd.ai/squid-cli/installation/){target=\_blank}

## Index a Tanssi Substrate Network {: #index-substrate-networks }

To get started indexing Substrate data on your Tanssi-powered network, you'll need to create a Squid project and configure it for your network by taking the following steps:

1. Create a Squid project based on the Substrate template by running

    ```bash
    sqd init INSERT_SQUID_NAME --template substrate
    ```

    For more information on getting started with this template, please check out the [Getting started: Substrate chains](https://docs.sqd.ai/sdk/how-to-start/squid-development/?template-tech=substrate){target=\_blank} guide on SQD's documentation site.

2. Navigate into the root directory of your Squid project and install dependencies by running

    ```bash
    npm ci
    ```

3. Modify the `src/processor.ts` file to set the data source to the RPC URL of your Tanssi network. Remove the `archive: lookupArchive` line as a Squid archive will not be used. Here, you'll need to specify the RPC URL of your Tanssi Substrate network, as the endpoint is used to ingest chain data

    ```ts
    const processor = new EvmBatchProcessor();
    processor.setDataSource({
      chain: 'INSERT_RPC_URL',
    })
    ```

4. Launch Postgres by running

    ```bash
    sqd up
    ```

5. Inspect and run the processor

    ```bash
    sqd process
    ```

6. Open a separate terminal window in the same directory, then start the GraphQL server

    ```bash
    sqd serve
    ```

7. You can query your template Substrate Squid with the below sample query. If you've modified the template Substrate squid to index different data, you'll need to modify this query accordingly

    ```graphql
    query MyQuery {
      accountsConnection(orderBy: id_ASC) {
        totalCount
      }
    }
    ```

And that's all you have to do to configure your Squid project to index Substrate data on your Tanssi-powered Substrate network! Now you can update the `schema.graphql`, `src/main.ts`, `typegen.json`, and `src/processor.ts` files to index the data you need for your project!

## Index a Tanssi EVM Network {: #index-evm-networks }

To get started indexing EVM data on a Tanssi-powered EVM network, you'll need to create a Squid project and configure it for your network by taking the following steps:

1. You can create a Squid project for EVM data by using the generic [EVM template](https://github.com/subsquid-labs/squid-evm-template){target=\_blank} or you can use the [ABI template](https://github.com/subsquid-labs/squid-abi-template){target=\_blank} for indexing data related to a specific contract

    === "EVM"

        ```bash
        sqd init INSERT_SQUID_NAME --template evm
        ```

    === "ABI"

        ```bash
        sqd init INSERT_SQUID_NAME --template abi
        ```

    For more information on getting started with both of these templates, please check out the following SQD docs:

      - [Getting started: EVM chains](https://docs.sqd.ai/sdk/how-to-start/squid-development/?template-tech=evm){target=\_blank}
      - [Quickstart: Squid generation tools](https://docs.sqd.ai/sdk/resources/tools/squid-gen/){target=\_blank}

2. Navigate into the root directory of your Squid project and install dependencies by running

    ```bash
    npm ci
    ```

3. Modify the `src/processor.ts` file to set the data source to the RPC URL of your Tanssi network. Remove the `archive: lookupArchive('eth-mainnet')` line as a Squid archive will not be used. Here, the RPC URL of the demo EVM network is specified. The Squid project will use the RPC endpoint to ingest the relevant data

    ```ts
    const processor = new EvmBatchProcessor();
    processor.setDataSource({
      chain: 'INSERT_RPC_URL',
    })
    ```

    !!! note
        To try this out on the demo EVM network, you can use the following RPC URL:

        ```text
        {{ networks.dancelight.demo_evm_rpc_url }}
        ```

4. Launch Postgres by running

    ```bash
    sqd up
    ```

5. Inspect and run the processor

    ```bash
    sqd process
    ```

6. Open a separate terminal window in the same directory, then start the GraphQL server

    ```bash
    sqd serve
    ```

7. You can now run queries, such as the sample query below, against your Squid on the GraphQL playground at `http://localhost:4350/graphql`. If you've modified the template Substrate squid to index different data, you'll need to modify this query accordingly

    ```graphql
    query MyQuery {
      burns(orderBy: value_DESC) {
        address
        block
        id
        txHash
        value
      }
    }
    ```

And that's all you have to do to configure your Squid project to index EVM data on your Tanssi-powered EVM network! Now you can update the `schema.graphql`, `src/main.ts`, and `src/processor.ts` files to index the data you need for your project!

If you're interested in a more comprehensive step-by-step tutorial to get started indexing data for your Tanssi network, you can check out the [Indexing ERC-20 Transfers on a Tanssi EVM Network](/builders/toolkit/integrations/indexers/sqd/erc20-transfers/){target=\_blank} tutorial!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/oracles/acurast/
--- BEGIN CONTENT ---
---
title: Using Acurast for Price Feed Oracles
description: Learn how to use Acurast's decentralized serverless cloud to get reliable price feed token asset data on your Tanssi EVM-compatible network.
icon: octicons-eye-24
categories: EVM-Template
---

# Accessing Price Feeds with Acurast

## Introduction {: #introduction }

[Acurast](https://acurast.com){target=\_blank} gives developers complete permissionless access to compute that is trustless, affordable, and confidential for deploying their applications.

One of Acurast's use cases is to enable developers to deploy their own push/pull oracles, interacting with off-chain APIs to bring price feeds on-chain. Pricing data is confidentially processed through Acurast Processors, pushing data to smart contracts of EVM-compatible chains like Tanssi-powered EVM networks via a [standard Chainlink Aggregator Interface](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=\_blank}.

This tutorial will walk through a demo of [interacting with price feeds](#fetch-price-data) enabled by Acurast on the [demo Tanssi EVM-compatible network](/builders/tanssi-network/testnet/demo-evm-network/){target=\_blank}. You can also deploy your own price feeds to your Tanssi EVM-compatible network. Please be advised that the steps shown in this tutorial are for demonstration purposes only - it's highly recommended that you contact the [Acurast](https://acurast.com){target=\_blank} team directly as they can assist you with launching price feeds on your network to ensure the integrity of the deployment process.

## What is Acurast? {: #what-is-acurast }

Acurast is a decentralized, serverless cloud where everyone can become part of the cloud with their new, used, or even mobile phones with a smashed screen by providing compute power to the cloud and earning rewards. These so-called Processors are scattered across the globe, creating a distributed network of compute across the globe.

Processors and developers can seamlessly interact through the [Acurast Console](https://console.acurast.com){target=\_blank}.

## Fetch Price Data {: #fetch-price-data }

You can design your Acurast price feed exactly as you wish. The demo price feed built for this tutorial inherits the same interface as the Chainlink price feeds. The data lives in a series of smart contracts (one per price feed) and can be fetched with the aggregator interface:

???+ code "AggregatorV3Interface.sol"

    ```solidity
    // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    /**
     * Returns the decimals to offset on the getLatestPrice call
     */
    function decimals() external view returns (uint8);

    /**
     * Returns the description of the underlying price feed aggregator
     */
    function description() external view returns (string memory);

    /**
     * Returns the version number representing the type of aggregator the proxy points to
     */
    function version() external view returns (uint256);

    /**
     * Returns price data about a specific round
     */
    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);

    /**
     * Returns price data from the latest round
     */
    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
}
    ```

As seen above in the interface, there are five functions for fetching data: `decimals`, `description`, `version`, `getRoundData`, and `latestRoundData`. For more information about the `AggregatorV3Interface.sol`, see the [Chainlink API Reference](https://docs.chain.link/data-feeds/api-reference){target=\_blank}.

## Interacting with Price Feeds on the Tanssi Demo EVM Network {: #interacting-with-price-feeds-demo-evm-network }

This tutorial will showcase interacting with a sample BTC/USDT price feed contract on the demo EVM network, but you can interact any of the price feeds listed in [Supported Assets](#supported-assets). The BTC/USDT price feed is [deployed on the demo EVM network]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x02093b190D9462d964C11587f7DedD92718D7B56){target=\_blank}, so you can interact with it by accessing the aggregator contract at the below contract address:

```text
{{ networks.demo_evm.oracles.acurast.btc_usd }}
```

For a refresher on setting up Remix to interface with the demo EVM network, see the [Deploy Smart Contracts with Remix](/builders/toolkit/ethereum-api/dev-env/remix/){target=\_blank} guide. Secondly, make sure you have [connected MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} to the demo EVM network.

Paste the [aggregator contract](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=\_blank} into a new file in Remix and compile it.

![Compile aggregator contract](/images/builders/toolkit/integrations/oracles/acurast/acurast-1.webp)

Then, take the following steps:

1. Head to the **Deploy and Run Transactions** tab
2. Set the **ENVIRONMENT** to **Injected Provider -- MetaMask**
3. Select the **AggregatorV3Interface** contract from the **CONTRACT** dropdown
4. Enter the sample price feed contract address for `BTC to USD`, which is `{{ networks.demo_evm.oracles.acurast.btc_usd }}` on the demo EVM network in the **At Address** field and click the **At Address** button

![Access aggregator contract](/images/builders/toolkit/integrations/oracles/acurast/acurast-2.webp)

The aggregator contract should now be accessible. To interact with the aggregator contract, take the following steps:

1. Expand the **AggregatorV3Interface** contract to reveal the available functions
2. Click **decimals** to query how many digits after the decimal point are included in the returned price data
3. Click **description** to verify the asset pair of the price feed
4. Click **latestRoundData** to see the most recent price data for the asset pair. The price data for the pair is returned as the **int256 answer**

![Check price data](/images/builders/toolkit/integrations/oracles/acurast/acurast-3.webp)

Note that to obtain a readable price from the price feed, it's essential to adjust for the feed's decimal places, which can be determined using the `decimals()` method. For instance, if the price feed returns a value of `51933620000`, you'll need to move the decimal point six places to accurately reflect the price. In this example, it corresponds to a Bitcoin price of `$51,933.62` at the time of writing.

### Supported Assets {: #supported-assets }

By its design, Acurast can support the price feed of any arbitrary asset that is accessible by an API. The API request that powers the demo price feed is as follows:

```bash
curl "https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT"
```

Upon running the above command in your terminal, you'll see a result that resembles the following:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>curl "https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT" </span>
  <span data-ty> </span>
  <span data-ty>{"symbol":"BTCUSDT","price":"51917.61000000"}</span>
  <span data-ty="input"><span class="file-path"></span> </span>
</div>

!!! note
    This simple example of fetching a price feed relies on a single source of price feed data from one exchange. You can build a more complex job script that aggregates pricing data from multiple sources.

The Acurast team has deployed the below price feeds on the Tanssi demo EVM network:

| Asset & Base Pair |                                                                           Aggregator Contract                                                                           |
|:-----------------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|   AAVE to USDT    | [{{ networks.demo_evm.oracles.acurast.aave_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x6239Ff749De3a21DC219bcFeF9d27B0dfE171F42){target=\_blank} |
|    BTC to USDT    | [{{ networks.demo_evm.oracles.acurast.btc_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x02093b190D9462d964C11587f7DedD92718D7B56){target=\_blank}  |
|    CRV to USDT    | [{{ networks.demo_evm.oracles.acurast.crv_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x01F143dfd745861902dA396ad7dfca962e5C83cA){target=\_blank}  |
|    DAI to USDT    | [{{ networks.demo_evm.oracles.acurast.dai_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x73aF6b14b73059686a9B93Cd28b2dEABF76AeC92){target=\_blank}  |
|    ETH to USDT    | [{{ networks.demo_evm.oracles.acurast.eth_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x007c3F3cc99302c19792F73b7434E3eCbbC3db25){target=\_blank}  |
|   USDC to USDT    | [{{ networks.demo_evm.oracles.acurast.usdc_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xe4a46ef4cFbf87D026C3eB293b7672998d932F62){target=\_blank} |
|    USDT to USD    | [{{ networks.demo_evm.oracles.acurast.usdt_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xf9c885E3A5846CEA887a0D69655BC08e52afe569){target=\_blank} |

## Designing and Launching Your Own Price Feed {: #designing-and-launching-your-own-price-feed }

You can build and launch your own Acurast price feed on your Tanssi-powered EVM-compatible network. Please be advised that the steps shown in this tutorial are unaudited, unverified, and for demonstration purposes only - it's highly recommended that you [contact the Acurast team directly](https://acurast.com){target=\_blank} as they can assist you with launching price feeds on your network to ensure the integrity of the deployment process.

To launch an Acurast price feed, you need two key components: a smart contract and a script. In the prior example of [Interacting with the BTC/USD price feed](#interacting-with-price-feeds-demo-evm-network) on the demo EVM network, the generic Chainlink interface is used because it is a more straightforward example for demonstration purposes. The underlying smart contract that powers that price feed conforms to the [Chainlink Aggregator interface](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=\_blank}, but the demo contract has additional components worthy of discussion. You can find both the demo contract and script at the [GitHub repo for the Acurast demo BTC/USD price feed](https://github.com/Acurast/acurast-evm-oracle-sample/tree/main){target=\_blank}.

The demo contract, `InsecureDummyPriceFeed.sol`, emits an event when the price is updated and when a new round begins. The `setPrice` method is insecure, as shown in this demo smart contract, but it is provided to show you where you might add logic like aggregation consensus, access control checks, and other parameters.

???+ code "InsecureDummyPriceFeed.sol"

    ```solidity
    // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces/chainlink/AggregatorV2V3Interface.sol";

/**
This Dummy Oracle is compatible with Chainlink's AggregatorV2V3Interface, meaning projects currently using
Chainlink can seamlessly migrate. The updating of the price feed happens in the interval you specified on
the Acurast script.

At the moment no check on the signer/source is being performed, making this implementation INSECURE. However
with a minimal effort you can extend the "setPrice" entrypoint to reflext the kind of logic you are looking for
(i.e. Aggregation Consensus, Check sources, thresholds, etc).
**/

contract DummyChainlinkCompatibleOracle is AggregatorV2V3Interface {
    int256 private latestPrice;
    uint256 private latestPriceTimestamp;
    uint256 private latestRoundId;

    // Assuming price can be set without restriction for simplicity
    // In a real-world scenario, there should be access control mechanisms
    function setPrice(int256 _price) external {
        latestPrice = _price;
        latestPriceTimestamp = block.timestamp;
        latestRoundId++;

        emit AnswerUpdated(latestPrice, latestRoundId, latestPriceTimestamp);
        emit NewRound(latestRoundId, msg.sender, latestPriceTimestamp);
    }

    // AggregatorInterface functions
    function latestAnswer() external view override returns (int256) {
        return latestPrice;
    }

    function latestTimestamp() external view override returns (uint256) {
        return latestPriceTimestamp;
    }

    function latestRound() external view override returns (uint256) {
        return latestRoundId;
    }

    function getAnswer(uint256 _roundId) external view override returns (int256) {
        if(_roundId == latestRoundId) {
            return latestPrice;
        }
        return 0; // Simplification, should handle historical data
    }

    function getTimestamp(uint256 _roundId) external view override returns (uint256) {
        if(_roundId == latestRoundId) {
            return latestPriceTimestamp;
        }
        return 0; // Simplification, should handle historical data
    }

    // AggregatorV3Interface functions
    function decimals() external pure override returns (uint8) {
        return 6; // Assume a common decimal value for simplicity
    }

    function description() external pure override returns (string memory) {
        return "Sample Price Feed";
    }

    function version() external pure override returns (uint256) {
        return 1;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        require(_roundId == latestRoundId, "Only latest round data available");
        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));
    }
}
    ```

!!! warning
    This demo contract has some security vulnerabilities and lacks access control mechanisms, making it unsuitable for any real use. It was developed by the Acurast team for demonstration purposes only.

Before proceeding to the next steps, you must first deploy your price feed's smart contract on your Tanssi EVM network. Or, you can deploy it to the [demo EVM network](/builders/tanssi-network/testnet/demo-evm-network/), and you can obtain TestNet {{ networks.dancelight.demo_evm_token_symbol }} tokens from the [Tanssi faucet](https://apps.tanssi.network/demo){target=\_blank}. Once deployed, be sure to record the contract address, as you will need to enter this information into your Acurast price feed script.

### Building the Acurast Script

The Acurast oracle script plays a crucial role by updating your on-chain oracle with fresh data, acting as the vital connection between the Tanssi network's price feed and the Acurast network. Through the Acurast console, you will upload this script and specify all necessary parameters for your price feed's operation, including its frequency, schedule, and rewards for Acurast processors, among others. To facilitate this process, you will need cACU tokens, which are available from the [faucet](https://faucet.acurast.com){target=\_blank}, and serve as the native currency of the Acurast Canary network.

The [Acurast script for the demo BTC/USD price feed](https://github.com/Acurast/acurast-evm-oracle-sample/blob/main/acurast_scripts/oracle_job.js){target=\_blank} can be used as a basis for creating your own script. Remember to update the contract address and RPC URL fields.

???+ code "AcurastScript.js"

    ```js
    /**
 * This Oracle Script observes the BTC USDT Pair and posts the price on-chain.
 * Deploying the script is easy using console.acurast.com and simply copy/pasting
 * this script. Make sure to update `DESTINATION_CONTRACT` and `EVM_RPC_NODE` to
 * reflect your deployment. For RPC's with API keys like i.e. infura make sure
 * to work with the Acurast confidential environment variables. After having set
 * them for your job, you can access them easily with a `_STD_.env["MY_KEY"]`. They
 * also come in handy for paid API KEYs, that you don't want to share publicly.
 */

const DESTINATION_CONTRACT = 'INSERT_CONTRACT_ADDRESS';
const EVM_RPC_NODE = 'INSERT_NETWORK_RPC_URL';

httpGET(
  'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT',
  {},
  (response, certificate) => {
    if (
      certificate ===
      '4795062d13e1ed971c6b6e5699764681e4d090bad39a7ef367cc9cb705652384'
    ) {
      //const price = BigInt(JSON.parse(response)["price"] * 10 ** 18); // if you need more precision, just keep in mind that JS stored bigger numbers in float format, rounding up/down your stuff.
      const price = BigInt(JSON.parse(response)['price'] * 10 ** 6);
      const int256AsBytes = '0x' + price.toString(16).padStart(64, '0');
      const payload = '0x' + _STD_.chains.ethereum.abi.encode(int256AsBytes);
      _STD_.chains.ethereum.fulfill(
        EVM_RPC_NODE,
        DESTINATION_CONTRACT,
        payload,
        {
          methodSignature: 'setPrice(int256)',
          gasLimit: '9000000',
          maxFeePerGas: '2550000000',
          maxPriorityFeePerGas: '2550000000',
        },
        (opHash) => {
          console.log('Succeeded: ' + opHash);
        },
        (err) => {
          console.log('Failed: ' + err);
        }
      );
    }
  },
  (err) => {
    console.log('Failed: ' + err);
  }
);
    ```

To configure your job, head to the [Acurast console](https://console.acurast.com/create){target=\_blank}, then take the following steps:

1. Click **Create Jobs** on the left-hand sidebar underneath the **Consumer** heading
2. Select **Moonbeam** as the chain
3. Select **Moonbase** as the environment. Remember that Tanssi's EVM-compatibility is derived from Moonbeam
4. Select **Price Feeds**
5. Paste in the code of your job script. You can copy and paste directly from the [script of the sample BTC/USD price feed](https://github.com/Acurast/acurast-evm-oracle-sample/blob/main/acurast_scripts/oracle_job.js){target=\_blank}, just make sure to change the destination contract to one that you deployed on your network and the RPC node to your network's RPC URL, which can be found on the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}
6. Optionally, you can test your code here. Any error messages will be readable in the browser's console

![Job setup on Acurast console](/images/builders/toolkit/integrations/oracles/acurast/acurast-4.webp)

Continuing down the same setup page, take the following steps:

1. Select **Use Public Processors**
2. Select **Interval**
3. Specify a **Start time** and **End time**
4. Specify the **Interval in minutes**
5. Specify a job duration and max start delay duration
6. Select **Number of processors to assign**. The more processors you choose, the proportionally higher amount of cACU you'll need, which you can get from the [faucet](https://faucet.acurast.com){target=\_blank}
7. Select **Max Reward** paid to each processor for each job execution. You don't need to specify exactly `0.01` cACU - this amount was chosen as an example
8. Review everything first, then Press **Publish Job**

![Job setup on Acurast console continued](/images/builders/toolkit/integrations/oracles/acurast/acurast-5.webp)

On the following screen, you'll be able to monitor the status of your job. For more information about using Acurast to build and access price feeds on your Tanssi EVM-compatible network, be sure to check out the [Acurast docs](https://docs.acurast.com){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/oracles/band/
--- BEGIN CONTENT ---
---
title: Using Band Protocol for Price Feed Oracles
description: Learn how to use the Band Protocol's descentralized oracle network to get reliable token prices enabling secure data access for your Tanssi EVM network.
icon: octicons-eye-24
categories: EVM-Template
---

# Accessing Price Feeds with the Band Protocol

## Introduction {: #introduction }

[Band Protocol](https://www.bandprotocol.com/){target=\_blank} is a decentralized oracle network that provides reliable, secure, real-time data to smart contracts on various blockchain networks.

The protocol is built on top of BandChain, a network designed to be compatible with most EVM-compatible chains, such as Tanssi-powered EVM networks, and blockchain development frameworks. The protocol aims to provide a solution that is:

- Decentralized, leveraging the computational power of a network of validators
- Flexible, supporting a wide range of data sources and formats, making integrations easy
- Scalable, designed to handle high volumes of data requests
- Affordable, allowing users to request data only when they need to and pay the associated fees

To deploy the oracle onto your network, reach out to the [Band Protocol](https://www.bandprotocol.com/){target=\_blank} team directly.

This tutorial will walk through the steps to interact with price feeds using the Band protocol's oracle on the [Tanssi demo EVM-compatible network](https://apps.tanssi.network/demo){target=\_blank}. 

## Setup on the Tanssi Demo EVM Network {: #setup-on-demo-evm-network }

The Band Protocol oracle is already deployed on the Tanssi demo EVM network and configured to provide prices for the `ETH` and `DOT` tokens.

The price feeds are pushed regularly to a smart contract that is accessible at the following address:

```text
{{ networks.demo_evm.oracles.band.smart_contract }}
```

The smart can be interacted with using the interface:

???+ code "IStdReference.sol"

    ```solidity
    // SPDX-License-Identifier: Apache-2.0

pragma solidity 0.8.26;

interface IStdReference {
    /// A structure returned whenever someone requests for standard reference data.
    struct ReferenceData {
        uint256 rate; // base/quote exchange rate, multiplied by 1e18.
        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.
        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.
    } 

    /// Returns the price data for the given base/quote pair. Revert if not available.
    function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory);

    /// Similar to getReferenceData, but with multiple base/quote pairs at once.
    function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes) external view returns (ReferenceData[] memory);
}
    ```

As seen above in the interface, there are two functions for fetching data:

???+ function "**getReferenceData**(_base, _quote) â€” fetches the price for a given base/quote pair"

    === "Parameters"

        - `_base` ++"string memory"++ - the token you want to get the price for
        - `_quote` ++"string memory"++ - the token (or `USD`) in which the price is expressed
        
    === "Example"

        - `_base` - ETH
        - `_quote` - USD
        
??? function "**getReferenceDataBulk**(_bases, _quotes) â€” fetches prices for the given base/quote pairs simultaneously"

    === "Parameters"

        - `_bases` ++"string[] memory"++ - the list of base tokens you want to get the prices for
        - `_quotes` ++"string[] memory"++ - the list of tokens (or `USD`) in which the prices are expressed

    === "Example"

        - `_bases` - ["ETH", "DOT"]
        - `_quotes` - ["USD", "USD"]

The response for both functions consists of the following data, grouped in one tuple in the case of `getReferenceData` and one list of tuples (one tuple per pair) in the case of `getReferenceDataBulk`:

- `rate` ++"uint256"++ - price for the given base/quote pair. Note that the result must be adjusted to consider eighteen decimal places
- `lastUpdatedBase` ++"uint256"++ - update timestamp for the `_base` parameter, expressed in UNIX epochs, which is the number of seconds that have passed since `01-01-1970 00:00:00 UT`
- `lastUpdatedQuote` ++"uint256"++ - update timestamp for the `_quote` parameter, expressed in UNIX epochs, which is the number of seconds that have passed since `01-01-1970 00:00:00 UT`

### Fetching Price Feeds Using Remix {: #fetching-price-feeds-remix }

In this section, we'll use remix to fetch the price of the pair `ETH/USD`. 

First, make sure you have an [EVM-compatible wallet](/builders/toolkit/ethereum-api/wallets/){target=\_blank} connected to the [demo EVM network](https://apps.tanssi.network/demo){target=\_blank}. [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} is used as an example in this guide. Now, head to [Remix](https://remix.ethereum.org/){target=\_blank}, paste the [`IStdReference`](#setup-on-demo-evm-network) interface into a new file, and compile it.

![Compile interface contract](/images/builders/toolkit/integrations/oracles/band/band-1.webp)

Then, take the following steps:

1. Head to the **Deploy & Run Transactions** tab
2. Set the **ENVIRONMENT** to **Injected Provider -- MetaMask**
3. Select the `IStdReference.sol` contract from the **CONTRACT** dropdown
4. Enter the data feed contract address, which is `{{ networks.demo_evm.oracles.band.smart_contract }}` on the demo EVM network in the **At Address** field and click the **At Address** button

![Access Interface contract](/images/builders/toolkit/integrations/oracles/band/band-2.webp)

The contract should now be accessible. To interact with it, take the following steps:

1. Expand the **IStdReference** contract to reveal the available functions
2. Expand **getReferenceData**, and set the `_base` and `_quote` input parameters to `ETH` and `USD`, respectively
3. Click **Call**
4. The result will show three values: the price, update time for the `_base` parameter, and update time for the `_quote` parameter

![Check price data](/images/builders/toolkit/integrations/oracles/band/band-3.webp)

Note that to obtain a readable price from the price feed, it's essential to adjust for the feed's decimal places, which are eighteen. For instance, the example above shows a value of `2361167929271984201806`, corresponding to an `ETH` price of `$2,361.167929271984201806` expressed in `USD`. Also, note that the update timestamp values are expressed in UNIX epoch time, expressed as the number of seconds that have passed since `01-01-1970 00:00:00 UT`. 

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/oracles/
--- BEGIN CONTENT ---
---
title: Oracles
description: Learn how to integrate specialized tools like decentralized price feed Oracles to provide asset price feeds to builders and users of your Tanssi network.
icon: octicons-eye-24
template: index-page.html
---

# Oracles

Blockchain oracles are services that enable blockchains to interact with external data sources, bridging the gap between smart contracts and real-world information. Oracles are essential for dynamic applications that rely on accurate and timely off-chain data.

Main features of oracles include:

- **External connectivity** - allowing smart contracts to fetch and utilize real-world data
- **Automation** - trigger contract execution based on external conditions
- **Flexibility** - support various data types, such as price feeds, weather updates, and sports results

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/oracles/phala/
--- BEGIN CONTENT ---
---
title: Using Phala for Price Feed Oracles
description: Learn how to use Phala's off-chain computing network to get reliable Ethereum Mainnet Chainlink Oracle token price feed data on your Tanssi-powered EVM network.
icon: octicons-eye-24
categories: EVM-Template
---

# Launching Price Feeds with Phala

## Introduction {: #introduction }

[Phala Network](https://phala.com/){target=\_blank} is an off-chain compute network powered by [Secure Enclaves](https://docs.phala.com/network/tech-specs/blockchain/overview#the-architecture){target=\_blank} that enables developers to build powerful smart contracts that connect to off-chain components called Phat Contracts. Phat Contracts are designed to enable functionality that surpasses the limitations of traditional smart contracts, such as storage, cost, and compute limitations while remaining trustless, verifiable, and permissionless. For more information about Phala's architecture, be sure to check out the [Phala docs](https://docs.phala.com/overview/phala-network){target=\_blank}.

Phala is not an oracle network itself; rather, Phala enables a variety of off-chain compute capabilities, such as a decentralized oracle network. Phala also provides a toolset called [Phala Bricks](https://bricks.phala.network){target=\_blank} that makes it easy to quickly launch these types of features without having to build them from scratch.

This tutorial will walk through a demo of [interacting with price feeds](#fetch-price-data) enabled by Phat contracts on the demo Tanssi-powered EVM-compatible network. Next, you'll learn how to [deploy price feeds to your Tanssi EVM-compatible network](#launching-price-feeds-on-an-evm-network). Please be advised that the steps shown in this tutorial are for demonstration purposes only - it's highly recommended that you [contact the Phala team directly](https://dashboard.phala.network){target=\_blank} as they can assist you with launching price feeds on a network to ensure the integrity of the deployment process.

## How Phala Enables Price Feeds {: #how-phala-enables-price-feeds }

Phala mirrors [Chainlink Price Feeds](https://docs.chain.link/data-feeds/price-feeds){target=\_blank} from Ethereum MainNet. Chainlink Price Feeds have stood the test of time and have wide industry adoption. As a reminder, Chainlink Price Feeds don't rely on any single source of truth, rather, their pricing data is collected and aggregated from a variety of data sources gathered by a decentralized set of independent node operators. This helps to prevent manipulation and erratic pricing data.

The core component of Phala's system design is the [Secure Enclave](https://docs.phala.com/network/tech-specs/blockchain/overview#the-architecture){target=\_blank}, which processes the inputs it receives from the Phala blockchain, acting as an encrypted message queue, and guarantees secure and faithful execution, regardless of the presence of malicious workers. In this sense, the Phala blockchain requests a price feed update, which the Phala off-chain workers fetch from Ethereum MainNet, and return to the Phala blockchain.

It's important to note that Phala isn't limited to replicating existing Oracles. You can create entirely new Oracles by sourcing off-chain data via Phat Contracts. In this [Phat-EVM Oracle example](https://github.com/Phala-Network/phat-offchain-rollup/blob/main/EvmRollup.md){target=\_blank}, pricing data is sourced from the CoinGecko API. Price quote updates can then be constantly streamed from the Phat contract (push design), or the EVM smart contract can ask for a refreshed quote from the Phat contract (pull design).

## Fetch Price Data {: #fetch-price-data }

There are several price feeds available on the demo EVM network that you can interact with. The price feeds enabled by Phat Contracts use the same interface as the Chainlink price feeds. The data lives in a series of smart contracts (one per price feed) and can be fetched with the aggregator interface:

???+ code "AggregatorV3Interface.sol"

    ```solidity
    // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    /**
     * Returns the decimals to offset on the getLatestPrice call
     */
    function decimals() external view returns (uint8);

    /**
     * Returns the description of the underlying price feed aggregator
     */
    function description() external view returns (string memory);

    /**
     * Returns the version number representing the type of aggregator the proxy points to
     */
    function version() external view returns (uint256);

    /**
     * Returns price data about a specific round
     */
    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);

    /**
     * Returns price data from the latest round
     */
    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
}
    ```

As seen above in the interface, there are five functions for fetching data: `decimals`, `description`, `version`, `getRoundData`, and `latestRoundData`. For more information about the `AggregatorV3Interface.sol`, see the [Chainlink API Reference](https://docs.chain.link/data-feeds/api-reference){target=\_blank}.

### Supported Assets {: #supported-assets }

Phala sources its price feed data by mirroring Chainlink's price feeds from Ethereum MainNet. Currently, there are data feed contracts for [the demo EVM network](/builders/tanssi-network/testnet/demo-evm-network/){target=\_blank} for the following asset pairs:

=== "Tanssi Demo EVM Network"
    | Asset & Base Pair |                                                                          Aggregator Contract                                                                          |
    |:-----------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
    |    AAVE to USD    | [{{ networks.demo_evm.oracles.phala.aave_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x2E1640853bB2dD9f47831582665477865F9240DB){target=\_blank} |
    |    BTC to USD     | [{{ networks.demo_evm.oracles.phala.btc_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x89BC5048d634859aef743fF2152363c0e83a6a49){target=\_blank}  |
    |    CRV to USD     | [{{ networks.demo_evm.oracles.phala.crv_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xf38b25b79A72393Fca2Af88cf948D98c64726273){target=\_blank}  |
    |    DAI to USD     | [{{ networks.demo_evm.oracles.phala.dai_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x1f56d8c7D72CE2210Ef340E00119CDac2b05449B){target=\_blank}  |
    |    ETH to USD     | [{{ networks.demo_evm.oracles.phala.eth_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x739d71fC66397a28B3A3b7d40eeB865CA05f0185){target=\_blank}  |
    |    USDC to USD    | [{{ networks.demo_evm.oracles.phala.usdc_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x4b8331Ce5Ae6cd33bE669c10Ded9AeBA774Bf252){target=\_blank} |
    |    USDT to USD    | [{{ networks.demo_evm.oracles.phala.usdt_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x5018c16707500D2C89a0446C08f347A024f55AE3){target=\_blank} |

=== "Ethereum MainNet"
    | Asset & Base Pair |                                                          Aggregator Contract                                                           |
    |:-----------------:|:--------------------------------------------------------------------------------------------------------------------------------------:|
    |    AAVE to USD    | [0x547a514d5e3769680Ce22B2361c10Ea13619e8a9](https://etherscan.io/address/0x547a514d5e3769680Ce22B2361c10Ea13619e8a9){target=\_blank} |
    |    BTC to USD     | [0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c){target=\_blank} |
    |    CRV to USD     | [0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f](https://etherscan.io/address/0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f){target=\_blank} |
    |    DAI to USD     | [0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9](https://etherscan.io/address/0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9){target=\_blank} |
    |    ETH to USD     | [0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419](https://etherscan.io/address/0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419){target=\_blank} |
    |    USDC to USD    | [0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6](https://etherscan.io/address/0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6){target=\_blank} |
    |    USDT to USD    | [0x3E7d1eAB13ad0104d2750B8863b489D65364e32D](https://etherscan.io/address/0x3E7d1eAB13ad0104d2750B8863b489D65364e32D){target=\_blank} |

### Interacting with Price Feeds on the Tanssi Demo EVM Network {: #interacting-with-price-feeds-demo-evm-network }

Next, this tutorial will showcase interacting with the price feed contracts on the demo EVM network. These contracts are already deployed on the demo EVM network, so you can interact with them by accessing the aggregator contract corresponding to your desired asset.

For a refresher on setting up Remix to interface with the demo EVM network, see the [Deploy Smart Contracts with Remix](/builders/toolkit/ethereum-api/dev-env/remix/){target=\_blank} guide. Secondly, make sure you have [connected MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} to the demo EVM network.

Paste the [aggregator contract](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=\_blank} into a new file in Remix and compile it.

![Compile aggregator contract](/images/builders/toolkit/integrations/oracles/phala/phala-1.webp)

Then, take the following steps:

1. Head to the **Deploy and Run Transactions** tab
2. Set the **ENVIRONMENT** to **Injected Provider -- MetaMask**
3. Select the **AggregatorV3Interface** contract from the **CONTRACT** dropdown
4. Enter the data feed contract address corresponding to `BTC to USD`, which is `0x89BC5048d634859aef743fF2152363c0e83a6a49` on the demo EVM network in the **At Address** field and click the **At Address** button

![Access aggregator contract](/images/builders/toolkit/integrations/oracles/phala/phala-2.webp)

The aggregator contract should now be accessible. To interact with the aggregator contract, take the following steps:

1. Expand the **AggregatorV3Interface** contract to reveal the available functions
2. Click **decimals** to query how many digits after the decimal point are included in the returned price data
3. Click **description** to verify the asset pair of the price feed
4. Click **latestRoundData** to see the most recent price data for the asset pair. The price data for the pair is returned as the **int256 answer**

![Check price data](/images/builders/toolkit/integrations/oracles/phala/phala-3.webp)

Note that to obtain a readable price, you must account for the decimals of the price feed, which is available with the `decimals()` method. So in this example, where the price feed returned a value of `5230364122303`, the decimal point will need to be moved eight places, which corresponds to a Bitcoin price of `$52,303.64` at the time of writing.

## Launching Price Feeds on an EVM Network {: #launching-price-feeds-on-an-evm-network }

It's easy to launch price feeds on a Tanssi-powered EVM network! The following sections will walk through the process of launching a variety of price feeds. This process can be followed for quick Trial networks and dedicated networks on [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}. Please be advised that these instructions are for demonstration purposes only, and it's highly recommended that you [contact the Phala Team](https://dashboard.phala.network){target=\_blank} for assistance in any production scenarios.

### Setup {: #setup }

To get started, clone the [Phala Mirrored Price Feed repo](https://github.com/Phala-Network/mirrored-price-feed){target=\_blank} to a local directory. Then, run the following command:

```bash
cd mirrored-price-feed/ && yarn install
```

Then, you'll need to configure your `.env` file. There's a convenient sample file in the repo that you can refer to. From the command line, run:  

```bash
cp env.example .env
```

Next, edit your `.env` to insert the private key of an account funded on your network, and the RPC URL of your network. If building on your own network, you can fund a dummy account from the Sudo account of your network. Your network's Sudo address and RPC URL are both accessible from your dashboard on the [Tanssi DApp](https://apps.tanssi.network){target=\_blank}. You can leave the other fields in the `.env` blank. Your `.env` should resemble the below:

```bash
PRIVATE_KEY=INSERT_PRIVATE_KEY
RPC_URL=INSERT_YOUR_NETWORK_RPC_URL
VERIFIER_URL=
VERIFY_ADDRESS=
```

!!! note
    You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.

### Configure Deployment Script {: #configure-deployment-script }

Next, you'll need to edit the `OffchainAggregator.s.sol` file located in the scripts directory. `OffchainAggregator.sol` takes two parameters upon deployment, a `decimals` value, and a description of the price feed. The decimal value can remain unchanged at `8`, and the description should be changed to the price feed that you'd like to add to your network. In this case, `BTC / USD` is specified. Take care to copy the description exactly as shown, and remember that only specified assets shown in the [Fetch Price Feed Data](#supported-assets) section are supported. If you specify an asset not supported by Phala, the price feed will not work correctly. Your `OffchainAggregator.s.sol` should resemble the following:

???+ code "OffchainAggregator.s.sol"

    ```solidity
    // SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Script, console2} from "forge-std/Script.sol";
import {OffchainAggregator} from "../src/OffchainAggregator.sol";

contract OffchainAggregatorScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();
        OffchainAggregator aggregator = new OffchainAggregator(
          8,
          'BTC / USD'
        );
        console2.log(address(aggregator));
        vm.stopBroadcast();
    }
}
    ```

There are a few more changes that you need to make in `feeder.ts`, the file that maintains and updates your price feeds. You'll need to insert the details of your EVM network as follows:

```typescript
const chain = defineChain({
  id: INSERT_EVM_CHAIN_ID,
  name: 'dancelight-evm-network',
  rpcUrls: {
    default: {
      http: ['INSERT_RPC_URL'],
    },
    public: {
      http: ['INSERT_RPC_URL'],
    },
  },
});
```

You'll also see two arrays of contract addresses at the top of `feeder.ts`. The first array, named `mainnetFeedContracts` refers to Ethereum MainNet aggregator contract addresses, and you can leave that untouched. The second array, named `aggregatorContracts ` still contains the addresses of the aggregator contracts on the demo EVM network. You should erase this array such that it is empty. Later in this guide, you'll return to it and add the contract addresses of your aggregator contracts specific to your Tanssi EVM network once they are deployed.

Once you're finished editing, your `feeder.ts` file should resemble the below:

???+ code "feeder.ts"

    ```ts
    import {
  createPublicClient,
  http,
  parseAbi,
  createWalletClient,
  defineChain,
} from 'viem';
import { mainnet } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts';
import * as dotenv from 'dotenv';

dotenv.config();

const mainnetFeedContracts = {
  'AAVE-USD': '0x547a514d5e3769680Ce22B2361c10Ea13619e8a9',
  'CRV-USD': '0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f',
  'ETH-USD': '0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419',
  'BTC-USD': '0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c',
  'DAI-USD': '0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9',
  'USDT-USD': '0x3E7d1eAB13ad0104d2750B8863b489D65364e32D',
  'USDC-USD': '0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6',
};

const aggregatorContracts = {};

const abi = parseAbi([
  'function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',
  'function transmit(uint80 _roundId, int192 _answer, uint64 _timestamp) external',
  'function getRoundData(uint80 _roundId) public view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',
]);

// Insert your network details here
const chain = defineChain({
  id: INSERT_EVM_CHAIN_ID,
  name: 'dancelight-evm-network',
  rpcUrls: {
    default: {
      http: ['INSERT_RPC_URL'],
    },
    public: {
      http: ['INSERT_RPC_URL'],
    },
  },
});

const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
});

const targetChainPublicClient = createPublicClient({
  chain,
  transport: http(),
});

async function getLatestRoundData(pair: string) {
  const address = mainnetFeedContracts[pair];
  if (!address) {
    throw new Error(`${pair} mainnet feed contract did not exist.`);
  }
  const data = await publicClient.readContract({
    address,
    abi,
    functionName: 'latestRoundData',
  });
  return data;
}

async function getRoundDataFromAggregator(pair: string, roundId: number) {
  const address = aggregatorContracts[pair];
  if (!address) {
    throw new Error(`${pair} aggregator contract did not exist.`);
  }
  const publicClient = createPublicClient({
    chain,
    transport: http(),
  });
  try {
    const data = await publicClient.readContract({
      address,
      abi,
      functionName: 'getRoundData',
      args: [roundId],
    });
    return data;
  } catch {}
}

async function updateFeed(
  walletClient: ReturnType<createWalletClient>,
  pair: string
) {
  if (!aggregatorContracts[pair]) {
    throw new Error(`${pair} aggregator contract did not exist.`);
  }
  const [roundId, answer, startedAt, updatedAt, answeredInRound] =
    await getLatestRoundData(pair);
  const aggregatorRoundId = Number(roundId & BigInt('0xFFFFFFFFFFFFFFFF'));
  const data = await getRoundDataFromAggregator(pair, aggregatorRoundId);
  if (data[1] === answer) {
    console.info(
      `${pair} aggregatorRoundId ${aggregatorRoundId} data exists: ${data}`
    );
    return;
  }

  const hash = await walletClient.writeContract({
    address: aggregatorContracts[pair],
    abi,
    functionName: 'transmit',
    args: [roundId, answer, startedAt],
  });
  await targetChainPublicClient.waitForTransactionReceipt({ hash });
  console.info(`${pair} updated, transmit tx hash: ${hash}`);
}

async function main() {
  if (!process.env.PRIVATE_KEY) {
    throw new Error('missing process.env.PRIVATE_KEY');
  }
  const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);
  const walletClient = createWalletClient({
    chain,
    transport: http(),
    account,
  });
  for (const pair in aggregatorContracts) {
    await updateFeed(walletClient, pair);
  }
}

main()
  .then(() => process.exit(0))
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
    ```

### Build and Test {: #build-and-test }

Run the following commands to build and test the project:

```bash
yarn build
```

```bash
yarn test
```

If everything was successful, you'll see output like the following:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>yarn build</span>
  <span data-ty>yarn run v1.22.10</span>
  <span data-ty="input" data-ty-prompt="$"> forge build</span>
  <span data-ty>[.] compiling</span>
  <span data-ty>No files changed, compilation skipped</span>
  <span data-ty>âœ¨ Done in 0.765.</span>
  <span data-ty> </span>
  <span data-ty="input"><span class="file-path"></span>yarn test</span>
  <span data-ty>yarn run v1.22.10</span>
  <span data-ty="input" data-ty-prompt="$"> forge test</span>
  <span data-ty>[.] compiling</span>
  <span data-ty>No files changed, compilation skipped</span>
  <span data-ty> </span>
  <span data-ty>Running 1 test for test/OffchainAggregator.t.sol:OffchainAggregatorTest</span>
  <span data-ty>[PASS] test_transmit() (gas: 60497)</span>
  <span data-ty>Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.96ms</span>
  <span data-ty>Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)</span>
  <span data-ty>âœ¨ Done in 0.765.</span>
  <span data-ty="input"><span class="file-path"></span> </span>
</div>

### Deploy {: #deploy }

To deploy your aggregator contract for the specified asset/base pair to your EVM network, use the following command:

```bash
yarn deploy
```

You'll get a transaction status as well as a contract address. Copy this contract address, as you'll need to refer to it in the following steps.

<div id="termynal" data-termynal>
  <span data-ty>Waiting for receipts.</span>
  <span data-ty>[O0:00:18]ã€######################################################ã€‘ 1/1 receipts CO.0s)</span>
  <span data-ty>#####7796</span>
  <span data-ty>âœ… [Success]Hash: Oxfb2f2dc6a35286c4595ce6e2bb64c93425b14c310a53f8224df0520666329fd</span>
  <span data-ty>âœ… Contract Address: OxBc788db88C3344a24706754c1203a267790D626</span>
  <span data-ty>Block: 4049</span>
  <span data-ty>Paid: 0.002392252 ETH (598063 gas * 4 gwei)</span>
  <span data-ty></span>
  <span data-ty>Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json</span>
  <span data-ty>Sensitive values saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json</span>
  <span data-ty></span>
  <span data-ty>==========================</span>
  <span data-ty>ONCHAIN EXECUTION COMPLETE & SUCCESSFUL.</span>
  <span data-ty></span>
  <span data-ty>Total Paid: 0.002392252 ETH (598063 gas * avg 4 gwei)</span>
  <span data-ty></span>
  <span data-ty>Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json</span>
  <span data-ty></span>
  <span data-ty>Sensitive values saved to: /Users/kevin/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json</span>
  <span data-ty></span>
  <span data-ty>âœ¨ Done in 30.765s.</span>
  <span data-ty="input"><span class="file-path"></span> </span>
</div>

### Access Aggregator Contract {: #access-aggregator-contract }

Next, this tutorial will demonstrate interacting with the newly deployed aggregator contract. Make sure that your MetaMask wallet is connected to your EVM network. You can add your network to your MetaMask by pressing **Add to MetaMask** on your dashboard on the [Tanssi dApp](https://apps.tanssi.network){target=\_blank}.

Paste the [aggregator contract](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=\_blank} into a new file in Remix and compile it.

Then, take the following steps:

1. Head to the **Deploy and Run Transactions** tab
2. Set the **ENVIRONMENT** to **Injected Provider -- MetaMask** and ensure that your MetaMask is on the network of your EVM network. You can verify the EVM chain ID in Remix if you are unsure
3. Select the **AggregatorV3Interface** contract from the **CONTRACT** dropdown
4. Enter the data feed contract address corresponding to your desired asset pair that was returned on the command line in the prior section in the **At Address** field and click the **At Address** button

![Access aggregator contract](/images/builders/toolkit/integrations/oracles/phala/phala-4.webp)

Expand the **AggregatorV3Interface** contract to reveal the available functions and click **latestRoundData** to see the most recent price data for the asset pair. You should see `0` values for all. This is because your aggregator contract has been deployed, but it hasn't yet fetched price data. You can fix this with a quick price feed update.

![Get output of deployed aggregator contract](/images/builders/toolkit/integrations/oracles/phala/phala-5.webp)

### Trigger Price Feed Update {: #Trigger Price Feed Update }

In a prior section, you cleared out the array of aggregator contracts, but since you've now deployed an aggregator contract, you should specify it in the `feeder.ts` file so that you can manually trigger a refresh of the price data. Edit the `aggregatorContracts` array as follows:

```typescript
const aggregatorContracts = {
  'BTC-USD': 'INSERT_AGGREGATOR_CONTRACT_ADDRESS',
}
```

Then, from the command line, run the following command:

```bash
npx tsx feeder.ts 
```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>npx tsx feeder.ts</span>
  <span data-ty>BTC-USD updated, transmit tx hash: Oxf1797cfc5bd71e2d848b099cae197ff30dafb5f6947481a5ef6c69271e059a96</span>
  <span data-ty="input"><span class="file-path"></span> </span>
</div>

Upon returning to Remix, click **latestRoundData** once more, and after waiting a moment, you should see an accurate value returned.

![Check price data](/images/builders/toolkit/integrations/oracles/phala/phala-6.webp)

For more information about using Phala to access off-chain data, be sure to check out the [Phala docs site](https://docs.phala.com/overview/phala-network){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/wallet-integrations/
--- BEGIN CONTENT ---
---
title: Wallets Integrations
description: Learn how to add wallet integrations to your dApp on Tanssi-powered networks so users can automatically connect to their wallets.
icon: material-wallet-outline
template: index-page.html
---

# Wallets Integrations

Wallet integrations are essential for enabling user interactions with decentralized applications (dApps) by allowing users to securely manage their digital assets, sign transactions, and authenticate their identity. These integrations provide developers with the tools to build applications that can interact with usersâ€™ wallets, facilitating blockchain transactions and interactions in a user-friendly manner.

Main features of wallet integraions include:

- **Multi-wallet support** - out-of-the-box support for multiple wallet providers, reducing the need for custom integration
- **Improved user experience** - users can easily connect using their preferred wallet via an intuitive user interface
- **Pre-built UI components** - ready-to-use UI components for  wallet connection, account display, and balance management, streamlining development
- **Customization** - customize the wallet modal's appearance and behavior to match your branding and user interface design

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/integrations/wallet-integrations/rainbowkit/
--- BEGIN CONTENT ---
---
title: How to Add RainbowKit to a Tanssi EVM Network 
description: Learn how to integrate RainbowKit with an Ethereum-compatible network deployed through Tanssi, making adding a great wallet experience to your dApp easy.
icon: material-wallet-outline
categories: EVM-Template
---

# Integrate RainbowKit with a Tanssi Network 

## Introduction 

[RainbowKit](https://rainbowkit.com/docs/introduction){target=\_blank} is a React library that adds wallet connection capabilities to a dApp. It supports numerous wallets and enables features such as switching connection chains, ENS address resolution, and balance display out-of-the-box. RainbowKit offers customization options for all EVM-compatible chains, making it possible to connect wallets to a network easily.


RainbowKit bundles together multiple tools to simplify adding wallet connections to a dApp:

- [Wagmi](https://wagmi.sh/){target=\_blank} - a React Hooks library for interacting with Ethereum accounts, wallets, contracts, transactions, signing, ENS, and more
- [viem](https://viem.sh/){target=\_blank} - TypeScript interface which provides low-level stateless primitives for interacting with Ethereum
- [WalletConnect](https://walletconnect.com/){target=\_blank} - adds encrypted connections and enhanced UX experiences like connecting a mobile wallet by scanning a QR code
- [TanStack Query](https://tanstack.com/query/latest/docs/framework/react/overview){target=\_blank} - helps manage and update server state within the application

This guide explains how to add RainbowKit to a dApp running on top of a Tanssi-powered network using the CLI, along with options for further customizing the integration.

## Quick Start {: #quick-start }

To start a new project, RainbowKit can scaffold a project using the CLI, combining RainbowKit and Wagmi in a [Next.js](https://nextjs.org/docs){target=\_blank} application. Use your preferred package manager to run the CLI command and start the project:

=== "npm"

    ```bash
    npm init @rainbow-me/rainbowkit@latest 
    ```

=== "pnpm"

    ```bash
    pnpm create @rainbow-me/rainbowkit@latest
    ```
=== "yarn"

    ```bash
    yarn create @rainbow-me/rainbowkit
    ```

The script will prompt for a project name, generate a new directory with the boilerplate starter code, and install all required dependencies. 

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>npm init @rainbow-me/rainbowkit@latest
</span>
    <span data-ty="input" data-ty-prompt=""> ðŸŒˆ Welcome to RainbowKit!</span>
    <span data-ty="input" data-ty-prompt="âœ” What is the name of your project?"> rainbow-demo</span>
    <span data-ty="input" data-ty-prompt=""> ðŸš€ Creating a new RainbowKit app in /Users/papermoon/Documents/papermoon_builds/RainbowKit/add-rainbow-kit/rainbow-demo</span>
    <span data-ty="input" data-ty-prompt=""> ðŸ“¦ Installing dependencies with npm. This could take a while.</span>
    <span data-ty="input" data-ty-prompt="">ðŸ“š Initializing git repository</span>
    <span data-ty="input" data-ty-prompt=""> ðŸŒˆ Done! Thanks for using RainbowKit ðŸ™</span>
    <span data-ty="input" data-ty-prompt=""> ðŸ‘‰ To get started, run cd rainbow-demo and then npm run dev</span>
    <span data-ty="input"><span class="file-path"></span></span>
</div>

Navigate to the project directory, start the development server, and open `http://localhost:3000` to view the project locally:

=== "npm"

    ```bash
    cd INSERT_PROJECT_NAME
    npm run dev 
    ```

=== "pnpm"

    ```bash
    cd INSERT_PROJECT_NAME
    pnpm run dev
    ```

=== "yarn"

    ```bash
    cd INSERT_PROJECT_NAME
    yarn dev
    ```

The starting screen should look like this:

![Scaffolded RainbowKit project landing page](/images/builders/toolkit/integrations/wallet-integrations/rainbowkit/rainbowkit-1.webp)

Open the project in a code editor and examine the directory and file structure, paying particular attention to the `wagmi.ts` file. This file allows configuration of the chains included in the list of networks that users can connect to via the dApp.

Since the [demo EVM network](https://apps.tanssi.network/demo/){target=\_blank} is a custom network on Tanssi, it cannot be imported directly from `wagmi/chains`. Instead, define the chain manually in the `wagmi.ts` file. For example, if the network uses the Tanssi demo network or another EVM-compatible chain, the necessary configurations must be added manually.

Here is the configuration for the demo EVM network on Tanssi:

=== "Demo EVM Network"
    ```js title="src/wagmi.ts"
    import '@rainbow-me/rainbowkit/styles.css';
import { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';
import { WagmiProvider } from 'wagmi';
import { QueryClientProvider, QueryClient } from '@tanstack/react-query';

import { type Chain } from 'viem'

export const demoEVMChain = {
  id: 5678,
  name: "Tanssi demo EVM Network",
  nativeCurrency: { name: "TANGO", symbol: "TANGO", decimals: 18 },
  rpcUrls: {
    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }
  },
  blockExplorers: {
    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }
  },
} as const satisfies Chain


export const config = getDefaultConfig({
  appName: 'My Tanssi-powered Network',
  projectId: 'TODO: get project id from...',
  chains: [demoEVMChain], 
  ssr: true,
});
    ```

To add support for the demo EVM network on Tanssi, update `wagmi.ts` as shown above. The following section explains how to generate the `projectId` value for WalletConnect.

## Manual Setup 

The following sections will walk you through the steps to integrate RainbowKit into an existing React application, such as installing and importing the necessary dependencies, configuring chain connections, and making the RainbowKit functionality available to users in the dApp. The setup will also include steps to specify which chain the **Connect Wallet** button should connect to by default and how to customize the RainbowKit theme to fit the project. This guide is based on the Tanssi [demo EVM network](https://apps.tanssi.network/demo){target=\_blank}, but can be adapted for your own Tanssi-powered EVM network by changing the RPC URL parameter.

### Checking Prerequisites {: #checking-prerequisites }

Before proceeding, ensure the following prerequisites are met:

- A Tanssi EVM-compatible network

- An existing dApp built with [React](https://react.dev/){target=\_blank}

- The [RainbowKit examples repository](https://github.com/rainbow-me/rainbowkit/tree/main/examples){target=\_blank} includes templates for multiple React frameworks
    
 - To follow this guide, visit [Next.js](https://nextjs.org/docs){target=\_blank} and follow the **Automatic Installation** instructions, selecting Typescript and the App Router options during setup 

- The wallet must support custom networks, as the Tanssi demo EVM network will be added manually

- A WalletConnect `projectId` - every dApp relying on WalletConnect is required to have an associated `projectId`. It is free to create an account,  and an ID can be generated instantly

    To obtain a WalletConnect `projectId`:

    1. Visit [WalletConnect Cloud](https://cloud.walletconnect.com/){target=\_blank}
    2. On the **Projects** page, select **Create** 
    3. Add the project information (leaving the **Homepage URL** blank if the dApp is not deployed)
    4. Select the **AppKit** SDK
    5. Select a coding environment or platform (React is used in this guide)
    6. Locate the `projectId` in the left menu. or find it in the **Get started** code snippet of WalletConnect Quickstart
 
### Getting Started {: #getting-started }

Ensure that the project is in the root directory before proceeding, then install RainbowKit and its peer dependencies:

=== "npm"

    ```bash
    npm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query
    ```

=== "pnpm"

    ```bash
    pnpm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query
    ```

=== "yarn"

    ```bash
    yarn add @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query
    ```
These packages provide the core functionality for wallet connections (RainbowKit), Ethereum interactions (wagmi and viem), and state management (TanStack Query).

Next, start the development server to create a local dApp instance:

=== "npm"

    ```bash
    npm run dev
    ```

=== "pnpm"

    ```bash
    pnpm run dev
    ```

=== "yarn"

    ```bash
    yarn dev
    ```

After starting the server, open `http://localhost:3000` to view the Next.js application in the browser.

To test the RainbowKit connection, the MetaMask app can be used. Ensure that the Tanssi demo EVM network is connected in the MetaMask wallet.

To add the Tanssi demo EVM network to MetaMask:

1. Open MetaMask and go to Settings > Networks > Add Network.
2. Input the following information:
    - Network Name: `Demo EVM Chain`
    - RPC URL: `{{ networks.dancelight.demo_evm_rpc_url }}`
    - Chain ID: `{{ networks.dancelight.demo_evm_chain_id }}`
    - Currency Symbol: `{{ networks.dancelight.demo_evm_token_symbol }}`
    - Block Explorer URL: `{{ networks.dancelight.demo_evm_blockscout_url }}`

For detailed instructions on connecting MetaMask to the Tanssi demo EVM network, refer to the guide [Connect MetaMask to your Tanssi EVM Network](https://docs.tanssi.network/builders/toolkit/ethereum-api/wallets/metamask/#connect-metamask-to-evm-network){target=\_blank}.

After connecting, `the projectId` can be safely added to the application:

1. Create a `.env.local` file in the root directory of the project

    ```bash
    touch .env.local
    ```

2. Add the `projectId` to this file

    ```text title=".env.local"
    NEXT_PUBLIC_PROJECT_ID='INSERT_PROJECT_ID'
    ```

3. Locate the `.gitignore` file in this same directory and ensure `.env*.local` is included in the list of files to ignore. This will prevent committing the `projectId` to GitHub

The stored `projectId` will be required for configuring the `wagmi` settings in the upcoming section.

### Connect DApp to MetaMask 

With the development environment set up and MetaMask configured for the Tanssi demo EVM network, the next step is to configure the dApp to connect with MetaMask's wallet using RainbowKit. This process involves the following key steps:

1. Import RainbowKit, Wagmi, and TanStack Query
2. Setup configuration for Wagmi
3. Wrap the application with providers
4. Add the connect button

### Import RainbowKit, Wagmi, and TanStack Query

To proceed, ensure the project is in the root directory, and then create a new file called `wagmi.ts`. This file will contain the necessary imports and configurations to connect the dApp to wallets and interact with blockchains.

```bash
touch wagmi.ts
```
In `wagmi.ts`, import the necessary libraries and define Demo EVM Chain as the supported chain:

```ts title="wagmi.ts"
import '@rainbow-me/rainbowkit/styles.css';
import { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';
import { WagmiProvider } from 'wagmi';
import { QueryClientProvider, QueryClient } from '@tanstack/react-query';

import { type Chain } from 'viem'

export const demoEVMChain = {
  id: 5678,
  name: "Tanssi demo EVM Network",
  nativeCurrency: { name: "TANGO", symbol: "TANGO", decimals: 18 },
  rpcUrls: {
    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }
  },
  blockExplorers: {
    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }
  },
} as const satisfies Chain


export const config = getDefaultConfig({
  appName: 'My Tanssi-powered Network',
  projectId: 'process.env.NEXT_PUBLIC_PROJECT_ID',
  chains: [demoEVMChain ], 
  ssr: true,
});
```

### Wrap the Application with Providers

Next, create a file named `providers.tsx` to wrap the application with the necessary providers: `WagmiProvider`, and `QueryClientProvider`.

```bash
cd app &&
touch providers.tsx
```

Open `providers.tsx` add the following code to manage the providers

```ts title="providers.tsx"
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider } from 'wagmi';
import { RainbowKitProvider } from '@rainbow-me/rainbowkit';
import { config } from '../wagmi';

const queryClient = new QueryClient();

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider>{children}</RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

Now locate the `layout.tsx` file inside the `app` directory and modify the code to import `Providers` and wrap the application:

```ts title="layout.tsx"
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import '@rainbow-me/rainbowkit/styles.css';
import { Providers } from './providers';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'My Tanssi dApp',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang='en'>
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```
This ensures that the app is wrapped with all necessary providers, including wagmi, and TanStack Query for state management.

### Add the Connect Button

RainbowKit offers a `ConnectButton` component, which renders the **Connect** and **Disconnect** buttons and UI elements for switching chains. This example imports the `ConnectButton` into the existing `page.tsx` file for simplicity, though it can also be added to an element like a **Header** or **Navbar** to appear at the top of every page. Update the code in `page.tsx` as follows:

```ts title="page.tsx"
import { ConnectButton } from '@rainbow-me/rainbowkit';

export default function Home() {
  return (
    <div className="flex h-screen items-center justify-center">
      <ConnectButton />
    </div>
  );
}
```

Once the development server is running, the home page will display a **Connect Wallet** button. Clicking this button will open the RainbowKit modal, providing options to either connect an existing wallet or get a new one. Select **MetaMask** and follow the on-screen instructions to complete the connection process.

The current configuration defaults to connecting to Demo EVM Chain and displays the current network, the native token balance, and the connected wallet address. If multiple networks are supported, selecting the arrow next to it will open the Switch Networks modal. This allows users to select another network and authorize the change.

Once connected, users will see their {{ networks.dancelight.demo_evm_token_symbol }} token balance and wallet address.

## Customize RainbowKit

RainbowKit simplifies the complexities of managing wallet connections while offering various options for customizing UI and functionality to fit the needs of a dApp. A full list of customization options can be found in the RainbowKit [documentation](https://rainbowkit.com/docs/introduction){target=\_blank}. This section covers customizing the **Connect Wallet** button to connect initially to the Demo EVM Chain and render it in a custom color. 

### Set Custom Initial Chain

By default, RainbowKit connects to the first chain supplied to Wagmi in the config. The order of chains listed in `wagmi.ts` will match the order displayed in the **Switch Networks** modal. To ensure that the Tanssi demo EVM network is always the default connection, simply move it to the top of the chain list. However, Relying solely on this default behavior might not be the best option.

A better approach is to use the `initialChain` prop in the `RainbowKitProvider` component. This prop defines which chain the wallet will connect to initially when **Connect Wallet** is selected. To configure this, open the `providers.tsx` file and update the code by passing the `initialChain` prop with the custom Tanssi demo EVM network object defined earlier:

```Ts title="providers.tsx"
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider } from 'wagmi';
import { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';
import { config, demoEVMChain } from '../wagmi';

const queryClient = new QueryClient();

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider initialChain={demoEVMChain}>
          {children}
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );

}
```

By setting `initialChain={demoEVMChain}`, RainbowKit will attempt to connect to the Tanssi demo EVM network first whenever the **Connect Wallet** button is clicked.

### Define Custom Theme Colors

RainbowKit provides three built-in theme functions: `lightTheme`, `darkTheme`, and `midnightTheme`. These functions return a theme object that can be passed to the `RainbowKitProvider` prop `theme` to customize colors, border radius, font stack, and overlay blur. Update `providers.tsx` with the following code and ensure that `darkTheme` is added to the `@rainbow-me/rainbowkit` import statement for the changes to apply correctly. After customizing the initial chain and theme, the `providers.tsx` file will look like this:

```js title="providers.tsx"
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider } from 'wagmi';
import { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';
import { config, demoEVMChain } from '../wagmi';

const queryClient = new QueryClient();

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider
          initialChain={demoEVMChain}
          theme={darkTheme({
            accentColor: '#189B9B', // Tanssi accent color
            accentColorForeground: 'white',
            borderRadius: 'medium',
            fontStack: 'system',
            overlayBlur: 'small'
          })}
        >
          {children}
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```
This configuration sets a dark theme with custom properties:

- `accentColor` - the primary highlight color. In this example, Tanssi's accent color (#189B9B) is used, but it can be adjusted to match the branding of the dApp
- `accentColorForeground` - the text color used on top of the accent color
- `borderRadius` - controls the roundness of UI elements. Options are 'none', 'small', 'medium', or 'large'
- `fontStack` - defines the fonts used. 'system' uses the default system fonts
- `overlayBlur` - the blur effect applied to the background when modals are open

!!! tip
    Experiment with different theme functions (`lightTheme`, `darkTheme`, `midnightTheme`) and color combinations to find the best match for the visual style of the dApp.

## Handle Disconnections

To disconnect MetaMask from the dApp and reconnect for testing purposes, two methods can be used to complete this process.  

### Disconnect from DApp {: #disconnect-from-dapp }

RainbowKit includes a **Disconnect** button out of the box. To open the modal, select the arrow next to the account number. Click the **Disconnect** button. At this point, the **Connect Wallet** option will reappear, and the account information will no longer be visible.

![Built in Disconnect button](/images/builders/toolkit/integrations/wallet-integrations/rainbowkit/rainbowkit-2.webp)

### Disconnect from MetaMask  {: #disconnect-from-metamask }

Some users prefer to disconnect from their wallet rather than use a button within a dApp. To use this method: 

1. Select the MetaMask extension in the browser to open the modal
2. Select the three dots in the upper right corner of the MetaMask modal
3. Select **Connected sites**
4. Review the list of sites connected to the wallet
5. Select **Disconnect** for each site that should be disconnected

## Final Result {: #final-result }

The **Connect Wallet** button on the home page should now render in the color specified for `accentColor` during theme customization. After selecting **Connect Wallet**, the same accent color will be displayed in the modal. MetaMask can be chosen, and signing the transaction will authorize the connection. The Tanssi demo EVM network will appear as the connected network, along with the {{ networks.dancelight.demo_evm_token_symbol }} token balance, without the need for manual network switching.


![Theme customization on the user modal](/images/builders/toolkit/integrations/wallet-integrations/rainbowkit/rainbowkit-3.webp)

This guide includes only a few of the customization options available through RainbowKit. More information about the library's capabilities and options can be found in the [RainbowKit Docs](https://rainbowkit.com/docs/introduction){target=\_blank}.

The complete example code is available in the [rainbow-manual-build-demo repository](https://github.com/papermoonio/rainbowkit-manual-build-demo){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/dev-env/chopsticks/
--- BEGIN CONTENT ---
---
title: How to use Chopsticks to Fork Your Network
description: Learn the basics of how to use Chopsticks to replay blocks, dissect state changes, test XCM interactions, and create a local fork of your Tanssi network.
icon: octicons-code-square-24
categories: Substrate-Template, EVM-Template
---

# How to Use Chopsticks to Fork Your Network

## Introduction {: #introduction }

[Chopsticks](https://github.com/AcalaNetwork/chopsticks){target=\_blank} provides a developer-friendly method of locally forking existing [Substrate-based](/learn/framework/overview/){target=\_blank} chains. It allows for the replaying of blocks to easily examine how transactions affect the state, the forking of multiple Tanssi networks for XCM testing, and more. This empowers developers to test and experiment with their custom blockchain configurations in a local development environment without deploying a live network.

Overall, Chopsticks aims to simplify the process of building blockchain applications on Substrate and make it accessible to a wider range of developers.

This article will cover using Chopsticks to fork and interact with the local copy of a Tanssi network.

!!! note
    Chopsticks currently does not support calls done via the Ethereum JSON-RPC. Consequently, you can't fork your chain using Chopsticks and connect Metamask to it.

## Prerequisites {: #prerequisites }

To follow along with this tutorial, you will need to clone the repository along with its submodules([Smoldot](https://github.com/smol-dot/smoldot.git){target=\_blank}):

```bash
git clone --recurse-submodules https://github.com/AcalaNetwork/chopsticks.git
```

Then, get into the folder and install the dependencies using [yarn](https://classic.yarnpkg.com/en/docs/install){target=\_blank}:

```bash
 cd chopsticks && yarn
```

Finally, build the project:

```bash
yarn build-wasm
```

Now the development environment is ready to start testing and debugging Tanssi-deployed networks.

## Forking a Demo EVM Network with Chopsticks {: #forking-demo-chain }

To fork a Tanssi network using Chopsticks, execute the command with only the RPC endpoint as a parameter:

```bash
yarn start --endpoint {{ networks.dancelight.demo_evm_rpc_wss_url }}
```

This command will start a local clone of the chain as it was in the latest block.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>
    chopsticks % yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001
  </span>
  <span data-ty>
    [01:59:42.628] INFO (xcm/59650): Frontier Container 2001 RPC listening on port 8000
  </span>
</div>

Typically, the configuration parameters are stored in a configuration file, as are the configurations in the repository's `configs` folder for the relay chains and parachains deployed in the Dotsama ecosystem. The following configuration file works for the [demo EVM network](/builders/tanssi-network/testnet/demo-evm-network/){target=\_blank}, overriding the chain's sudo account with Alith's and additionally funding the account with tokens:

```yaml
endpoint: {{ networks.dancelight.demo_evm_rpc_wss_url }}
mock-signature-host: true
allow-unresolved-imports: true
db: ./tmp/db_ftrcon.sqlite

import-storage:
  System:
    Account:
      - - - "0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac" # Alith
        - providers: 1
          sufficients: 1
          consumers: 1
          data:
            free: "100000000000000000000000"
  Sudo:
    Key: "0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac"
```

The configuration file accepts all of the following parameters:

|           Option           |                                                 Description                                                  |
|:--------------------------:|:------------------------------------------------------------------------------------------------------------:|
|         `genesis`          |          The link to a parachain's raw genesis file to build the fork from, instead of an endpoint.          |
|        `timestamp`         |                                     Timestamp of the block to fork from.                                     |
|         `endpoint`         |                                    The endpoint of the parachain to fork.                                    |
|          `block`           |                       Use to specify at which block hash or number to replay the fork.                       |
|      `wasm-override`       |              Path of the Wasm to use as the parachain runtime instead of an endpoint's runtime.              |
|            `db`            |               Path to the name of the file that stores or will store the parachain's database.               |
|          `config`          |                                       Path or URL of the config file.                                        |
|           `port`           |                                      The port to expose an endpoint on.                                      |
|     `build-block-mode`     |                       How blocks should be built in the fork: batch, manual, instant.                        |
|      `import-storage`      |              A pre-defined JSON/YAML storage file path to override in the parachain's storage.               |
| `allow-unresolved-imports` |              Whether to allow Wasm unresolved imports when using a Wasm to build the parachain.              |
|           `html`           |                           Include to generate storage diff preview between blocks.                           |
|   `mock-signature-host`    | Mock signature host so that any signature starts with `0xdeadbeef` and filled by `0xcd` is considered valid. |

You can run the command `yarn start` to fork chains by specifying a local configuration file. Alternatively, the name or the GitHub URL can be used if the chain is listed in the repository's `configs` folder.

=== "Local File Path"

    ```bash
    yarn start --config=configs/polkadot.yml
    ```

=== "Chain Name"

    ```bash
    yarn start --config=polkadot
    ```

=== "GitHub URL"

    ```bash
    yarn start \
    --config=https://github.com/AcalaNetwork/chopsticks.git/master/configs/polkadot.yml
    ```

All settings (except `genesis` and `timestamp`) can also be passed as flags to configure the environment completely in the command line. For example, the following command forks the demo EVM network at block 100.

```bash
yarn start --endpoint {{ networks.dancelight.demo_evm_rpc_wss_url }} --block 100
```

### Interacting with a Fork {: #interacting-with-a-fork }

When running a fork, by default, it will be accessible at:

```text
ws://localhost:8000
```

You can interact with the parachain via libraries such as [Polkadot.js](https://github.com/polkadot-js/common){target=\_blank} and its [user interface, Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A8000#/explorer){target=\_blank}.

![Polkadot Js](/images/builders/toolkit/substrate-api/dev-env/chopsticks/chopsticks-1.webp)

You should now be able to interact with the forked chain as you would with the real one.

!!! note
    If your browser cannot connect to the WebSocket endpoint provided by Chopsticks, you might need to allow insecure connections for the Polkadot.js Apps URL. Another solution is to run the [Docker version of Polkadot.js Apps](https://github.com/polkadot-js/apps#docker){target=\_blank}.

## Replaying Blocks {: #replaying-blocks }

If you would like to replay a block and retrieve its information to dissect the effects of an extrinsic, you can use the `yarn start run-block` command. Its following flags are:

|            Flag            |                                      Description                                       |
|:--------------------------:|:--------------------------------------------------------------------------------------:|
|         `endpoint`         |                         The endpoint of the parachain to fork.                         |
|          `block`           |            Use to specify at which block hash or number to replay the fork.            |
|      `wasm-override`       |   Path of the Wasm to use as the parachain runtime instead of an endpoint's runtime.   |
|            `db`            |    Path to the name of the file that stores or will store the parachain's database.    |
|          `config`          |                            Path or URL of the config file.                             |
| `output-path=/[file_path]` |   Use to print out results to a JSON file instead of printing it out in the console.   |
|           `html`           | Include to generate an HTML representation of the storage diff preview between blocks. |
|           `open`           |                        Whether to open the HTML representation.                        |

For example, running the following command will re-run the demo EVM networks's block 1000 and write the storage diff and other data in a `chain-output.json` file:  

```bash
yarn start run-block  \
--endpoint {{ networks.dancelight.demo_evm_rpc_wss_url }}  \
--output-path=./chain-output.json  \
--block 1000
```

## WebSocket Commands {: #websocket-commands }

Chopstick's internal WebSocket server has special endpoints that allow the manipulation of the local Substrate chain.

These are the methods that can be invoked and their parameters:

???+ function "**dev_newBlock** (options) â€” Generates one or more new blocks"

    === "Parameters"

        - **options** - `{ "to": number, "count": number }` - a JSON object where `"to"` will create blocks up to a certain value, and `"count"` will increase by a certain number of blocks. Use only one entry at a time within the JSON object

    === "Example"

        ```js
        import { WsProvider } from '@polkadot/api'
        const ws = new WsProvider(`ws://localhost:8000`)
        // Creates five new blocks
        await ws.send('dev_newBlock', [{ count: 5 }])
        ```

??? function "**dev_setStorage** (values, blockHash) â€” Creates or overwrites the value of any storage"

    === "Parameters"

         - **values** - Object - a JSON object resembling the path to a storage value, similar to what you would retrieve via Polkadot.js  
        - **blockHash** - String - optional, the block hash at which the storage value is changed  
        
    === "Example"

        ```js
        import { WsProvider } from '@polkadot/api';
        const ws = new WsProvider(`ws://localhost:8000`);
        // Overwrites the sudo key
        await ws.send('dev_setStorage', 
            [{"Sudo": { "Key": "0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b" }}]
        );
        ```

??? function "**dev_timeTravel** (date) â€” Sets the timestamp of the block to the date value"

    === "Parameters"

         - **date** - Date - a string compatible with the JavaScript Date library that will change the timestamp at which the next blocks being created will be. All future blocks will be sequentially created after that point in time  

    === "Example"

        ```js
        import { WsProvider } from '@polkadot/api';
        const ws = new WsProvider(`ws://localhost:8000`);
        // Sets the timestamp of the block to 15th August 2030
        await ws.send('dev_timeTravel', ["2030-08-15T00:00:00"]);
        ```

??? function "**dev_setHead** (hashOrNumber) â€” Sets the head of the blockchain to a specific hash or number"

    === "Parameters"

         - **hashOrNumber** - number | string - if found, the chain head will be set to the block with the block number or block hash of this value
        
    === "Example"

        ```js
        import { WsProvider } from '@polkadot/api';
        const ws = new WsProvider(`ws://localhost:8000`);
        // Sets the head to block number 500
        await ws.send('dev_setHead', [500]);
        ```

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/dev-env/
--- BEGIN CONTENT ---
---
title: Substrate Development Environments
description: Check out the Substrate development environments, which can be used to develop, test, and debug a Tanssi-powered network in a local development environment.
icon: octicons-code-square-24
template: index-page.html
---

# Set Up Your Workspace

Building on Substrate involves working with a flexible, modular blockchain framework. Unlike traditional blockchains, Substrateâ€™s pallet-based architecture allows developers to create custom blockchains and integrate specialized features, which requires a development environment tailored to its complexities.

In this section, you'll explore tools and techniques that can help you achieve the following with a Substrate development environment:

- **Local environment setup** - spin up a test environment without dealing with the complexity of configuring a Substrate node manually
- **Network interaction** - connect to and interact with Tanssi and Tanssi-powered networks
- **Transaction simulation** - test and simulate transactions on forked networks to evaluate changes before deploying
- **Debugging** - use debugging tools to troubleshoot and analyze transaction flow, state transitions, and more in a controlled environment

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/
--- BEGIN CONTENT ---
---
title: Substrate API
description: Learn how to interact with your Tanssi-powered network using the Substrate API, leveraging tools like the Polkadot.js API, Sidecar API, Chopsticks, and others.
icon: simple-paritysubstrate
template: index-page.html
---

# Substrate Tools

When developing on Tanssi or any Tanssi-powered network, it's important to understand the underlying infrastructure that drives these chains. Built on top of the Substrate framework, these networks offer a robust and flexible foundation for building decentralized applications and services. Interacting with the Substrate API is key to engaging with the blockchain's core functionalities.

Whether you're building decentralized applications (dApps), deploying smart contracts, or querying blockchain data, having the right tools and workflows to interact with this API will help you streamline development and ensure seamless integration with the network.

Ready to dive in? Check out some of the following tools:

- **Development environments** - [Chopsticks](/builders/toolkit/substrate-api/dev-env/chopsticks/)
- **Libraries** - [Polkadot.js API](/builders/toolkit/substrate-api/libraries/polkadot-js-api/) and [Sidecar REST API](/builders/toolkit/substrate-api/libraries/sidecar-api/)
- **Wallets** - [SubWallet](/builders/toolkit/ethereum-api/wallets/subwallet/), and [Talisman](/builders/toolkit/ethereum-api/wallets/talisman/)

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/libraries/
--- BEGIN CONTENT ---
---
title: Substrate Libraries
description: Learn how to use Substrate libraries such as the Polkadot.js API to send transactions (extrinsics) and interact with an network's Substrate-layer.
icon: octicons-code-24
template: index-page.html
---

# Libraries

As Tanssi and Tanssi-powered networks are built on Substrate, developers can utilize libraries tailored to the Substrate API to tap into the networkâ€™s distinctive features.

These libraries streamline the interaction with Substrateâ€™s modular architecture, helping you navigate the complexities of custom modules with ease and accelerate your development process.

Some key capabilities of working with libraries include:

- **Transaction management** - build and sign transactions for submitting extrinsics (state changes) to the blockchain
- **Interaction with custom modules** - invoke a module's exposed functions, to query chain data or trigger state changes
- **Account management** - create cryptographic key pairs for signing transactions and manage on-chain account information such as balances

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/libraries/polkadot-js-api/
--- BEGIN CONTENT ---
---
title: How to use the Polkadot.js API
description: Learn how to use the Polkadot.js API to interact with a Tanssi-powered network to get chain data and send transactions (extrinsics) via the Substrate API.
icon: octicons-code-24
categories: Substrate-Template
---

# Polkadot.js API Library

## Introduction {: #introduction }

[Polkadot.js](https://wiki.polkadot.com/general/polkadotjs/){target=\_blank} is a collection of tools that allow you to interact with Substrate-based blockchains, such as your Tanssi-powered network! The [Polkadot.js API](https://polkadot.js.org/docs/api){target=\_blank} is one component of Polkadot.js and is a library that allows application developers to query a network and interact with the node's Substrate interfaces using JavaScript, enabling you to read and write data to the network.

You can use the Polkadot.js API to query on-chain data and send transactions from the Substrate side of your Tanssi network. You can query runtime constants, chain state, events, transaction (extrinsic) data, and more.

Here you will find an overview of the available functionalities and some commonly used [TypeScript](https://www.typescriptlang.org){target=\_blank} code examples to get you started on interacting with your Tanssi network using the Polkadot.js API library.

!!! note "Editorâ€™s Note (2025 Update)"
    Polkadot.js is the name of a developer toolset created for interacting with Substrate-based blockchains. While the name references Polkadot, the library itself is chain-agnostic and works with any Substrate-based network, including Tanssi.

!!! note
    The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.
    
    Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their [official documentation](https://nodejs.org/en/download){target=\blank}.
    
    Also, make sure you've initialized a `package.json` file for ES6 modules. You can initialize a default `package.json` file using npm by running the following command `npm init --yes`.

## Install Polkadot.js API {: #installing-polkadot.js-api-library }

First, you need to install the Polkadot.js API library and the RLP library through a package manager such as `yarn`. Both dependencies are required to run the examples in this guide successfully.

Install them in your project directory with the following command:

=== "npm"

    ```bash
    npm i @polkadot/api
    npm i @polkadot/util-rlp
    ```

=== "yarn"

    ```bash
    yarn add @polkadot/api
    yarn add @polkadot/util-rlp
    ```

The library also includes other core components, like Keyring for account management or some utilities that are used throughout this guide.

## Create an API Provider Instance {: #creating-an-API-provider-instance }

To start interacting with your Tanssi network using the Polkadot.js API, you first need to create an instance of the Polkadot.js API. Create the `WsProvider` using the WebSocket endpoint of your Tanssi network.

```typescript
// Import
import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Code goes here

  await api.disconnect();
};

main();
```

### Metadata and Dynamic API Decoration {: #metadata-and-dynamic-api-decoration }

Before diving into the details of performing different tasks via the Polkadot.js API library, it's useful to understand some of the basic workings of the library.

When the Polkadot.js API connects to a node, one of the first things it does is retrieve the metadata and decorate the API based on the metadata information. The metadata effectively provides data in the form of:

```text
api.<type>.<module>.<section>
```

Where `<type>` can be either:

- `query` - for endpoints to read all the state queries
- `tx` - for endpoints related to transactions
- `rpc` - for endpoints specific to RPC calls
- `consts` - for endpoints specific to runtime constants

And therefore, none of the information contained in the `api.{query, tx, rpc, consts}.<module>.<method>` endpoints are hard-coded in the API. This allows the Polkadot.js API library to be modular and adapt to any Substrate-based chains with different [modules](/learn/framework/modules/){target=\_blank}, like your Tanssi network!

## Query On-Chain Data {: #querying-for-information }

In this section, you will learn how to query for on-chain information using the Polkadot.js API library.

### Chain State Queries {: #state-queries }

This category of queries retrieves information related to the current state of the chain. These endpoints are generally of the form `api.query.<module>.<method>`, where the module and method decorations are generated through metadata. You can see a list of all available endpoints by examining the `api.query` object, for example via:

```typescript
console.log(api.query);
```

For example, assuming you've [initialized the API](#creating-an-API-provider-instance), you can retrieve basic account information with the following snippet:

```typescript
// Define wallet address
const addr = 'INSERT_ADDRESS';

// Retrieve the last timestamp
const now = await api.query.timestamp.now();

// Retrieve the account balance & current nonce via the system module
const { nonce, data: balance } = await api.query.system.account(addr);

console.log(
  `${now}: balance of ${balance.free} and a current nonce of ${nonce}`
);
```

??? code "View the complete script"

    ```typescript
    import '@polkadot/api-augment';
import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Define wallet address
  const addr = 'INSERT_ADDRESS';

  // Retrieve the last timestamp via the timestamp module
  const now = await api.query.timestamp.now();

  // Retrieve the account balance & current nonce via the system module
  const { nonce, data: balance } = await api.query.system.account(addr);

  console.log(
    `${now}: balance of ${balance.free} and a current nonce of ${nonce}`
  );

  // Disconnect the API
  await api.disconnect();
};

main();
    ```

### RPC Queries {: #rpc-queries }

The RPC calls provide the backbone for the transmission of data to and from the node. This means that all API endpoints such as `api.query`, `api.tx` or `api.derive` just wrap RPC calls, providing information in the encoded format as expected by the node. You can see a list of all available endpoints by examining the `api.rpc` object, for example, via:

```typescript
console.log(api.rpc);
```

The `api.rpc` interface follows the a similar format to `api.query`. For instance, assuming you've [initialized the API](#creating-an-API-provider-instance), you can get chain data and latest header with the following snippet:

```typescript
// Retrieve the chain name
const chain = await api.rpc.system.chain();

// Retrieve the latest header
const lastHeader = await api.rpc.chain.getHeader();

// Log the information
console.log(
  `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`
);
```

??? code "View the complete script"

    ```typescript
    import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Retrieve the chain name
  const chain = await api.rpc.system.chain();

  // Retrieve the latest header
  const lastHeader = await api.rpc.chain.getHeader();

  // Log the information
  console.log(
    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`
  );

  // Disconnect the API
  await api.disconnect();
};

main();
    ```

### Query Subscriptions {: #query-subscriptions }

The `rpc` API also provides endpoints for subscriptions. Assuming you've [initialized the API](#creating-an-API-provider-instance), you can adapt the previous example to start using subscriptions to listen to new blocks.

```typescript
// Retrieve the chain name
const chain = await api.rpc.system.chain();

// Subscribe to the new headers
await api.rpc.chain.subscribeNewHeads((lastHeader) => {
  console.log(
    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`
  );
});
```

The general pattern for `api.rpc.subscribe*` functions is to pass a callback into the subscription function, and this will be triggered on each new entry as they are imported.

Other calls under `api.query.*` can be modified in a similar fashion to use subscription by providing a callback function, including calls that have parameters. Here is an example of how to subscribe to balance changes in an account:

```typescript
// Define wallet address
const addr = 'INSERT_ADDRESS';

// Subscribe to balance changes for a specified account
await api.query.system.account(addr, ({ nonce, data: balance }) => {
  console.log(
    `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`
  );
});
```

??? code "View the complete script"

    ```typescript
    import '@polkadot/api-augment';
import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Retrieve the chain name
  const chain = await api.rpc.system.chain();

  // Subscribe to the new headers
  await api.rpc.chain.subscribeNewHeads((lastHeader) => {
    console.log(
      `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`
    );
  });

  // Define wallet address
  const addr = 'INSERT_ADDRESS';

  // Subscribe to balance changes for a specified account
  await api.query.system.account(addr, ({ nonce, data: balance }) => {
    console.log(
      `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`
    );

    // Handle API disconnect here if needed
  });
};

main();
    ```

## Create a Keyring for an Account {: #keyrings }

The Keyring object is used for maintaining key pairs, and the signing of any data, whether it's a transfer, a message, or a contract interaction.  

### Create a Keyring Instance {: #creating-a-keyring-instance }

You can create an instance by just creating an instance of the Keyring class and specifying the default type of wallet address used. The default wallet type is `SR25519`, but for Tanssi EVM-compatible networks, the wallet type should be `ethereum`.

```typescript
// Import the keyring as required
import Keyring from '@polkadot/keyring';

// Create a keyring instance (ECDSA)
const keyringECDSA = new Keyring({ type: 'ethereum' });

// Create a keyring instance (SR25519)
const keyring = new Keyring({ type: 'sr25519' });
```

### Add an Account to a Keyring {: #adding-accounts }

There are a number of ways to add an account to the keyring instance, including from the mnemonic phrase and the short-form private key. The following sample code will provide some examples:

=== "From Mnemonic (ECDSA)"

    ```typescript
    // Import the required packages
import Keyring from '@polkadot/keyring';
import { u8aToHex } from '@polkadot/util';
import { mnemonicToLegacySeed, hdEthereum } from '@polkadot/util-crypto';

// Import Ethereum account from mnemonic
const keyringECDSA = new Keyring({ type: 'ethereum' });
const mnemonic = 'INSERT_MNEMONIC';

// Define index of the derivation path and the derivation path
const index = 0;
const ethDerPath = "m/44'/60'/0'/0/" + index;
console.log(`Mnemonic: ${mnemonic}`);
console.log(`--------------------------\n`);

// Extract Ethereum address from mnemonic
const newPairEth = keyringECDSA.addFromUri(`${mnemonic}/${ethDerPath}`);
console.log(`Ethereum Derivation Path: ${ethDerPath}`);
console.log(`Derived Ethereum Address from Mnemonic: ${newPairEth.address}`);

// Extract private key from mnemonic
const privateKey = u8aToHex(
  hdEthereum(mnemonicToLegacySeed(mnemonic, '', false, 64), ethDerPath)
    .secretKey
);
console.log(`Derived Private Key from Mnemonic: ${privateKey}`);
    ```

=== "From Private Key (ECDSA)"

    ```typescript
    // Import the required packages
import Keyring from '@polkadot/keyring';

// Import Ethereum account from private key
const keyringECDSA = new Keyring({ type: 'ethereum' });
const privateKeyInput = 'INSERT_PK';

// Extract address from private key
const otherPair = keyringECDSA.addFromUri(privateKeyInput);
console.log(`Derived Address from provided Private Key: ${otherPair.address}`);
    ```

=== "From Mnemonic (SR25519)"

    ```typescript
    // Import the required packages
import Keyring from '@polkadot/keyring';
import { cryptoWaitReady } from '@polkadot/util-crypto';

const main = async () => {
  await cryptoWaitReady();

  // Import SR25519 account from mnemonic
  const keyring = new Keyring({ type: 'sr25519' });
  const mnemonic = 'INSERT_MNEMONIC';

  // Extract SR25519 address from mnemonic
  const newPair = keyring.addFromUri(`${mnemonic}`);
  console.log(`Derived SR25519 Address from Mnemonic: ${newPair.address}`);
};

main();
    ```

## Sending Transactions  {: #transactions }

Transaction endpoints are exposed on endpoints generally of the form `api.tx.<module>.<method>`, where the module and method decorations are generated through metadata. These allow you to submit transactions for inclusion in blocks, be they transfers, interactions with pallets, or anything else Moonbeam supports. You can see a list of all available endpoints by examining the `api.tx` object, for example, via:

```typescript
console.log(api.tx);
```

### Send a Basic Transaction {: #sending-basic-transactions }

The Polkadot.js API library can be used to send transactions to the network. For example, assuming you've [initialized the API](#creating-an-API-provider-instance) and a [keyring instance](#creating-a-keyring-instance), you can use the following snippet to send a basic transaction (this code sample will also retrieve the encoded calldata of the transaction as well as the transaction hash after submitting):

```typescript
// Initialize wallet key pairs
const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');

// Form the transaction
const tx = await api.tx.balances.transferAllowDeath(
  'INSERT_BOBS_ADDRESS',
  BigInt(INSERT_VALUE)
);

// Retrieve the encoded calldata of the transaction
const encodedCallData = tx.method.toHex()
console.log(`Encoded calldata: ${encodedCallData}`);

// Sign and send the transaction
const txHash = await tx.signAndSend(alice);

// Show the transaction hash
console.log(`Submitted with hash ${txHash}`);
```

??? code "View the complete script"

    ```typescript
    import { ApiPromise, WsProvider } from '@polkadot/api';
import Keyring from '@polkadot/keyring';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Create a keyring instance (ECDSA)
  const keyring = new Keyring({ type: 'ethereum' });

  // Initialize wallet key pairs
  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');

  // Form the transaction
  const tx = await api.tx.balances.transferAllowDeath(
    'INSERT_BOBS_ADDRESS',
    BigInt(INSERT_VALUE)
  );

  // Retrieve the encoded calldata of the transaction
  const encodedCalldata = tx.method.toHex();
  console.log(`Encoded calldata: ${encodedCalldata}`);

  // Sign and send the transaction
  const txHash = await tx.signAndSend(alice);

  // Show the transaction hash
  console.log(`Submitted with hash ${txHash}`);

  // Disconnect the API
  await api.disconnect();
};

main();
    ```

Note that the `signAndSend` function can also accept optional parameters, such as the `nonce`. For example, `signAndSend(alice, { nonce: aliceNonce })`. You can use the [sample code from the State Queries](#state-queries){target=\_blank} section to retrieve the correct nonce, including transactions in the mempool.

### Fee Information {: #fees}

The transaction endpoint also offers a method to obtain weight information for a given `api.tx.<module>.<method>`. To do so, you'll need to use the `paymentInfo` function after having built the entire transaction with the specific `module` and `method`.

The `paymentInfo` function returns weight information in terms of `refTime` and `proofSize`, which can be used to determine the transaction fee. This is extremely helpful when crafting remote execution calls via XCM.

For example, assuming you've [initialized the API](#creating-an-API-provider-instance), the following snippet shows how you can get the weight info for a simple balance transfer between two accounts:

```typescript
// Transaction to get weight information
const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));

// Get weight info
const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');

console.log(`Transaction weight: ${weight}`);
console.log(`Transaction fee: ${partialFee.toHuman()}`);
```

??? code "View the complete script"
    ```typescript
    import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Transaction to get weight information
  const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));

  // Get weight info
  const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');

  console.log(`Transaction weight: ${weight}`);
  console.log(`Transaction fee: ${partialFee.toHuman()}`);

  // Disconnect the API
  await api.disconnect();
};

main();
    ```


### Transaction Events {: #transaction-events }

Any transaction will emit events; at a bare minimum, this will always be a `system.ExtrinsicSuccess` or `system.ExtrinsicFailed` event for the specific transaction. These provide the overall execution result for the transaction, that is, whether the execution has succeeded or failed.

Depending on the transaction sent, some other events may be emitted; for instance, for a balance transfer event, this could include one or more `balance.Transfer` events.

### Batch Transactions {: #batching-transactions }

The Polkadot.js API allows transactions to be batch processed via the `api.tx.utility.batch` method. The batched transactions are processed sequentially from a single sender. The transaction fee can be estimated using the `paymentInfo` helper method.

For example, assuming you've [initialized the API](#creating-an-API-provider-instance), a [keyring instance](#creating-a-keyring-instance) and [added an account](#adding-accounts), the following example makes a couple of transfers in one transaction:

```typescript
// Construct a list of transactions to batch
const txs = [
  api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),
  api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),
];

// Estimate the fees as RuntimeDispatchInfo, using the signer (either
// address or locked/unlocked keypair) 
const info = await api.tx.utility
  .batch(txs)
  .paymentInfo(alice);

console.log(`Estimated fees: ${info}`);

// Construct the batch and send the transactions
await api.tx.utility
  .batch(txs)
  .signAndSend(alice, ({ status }) => {
    if (status.isInBlock) {
      console.log(`included in ${status.asInBlock}`);

      // Disconnect API here!
    }
  });
```

??? code "View the complete script"

    ```typescript
    import { ApiPromise, WsProvider } from '@polkadot/api';
import Keyring from '@polkadot/keyring';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Create a keyring instance (ECDSA)
  const keyring = new Keyring({ type: 'ethereum' });

  // Initialize wallet key pairs
  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');

  // Construct a list of transactions to batch
  const txs = [
    api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),
    api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),
  ];

  // Estimate the fees as RuntimeDispatchInfo, using the signer (either
  // address or locked/unlocked keypair)
  const info = await api.tx.utility.batch(txs).paymentInfo(alice);

  console.log(`Estimated fees: ${info}`);

  // Construct the batch and send the transactions
  await api.tx.utility.batch(txs).signAndSend(alice, async ({ status }) => {
    if (status.isInBlock) {
      console.log(`Included in ${status.asInBlock}`);

      // Disconnect the API
      await api.disconnect();
    }
  });
};

main();
    ```

## Sample Code for Monitoring Native Token Transfers { #sample-code-for-monitoring-native-token-transfers }

The following code samples will demonstrate how to listen to both types of native token transfers, sent via Substrate or Ethereum API, using either the [Polkadot.js API library](https://polkadot.js.org/docs/api/start){target=\_blank} or [Substrate API Sidecar](https://github.com/paritytech/substrate-api-sidecar){target=\_blank}. The following code snippets are for demo purposes only and should not be used without modification and further testing in a production environment.

The following code snippet uses [`subscribeFinalizedHeads`](https://polkadot.js.org/docs/substrate/rpc/#subscribefinalizedheads-header){target=\_blank} to subscribe to new finalized block headers, and loops through extrinsics fetched from the block, and retrieves the events of each extrinsic.

Then, it checks if any event corresponds to a `balances.Transfer` event. If so, it will extract the `from`, `to`, `amount`, and the `tx hash` of the transfer and display it on the console. Note that the `amount` is shown in the smallest unit (Wei).  You can find all the available information about Polkadot.js and the Substrate JSON RPC in their [official documentation site](https://polkadot.js.org/docs/substrate/rpc){target=\_blank}.

```typescript
import '@polkadot/api-augment';
import { ApiPromise, WsProvider } from '@polkadot/api';

// This script will listen to all Native token transfers (Substrate & Ethereum) and extract the tx hash
// It can be adapted for any Tanssi-powered network

const main = async () => {
  // Define the provider
  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');
  // Create the provider
  const polkadotApi = await ApiPromise.create({
    provider: wsProvider,
  });

  // Subscribe to finalized blocks
  await polkadotApi.rpc.chain.subscribeFinalizedHeads(
    async (lastFinalizedHeader) => {
      const [{ block }, records] = await Promise.all([
        polkadotApi.rpc.chain.getBlock(lastFinalizedHeader.hash),
        (await polkadotApi.at(lastFinalizedHeader.hash)).query.system.events(),
      ]);

      block.extrinsics.forEach((extrinsic, index) => {
        const {
          method: { args, method, section },
        } = extrinsic;

        const isEthereum = section == 'ethereum' && method == 'transact';

        // Gets the transaction object
        const tx = args[0] as any;

        // Convert to the correct Ethereum Transaction format
        const ethereumTx =
          isEthereum &&
          ((tx.isLegacy && tx.asLegacy) ||
            (tx.isEip1559 && tx.asEip1559) ||
            (tx.isEip2930 && tx.asEip2930));

        // Check if the transaction is a transfer
        const isEthereumTransfer =
          ethereumTx &&
          ethereumTx.input.length === 0 &&
          ethereumTx.action.isCall;

        // Retrieve all events for this extrinsic
        const events = records.filter(
          ({ phase }) =>
            phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(index)
        );

        // This hash will only exist if the transaction was executed through Ethereum.
        let ethereumHash = '';

        if (isEthereum) {
          // Search for Ethereum execution
          events.forEach(({ event }) => {
            if (event.section == 'ethereum' && event.method == 'Executed') {
              ethereumHash = event.data[2].toString();
            }
          });
        }

        // Search if it is a transfer
        events.forEach(({ event }) => {
          if (event.section == 'balances' && event.method == 'Transfer') {
            const from = event.data[0].toString();
            const to = event.data[1].toString();
            const balance = (event.data[2] as any).toBigInt();

            const substrateHash = extrinsic.hash.toString();

            console.log(
              `Transfer from ${from} to ${to} of ${balance} (block #${lastFinalizedHeader.number})`
            );
            console.log(`  - Triggered by extrinsic: ${substrateHash}`);
            if (isEthereum) {
              console.log(
                `  - Ethereum (isTransfer: ${isEthereumTransfer}) hash: ${ethereumHash}`
              );
            }
          }
        });
      });
    }
  );
};

main();
```

In addition, you can find more sample code snippets related to more specific cases around balance transfers at this [GitHub page](https://gist.github.com/crystalin/b2ce44a208af60d62b5ecd1bad513bce){target=\_blank}.

## Utility Functions {: #utilities }

The Polkadot.js API also includes a number of utility libraries for computing commonly used cryptographic primitives and hash functions.

The following example computes the deterministic transaction hash of a raw Ethereum legacy transaction by first computing its RLP ([Recursive Length Prefix](https://ethereum.org/developers/docs/data-structures-and-encoding/rlp/){target=\_blank}) encoding and then hashing the result with keccak256.

```typescript
import { encode } from '@polkadot/util-rlp';
import { keccakAsHex } from '@polkadot/util-crypto';
import { numberToHex } from '@polkadot/util';

// Set the key type to string
type txType = {
  [key: string]: any;
};

// Define the raw signed transaction
const txData: txType = {
  nonce: numberToHex(1),
  gasPrice: numberToHex(21000000000),
  gasLimit: numberToHex(21000),
  to: '0xc390cC49a32736a58733Cf46bE42f734dD4f53cb',
  value: numberToHex(1000000000000000000),
  data: '',
  v: '0507',
  r: '0x5ab2f48bdc6752191440ce62088b9e42f20215ee4305403579aa2e1eba615ce8',
  s: '0x3b172e53874422756d48b449438407e5478c985680d4aaa39d762fe0d1a11683',
};

// Extract the values to an array
var txDataArray = Object.keys(txData).map(function (key) {
  return txData[key];
});

// Calculate the RLP encoded transaction
var encoded_tx = encode(txDataArray);

// Hash the encoded transaction using keccak256
console.log(keccakAsHex(encoded_tx));
```

You can check the respective [NPM repository page](https://www.npmjs.com/package/@polkadot/util-crypto){target=\_blank} for a list of available methods in the `@polkadot/util-crypto` library and their descriptions.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/libraries/sidecar-api/
--- BEGIN CONTENT ---
---
title: Using Substrate API Sidecar
description: Learn how to use Substrate-based REST service with Tanssi-powered networks to access blocks, account balance, compute gas used, and more.
icon: octicons-code-24
categories: Substrate-Template
---

# Using Substrate API Sidecar

## Introduction {: #introduction }

Substrate API Sidecar allows applications to access blocks, account balance, and other information of Substrate-based blockchains through a REST API. This can be useful for exchanges, wallets or other types of applications that need to keep track of account balance and other state changes on a Tanssi-powered network. This page will describe how to install and run a Substrate API Sidecar for a Tanssi network, and the commonly used API endpoints.

## Installing and Running Substrate API Sidecar {: #installing-and-running-substrate-api-sidecar }

There are multiple ways of installing and running the Substrate API Sidecar. This guide will describe the steps for installing and running it locally through NPM. For running Substrate API Sidecar through Docker, or building and running it from source, please refer to the [Substrate API Sidecar Github Repository](https://github.com/paritytech/substrate-api-sidecar#readme).

!!! note
    The examples in this guide are based on a MacOS or Ubuntu 20.04 environment. If you're using Windows, you'll need to adapt them accordingly.
    
    Furthermore, please ensure that you have Node.js and a package manager (such as npm or yarn) installed. To learn how to install Node.js, please check their [official documentation](https://nodejs.org/en/download){target=\blank}.
    
    Also, make sure you've initialized a `package.json` file for ES6 modules. You can initialize a default `package.json` file using npm by running the following command `npm init --yes`.

### Installing the Substrate API Sidecar {: #installing-the-substrate-api-sidecar }

To install the Substrate API Sidecar service locally in the current directory, run this from the command line:

```bash
npm install @substrate/api-sidecar@{{ networks.mainnet.substrate_api_sidecar.stable_version }}
```

!!! note
    If the current folder does not already have a Node.js project structure, you need to manually created the `node_modules` directory by typing `mkdir node_modules`.

Substrate API Sidecar v{{ networks.mainnet.substrate_api_sidecar.stable_version }} is the current stable version that has been tested to work with Tanssi networks. You can verify the installation was successful by typing from the installation directory root:

```bash
node_modules/.bin/substrate-api-sidecar --version
```

## Setting up the Substrate API Sidecar {: #setting-up-the-substrate-api-sidecar }

In the terminal that Sidecar will run, export the environmental variable for the WS endpoint of the network you want to connect to. For example, the WSS endpoint of your Tanssi network. Some examples:

=== "Tanssi MainNet"

    ```bash
    export SAS_SUBSTRATE_URL=wss://{{ networks.mainnet.dns_name }}
    ```

=== "Dancelight TestNet"

    ```bash
    export SAS_SUBSTRATE_URL=wss://{{ networks.dancelight.dns_name }}
    ```

=== "Demo EVM Network"

    ```bash
    export SAS_SUBSTRATE_URL={{ networks.dancelight.demo_evm_rpc_wss_url }}
    ```

=== "Your Network"

    ```bash
    export SAS_SUBSTRATE_URL=INSERT_NETWORK_WSS_ENDPOINT
    ```

After setting the environmental variable, you can use the `echo` command to check that the environmental variable has been set correctly, by typing:

```bash
echo $SAS_SUBSTRATE_URL
```

And it should display the network endpoint you have just set.

## Running Substrate API Sidecar {: #running-substrate-api-sidecar }

With the network endpoint environmental variable set, and from the installation directory root, run:

```bash
node_modules/.bin/substrate-api-sidecar
```

If the installation and configuration are successful, you should see this output in the console:

![Successful Output](/images/builders/toolkit/substrate-api/libraries/sidecar-api/sidecar-1.webp)

## Substrate API Sidecar Endpoints {: #substrate-api-sidecar-endpoints }

Some of the commonly used Substrate API Sidecar endpoints include:

 - **GET /blocksâ€‹/head** â€” Get the most recently finalized block. The optional parameter `finalized` can be set to `false` to the get the newest known block, which may not be finalized
 - **GET /blocks/head/header** â€” Get the most recently finalized block header. The optional parameter `finalized` can be set to `false` to the get the newest known block header, which may not be finalized
 - **GET /blocks/{blockId}** â€” Get a block by its height or hash
 - **GET /accounts/{accountId}/balance-info** â€” Get balance information for an account
 - **GET /node/version** â€” Get information about the Substrates node's implementation and versioning
 - **GET /runtime/metadata** â€” Get the runtime metadata in decoded, JSON form

For a full list of API endpoints available on Substrate API Sidecar, please refer to the [official documentation](https://paritytech.github.io/substrate-api-sidecar/dist).

## Field Mapping in Block JSON Object {: #fields-mapping-in-block-json-object }

Substrate API Sidecar returns blocks as a JSON object. Part of this JSON object is a nesting structure for individual extrinsics processed in a specific block. Each extrinsic calls a specific method of a given module. Generally speaking, for individual extrinsics, the nesting structure is as following:

```text
RESPONSE JSON Block Object:
    |--extrinsics
        |--{extrinsic_number}
            |--method
                |--pallet: "MODULE_NAME"
                |--method: "METHOD_NAME"
            |--signature
            |--nonce
            |--args
                |--transaction
                    |--{transaction_type}
            |--hash
            |--events
                |--{event_number}
                    |--method
                        |--pallet: "MODULE_NAME"
                        |--method: "METHOD_EVENT_NAME"
                    |--data
                        |--0
                        |--1
                        |--2
                        |--3
    ...

```

Consequently, information from specific extrinsics (like balance transfers) can be extracted by knowing the module and method called by the extrinsic.

## EVM Field Mapping in Block JSON Object {: #evm-fields-mapping-in-block-json-object }

For Tanssi EVM networks, the information related to EVM execution of each Tanssi EVM network transaction can be identified by the `method` field under the current extrinsic object, where it is set to:

```text
{extrinsic_number}.method.pallet = "ethereum"
{extrinsic_number}.method.method = "transact"
```

The nesting structure for EVM transactions is as following:

```text
RESPONSE JSON Block Object:
    |--extrinsics
        |--{extrinsic_number}
            |--method
                |--pallet: "ethereum"
                |--method: "transact"
            |--signature
            |--nonce
            |--args
                |--transaction
                    |--{transaction_type}
            |--hash
            |--events
                |--{event_number}
                    |--method
                        |--pallet: "ethereum"
                        |--method: "Executed"
                    |--data
                        |--0
                        |--1
                        |--2
                        |--3
    ...

```

For example, for Substrate transactions, the "Nonce" and "Signature" fields are under:

```text
extrinsics[extrinsic_number]
```

### EVM Transaction Types and Payload {: #transaction-types-and-payload }

Tanssi EVM networks currently support three transaction standards: `legacy`, `eip1559`, and `eip2930`. These correspond to the `transaction type` field in the above JSON object diagram. For each transaction type, the transaction payload contains the following fields:

=== "EIP1559"

    ```text
        ...
        |--eip1559
            |--chainId
            |--nonce
            |--maxPriorityFeePerGas
            |--maxFeePerGas
            |--gasLimit
            |--action
            |--value
            |--input
            |--accessList
            |--oddYParity
            |--r
            |--s
        ...
    ```

=== "Legacy"

    ```text
        ...
        |--legacy
            |--nonce
            |--gasPrice
            |--gasLimit
            |--action
            |--value
            |--input
            |--signature
        ...
    ```

=== "EIP2930"

    ```text
        ...
        |--eip2930
            |--chainId
            |--nonce
            |--gasPrice
            |--gasLimit
            |--action
            |--value
            |--input
            |--accessList
            |--oddYParity
            |--r
            |--s
        ...
    ```

For more information on the new [EIP1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} and [EIP2930](https://eips.ethereum.org/EIPS/eip-2930){target=\_blank} transaction types and what each field means, please refer to the respective official Ethereum proposal specs.

### Transaction Field Mappings {: #transaction-field-mappings }

To obtain the EVM sender address, recipient address, and EVM hash of any EVM transaction type, check the `events` field under the current extrinsic object, and identify the event where the `method` field is set to:

```text
{event_number}.method.pallet: "ethereum"
{event_number}.method.method: "Executed"
```

The EVM field mappings are then summarized as the following:

=== "EIP1559"
    |        EVM Field         |                               Block JSON Field                               |
    |:------------------------:|:----------------------------------------------------------------------------:|
    |         Chain ID         |       `extrinsics[extrinsic_number].args.transaction.eip1559.chainId`        |
    |          Nonce           |        `extrinsics[extrinsic_number].args.transaction.eip1559.nonce`         |
    | Max priority fee per gas | `extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas` |
    |     Max fee per gas      |     `extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas`     |
    |        Gas limit         |       `extrinsics[extrinsic_number].args.transaction.eip1559.gasLimit`       |
    |       Access list        |      `extrinsics[extrinsic_number].args.transaction.eip1559.accessList`      |
    |        Signature         |    `extrinsics[extrinsic_number].args.transaction.eip1559.oddYParity/r/s`    |
    |      Sender address      |         `extrinsics[extrinsic_number].events[event_number].data[0]`          |
    |    Recipient address     |         `extrinsics[extrinsic_number].events[event_number].data[1]`          |
    |         EVM hash         |         `extrinsics[extrinsic_number].events[event_number].data[2]`          |
    |   EVM execution status   |         `extrinsics[extrinsic_number].events[event_number].data[3]`          |

=== "Legacy"
    |      EVM Field       |                         Block JSON Field                         |
    |:--------------------:|:----------------------------------------------------------------:|
    |        Nonce         |   `extrinsics[extrinsic_number].args.transaction.legacy.nonce`   |
    |      Gas price       | `extrinsics[extrinsic_number].args.transaction.legacy.gasPrice`  |
    |      Gas limit       | `extrinsics[extrinsic_number].args.transaction.legacy.gasLimit`  |
    |        Value         |   `extrinsics[extrinsic_number].args.transaction.legacy.value`   |
    |      Signature       | `extrinsics[extrinsic_number].args.transaction.legacy.signature` |
    |    Sender address    |   `extrinsics[extrinsic_number].events[event_number].data[0]`    |
    |  Recipient address   |   `extrinsics[extrinsic_number].events[event_number].data[1]`    |
    |       EVM hash       |   `extrinsics[extrinsic_number].events[event_number].data[2]`    |
    | EVM execution status |   `extrinsics[extrinsic_number].events[event_number].data[3]`    |

=== "EIP2930"
    |      EVM Field       |                            Block JSON Field                            |
    |:--------------------:|:----------------------------------------------------------------------:|
    |       Chain ID       |    `extrinsics[extrinsic_number].args.transaction.eip2930.chainId`     |
    |        Nonce         |     `extrinsics[extrinsic_number].args.transaction.eip2930.nonce`      |
    |      Gas price       |    `extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice`    |
    |      Gas limit       |    `extrinsics[extrinsic_number].args.transaction.eip2930.gasLimit`    |
    |        Value         |     `extrinsics[extrinsic_number].args.transaction.eip2930.value`      |
    |     Access list      |   `extrinsics[extrinsic_number].args.transaction.eip2930.accessList`   |
    |      Signature       | `extrinsics[extrinsic_number].args.transaction.eip2930.oddYParity/r/s` |
    |    Sender address    |      `extrinsics[extrinsic_number].events[event_number].data[0]`       |
    |  Recipient address   |      `extrinsics[extrinsic_number].events[event_number].data[1]`       |
    |       EVM hash       |      `extrinsics[extrinsic_number].events[event_number].data[2]`       |
    | EVM execution status |      `extrinsics[extrinsic_number].events[event_number].data[3]`       |

For example, for EVM transactions, the "Nonce" and "Signature" fields are under:

```text
extrinsics[extrinsic_number].args.transaction[transaction_type]
```

Consequently, this leaves the "Nonce" and "Signature" for the Substrate-level field `extrinsics[extrinsic_number]` to be `null`.

A successfully executed EVM transaction will return either `succeed: "Stopped"` or `succeed: "Returned"` under the "EVM Execution Status" field.

## Monitor Token Balance Transfers {: #monitor-transfers }

The following code samples will demonstrate how to listen to both native token transfers, sent via Substrate or Ethereum API, and ERC-20 token transfers sent via the Ethereum API, using Substrate API Sidecar. Transfers via the Ethereum API are only applicable to Tanssi EVM networks.

### Native Token Transfers { #native-token-transfers }

Both Tanssi non-EVM networks and EVM networks can perform Substrate-based native token balance transfers.

The following code snippet uses the Axios HTTP client to query the Sidecar endpoint [`/blocks/head`](https://paritytech.github.io/substrate-api-sidecar/dist){target=\_blank} for the latest finalized block, and then decodes the block for the `from`, `to`, `value`, `tx hash` and `transaction status` of native token transfers at both the EVM and Substrate API level.

```typescript
import axios from 'axios';

// This script will decode all native token transfers (Substrate & Ethereum)
// in a given Sidecar block, and extract the tx hash. It can be adapted for
// any Tanssi-powered network.

// Endpoint to retrieve the latest block
const endpoint = 'http://127.0.0.1:8080/blocks/head';

async function main() {
  try {
    // Retrieve the block from the Sidecar endpoint
    const response = await axios.get(endpoint);
    // Retrieve the block height of the current block
    console.log('Block Height: ' + response.data.number);

    // Iterate through all extrinsics in the block
    response.data.extrinsics.forEach((extrinsic) => {
      // Retrieve Ethereum Transfers
      if (
        extrinsic.method.pallet === 'ethereum' &&
        extrinsic.method.method === 'transact'
      ) {
        // Get the value for any of the three EIP transaction standards supported
        const value =
          (extrinsic.args.transaction.legacy &&
            extrinsic.args.transaction.legacy.value) ||
          (extrinsic.args.transaction.eip1559 &&
            extrinsic.args.transaction.eip1559.value) ||
          (extrinsic.args.transaction.eip2930 &&
            extrinsic.args.transaction.eip2930.value);

        // Iterate through the events to get transaction details
        extrinsic.events.forEach((event) => {
          if (
            event.method.pallet === 'ethereum' &&
            event.method.method === 'Executed'
          ) {
            console.log('From: ' + event.data[0]);
            console.log('To: ' + event.data[1]);
            console.log('Tx Hash: ' + event.data[2]);
            console.log('Value: ' + value);
            // Check the execution status
            if (event.data[3].succeed) {
              console.log('Status: Success');
            } else {
              console.log('Status: Failed');
            }
          }
        });
      }

      // Retrieve Substrate Transfers
      if (
        extrinsic.method.pallet === 'balances' &&
        (extrinsic.method.method === 'transferKeepAlive' ||
          extrinsic.method.method === 'transfer')
      ) {
        // Iterate through the events to get transaction details
        extrinsic.events.forEach((event) => {
          if (
            event.method.pallet === 'balances' &&
            event.method.method === 'Transfer'
          ) {
            console.log('From: ' + event.data[0]);
            console.log('To: ' + event.data[1]);
            console.log('Tx Hash: ' + extrinsic.hash);
            console.log('Value: ' + event.data[2]);
            // Check the execution status
            if (extrinsic.success) {
              console.log('Status: Success');
            } else {
              console.log('Status: Failed');
            }
          }
        });
      }
    });
  } catch (err) {
    console.log(err);
  }
}

main();
```

### ERC-20 Token Transfers {: #erc-20-token-transfers }

Events emitted by smart contracts such as an ERC-20 token contract deployed on Tanssi EVM networks can be decoded from Sidecar block JSON objects. The nesting structure is as following:

```text
RESPONSE JSON Block Object:
    |--extrinsics
        |--{extrinsic_number}
            |--method
                |--pallet: "ethereum"
                |--method: "transact"
            |--signature:
            |--nonce:
            |--args
                |--transaction
                    |--{transaction_type}
            |--hash
            |--events
                |--{event_number}
                    |--method
                        |--pallet: "evm"
                        |--method: "Log"
                    |--data
                        |--0
                            |-- address
                            |-- topics
                                |--0
                                |--1
                                |--2
					        |-- data
            ...
    ...

```

ERC-20 token transfers will emit the [`Transfer`](https://eips.ethereum.org/EIPS/eip-20){target=\_blank} event which can be decoded as the following:

|     Tx Information      |                           Block JSON Field                            |
|:-----------------------:|:---------------------------------------------------------------------:|
| ERC-20 contract address |  `extrinsics[extrinsic_number].events[event_number].data[0].address`  |
|  Event signature hash   | `extrinsics[extrinsic_number].events[event_number].data[0].topics[0]` |
|     Sender address      | `extrinsics[extrinsic_number].events[event_number].data[0].topics[1]` |
|    Recipient address    | `extrinsics[extrinsic_number].events[event_number].data[0].topics[2]` |
|         Amount          |   `extrinsics[extrinsic_number].events[event_number].data[0].data`    |

Other events emitted by EVM smart contracts can be decoded in a similar fashion, but the content of the topics and data fields will change depending on the definition of the specific event.

!!! note
    The amount transferred is given in accounting for decimals and in hexadecimal format.

## Substrate API Transaction Fees {: #substrate-api-transaction-fees }

For Tanssi non-EVM networks and EVM networks, all the information around fee data for transactions sent via the Substrate API can be extracted from the following block endpoint:

```text
GET /blocks/{blockId}
```

The block endpoints will return data relevant to one or more blocks. You can read more about the block endpoints on the [official Sidecar documentation](https://paritytech.github.io/substrate-api-sidecar/dist/#operations-tag-blocks){target=\_blank}.

Read as a JSON object, for a given `pallet` (module) and `method`, the transaction fee is provided by an associated event with the following extructure:

```text
{event_number}.method.pallet: "transactionPayment"
{event_number}.method.method: "TransactionFeePaid"
```

The relevant nesting structure is as follows:

```text
RESPONSE JSON Block Object:
    ...
    |--number
    |--extrinsics
        |--{extrinsic_number}
            |--method
            |--signature
            |--nonce
            |--args
            |--tip
            |--hash
            |--info
            |--era
            |--events
                |--{event_number}
                    |--method
                        |--pallet: "transactionPayment"
                        |--method: "TransactionFeePaid"
                    |--data
                        |--0
                        |--1
                        |--2
    ...

```

The object mappings are summarized as follows:

|   Tx Information   |                      Block JSON Field                       |
|:------------------:|:-----------------------------------------------------------:|
| Fee paying account | `extrinsics[extrinsic_number].events[event_number].data[0]` |
|  Total fees paid   | `extrinsics[extrinsic_number].events[event_number].data[1]` |
|        Tip         | `extrinsics[extrinsic_number].events[event_number].data[2]` |

Then, the total transaction fee paid for this extrinsic is mapped to the following field of the block JSON object:

```text
extrinsics[extrinsic_number].events[event_number].data[1]
```

## Ethereum API Transaction Fees {: #ethereum-api-transaction-fees }

For Tanssi EVM networks, users could also send funds via the Ethereum API. To calculate the fee incurred on transactions sent via the Ethereum API, the following formula can be used:

=== "EIP-1559"

    ```text
    GasPrice = BaseFee + MaxPriorityFeePerGas < MaxFeePerGas ?
                BaseFee + MaxPriorityFeePerGas : 
                MaxFeePerGas;
    Transaction Fee = (GasPrice * TransactionWeight) / 25000
    ```

=== "Legacy"

    ```text
    Transaction Fee = (GasPrice * TransactionWeight) / 25000
    ```

=== "EIP-2930"

    ```text
    Transaction Fee = (GasPrice * TransactionWeight) / 25000
    ```

The following sections describe in more detail each of the components needed to calculate the transaction fee.

### Base Fee {: #base-fee}

The `BaseFee` is the minimum amount charged to send a transaction and is a value set by the network itself. It was introduced in [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank}. Tanssi EVM networks have a dynamic fee mechanism that aims to replicate the [EIP-1559 fee market mechanism](https://eips.ethereum.org/EIPS/eip-1559#specification){target=\_blank}, where the base fee is adjusted based on block congestion.

For example, for the Tanssi EVM network template the minimum gas price is `1 GWei`.

The `BaseFee` can be directly retrieved from the `baseFeePerGas` storage found in the `baseFee` module (pallet), using the following endpoint:

```text
GET /pallets/baseFee/storage/baseFeePerGas?at={blockId}
```

Read as a JSON object, the relevant nesting structure is as follows:

```text
RESPONSE JSON Storage Object:
    |--at
        |--hash
        |--height
    |--pallet
    |--palletIndex
    |--storageItem
    |--keys
    |--value
```

The relevant data will be stored in the `value` key of the JSON object. This value is a fixed point data type, hence the real value is found by dividing the `value` by the decimals.

### GasPrice, MaxFeePerGas, and MaxPriorityFeePerGas {: #gasprice-maxfeepergas-maxpriorityfeepergas }

The `GasPrice` is used to specify the gas price of legacy transactions prior to [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank}. The `MaxFeePerGas` and `MaxPriorityFeePerGas` were both introduced in EIP-1559 alongside the `BaseFee`. The `MaxFeePerGas` defines the maximum fee permitted to be paid per unit of gas and is the sum of the `BaseFee` and the `MaxPriorityFeePerGas`. The `MaxPriorityFeePerGas` is the maximum priority fee configured by the sender of a transaction that is used to incentive the prioritization of a transaction in a block.

Although Tanssi EVM networks are Ethereum-compatible, they are also Substrate-based chains at their core, and priorities work differently in Substrate than in Ethereum. In Substrate, transactions are not prioritized by gas price. To address this, Tanssi EVM networks uses a modified prioritization system that reprioritizes Substrate transactions using an Ethereum-first solution. A Substrate transaction still goes through the validity process, where it is assigned transaction tags, longevity, and a priority. The original priority is then overwritten with a new priority based on the transaction's fee per gas, which is derived from the transaction's tip and weight. If the transaction is an Ethereum transaction, the priority is set according to the priority fee.

It's important to note that priority is not the sole component responsible for determining the order of transactions in a block. Other components, such as the longevity of a transaction, also play a role in the sorting process.

The values of `GasPrice`, `MaxFeePerGas` and `MaxPriorityFeePerGas` for the applicable transaction types can be read from the block JSON object according to the structure described in [the Sidecar API page](#evm-fields-mapping-in-block-json-object).

The data for an Ethereum transaction in a particular block can be extracted from the following block endpoint:

```text
GET /blocks/{blockId}
```

The paths to the relevant values have also truncated and reproduced below:

=== "EIP1559"
    |      EVM Field       |                               Block JSON Field                               |
    |:--------------------:|:----------------------------------------------------------------------------:|
    |     MaxFeePerGas     |     `extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas`     |
    | MaxPriorityFeePerGas | `extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas` |

=== "Legacy"
    | EVM Field |                        Block JSON Field                         |
    |:---------:|:---------------------------------------------------------------:|
    | GasPrice  | `extrinsics[extrinsic_number].args.transaction.legacy.gasPrice` |

=== "EIP2930"
    | EVM Field |                         Block JSON Field                         |
    |:---------:|:----------------------------------------------------------------:|
    | GasPrice  | `extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice` |

### Transaction Weight {: #transaction-weight}

`TransactionWeight` is a Substrate mechanism used to measure the execution time a given transaction takes to be executed within a block. For all transactions types, `TransactionWeight` can be retrieved under the event of the relevant extrinsic where the `method` field is set to:

```text
pallet: "system", method: "ExtrinsicSuccess"
```

And then `TransactionWeight` is mapped to the following field of the block JSON object:

```text
extrinsics[extrinsic_number].events[event_number].data[0].weight
```

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/wallets/
--- BEGIN CONTENT ---
---
title: Substrate Wallets
description: Learn how to interact with your Tanssi-powered Substrate network through the Substrate API, including configuring wallets, adding RPC Urls, and sending funds.
icon: material-wallet-outline
template: index-page.html
---

# Wallets

Wallets are digital tools that allow users to securely store, manage, and transact with their digital assets. They store the cryptographic keys required to access digital assets and enable one to execute transactions on blockchain networks.

The pages in this section provide an overview of getting started with various wallet providers. It covers how to create and import accounts, connect to your network, and begin interacting with it.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/wallets/ledger/
--- BEGIN CONTENT ---
---
title: Using Ledger With Your Substrate Appchain
description: This guide walks you through setting up and using a Ledger device to interact with the Tanssi network or any of the Tanssi-powered Substrate appchains.
icon: material-wallet-outline 
categories: Substrate-Template
---

# Interacting with Substrate Tanssi Chains Using Ledger

## Introduction {: #introduction }

Developers and users of Substrate networks, such as the Tanssi network or non-EVM Tanssi-powered appchains, have a variety of options when it comes to wallets. Regarding cold wallets, which store your private keys in a secure, offline environment, [Ledger](https://www.ledger.com/){target=\_blank} is one of the most popular options. Ledger provides full support for Substrate blockchains, such as the Tanssi network.

Ledger devices are hardware wallets designed to store the private keys offline. They are used to verify and sign the transactions, but they still need a software layer to provide the UI that interacts with the networks, builds the transactions, and sends the signed transactions back to the network once the user has verified them.

This guide takes you through all the necessary steps to use your Ledger device with Substrate Tanssi chains.

## Setting Up Your Ledger Device {: #setting-up-ledger-device }

If you have a brand new Ledger device, refer to the [official website](https://support.ledger.com/article/4404389503889-zd){target=\_blank} for a guide on getting it started with the initial setup.

Now, with your Ledger already initiated, install the _Polkadot_ app taking the following steps:

1. Open the Ledger Live App on your computer.
2. Go to My Ledger.
3. Connect and unlock the device.

Finally, search for **Polkadot (DOT)** app in Ledger Live and install it on your device.

!!! note
    Why Polkadot? Tanssi is built using Substrate, the same framework that powers Polkadot. As a result, even though Tanssi and Polkadot are separate networks, they share the same cryptographic signature schema. This means that the Ledger app named **Polkadot (DOT)** is fully compatible with Tanssi.

![Install Polkadot in Ledger Live](/images/builders/toolkit/substrate-api/wallets/ledger/ledger-1.webp)

And that's it. Your device now has a Substrate account and is able to sign transactions on Tanssi and any non-EVM Tanssi-powered appchain.

## Adding the Ledger to a Hot Wallet {: #adding-Ledger-hot-wallet }

As presented in the [introduction](#introduction), a Ledger hardware wallet provides secure, offline storage for private keys, allowing users to verify and sign transactions. However, by design, it can't interact with blockchains or dApps by itself, nor does it offer a UI for managing assets. To complement the device, a hot wallet is required. The user can choose any Substrate wallet, such as [Talisman](/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank} or [SubWallet](/builders/toolkit/substrate-api/wallets/subwallet/){target=\_blank}.

For demonstration purposes, we'll show how to configure Talisman to work with your hardware wallet, but these steps are generally applicable to any other Substrate-enabled wallet that supports Ledger. To follow along with the steps, make sure you have [Talisman installed](/builders/toolkit/substrate-api/wallets/talisman/#setting-up-talisman){target=\_blank} in your browser, then open the extension and:

1. Press the **+** icon (Add Account).
2. Click on the **Connect** tab.
3. Select **Connect Ledger**.

![Connect Ledger](/images/builders/toolkit/substrate-api/wallets/ledger/ledger-2.webp)

On the following screen, take the following steps:

1. Select **Polkadot**. Other options will be presented below.
2. Select **Polkadot** from the dropdown.
3. Select **Polkadot App** from the box. You'll be prompted to connect your ledger and open the Polkadot app.
4. Make sure that your ledger is successfully connected.
5. Click on **Continue**.

![Connect Ledger](/images/builders/toolkit/substrate-api/wallets/ledger/ledger-3.webp)

In the next step, you will be presented with a list of derived accounts. Select the one you want to import, click **Continue**, and that's all! Your Talisman wallet can now sign transactions using your Ledger device.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/wallets/subwallet/
--- BEGIN CONTENT ---
---
title: How to Connect SubWallet to Tanssi Substrate
description: This guide walks you through how to connect SubWallet, a comprehensive Polkadot, Substrate, and Ethereum wallet, to your Tanssi-powered Substrate network.
icon: material-wallet-outline
categories: Substrate-Template
---

# Interacting with Your Tanssi Substrate Network Using SubWallet

## Introduction {: #introduction }

Developers and users of Tanssi-powered Substrate networks have a variety of options when it comes to wallets. SubWallet is a comprehensive Web3 wallet that natively supports Substrate (Polkadot) and Ethereum accounts. This tutorial centers on the Substrate API, but you can check out a similar [tutorial for interacting with SubWallet using the Ethereum API](/builders/toolkit/ethereum-api/wallets/subwallet/){target=\_blank}.

The SubWallet wallet browser extension [can be downloaded](https://www.subwallet.app/download.html){target=\_blank} for all supported browsers, including Chrome, Brave, Firefox, and MS Edge. SubWallet also has a mobile app for both iOS and Android, but that is beyond the scope of this guide. A complete online asset dashboard is accessible at [web.subwallet.app](https://web.subwallet.app){target=\_blank}.

This guide takes you through all the necessary steps, from installing SubWallet to setting up a wallet, connecting it to your Tanssi Substrate network, and sending funds.

## Creating Your First Substrate Account {: #creating-your-first-substrate-account }

First, download and install the [SubWallet extension](https://www.subwallet.app/download.html){target=\_blank}. Creating a new account will generate a seed phrase that can derive multiple Ethereum and Substrate accounts. By default, SubWallet will generate a single Ethereum and a single Substrate account, but you can easily derive more from the same seed phrase. Click **Create a new account** to get started.

![Get started with SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-1.webp)

On the following screen, you'll be prompted to create a password to secure your new wallet.

![Create a password for SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-2.webp)

You'll then be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.

![Back up your seed phrase in SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-3.webp)

!!! note
    You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.

## Importing an Existing Substrate Account {: #importing-an-existing-substrate-account }

Of course, you can import an existing Substrate account into SubWallet. To get started, take the following steps:

1. Press the **All accounts** button at the top
2. Press the **Import account** icon

![Import account part 1](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-4.webp)

On the following screen, select the method by which you would like to import the existing account. If you're importing a Substrate account, you can choose from the seed phrase, Polkadot.js (JSON), or QR code options.

![Import existing account part 2](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-5.webp)

On the following screen, you'll be able to provide the relevant seed phrase, JSON file, or QR code, and you can begin using your new account right away.

## Connecting SubWallet to Dancelight {: #connecting-Subwallet-to-dancelight }

SubWallet comes pre-configured with support for Dancelight, the Tanssi TestNet, but it may not be enabled by default. You just need to head to the **Manage networks** page to toggle it on. Remember that [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank} itself is the Substrate-based network that orchestrates and manages the launch of Tanssi-powered networks. To configure your SubWallet to work with Dancelight, press the **More Options** icon in the upper left corner. Then click **Manage networks** and take the following steps:

1. Search for **Dancelight**
2. Toggle the slider on to enable support for Dancelight

![Toggle support for Dancelight](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-6.webp)

If you have a balance of Dancelight tokens, you'll see your account balance on the homepage of the SubWallet wallet. By default, all balances are hidden in SubWallet, but if you press the eye icon, you can toggle balance visibility.

![See your TestNet account balances in SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-7.webp)

## Connecting SubWallet to Your Substrate Network {: #connecting-Subwallet-to-your-substrate-network }

To configure SubWallet for your Substrate network, press the **More Options** icon in the upper left corner. Then click **Manage networks**. Press the **+** icon. On the following page, you'll then be prompted to enter the network details for your Tanssi network. For demonstration purposes, Dancelight is used here; however, you can substitute these details with your own Tanssi network. To add your Tanssi network to SubWallet, take the following steps:

1. Paste in the WSS URL of your Tanssi network. Other parameters like the parachain ID and token decimals may be auto-populated
2. Provide a name for your Tanssi network
3. Press **Save**

![Add Network in SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-8.webp)

## Connecting to Polkadot.js {: #connecting-to-polkadotjs}

To connect your Tanssi Substrate network to Polkadot.js Apps, first head to [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank}. In this example, Polkadot.js Apps is connected to Dancelight, but you can point Polkadot.js to your Tanssi network by clicking on the network dropdown and filling in the WSS endpoint of your Tanssi network in the **custom endpoint** field.

![Connect to Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-9.webp)

The SubWallet extension will prompt you to select the accounts you'd like to use with Polkadot.js Apps. If it doesn't automatically pop up, you can open the SubWallet extension and click on the **Connected** icon next to your account at the top. To configure SubWallet to correctly interface with your Tanssi network on Polkadot.js Apps, you should take the following steps:

1. Select the Substrate account(s) that you'd like to use with Polkadot.js Apps
2. Press **Connect**

![Connect SubWallet to Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-10.webp)

Your SubWallet wallet is now connected to Polkadot.js Apps. After refreshing Polkadot.js Apps, you should see your SubWallet account in the [Accounts page of Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} underneath the **extension** heading.

## Sending a Transaction {: #sending-a-transaction}

To send a transaction through the Substrate API, click **Send** next to your account on Polkadot.js Apps. Then, take the following steps:

1. Input the **send to address**
2. Enter the **amount**
3. Press **Make Transfer** and confirm the transaction in the resulting Polkadot.js pop-up
4. Press **View Details** if you'd like to inspect the contents of the transaction
5. Press **Approve** to submit the transaction

![Send funds through Substrate API with Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-11.webp)

You can also send a transaction through the Substrate API directly from the SubWallet extension without using Polkadot.js Apps. To do so, press the **Send** icon and take the following steps:

1. Specify the asset to send
2. Specify the destination chain (in this case, the same chain that you're sending from)
3. Enter the destination address
4. Enter the number of tokens to send
5. Look over the transaction details, then press **Transfer** and subsequently **Approve**

![Send funds through Substrate API directly in SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-12.webp)

This guide focused specifically on configuring SubWallet to work with your Tanssi Substrate network, but SubWallet is also a full-featured wallet for EVM accounts. Under the Ethereum API section, you'll find a [similar guide for configuring SubWallet for use with your Tanssi EVM network](/builders/toolkit/ethereum-api/wallets/subwallet/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/builders/toolkit/substrate-api/wallets/talisman/
--- BEGIN CONTENT ---
---
title: How to Connect Talisman to Tanssi
description: This guide walks you through how to connect Talisman, a Substrate and Ethereum wallet, to the Tanssi network or your Tanssi-powered Substrate appchain.
icon: material-wallet-outline
categories: Substrate-Template
---

# Interacting with Tanssi or Your Substrate Appchain Using Talisman

## Introduction {: #introduction }

Developers and users of Substrate networks, such as the Tanssi network or Tanssi-powered Substrate appchains, have a variety of options when it comes to wallets. Talisman is a great option, as it provides full native support for both Substrate and Ethereum accounts. This guide focuses on the Substrate API. You can also check out a [similar guide for configuring Talisman for use with your Tanssi EVM network](/builders/toolkit/ethereum-api/wallets/talisman/){target=\_blank}.

Talisman is a Web3 wallet that natively supports Substrate and Ethereum accounts. The Talisman wallet browser extension is available on [Google Chrome, Brave, and other Chromium-based browsers](https://chromewebstore.google.com/detail/talisman-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld){target=\_blank}, as well as [Firefox](https://addons.mozilla.org/en-US/firefox/addon/talisman-wallet-extension/){target=\_blank}. An asset dashboard is accessible at [app.talisman.xyz](https://app.talisman.xyz){target=\_blank}

This guide takes you through all the necessary steps, from installing Talisman to setting up a wallet, connecting it to your Tanssi Substrate network, and sending funds.

!!! note "Editorâ€™s Note (2025 Update)"
    This guide references options like Polkadot.js Apps or Polkadot account type because these are the labels used in common Substrate tools. Tanssi itself is independent â€” built with Substrate and aligned with Ethereum-backed security.

## Setting Up Talisman {: #setting-up-talisman }

First, download and install the [Talisman extension](https://talisman.xyz/){target=\_blank}. This guide will first cover creating a new wallet and later address importing an existing one. Review the terms and conditions, then press **Get Started**.

![Get started with Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-1.webp)

On the following screen, you'll be prompted to create a password to secure your new wallet.

![Enter password for Talisman Wallet](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-2.webp)

## Create a Substrate Account {: #create-a-substrate-account }

To create your first Substrate account in Talisman, take the following steps:

1. Select the **Polkadot** option.
2. Give your account a name.
3. Press **Create**.

!!! note
    Why Polkadot? Tanssi and Tanssi-powered appchains are built using Substrate, the same framework that powers Polkadot. As a result, even though Tanssi and Polkadot are separate networks, they share the same cryptographic signature schema.

![Create your first Polkadot account in Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-3.webp)

After creating your first account, you'll be prompted to back up your seed phrase. This is an important step, especially because you have the option to later derive additional accounts from this seed phrase.

![Back up your seed phrase](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-4.webp)

!!! note
    You should never share your seed phrase (mnemonic) or private key with anyone. This gives them direct access to your funds. This guide is for educational purposes only.

## Importing an Existing Substrate Account {: #importing-an-existing-substrate-account }

Of course, you can import an existing Substrate account into Talisman. To do so, take the following steps:

1. Press **Add Account**.
2. Press **Import**.
3. Select **Import via Recovery Phrase**.

![Import existing account setup](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-12.webp)

On the following screen, take the following steps:

1. Select the **Polkadot** account type.
2. Provide a name for your account.
3. Paste in your seed.
4. Select which accounts you'd like to import.
5. Press **Import**.

![Import existing account final steps](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-13.webp)

## Connecting Talisman to the Tanssi Network {: #connecting-talisman-to-the-tanssi-network }

Talisman already comes pre-configured with support for Tanssi MainNet and [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}. To connect to Dancelight, you first need to make sure you have enabled support for TestNets on Talisman. To do so, take the following steps:

1. Open the Talisman extension and click on the Talisman logo.
2. Select **Settings**.
3. Ensure that **Enable testnets** is checked.

![See your TestNet account balances in Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-5.webp)

If you have a balance of Tanssi MainNet or Dancelight tokens, you'll see your account balance on the homepage of the Talisman wallet. When you don't have a balance, the network is omitted from your list of assets.

![See your TestNet account balances in Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-6.webp)

## Connecting Talisman to Your Substrate Network {: #connecting-talisman-to-your-substrate-network }

To configure Talisman for your Tanssi-powered Substrate network, open the Talisman extension and click on the **More Options** tab. Click on **Settings** > **Networks & Tokens** > **Manage Networks**.

1. Slide the network slider to **Polkadot**.
2. Check the **Enable testnets** box.
3. Press **Add Network**.

![Add Network in Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-7.webp)

On the following page, you'll then be prompted to enter the network details for your Tanssi network. For demonstration purposes, Dancelight is used here, but you can substitute these details for your own Tanssi network. To add your Tanssi network to Talisman, take the following steps:

1. Paste in the RPC URL of your Tanssi network. Other parameters will be auto-populated.
2. Optionally, enter the block explorer URL of your Tanssi network, if applicable.
3. Check the **This is a testnet** box if applicable.
4. Press **Add Network**.

![Add your Tanssi-Powered Network Details](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-8.webp)

## Connecting to Polkadot.js {: #connecting-to-polkadotjs}

To connect your Tanssi Substrate network to Polkadot.js Apps, first head to [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank}. In this example, Polkadot.js Apps is connected to Dancelight, but you can point Polkadot.js to your Tanssi network by clicking on the network dropdown and filling in the WSS endpoint of your Tanssi network in the **custom endpoint** field.

![Connect to Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-9.webp)

The Talisman extension will prompt you to select the accounts you'd like to use with Polkadot.js Apps. If it doesn't automatically pop up, you can open the Talisman extension and click on the **polkadot.js.org** heading at the top. To configure Talisman to correctly interface with your Tanssi network on Polkadot.js Apps, you should take the following steps:

1. Select the Substrate account(s) that you'd like to use with Polkadot.js Apps
2. Press **Connect 1**. The value will change depending on the number of accounts you are connecting

![Connect Talisman to Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-10.webp)

Your Talisman wallet is now connected to Polkadot.js Apps. After refreshing Polkadot.js Apps, you should see your Talisman account in the [Accounts page of Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} underneath the **extension** heading.

## Sending a Transaction {: #sending-a-transaction}

To send a transaction through the Substrate API, click **Send** next to your account on Polkadot.js Apps. Then, take the following steps:

1. Input the **send to address**.
2. Enter the **amount**.
3. Press **Make Transfer** and confirm the transaction in the resulting Polkadot.js pop-up.
4. Press **View Details** if you'd like to inspect the contents of the transaction.
5. Press **Approve** to submit the transaction.

![Send funds through Substrate API with Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-11.webp)

This guide focused specifically on configuring Talisman to work with your Tanssi Substrate network, but Talisman is also a full-featured wallet for EVM accounts. Under the Ethereum API section, you'll find a [similar guide for configuring Talisman for use with your Tanssi EVM network](/builders/toolkit/ethereum-api/wallets/talisman/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/decentralized-networks/included-templates/
--- BEGIN CONTENT ---
---
title: Network Templates Included in Tanssi
description: Tanssi protocol provides useful templates to start building your decentralized network, including a ready-to-use EVM template for Ethereum compatibility.
icon: octicons-copy-24
categories: Basics
---

# Network Templates Included in Tanssi {: #network-templates-included-in-tanssi }

## Introduction {: #introduction }

Building a new network from scratch can be a daunting prospect. Fortunately, thanks to the [network development framework](/learn/framework/overview/){target=\_blank} used by Tanssi and its modular-oriented architecture, developers can leverage some pre-bundled network templates that help them jumpstart the process and benefit in some aspects, such as:

- **Head Start** - Tanssi network templates provide a starting point for your project, saving significant time and effort by providing a basic structure and a set of tested and ready-to-use functionalities. It allows developers to accelerate the construction of prototypes or minimum viable products (MVPs) and reduce the time to market

- **Consistency** - included Tanssi network templates follow established design patterns, coding standards, and best practices widely accepted among the developer community. They also provide a default set of architecture definitions to streamline blockchain development

- **UX** - Tanssi network templates cover the most demanded use cases, such as the EVM support for an Ethereum-compatible network

- **Customizability** - Tanssi network templates are a great starting point and are completely customizable. The functionalities and default configurations they include can be modified, replaced, or extended to meet the specific requirements of the use case

- **Upgrades and Compatibility** - Tanssi is built on top of an evolving framework, with new features, enhancements, and bug fixes being regularly introduced. The provided Tanssi network templates are kept up-to-date with these upgrades

## Start Building a Network {: #start-building }

To start building a decentralized network to deploy in Tanssi, some useful Tanssi network templates to kick-start the development process are provided in the [official repository](https://github.com/moondance-labs/tanssi){target=\_blank}.

The process is as simple as:

1. Select one of the templates
2. Add the specific logic to adapt the runtime to the requirements of the use case
3. Deploy in Tanssi

![Using Templates to Speed Up the Development Process](/images/learn/decentralized-networks/templates/templates-1.webp)

The two included templates are the *baseline network template* and the *baseline EVM template*, which are presented in the following sections.

### Baseline Network Template {: #baseline-network-template }

As presented in the [Overview](/learn/tanssi/overview/){target=\_blank} article, networks deployed through Tanssi are fully sovereign and customizable blockchains.

As part of the Tanssi ecosystem, networks must include the essential components to implement the consensus mechanism and be able to interact and synchronize with the security provider of their choice (for example, [Symbiotic](https://symbiotic.fi/){target=\_blank} on Ethereum). The baseline Tanssi network template includes all the necessary functionality for the sequencers logic, p2p, database, and synchronization layers between the network and the security provider, allowing developers to focus solely on customizing their product.

This template also includes Tanssi's [Author Noting](https://github.com/moondance-labs/tanssi/blob/master/pallets/author-noting/src/lib.rs){target=\_blank} module, which implements the logic for retrieving and validating the set of sequencers assigned to provide block production services to the network. It also includes logic that allows a sequencer to sign the block when the consensus mechanism determines that it is the sequencer's turn to produce the block (and thus be rewarded accordingly).

The source code for this template is public and accessible on the [Tanssi GitHub repository](https://github.com/moondance-labs/tanssi/blob/master/chains/container-chains/runtime-templates/simple/src/lib.rs){target=\_blank}.

### Baseline EVM (Ethereum Virtual Machine) Template {: #baseline-evm-template }

Extending the [baseline Tanssi network template](#baseline-network-template), this template provides not only Tanssi protocol support but also an EVM and full Ethereum compatibility.

Leveraging a set [EVM-specific modules](https://github.com/polkadot-evm/frontier){target=\_blank}, this template includes an Ethereum compatibility layer for networks to allow running unmodified Ethereum dApps.

Using this template, networks support the deployment and running of any existing smart contract written in Solidity or Vyper with no changes. By emulating Ethereum block production and exposing the expected RPC interface, developers can also continue using the same tools like [Metamask](https://metamask.io){target=\_blank}, [Hardhat](https://hardhat.org){target=\_blank}, [Remix](https://remix.ethereum.org){target=\_blank}, [Foundry](https://github.com/foundry-rs/foundry){target=\_blank}, and many more out of the box, with no extra adapters.

With this EVM template, developers can deploy a [Moonbeam](https://moonbeam.network){target=\_blank}-like network in no time and add their custom logic and features specific to their use case.

The source code for this template is public and accessible on the [Tanssi GitHub repository](https://github.com/moondance-labs/tanssi/blob/master/chains/container-chains/runtime-templates/frontier/src/lib.rs){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/decentralized-networks/
--- BEGIN CONTENT ---
---
title: Learn about Tanssi-Powered Networks
description: Discover the features in EVM and Substrate networks deployed through Tanssi, leveraging user-friendly and easy-to-deploy templates for enhanced capabilities.
icon: octicons-workflow-24
template: index-page.html
---

# Tanssi-Powered Networks

Developing a blockchain that balances scalability, efficiency, and customization is a complex task. Tanssi-Powered Networks address these challenges through their integration into Tanssi's modular infrastructure. This section explains the networks' structure, functionality, and unique characteristics in the Tanssi ecosystem.

Key features of Tanssi-powered networks:

- **Runtime customization** - adapt transaction types, execution logic, and state transitions to fit your network's specific requirements
- **Transaction efficiency** - optimize transaction fees for scalability and economic sustainability
- **Scalability at its core** - build networks that are prepared to grow alongside your ecosystem

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/decentralized-networks/overview/
--- BEGIN CONTENT ---
---
title: Network Overview
description: Learn the high-level definitions of how a Tanssi network works, its architecture, and its block production as a service mechanism with deterministic finality.
icon: octicons-home-24
categories: Basics
---

# Tanssi Networks Overview {: #networks-tanssi-overview }

## Introduction {: #introduction }

Networks deployed through Tanssi receive many [benefits](/learn/tanssi/overview/#what-tanssi-provides){target=\_blank}, like block production as a service, data retrievability as a service, and security through an [external security providers](/learn/tanssi/external-security-providers/){target=\_blank} such as [Symbiotic](https://symbiotic.fi/){target=\_blank} on Ethereum.

Also, because Tanssi-powered networks are based on a [modular tech stack](/learn/framework/){target=\_blank}, they profit from unique advantages when customizations are required at a runtime level. This [modularity](/learn/framework/modules/){target=\_blank} allows developers to add functionality directly into the runtime or extend the capabilities of the EVM itself via precompiled contracts.

For example, Tanssi provides a ready-to-use [template](/learn/decentralized-networks/included-templates#baseline-evm-template){target=\_blank} that includes [Frontier](https://github.com/polkadot-evm/frontier){target=\_blank} modules, enabling the effortless deployment of an EVM-compatible networks, similar to [Moonbeam](https://moonbeam.network){target=\_blank}.

This section covers the fundamentals of a Tanssi network, its architecture, its core modules and functionalities, and the transaction fee mechanism.

## General Architecture {: #general-architecture}

As previously discussed, networks deployed through Tanssi are customizable blockchains that, among other features, receive block production as a service and inherit security with deterministic block finality within seconds from an external security provider. 

Tanssi-powered networks are fully decentralized networks. The decentralized nature of the networks considerably increases their resilience and fault tolerance since they don't rely on a single authority or entity to ensure their liveness, security, and performance but on trustless, decentralized protocols. For example, they receive block production services from a decentralized and incentivized set of sequencers managed by Tanssi.

The Tanssi protocol runs with an [external security provider](/learn/tanssi/external-security-providers/){target=\_blank}, which has a set of operators (also called validators) with assets at stake, validating the transactions from the Tanssi network itself and all of the networks deployed through Tanssi. This way, all Tanssi-powered networks inherit the economic security derived from the Tanssi protocol and, indirectly, from the operators, which verify every transaction from every network. Tanssi networks don't need to run their own operator set nor bootstrap liquidity to secure their protocol.

Tanssi networks also benefit from a set of Data-Preservers, with full archive nodes, ensuring the data availability layer availability. These data-preservers are incentivized through Tanssi's data retrieval services and also provide the RPC infrastructure for apps and users interacting with Tanssi networks.

```mermaid
flowchart TB
    networks["Tanssi Networks<br/>(Decentralized Networks)"]

    subgraph tanssi["Tanssi Protocol"]
        direction TB
        sequencers["Decentralized Sequencers Set"]
        node["Full Archive Nodes with<br/>RPC Services"]
    end

    security["External Security Provider<br/>Operators"]
    
    networks<--Block Production-->tanssi
    networks<--Shared Security Model-->tanssi
    networks<--Data Availability<br/>RPC endpoints-->tanssi
    tanssi<--Transactions<br/>Validation and Finality-->security
```

## Network Transaction Flow {: #network-transaction-flow }

A transaction submitted to a Tanssi-powered network follows a complex yet seamless path from submission to block inclusion and finalization. The network infrastructure, Tanssi, and the chosen [security provider](/learn/tanssi/external-security-providers/){target=\_blank} work together at different levels to ensure the process happens as quickly as possible, usually taking around 30 seconds. Remember that a transaction in a Tanssi network reaches deterministic finality. Consequently, once the transaction is final, it becomes irreversible and unchangeable, and the state transition resulting from executing that transaction is final.

For example, a user initiates a transaction when interacting via an application deployed to a Tanssi-powered network. The RPC provider will share the transaction, which sits in the chain's transaction pool, with all network participants. A sequencer assigned by Tanssi to that network will eventually pick up the transaction and include it in the next network block.

Then, the sequencer will share with the security provider's operators:

- The block itself with the state transitions
- The storage components in the Tanssi network database that the block is modifying
- The necessary hashes of the unaffected points in the Merkle tree of the storage

These components constitute the proof of validity (PoV).

Next, the PoV is verified by the security provider's operators. Note that the operators do not check that the Tanssi network storage is valid but that the state transitions that affect it are. A summary of that verification is then gossiped to other operators so they can verify it and include it in the next Tanssi block. Lastly, that Tanssi block with all the networks' verifications is finalized.

The transaction flow process is summarized in the following diagram:

![Path of a Tanssi Network Block in Tanssi](/images/learn/decentralized-networks/overview/overview-1.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/decentralized-networks/runtime-features/
--- BEGIN CONTENT ---
---
title: Core Runtime Features
description: Learn about the core features of a Tanssi network, the transactions types, how they are executed and included in a block, and the forkless runtime upgrades.
icon: octicons-package-24
categories: Basics
---

# Core Runtime Features {: #core-runtime-features }

## Introduction {: #introduction}

Networks deployed through Tanssi have [many benefits](/learn/tanssi/overview/#what-tanssi-provides){target=\_blank} due to its unique [architecture](/learn/tanssi/overview/#tanssi-architecture){target=\_blank}.

Nevertheless, Tanssi-powered networks are also unique due to the [framework](/learn/framework/){target=\_blank} (Substrate) they are built on top of, which provides some unique characteristics that developers can leverage to fine-tune specific behaviors in their runtime.

This section covers some of these Tanssi network core runtime-specific features, including the different origins a transaction might have, the different types of transactions and how they are executed and included in a block, the special account known as _SUDO_, and the quite unique feature of Tanssi networks: the forkless runtime upgrades.

## Origins {: #origins}

Generally speaking, all calls in a Tanssi network have an origin. But what is an origin? Developers from the EVM realm might be familiar with the concept of _msg.sender_ in EVM transactions. Origins are to Tanssi networks what _msg.sender_ is to an EVM transaction, but supercharged with many extra functionalities.

An origin defines where the call is coming from. In contrast to Ethereum-compatible chains, there can be many origins in Tanssi networks. For example, the _msg.sender_ of an EVM transaction is known as a _signed origin_, which means that the call is a transaction that was signed by some on-chain account's private key. This allows the runtime to authenticate the source of the call and, for example, charge transaction fees to the associated account.

However, origins can do much more than represent a private key/public key pair. Origins also have different privilege levels. For example, a _signed origin_ can send a transaction that is dispatched by the private key/public key pair but should not be able to authorize a runtime upgrade.

Some of the most common types of origins are:

- **Root** - a system-level origin with the highest privilege level. It can be thought of as a superuser of the chain, which can execute any call
- **Signed** - as mentioned before, the origin of a transaction signed by an on-chain account's private key, which includes the account identifier (address) as the signer
- **None** - a lack of origin. Used in specific actions that must be agreed upon at a runtime level. For example, you can program your runtime so that a transaction with _none_  origin can enact a pre-authorized runtime upgrade, which means that the transaction has no fee associated with it
- **Custom** - developers can also create custom origins for specific use cases. For example, [Moonbeam's on-chain governance](https://docs.moonbeam.network/learn/features/governance){target=\_blank} has specific origins for each type of governance vote, called _tracks_. Consequently, each track can be configured to only execute calls with specific privilege levels. One track is _Root_, whose origin is the _Root_ origin mentioned before, and has a very restrictive configuration for votes to go through. But other tracks have much lower privilege levels to do some less critical network operations

## Transaction Types {: #transaction-types}

Tanssi networks have three main types of transactions:

- **Signed Transactions** - include a signed payload requesting to execute some runtime call. Generally, the signature is associated with a private key/public key pair. Depending on the runtime logic, the account associated with the signature pays a transaction fee
- **Unsigned Transactions** - include an unsigned payload requesting to execute some runtime call. Because these transactions are unsigned, there is no account associated with them. Consequently, runtimes need to define specific conditions that prevent network spam or replay attacks because there is no fee mechanism to prevent such malicious behaviors. One example of an unsigned transaction is executing pre-approved actions, like a runtime upgrade
- **Inherent Transactions** - an unsigned transaction that a sequencer inserts into a block when initializing its construction. These transactions are part of the block and are not stored in the transaction pool or shared among network participants. In addition, the data inserted through inherent transactions can skip runtime validation, and it might be up to operators to accept it. One example is the block timestamp. This is injected into the block by an inherent transaction, and operators can accept or reject the block based on whether the timestamp is within some acceptable range

## Transaction Execution {: #transaction-execution}

When a user or application submits a signed transaction to a Tanssi network, the transaction is validated at a full-node level using rules defined in the runtime, and then it is queued in a transaction pool. This ensures that only transactions that comply with certain chain-specific conditions are considered to be included in a block.

!!! note
    The most common type of transaction is a signed transaction. Nevertheless, unsigned transactions are also validated before they are queued in the transaction pool.

The valid transaction queue comprises two pools: ready and future. The ready queue contains all transactions that can be included in a new pending block. The future queue is for transactions that don't meet all the criteria to be included now but might become valid. For example, transactions with a future nonce. Invalid transactions are directly rejected.

During the block-building process, a sequencer uses a [priority system](https://github.com/paritytech/substrate/blob/fb24fda76d613305ebb2e5728c75362c94b64aa1/frame/transaction-payment/src/lib.rs#L614-L681){target=\_blank} through a transaction orchestration module to order transactions for the next block, until the block reaches its maximum capacity. The block building and execution order has the following operations:

- **Initializing a Block** - known as `on_initialize`,  enables you to define runtime logic executed before any other transaction is accounted for. For example, inherent transactions, like the timestamp in the previous example, are commonly executed when initializing a block. Once the initialization logic is completed, the transaction orchestration module verifies the parent hash in the block header and the trie root to ensure the information is correct
- **Transaction Execution** - with the block already initialized, the transaction orchestration module executes each valid transaction according to its priority. The initial state is not cached before the execution, meaning that if one of the transactions fails mid-execution, any state changes committed up to that moment cannot be reverted, and the subsequent block will be invalid. Consequently, runtime logic should perform all necessary checks to ensure all valid transactions will succeed
- **Finalizing a Block** - after all queued valid transactions are executed or the block limit is reached, the orchestration module calls into each runtime module the `on_idle` and `on_finalize` functions. These two functions allow the definition of extra business logic that is automatically executed in the block finalization process. After the last `on_finalize` function is called, the orchestration module ensures that the block digest and storage root match what was calculated when the block was initialized

## Forkless Upgrades {: #forkless-upgrades}

Networks deployed through Tanssi have a thrilling feature: [forkless upgrades](https://docs.polkadot.com/develop/parachains/maintenance/runtime-upgrades/){target=\_blank}. Forkless upgrades allow developers to change the state transition function that governs the chain without creating a network fork, as seen on Ethereum multiple times. Furthermore, if the Tanssi network is set up with an on-chain governance system, upgrades to the network can happen in a truly decentralized and trustless way.

Forkless upgrades are made possible by storing the state transition function as a WebAssembly (Wasm) blob in both the Tanssi network itself and the Tanssi-powered network. When a new runtime is scheduled through a function call in the Tanssi-powered network, the Tanssi network validates this block, so it is notified and readies itself to validate incoming blocks using the most recent state transition function. Following a specified runtime upgrade delay period, a Tanssi sequencer on the Tanssi-powered network constructs a block that references a Tanssi network block, signaling to the Tanssi network that it can now apply the new runtime. Consequently, this new state transition function is utilized for that specific block. As all infrastructure participants at the network level employ the on-chain Wasm blob, every Tanssi network node operator can validate new blocks using the latest state transition function.

A high-level summary of the runtime upgrade process is shown in the following diagram:

![Runtime Upgrade Process Tanssi Networks](/images/learn/decentralized-networks/runtime-features/runtime-features-1.webp)

## SUDO Account {: #sudo-account}

Tanssi networks may use a specific module called [SUDO](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/pallet/struct.Pallet.html){target=\_blank}. This module introduces a new type of account, also named _SUDO_, that can execute transactions with the [_Root_ origin](#origins).

Consequently, the SUDO account can perform **any** action that the runtime allows the _Root_ origin to execute. This can include:

- Mint new native Tanssi network tokens
- Perform [forkless runtime upgrades](#forkless-upgrades)
- Send transactions impersonating other [origin types](#origins). Therefore, SUDO can send transactions on behalf of other users without accessing their private key

_SUDO_ is recommended for TestNets as it allows them to swiftly make changes without the need to go through a lengthy on-chain governance process. It is good practice to have _SUDO_ keys stored safely and grant access to _SUDO_ calls via proxy accounts. Nevertheless, having _SUDO_ enabled in a production environment can lead to undesired consequences.

**Understanding the centralization risks of having _SUDO_ in a production environment is key.**
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/decentralized-networks/tx-fees/
--- BEGIN CONTENT ---
---
title: Transaction Fees
description: Learn about the transaction fee mechanism in Tanssi networks, how it works from a Substrate perspective, and in the Ethereum EVM emulation layer with EIP-1559.
icon: material-piggy-bank-outline 
categories: Basics
---

# Transaction Fees {: #transaction-fees }

## Introduction {: #introduction}

Tanssi-powered networks are built with a [modular framework](/learn/framework/){target=\_blank} called [Substrate](https://docs.polkadot.com/develop/parachains/intro-polkadot-sdk/){target=\_blank}. With this framework, you can build unique ways to handle transaction fees. For example, most transactions use a specific module called [Transaction Payment](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment){target=\_blank}. However, transaction fees on Tanssi-powered EVM-compatible networks can be charged at an EVM execution level, bypassing other fee-related modules.

Under the hood, for execution time, instead of working with a gas-based mechanism, all Tanssi networks work with a [weight-based mechanism](https://docs.polkadot.com/polkadot-protocol/parachain-basics/blocks-transactions-fees/fees/){target=\_blank}. Weight refers to the time (in picoseconds) it takes to validate a block. Generally speaking, for both EVM and non-EVM Tanssi networks, all function calls have a weight associated with them, which sets limits on storage input/output and computation. For Tanssi EVM networks, there is a gas-to-weight mapping that fully complies with the expected gas requirements for Ethereum API-based tools.

A transaction fee scheme is applied on top of the weight-based mechanism to ensure economic incentives are in line to limit the execution time, computation, and number of calls (database read/writes) to perform operations. Transaction fees are fundamental to preventing network spam, as they represent the cost of using the Tanssi network service. Consequently, a user interacting with the network through a specific function call will pay a transaction fee determined by a baseline fee algorithm.

This page covers the fundamentals of transaction fees for Tanssi networks. It first covers the underlying transaction fee architecture and how it is adapted to a fully EIP-1559-compliant model for Tanssi EVM networks.

## Baseline Fees Calculation {: #baseline-fees }

Every action that alters the state of a Tanssi network incurs a transaction fee. This fee is essential for the network's operation, covering the computational resources required to process transactions, similar to the gas and gas price parameters in EVM-compatible chains like Ethereum.

Tanssi networks [modular framework](/learn/framework/){target=\_blank} use a weight-based fee calculation mechanism to determine transaction fees. This approach considers various factors, including computational resources and storage operations (inputs/outputs), to reflect the true cost of transactions accurately. By accounting for these elements, the network ensures fair and efficient resource allocation.

Furthermore, Tanssi networks modularity ensures that EVM-compatible networks support legacy and [EIP-1559 compatible](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} transaction pricing mechanisms, ensuring full compatibility with development environments commonly used in Ethereum.

This section outlines all the different concepts associated with transaction fees for Tanssi networks.

### Weight {: #baseline-weight}

Broadly speaking, weight refers to the execution time it takes to validate a block, measured in picoseconds. Weight is divided into two separate variables:

- **`refTime`** - corresponds to the weight associated with computation time and database reads/writes
- **`proofSize`** - corresponds to the weight associated with the size of the Proof-Of-Validity (or PoV for short). The PoV is associated with the relevant state of a transaction, and it is what the Tanssi network sequencer shares with the security provider operators to get a block validated and finalized as part of the [network transaction flow](/learn/decentralized-networks/overview/#network-transaction-flow){target=\_blank}

To find the weights for all function calls, they are benchmarked in a system with reference hardware, and the approximate values of `refTime` and `proofSize` are set. This process is repeated for all function calls that consume blockspace and affect the PoV.

For transactions in which the fees are handled by the [transaction payment](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment){target=\_blank} module, all weight-based parameters are then passed through a _weight to fee_ algorithm that converts all to a final value, deducted from the sender's account when executing the function call. The algorithm can be customized, but Tanssi networks have a constant value set.

For EVM transactions, gas is converted to weight through a gas-to-weight algorithm so that all EVM calls can be mapped to block execution time. Nevertheless, fees are handled at an EVM execution level.

### Baseline Transaction Fees {: #baseline-transaction-fees}

<!-- https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/transaction-payment/src/lib.rs#L627-L652 -->

With all function calls benchmarked, the transaction fee for each specific call can be obtained. Transaction fees are typically comprised of the following elements:

- **`BaseFee`** - baseline cost for a transaction to be included. It accounts for the transaction inclusion overhead, like signature verification. The fee is defined by two separate parameters:
    - **`ExtrinsicBaseWeight`** - a constant value that represents the weight of the transaction inclusion overhead
    - **`WeightToFee`** - a polynomial function that converts weight to fee
- **`WeightFee`** - fee defined by two separate parameters:
    - **`BenchmarkedWeight`** - weight that accounts for the complexity (execution time) of a specific call
    - **`CongestionMultiplier`** - a function that converts weight to fee and can be adjusted to account for the congestion of the network (weight consumed in the previous block). The default strategy for Tanssi networks is [`SlowAdjustingFeeUpdate`](https://research.web3.foundation/Polkadot/overview/token-economics#2-slow-adjusting-mechanism){target=\_blank}, which adjusts this multiplier slowly over time following the network load
- **`LengthFee`** - a fee correlated to the length in bytes of the function call. The fee is defined by two separate parameters:
    - **`ByteLengthFunctionCall`** - length in bytes of the call being executed
    - **`LengthToFee`** - a function that defines the per-byte fee algorithm. For Tanssi networks, this is a constant value
- **`Tip`** - an optional value that increases the overall fee, increasing the priority of the transaction by incentivizing sequencers to include it in the next block

Therefore, in general terms, the transaction fee can be calculated with the following equation:

<!-- https://github.com/moondance-labs/substrate/blob/master/frame/support/src/weights/extrinsic_weights.rs#L57 -->
<!-- https://github.com/moondance-labs/tanssi/blob/master/container-chains/templates/frontier/runtime/src/lib.rs#L265-L277 -->

```text
BaseFee = ExtrinsicBaseWeight * WeightToFee
WeightFee = BenchmarkedWeight  * CongestionMultiplier
LengthFee = ByteLengthFunctionCall * LengthToFee

InclusionFee = BaseFee + WeightFee + LengthFee
FinalFee = InclusionFee + Tip
```

All non-EVM function calls available to developers use these baseline calculations for transaction fees. Tanssi EVM networks have an extra layer to translate this fee scheme into an Ethereum-like scheme from an Ethereum JSON-RPC and EVM perspective. 

### EVM Transaction Fees {: #evm-transaction-fees }

<!-- https://github.com/polkadot-evm/frontier/blob/272fe8839f87161ed89350de166b379f1f4c6136/frame/base-fee/src/lib.rs#L126-L199 -->

Tanssi offers [templates for full Tanssi EVM-compatible networks](/builders/build/templates/evm/){target=\_blank}. Such networks provide an Ethereum-like environment for developers, where they can use Eth-specific libraries like [Ethers.js](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}, [Hardhat](/builders/toolkit/ethereum-api/dev-env/hardhat/){target=_blank}, and [Foundry](/builders/toolkit/ethereum-api/dev-env/foundry/){target=\_blank}.

In addition, all Tanssi EVM-compatible networks have an [EIP-1559 compatible](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} transaction pricing mechanism for EVM transactions. But they support both commonly used EVM transaction types:

- **Type 0 (Legacy)** - the transaction fee is calculated through a single gas price value that is included in the signed transaction blob. Because Tanssi EVM-compatible networks have a dynamic pricing mechanism, gas price must be greater than the current block's `baseFee` for a transaction to be considered valid
- **Type 2 (EIP-1559)** - the transaction fee is calculated with a combination of the `maxFeePerGas` and `maxPriorityFeePerGas` from the signed transaction blob, and the network's `baseFee` dynamically changes based on block congestion

Independently of the transaction type, the outcome of all EVM transactions is that there is an associated cost in native tokens that the network must charge. 

By default, Tanssi EVM-compatible networks are configured with the following parameters:

- **Minimum BaseFee** - the minimum gas price of the network in case there are no transactions for long periods. The default value is set to 1 GWei
- **Block Fulness Target (Elasticity)** - the target gas used in a block so that the `baseFee` remains the same. [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} defines this value as a constant set to 2, meaning that the target usage is 50% of the block gas limit. All Tanssi EVM-compatible networks are set with the same target
- **Maximum BaseFee Increase** - the maximum amount the `baseFee` can increase or decrease, in percent points, based on the previous block target usage. [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} defines this value as a constant set to 12.5%. Consequently, if the block is full/empty, the `baseFee` will increase/decrease by 12.5%, and any intermediate values are linearly adjusted. Developers can configure this value for Tanssi EVM-compatible networks, but the default value is 12.5%

!!! note
    One key difference in Tanssi EVM-compatible networks EIP-1559 implementation is that the transaction fees are calculated using the previous block `baseFee`.

The EVM transaction fee cost associated with all Tanssi EVM-compatible networks is captured at an EVM execution level. Nevertheless, EVM transactions do take block execution time. Therefore a gas-to-weight algorithm is required to account for the weight consumed by a specific call relative to the gas it is consuming.

<!-- https://github.com/moondance-labs/tanssi/blob/master/container-chains/templates/frontier/runtime/src/lib.rs#L825 -->
<!-- https://github.com/polkadot-evm/frontier/blob/272fe8839f87161ed89350de166b379f1f4c6136/primitives/evm/src/lib.rs#L253-L265 -->

Ultimately, the transaction fee and weight associated to an EVM call in a Tanssi EVM-compatible network can be calculated with the following formula:

=== "EIP-1559"
    ```text
    Gas Price = baseFee + maxPriorityFeePerGas < maxFeePerGas ? 
               baseFee + maxPriorityFeePerGas : 
               maxFeePerGas;
    Transaction Fee = Gas Price * Gas Used
    Transaction Weight = Gas Used * GasToWeight
    ```

=== "Legacy"
    ```text
    Transaction Fee = GasPrice * GasUsed
    Transaction Weight = GasUsed * GasToWeight
    ```

`GasToWeight` is a constant value set to `{{ templates.evm.gas_to_weight }}`.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/framework/architecture/
--- BEGIN CONTENT ---
---
title: Framework Architecture
description: In a Substrate node, two main components are the runtime, which controls the blockchain's state transition, and the client, which manages everything else.
icon: octicons-stack-24
categories: Basics
---

# Framework Architecture {: #framework-architecture }

## Introduction {: #introduction }

Substrate is a software development kit (SDK) for building blockchains. This framework is the foundation and engine powering many projects across the Web3 ecosystem, including the Tanssi network itself and the networks deployed through Tanssi.

Written in the Rust language and designed with a modular architecture, Substrate is extremely performant, flexible, and highly customizable, making it the best choice for developing blockchains.

In this article, the architecture of a Substrate node is covered.

## Architecture {: #architecture }

The Substrate framework is designed for maximum customizability, providing a fully functional implementation for every important internal aspect of a blockchain. It allows developers to focus on the specifics of the use case and the runtime characteristics, and it provides the ability to change any of the default features (should the need arise).

The architecture of a Substrate node contains two main components:

- **Core Client** - handles the communication with the outer world (other nodes, dApps, end users, among others), and many other internal responsibilities, such as storage and communication
- **Runtime** - implements the custom logic of the Tanssi network, executes transactions, and manages the state transitions

From the end-user perspective, all the interaction with the Tanssi network is usually made through dApps or directly via the node RPC endpoints, for example, using a wallet. When a user triggers a request to fetch data or sends transactions to a node, the core client is responsible for responding or queuing the transactions until execution in the runtime. Still, all these internal aspects of the node design are kept transparent to the user.

![Basic substrate node architecture](/images/learn/framework/architecture/architecture-1.webp)

## The Core Client {: #core-client }

The core client comprises components responsible for everything in the operation of a node in the network except for what happens in the runtime.

Some of the main components are:

- **Networking** - this component handles the communication with the peers in the network (synchronizing blocks, propagating transactions, and so on) and exposes the endpoints that allow dApps to integrate and interact with the Tanssi network
- **Storage** - this component manages the state storage of the Tanssi network in a highly efficient key-value database
- **Consensus** - this component ensures that all the participants in the network agree on the state of the blockchain, validating transactions, state transitions, and the resulting blocks

The default configuration of a Substrate node and the built-in implementations of the components are usually the best choice for most use cases. Still, teams are welcome to innovate and change or replace any piece of the node or even write a completely different implementation of the core client, such as [Kagome](https://github.com/soramitsu/kagome#intro){target=\_blank} (C++ implementation) and [Gossamer](https://github.com/ChainSafe/gossamer#a-go-implementation-of-the-polkadot-host){target=\_blank} (Golang implementation).

## The Runtime {: #runtime }

The runtime plays a crucial role in the operation of the Tanssi network. It contains the core logic and rules to meet the requirements of the use case the developers are building, and, therefore, it is responsible for validating the transactions and executing the state transitions.

Being the core element in a Tanssi network, designing the Substrate architecture an important decision has been made regarding the format for the runtime: it is compiled to [WebAssembly (Wasm)](https://webassembly.org){target=\_blank} byte code.

The Wasm format offers many advantages to a deployed Tanssi network, including:

- **Portability** - the Wasm format is platform-independent, meaning that the same binary can be distributed and run on different nodes using different hardware architectures and operating systems
- **Deterministic Execution** - the Wasm format ensures deterministic execution of code, which means that the same input will always produce the same output. Determinacy is a critical aspect in blockchains to obtain the same state transitions across every node in the network and reach a consensus
- **Forkless Upgradeability** - Substrate stores the runtime Wasm blob on-chain, meaning that the runtime itself becomes part of the state. This design allows upgrading the runtime logic in a forkless way using a transaction

Besides the format, internally, a Substrate runtime is built by composing different modules, either provided and ready-to-use by Substrate or custom-made. Each one of these modules define, among other things, the transactions they expose, the logic behind them, what needs to be stored in the chain state, the best format to do it, and how they cooperate with other modules composing functionality. More details about building a runtime will be covered in the [modules](/learn/framework/modules/){target=\_blank} section.

## Client-Runtime Communication {: #client-runtime-communication }

As previously described, the two main components of a Substrate node (the core client and the runtime) have a clear separation of concerns. Beyond the functional responsibilities, at a lower level, their binary representation and execution environments are different. While the node is compiled to be installed and run on a specific platform (be it Linux x64 or any other), the Tanssi network runtime is compiled to a Wasm format that is platform-agnostic and runs in an isolated execution environment.

Bearing in mind the separated execution environments, all the communication between the node client and the runtime occurs through a limited and well-defined interface, allowing the necessary operations such as:

- **Executing Transactions** - when a user submits a transaction to the client node, the node passes this transaction to the runtime through the defined API for its execution
- **State Queries** - the client node can query the current state of the blockchain to retrieve information such as account balances and any other domain-specific data
- **Consensus and Finality** - the client node coordinates consensus and finalization of the blocks, but it is the runtime's responsibility to determine the validity of new blocks, validate transactions, and ensure that the consensus rules are followed
- **Event Notifications** - the runtime emits events while executing transactions that the client node can use to keep external users updated about specific actions or changes in the state
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/framework/
--- BEGIN CONTENT ---
---
title: Appchain Development Framework
description: Learn about the network development framework, Rust programming language, Substrate and its features, including XCM and ready-to-use pallets for your runtime.
icon: octicons-code-24
template: index-page.html
---

# Network Development Framework

Building a blockchain from scratch is an intricate process that demands deep knowledge of consensus algorithms, cryptography, data structures, governance, and more. Tanssi simplifies this process by leveraging Substrate, a powerful blockchain development framework that provides all the essential components for creating customized blockchains.

With Substrateâ€™s modular architecture, you can modify runtime characteristics, integrate pre-built modules, or develop new ones based on your networkâ€™s specific needs. Tanssi provides the foundation you need to bring your blockchain vision to life.

Key features of the framework:

- **Substrate core architecture** - divided into the _core client_, which manages external communications and internal responsibilities like storage, and the _runtime_, which executes transactions and manages state transitions with customizable logic
- **End-user simplicity** - the internal workings of the framework are abstracted for end-users, ensuring seamless interaction through dApps or via RPC endpoints, such as those used by wallets
- **Modular system design** - incorporate pre-built modules or create custom ones to meet specific needs
- **Developer-centric flexibility** - focus on runtime characteristics and use case specifics, allowing you to create a blockchain tailored to your vision without unnecessary complexity

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/framework/modules/
--- BEGIN CONTENT ---
---
title: Network Modules for your Runtime
description: Substrate is a modular blockchain development framework with an extensive set of ready-to-use components to bundle with custom logic into the network Runtime.
icon: material-puzzle-outline
categories: Custom-Runtime, Basics
---

# Network Framework Modules {: #network-framework-modules }

## Introduction {: #introduction }

The Substrate framework provides complete and ready-to-use implementations of the main functions a Tanssi network needs to work properly, including cryptography, consensus, governance, and so on. These implementations are fully customizable and could be replaced with custom logic if needed.

When building the Runtime, which defines the state transition rules between two blocks applied to a set of transactions, the intended behavior and features of the blockchain need to be set by determining the rules of the state transition.

To build the Runtime, Substrate provides many built-in modules (also known as pallets) that can be freely used as building blocks to compose and interact with any other custom-made modules, allowing teams to create unique behaviors according to the specific requirements of their Tanssi network.

![Built-in modules](/images/learn/framework/modules/modules-1.webp)

## Built-in Modules {: #built-in-modules }

When designing and writing the rules of a Tanssi network, the available set of functional modules brings a solution to many of the coding requirements that would otherwise need to be built from scratch.

Here is a list of some of the most popular modules:

- **[Balances](https://paritytech.github.io/substrate/master/pallet_balances/index.html){target=\_blank}** - it provides functions for handling accounts and balances for the Tanssi network native currency
- **[Assets](https://paritytech.github.io/substrate/master/pallet_assets/index.html){target=\_blank}** - it provides functions for handling any type of fungible tokens
- **[NFTs](https://paritytech.github.io/substrate/master/pallet_nfts/index.html){target=\_blank}** - it provides functions for dealing with non-fungible tokens
- **[Democracy](https://paritytech.github.io/substrate/master/pallet_democracy/index.html){target=\_blank}** - it provides functions to manage and administer general stakeholder voting
- **[Multisig](https://paritytech.github.io/substrate/master/pallet_multisig/index.html){target=\_blank}** - it provides functions for multi-signature dispatch
- **[Recovery](https://paritytech.github.io/substrate/master/pallet_recovery/index.html){target=\_blank}** - it provides functions to allow users to regain access to their accounts when the private key is lost. This works by granting other accounts the right to sign transactions on behalf of the lost account (note that it is necessary to have previously chosen the authorized accounts)
- **[Staking](https://paritytech.github.io/substrate/master/pallet_staking/index.html){target=\_blank}** - it provides functions to administer staked tokens, support rewarding, slashing, depositing, withdrawing, and so on

In addition to those previously listed, other modules like [identity](https://paritytech.github.io/substrate/master/pallet_identity/index.html){target=\_blank}, [smart contracts](https://paritytech.github.io/substrate/master/pallet_contracts/index.html){target=\_blank}, [vesting](https://paritytech.github.io/substrate/master/pallet_vesting/index.html){target=\_blank}, and many others that are freely available can speed up the development of the Tanssi network and, consequently, the time to market.

!!! note
    The framework also includes other modules that provide core protocol functionality, such as consensus and low-level data encoding.

## Custom-Made Modules {: #custom-modules }

Developers creating new modules enjoy complete freedom to express any desired behavior in the core logic of the blockchain, like exposing new transactions, storing sensible information, and validating and enforcing business logic.

As explained in the [Architecture](/learn/framework/architecture/#client-runtime-communication){target=\_blank} article, a module needs to be able to communicate with the core client by exposing and integrating with a very specific API that allows the runtime to expose transactions, access storage, and code and decode information stored on-chain. It also needs to include many other required wiring codes that make the module work in the node.

To improve developer experience when writing modules, Substrate relies heavily on [Rust macros](https://doc.rust-lang.org/book/ch19-06-macros.html){target=\_blank}. Macros are special instructions that automatically expand to Rust code just before compile-time, allowing modules to keep up to seven times the amount of code out of sight of the developers. This allows developers to focus on the specific functional requirements when writing modules instead of dealing with technicalities and the necessary scaffolding code.

All modules in Substrate, including custom-made ones, implement these attribute macros, of which the first three are mandatory:

- **`#[frame_support::pallet]`** - this attribute is the entry point that marks the module as usable in the runtime
- **`#[pallet::pallet]`** - applied to a structure that is used to retrieve module information easily
- **`#[pallet::config]`** - is a required attribute to define the configuration for the data types of the module
- **`#[pallet::call]`** -  this macro is used to define functions that will be exposed as transactions, allowing them to be dispatched to the runtime. It is here that the developers add their custom transactions and logic
- **`#[pallet::error]`** - as transactions may not be successful (insufficient funds, as an error example), and for security reasons, a custom module can never end up throwing an exception, all the possible errors are to be identified and listed in an enum to be returned upon an unsuccessful execution
- **`#[pallet::event]`** - events can be defined and used as a means to provide more information to the user
- **`#[pallet::storage]`** - this macro is used to define elements that will be persisted in storage. As resources are scarce in a blockchain, it should be used wisely to store only sensible information

All these macros act as attributes that must be applied to the code just above Rust modules, functions, structures, enums, types, etc., allowing the module to be built and added to the runtime, which, in time, will expose the custom logic to the outer world, as exposed in the following section.

### Custom Module Example { #custom-module-example }

As an example of a custom module, the following code (not intended for production use) showcases the use of the previously mentioned macros by presenting a simple lottery with minimal functionality, exposing two transactions:

- **buy_ticket** - this transaction verifies that the user signing the request has not already bought a ticket and has enough funds to pay for it. If everything is fine, the module transfers the ticket price to a special account and registers the user as a participant for the prize

- **award_prize** - this transaction generates a random number to pick the winner from the list of participants. The winner gets the total amount of the funds transferred to the module's special account

```rust
#![cfg_attr(not(feature = "std"), no_std)]

/// Learn more about FRAME and the core library of Substrate FRAME pallets:
/// <https://docs.substrate.io/reference/frame-pallets/>
pub use pallet::*;

#[frame_support::pallet(dev_mode)]
pub mod pallet {

	use super::*;
	use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};
	use frame_system::pallet_prelude::*;
	use scale_info::prelude::vec::Vec;

	use frame_support::
	{
		sp_runtime::traits::AccountIdConversion,
		traits:: {
			Currency, ExistenceRequirement, Randomness
		},
		PalletId,
	};

	type BalanceOf<T> = 
		<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

	#[pallet::pallet]
	pub struct Pallet<T>(_);

	/// Configure the module by specifying the parameters and types on which it depends.
	#[pallet::config]
	pub trait Config: frame_system::Config {

		// Event definition
		type RuntimeEvent: From<Event<Self>> 
			+ IsType<<Self as frame_system::Config>::RuntimeEvent>;

		// Currency 
		type Currency: Currency<Self::AccountId>;

		// Randomness
		type MyRandomness: Randomness<Self::Hash, BlockNumberFor<Self>>;

		// Ticket cost
		#[pallet::constant]
		type TicketCost: Get<BalanceOf<Self>>;

		// Maximum number of participants
		#[pallet::constant]
		type MaxParticipants: Get<u32>;

		// Module Id
		#[pallet::constant]
		type PalletId: Get<PalletId>;
	}

	// The pallet's runtime storage items.
	#[pallet::storage]
	#[pallet::getter(fn get_participants)]
	pub(super) type Participants<T: Config> = StorageValue<
		_,
		BoundedVec<T::AccountId, T::MaxParticipants>,
		OptionQuery
	>;

	#[pallet::storage]
	#[pallet::getter(fn get_nonce)]
	pub(super) type Nonce<T: Config> = StorageValue<
		_,
		u64,
		ValueQuery
	>;

	// Pallets use events to inform users when important changes are made.
	// https://docs.substrate.io/main-docs/build/events-errors/
	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		/// Event emitted when a ticket is bought
		TicketBought { who: T::AccountId },
		/// Event emitted when the prize is awarded
		PrizeAwarded { winner: T::AccountId },
		/// Event emitted when the prize is to be awarded, but there are no participants
		ThereAreNoParticipants,
	}

	// Errors inform users that something went wrong
	#[pallet::error]
	pub enum Error<T> {
		NotEnoughCurrency,
		AccountAlreadyParticipating,
		CanNotAddParticipant,
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {

		#[pallet::call_index(0)]
		#[pallet::weight(0)]
		pub fn buy_ticket(origin: OriginFor<T>) -> DispatchResult {

			// 1. Validates the origin signature
			let buyer = ensure_signed(origin)?;

			// 2. Checks that the user has enough balance to afford the ticket price
			ensure!(
				T::Currency::free_balance(&buyer) >= T::TicketCost::get(),
				Error::<T>::NotEnoughCurrency
			);

			// 3. Checks that the user is not already participating
			if let Some(participants) = Self::get_participants() {
				ensure!(
					!participants.contains(&buyer),
					Error::<T>::AccountAlreadyParticipating
				);
			}

			// 4. Adds the user as a new participant for the prize
			match Self::get_participants() {
				Some(mut participants) => { 
					ensure!(
						participants.try_push(buyer.clone()).is_ok(), 
						Error::<T>::CanNotAddParticipant
					);
					Participants::<T>::set(Some(participants));
				}, 
				None => {
					let mut participants = BoundedVec::new();
					ensure!(
						participants.try_push(buyer.clone()).is_ok(), 
						Error::<T>::CanNotAddParticipant
					);
					Participants::<T>::set(Some(participants));
				}
			};

			// 5. Transfers the ticket cost to the module's account
			// to be hold until transferred to the winner
			T::Currency::transfer(
				&buyer, 
				&Self::get_pallet_account(), 
				T::TicketCost::get(), 
				ExistenceRequirement::KeepAlive)?;
			
			// 6. Notify the event
			Self::deposit_event(Event::TicketBought { who: buyer });
			Ok(())
		}

		#[pallet::call_index(1)]
		#[pallet::weight(0)]
		pub fn award_prize(origin: OriginFor<T>) -> DispatchResult {

			// 1. Validates the origin signature
			let _who = ensure_root(origin)?;

			match Self::get_participants() {
				Some(participants) => { 
					
					// 2. Gets a random number from the randomness module
					let nonce = Self::get_and_increment_nonce();
					let (random_seed, _) = T::MyRandomness::random(&nonce);
					let random_number = <u32>::decode(&mut random_seed.as_ref())
						.expect("secure hashes should always be bigger than u32; qed");
					
					// 3. Selects the winner from the participants lit
					let winner_index = random_number as usize % participants.len();
					let winner = participants.as_slice().get(winner_index).unwrap();

					// 4. Transfers the total prize to the winner's account
					let prize = T::Currency::free_balance(&Self::get_pallet_account());
					T::Currency::transfer(
						&Self::get_pallet_account(), 
						&winner, 
						prize, 
						ExistenceRequirement::AllowDeath)?;

					// 5. Resets the participants list, and gets ready for another lottery round
					Participants::<T>::kill();

					// 6. Notify the event
					Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );
				}, 
				None => {
					// Notify the event (No participants)
					Self::deposit_event(Event::ThereAreNoParticipants);
				}
			};

			Ok(())
		}
	}

	impl<T: Config> Pallet<T> {

		fn get_pallet_account() -> T::AccountId {
			T::PalletId::get().into_account_truncating()
		}

		fn get_and_increment_nonce() -> Vec<u8> {
			let nonce = Nonce::<T>::get();
			Nonce::<T>::put(nonce.wrapping_add(1));
			nonce.encode()
		}
	}
}
```

For more information about the step-by-step process of creating a custom-made module to the runtime, please refer to the [Adding a Custom-Made Module](/builders/build/customize/adding-custom-made-module/){target=\_blank} in the Builder's section.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/framework/overview/
--- BEGIN CONTENT ---
---
title: Network Development Framework Overview
description: Substrate is a blockchain development framework built in Rust Programming Language that streamlines and speeds up the process of developing new networks.
icon: octicons-home-24
categories: Basics
---

# Network Development Framework Overview {: #network-dev-framework-overview }

## Introduction {: #introduction }

Building a network from scratch is a very complex task that requires deep knowledge in a wide range of areas, including (but not limited to):

- **Consensus Algorithms** - consensus ensures that all participants in the blockchain network agree on the validity of transactions. Some popular consensus mechanisms include Proof of Work (PoW) and Proof of Stake (PoS)

- **Cryptography** - cryptography plays a crucial role in securing the blockchain. You'll need cryptographic algorithms for tasks like creating digital signatures, verifying transactions, and encrypting data

- **Distributed Network** - a network architecture to enable nodes to communicate, validate transactions, and synchronize the blockchain data is key to maintaining a shared ledger in a decentralized network

- **Data Structures** - besides the list of blocks, where each block contains a set of transactions along with a reference to the previous block, an optimized and performant strategy to store the state of the network is needed

- **Governance** - if the network is designed to be permissionless, a voting mechanism is important in order to keep it evolving and reflecting the community will

- **Upgradeability** - it is necessary to clearly define how to upgrade, how modifications are implemented, and how conflicts are resolved within the network

Fortunately, thereâ€™s no need to build these blockchain components from scratch, thanks to an excellent open-source framework called [Substrate](https://docs.polkadot.com/develop/parachains/intro-polkadot-sdk/){target=\_blank}. Tanssi itself is built with this framework, leveraging its comprehensive base implementations, modularity, and flexibility to achieve a high level of customization.

## Substrate Framework {: #substrate-framework}

Substrate is an extremely performant, flexible, modular, and highly customizable framework for building blockchains. This framework is the foundation and engine powering many projects across the Web3 ecosystem, including the Tanssi network itself and the networks deployed through Tanssi.

Many of its great features, such as performance, ease of use, and modularity, result from the programming language chosen for its development. This is where the [Rust Programming Language](#rust-programming-language) shines: It is fast, portable, and provides a wonderful model to handle memory, among other reasons detailed in the [next section](#rust-programming-language).

When developing a network, Substrate represents a great head start by providing a ready-to-use set of implementations of the main building blocks a project needs:

- **Consensus Algorithms** - there are multiple built-in consensus engines, such as Aura (Proof of Authority), Babe (Proof of Stake), and Grandpa (block finality), but due to the high degree of customization Substrate offers, teams can always choose to develop their specific consensus to adapt to the use case needs, as the Moonbeam team did with the [Nimbus Parachain Consensus Framework](https://docs.moonbeam.network/learn/features/consensus){target=\_blank}

- **Runtime Modules** - many built-in modules (explained in detail in the [modules](/learn/framework/modules/){target=\_blank} section) can be selected and configured into your network, such as accounts, balances, staking, governance, identity, and more

- **Networking** - built-in protocols and libraries for establishing connections, propagating transactions and blocks, synchronizing the blockchain state, and managing network interactions

- **Storage** - built-in storage mechanisms for efficient data storage and retrieval

- **Transaction Queue** - built-in transaction queue system that manages transaction validation, prioritization, and inclusion in blocks, ensuring the consistency and integrity of the network's state

- **RPC APIs** - Substrate provides Remote Procedure Call (RPC) APIs that enable external applications to interact with the network by querying blockchain data, submitting transactions, and accessing various functionalities exposed by the runtime

Every feature Substrate offers can be used as-is, extended, customized, or replaced to meet the specific requirements of the use case of the network.

Substrate streamlines and speeds up the process of developing new networks. When used in conjunction with Tanssi, which helps in handling the infrastructure and overseeing the deployment, the task of launching a new network becomes significantly simpler!

## Rust Programming Language {: #rust-programming-language}

[Rust](https://rust-lang.org/){target=\_blank} is a programming language with features developers consistently rank highly in surveys like [Stack Overflow's annual developer survey](https://survey.stackoverflow.co/){target=\_blank}.

In addition to providing a great experience for developers, Rust excels in many areas:

- **Memory safety** - Rust compiler enforces strict compile-time checks to prevent common programming errors such as null pointer dereferences, buffer overflows, and data races. Additionally, memory is managed through a novel system of ownership (checked by the compiler), which eliminates the necessity for a garbage collector

- **Performance** - Rust achieves performance comparable to that of C and C++ by providing low-level control over system resources and minimizing runtime overhead. It has a zero-cost abstraction principle, similar to "what you don't use, you don't pay for" from C++, meaning that abstractions have no extra overhead

- **Concurrency** - Rust has built-in features that make it easy to write concurrent and parallel code without introducing data races. It provides lightweight threads (tasks) and a powerful ownership model that ensures the safe sharing of data between threads

- **Expressive and safe abstractions** - Rust offers a rich set of modern language features, such as pattern matching, algebraic data types, closures, and type inference, allowing developers to write and read expressive and concise code. The Rust compiler enforces the strong type system, preventing many runtime errors at compile-time

- **Cross-platform compatibility** - Rust is designed to work well on a variety of platforms and architectures. It supports major operating systems like Windows, macOS, and Linux, as well as embedded systems and WebAssembly. This versatility allows developers to write code that can be deployed across different environments

- **Growing ecosystem** - Rust has a rapidly growing ecosystem with a vibrant community and a rich collection of libraries and tools. The official package manager, Cargo, simplifies dependency management, building, and testing

- **Interoperability** - Rust provides seamless interoperability with existing codebases written in C and C++. It has a Foreign Function Interface (FFI) that allows Rust code to interface with code written in other languages, enabling developers to gradually introduce Rust into existing projects, like the Linux kernel
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/framework/xcm/
--- BEGIN CONTENT ---
---
title: Native Cross-Chain Communication
description: Tanssi networks benefit from XCM, a native cross-chain communication language, which allows fast and secure bridging guaranteed by Polkadot's relay chain.
categories: Basics
---

# Native Cross-Chain Communication

## Introduction {: #introduction }

All Tanssi-powered networks have an inherent capability to communicate and interoperate with any other network in the ecosystem. This native cross-chain communication feature is possible thanks to the unique infrastructure the networks are built on top of, leveraging the Cross-Consensus Message format (XCM for short), which facilitates communication between different consensus systems.

XCM is a messaging language designed to be generic. It doesn't make any assumptions about the destination chain and can communicate different intentions between sovereign consensus systems.

An XCM message is a program holding one or more instructions that will be relayed for execution to the destination chain. By itself, each XCM instruction is meaningless, but the combination of a specific set of instructions can result in a desired action when the XCM message is executed in the destination chain.

In this article, we cover the basic concepts of the native cross-chain communication mechanism that allows fast and secure bridging within the ecosystem.

## Design Principles {: #design-principles }

Conceived with an abstract mindset, XCM is not designed to comply with a specific use case or specific destination network setup, thus minimizing the coupling effect. Its core design principles are:

- **Asynchronous** - similar to sending a postcard -but way faster- the sender will keep performing its duties as usual, without blocking itself or awaiting a response from the destination
- **Absolute** -  messages are guaranteed to be delivered to the intended destination, in order and in a timely fashion
- **Asymmetric** -  messages sent have no response counterpart. Any return values, if required, must be sent back from the destination to the sender with another message
- **Agnostic** -  there are no assumptions whatsoever about the configuration or properties of two communicating networks. Networks might differ in every aspect, except the ability to understand XCM. E.g., one chain could be EVM-compatible and not the other, one chain could be a DeFi network and the other a gaming network, and so on

## Fees {: #fees }

A user executing a transaction on a network must pay the fees derived from computational effort associated with the task, and cross-chain execution is no exception to this rule. In cross-chain communication, a message requires execution on at least two different chains, and the user needs to pay for the fees associated with the computational effort made by every chain involved. Besides the execution-related costs, Tanssi networks include a default [delivery fee](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_common/xcm_sender/struct.ExponentialPrice.html){target=\_blank} to prevent XCM spamming.

For example, if a user on network A wants to call a smart contract on network B, the user must have enough funds to pay for the message delivery and include instructions in the XCM message to provide an asset that network B accepts as payment for its services to cover the associated fees. Once such an asset is provided, the execution can now be bought on the destination chain.

!!! note
    Since networks are sovereign, they get to decide which tokens are valid for paying their XCM execution fees.
    E.g., if network B accepts network A tokens for fee payments, any user on network A can pay for an XCM message destined for network B using only network A tokens.

## Common Use Cases {: #common-use-cases }

Many use cases can be addressed by benefiting from the common ground and versatility XCM provides. Two of the most recurrent ones are asset transfers and remote execution.

### Asset Transfers {: #asset-transfer }

Moving digital assets from one network to another is essential for creating a more dynamic, efficient, and interconnected blockchain ecosystem. The native cross-chain capability allows two main strategies to transfer assets from one chain to another:

- **Teleport** - teleporting an asset is a simple and efficient mechanism, but it has a major caveat: it requires trust between the parties. In essence, when network A wants to send X amount of assets to network B, it burns X amount of assets and sends a message to network B instructing them to mint exactly X amount of assets, preserving the overall asset balance and concluding the teleport action. In this process, network A trusts network B not to mint more tokens than what was transferred, and network B trusts network A to burn the tokens that were transferred
- **Reserve transfer** - A reserve transfer involves the **reserve chain** of an asset, which is the chain where the asset is native (e.g., [Moonbeam](https://moonbeam.network/){target=\_blank} is the reserve chain for the GLMR token). Also, non-reserve networks hold a *sovereign account* on the reserve chain, a keyless account managed by the respective network governor. Thus, when reserve network A wants to send X amount of an asset to non-reserve network B, it locally transfers the assets to network's B sovereign account and, in the same atomic action, it sends an XCM message to network B with instructions to mint X amount of a derivative form of the transferred asset. On the other way around, if non-reserve network B wants to send X amount of an asset to reserve network A, then the steps are: network B burns the derived form of the asset locally and sends an XCM message to network A, with instructions to transfer the assets from network B's sovereign account to network's A destination account. Even if the non-reserve network mints derived tokens in excess (or doesn't burn tokens when transferring), these tokens will have no real value because they are not backed one-to-one in the reserve chain

The associated fees for executing transfers are typically deducted from the transferred amount, so the recipient receives the intended amount minus the fees.

### Remote Execution {: #remote-execution }

The native interoperability XCM provides allows a network to send a message to another triggering some action. For example, If the destination chain is EVM-compatible, network A can call a smart contract deployed on network B.

As mentioned in the [fees section](#fees), to get any on-chain request executed it is necessary to cover its associated fees. On XCM, remote execution can be bought with two steps:

1. Reserve some assets using the `WithdrawAsset` XCM instruction, which takes funds from the call origin and puts them in a holding register
2. Pay for the on-chain execution, using the `BuyExecution` XCM instruction, which uses the previously withdrawn assets

!!! note
    When a network sends an XCM message, its default source on the receiving end is the origin network's Sovereign account. The sender network can add an XCM instruction called `DescendOrigin` to the message, changing the origin account to match the signing user's account, ensuring execution occurs on behalf of the same entity initiating the XCM message on the source chain, and avoiding a potentially unsafe scenario.

Finally, the execution takes place on the destination chain, calling a smart contract or any other transaction using the XCM instruction called `Transact`.

The general flow for remote execution is represented in the following diagram:

![Remote Execution Flow](/images/learn/framework/xcm/xcm-1.webp)

## Establishing Cross-Chain Communication {: #channel-registration }

Before two chains can communicate, a messaging channel must be established. Channels are unidirectional, which means that separate channels are needed to send messages from chain A to chain B and B to A.

For chain A to communicate with chain B, chain A must send an open channel transaction to the relay chain requesting a channel be opened with chain B. Chain B must then accept the request by sending a corresponding XCM message to the relay chain. Only when both chains agree is the channel opened in the next epoch. The same process is required to establish a channel from chain B to chain A.

It is important to note that a channel between a network and the relay chain is automatically opened upon network registration and onboarding.

![XCM Channel Registration Overview](/images/learn/framework/xcm/xcm-2.webp)

Once the channel is established, cross-chain messages can be sent between networks. For asset transfers, assets will also need to be registered before being transferred.

!!! note
    XCM is a versioned, ever-evolving language. When two communicating networks use different XCM versions, they must use the latest version supported by the less upgraded side. To find out the latest XCM version a network can work with, other networks can query it and subscribe for updates whenever this changes.

## Message Destinations {: #message-destinations }

To compose meaningful messages in a multichain environment it is necessary to have a precise yet abstract way of referencing resources located in different consensus systems. A concept called *multilocation* is used to serve this purpose and target a specific chain or any of its inner elements, such as an account, an asset, or a smart contract.

XCM's destination elements are organized in a hierarchical architecture, where elements are contained within other components. For example, a smart contract is an element contained within a network, and the same can be said for an account or an ERC20 asset. Networks are contained by the relay chain, which plays a crucial role in the cross-chain messaging process, relaying messages from one network to another.

Multilocations are not a universal resource locator. They refer to elements from the sender's perspective and are composed of two components: `parents` and `interior`. Parents is a property that indicates if the route must "move up" in the hierarchy, i.e., from a network to the relay chain. Interior is a list of junctions that define how to locate the destination. Here are some examples of multilocations:

- **Network A references a smart contract in network B** - from the point of view of network A, to reach a smart contract in network B it is necessary to move up in the hierarchy (to the relay chain) and then descend to network B to, once there, reference the smart contract's address. The multilocation is therefore defined with a `parents` value set to `1`, which moves up, and two junctions, one defining which network should receive the message, and the other defining the H160 address of the smart contract that will be called

![Smart Contract Multilocation Example](/images/learn/framework/xcm/xcm-3.webp)

- **Network A references an account in the relay chain** - from the point of view of network A, to reference an account in the relay chain, it is necessary to move up and then reference the account. The multilocation is defined with a `parents` value set to `1`, which moves up to the relay chain, and one junction that references the substrate type destination address

![Account Multilocation Example](/images/learn/framework/xcm/xcm-4.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/
--- BEGIN CONTENT ---
---
title: Learn About Tanssi Infrastructure Protocol
description: Learn about Tanssi protocol and how it helps developers to build and deploy networks by handling infrastructure complexities and providing key integrations.
template: root-index-page.html
---

# Learn

Launching a decentralized network has traditionally been a challenging and time-consuming process, requiring expertise in infrastructure, security, and operational setup. Tanssi simplifies this journey by removing the complexities and making network deployment fast and accessible.

This section explores the core elements that define Tanssi as a leading solution for network development. Whether youâ€™re starting your journey into decentralized networks or deepening your understanding of Tanssiâ€™s unique capabilities, these documents provide everything you need to understand how Tanssi sets a new standard for network infrastructure.

## Explore This Section

:::INSERT_GENERATED_CARDS:::

## Jump Right into Building

Start your Tanssi journey here if you prefer to learn by doing.

<div class="subsection-wrapper">
  <div class="card">
    <a href="/builders/build/">
      <div class="card-header">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z"></path></svg>
        <h2 class="title">Build Your Network</h2>
      </div>
      <p class="description">Learn how to design and customize your network with ready-to-use templates and tools tailored to your technical needs.</p>
    </a>
  </div>
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/account-types/
--- BEGIN CONTENT ---
---
title: Accounts in the Tanssi Protocol
description: Overview of the cryptographic keys essential for the Tanssi protocol, detailing the account types used and their general functions.
icon: octicons-key-24
categories: Basics
---

# Accounts in the Tanssi Protocol

## Introduction {: #introduction }

Blockchain technology relies on [public-private](https://en.wikipedia.org/wiki/Public-key_cryptography){target=\_blank} key cryptography for secure asset ownership and transaction verification. Private keys authorize transactions, while public keys serve as addresses for verification. Due to the Tanssi protocol's hybrid [Substrate](/learn/framework/overview/#substrate-framework){target=\_blank} and Ethereum nature, understanding the different account types is crucial for users and operators.

## Account Types in the Tanssi Protocol {: #key-types-in-tanssi-protocol }

| **Account Type** | **Underlying Algorithm** | **Primary Use in Tanssi** |
| --- | --- | --- |
| [Sr25519](https://wiki.polkadot.com/learn/learn-cryptography/){target=_blank} | Schnorr signatures on the Ristretto group | Default signature scheme for Substrate-based transactions and operator identity. |
| [Ed25519](https://wiki.polkadot.com/learn/learn-cryptography/){target=_blank} | EdDSA using Curve25519 | Used for specific consensus roles (e.g., block production, finality) within the Substrate framework. |
| [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm){target=_blank} | Elliptic Curve Digital Signature Algorithm | Receiving rewards through the Ethereum-based Symbiotic protocol for operators. |

## Identity and Operations { : #identity-and-operations }

Tanssi, built with the Substrate framework, utilizes distinct cryptographic schemes for different functions, primarily _Sr25519_ and _Ed25519_. These account types are crucial for interacting with the protocol's Substrate components by signing transactions.

**Sr25519 (Schnorrkel/Ristretto x25519)** - is the primary account type used for most user-facing operations within Tanssi. Its strengths lie in security and efficiency. **Sr25519 accounts serve as your on-chain identity, used for holding tokens, participating in governance, paying transaction fees, and other general interactions with the network.** When you create a wallet to interact with Tanssi as a regular user, you will create and use an Sr25519 account.

**Ed25519 (Edwards-curve Digital Signature Algorithm)** - while Sr25519 handles general identity and transactions, Ed25519 is specifically leveraged for its high performance in cryptographic signing, making it ideal for consensus-related operations. **Within Tanssi, Ed25519 accounts are used by node operators for critical consensus mechanisms, such as block production and finality.** Regular users will typically not create or directly use an Ed25519 account. However, these accounts are fundamental for the security and operation of the network, managed by those running nodes.

Node operators on Tanssi require a Substrate account to record their activities, including operators who secure the network and sequencers who produce blocks. This account also tracks rewards, with session keys mapped to it for enhanced security.

## Security and Rewards on Ethereum { : #security-and-rewards-on-ethereum }

The Elliptic Curve Digital Signature Algorithm (ECDSA) is fundamental to Ethereum and is used by Tanssi to integrate with the Ethereum network via Symbiotic. This partnership leverages Ethereum's security for Tanssi-powered networks.

Tanssi operators need an ECDSA account to receive rewards distributed on Ethereum, likely through the Symbiotic protocol. The necessity of both Substrate and ECDSA accounts highlights Tanssi's hybrid design, where operations are Substrate-based, and security and rewards are linked to Ethereum.

## Account Mappings in Tanssi { : #account-mappings-in-tanssi}

### Internal Key Binding (_Sr25519_ and _Ed25519_)

Within Tanssi's Substrate-based protocol, an operatorâ€™s primary _Sr25519_ identity links to specific _Ed25519_ keys used for consensus tasks (like block production). Operators create this binding with an on-chain transaction. This transaction maps their internal public keys ("session keys") with the stash account. This on-chain registration ensures the network correctly attributes all actions from the session keys to the operator's primary identity.

### Cross-Ecosystem Reward Mapping (_Sr25519_ and _ECDSA_)

For rewards on Ethereum (e.g., via [Symbiotic](/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}), an operator's Tanssi _Sr25519_ identity maps to an Ethereum _ECDSA_ address. Operators inform both accounts, which are then linked through the Tanssi middleware. This trusted link ensures that rewards from the operator's node work on the Tanssi network are routed to the operator's designated Ethereum account.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/external-security-providers/
--- BEGIN CONTENT ---
---
title: External Security Providers
description: Learn about Tanssi's design, which allows developers to connect to external security providers and benefit from Ethereum-level security right from the start.
icon: octicons-shield-check-24
template: index-page.html
---

# External Security Providers

Tanssi integrates external security providers to strengthen the flexibility and resilience of its ecosystem. By adopting decentralized security models, these providers deliver customized solutions that address diverse operational needs, ensuring greater levels of security and trust across networks.

This approach addresses common challenges developers face, such as securing significant economic resources or negotiating with operators to maintain nodes. Through Tanssi's collaborative security framework, developers can bypass these obstacles and focus on innovation, leveraging a secure and scalable infrastructure to streamline the deployment of networks.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/external-security-providers/symbiotic/
--- BEGIN CONTENT ---
---
title: Ethereum with Symbiotic
description: Tanssi's design allows developers to choose and connect to the Symbiotic restaking protocol, benefiting from Ethereum-grade security right from the start.
icon: octicons-shield-check-24
categories: Basics
---

# Ethereum with Symbiotic {: #ethereum-symbiotic }

## Introduction {: #introduction }

The Tanssi protocol takes care of critical infrastructural components, making it easy for developers to launch their networks in a few minutes. In addition to block production, data retrievability, and integrations with essential tools such as wallets, RPC endpoints, block explorers, and others, another major task to tackle is providing security to the network.

Tanssi is designed to offer developers a shared security model, alleviating them from having to source enough economic security or negotiating with operators to run nodes opting-in for their networks. By deploying networks through Tanssi, and by choosing [Symbiotic](https://symbiotic.fi/){target=\_blank} as a security provider, developers benefit from Ethereum-grade security, tapping into billions of dollars in shared security from staked ETH.

The following sections describe how the Symbiotic protocol works and how Tanssi networks can leverage it as their consensus mechanism.

## Ethereum-Grade Security with Symbiotic {: #symbiotic }

[Symbiotic](https://symbiotic.fi/){target=\_blank} is a shared security protocol designed to be permissionless, multi-asset, and network-agnostic. It fosters capital efficiency by allowing users to extend the functionality of their staked assets to secure other networks while providing additional utility.

The protocol provides a coordination layer for its main components and participants, aligning incentives among parties while minimizing execution layer risks by deploying non-upgradeable core contracts on Ethereum. The following diagram resumes all the components and actors participating in the protocol:

```mermaid
flowchart TD
    %% Vaults subgraph
    subgraph Ethereum["Ethereum/Symbiotic"]
        slash[/Slashing Events/]
        Restakers -- Deposit Assets --> Vaults
        manager["Vault managers"] -- Manage --> Vaults
        Resolvers -- Decide On --> slash
        slash -- Executes On --> Vaults
    end

    %% Operators subgraph
    subgraph Operators
        direction BT
        operators["Operators (Validators)"]
        node_operators["Node Operators"]
        node_operators -- Run --> operators
    end

    %% Networks subgraph
    subgraph Networks
        direction BT
        developers["Developers"]
        networks["Decentralized Networks"]
        developers -- Launch --> networks
    end

    Vaults <--> Tanssi
    Tanssi <--> Operators
    Tanssi <--> Networks
```

Symbiotic's flexible design allows every party to decide on setups that best fit their use cases. For example, vaults can choose what forms of collateral they accept, operators can determine which networks they want to provide services to, and decentralized networks can customize their use case and define the level of security (which collaterals are accepted, for example) they need.

The following sections describe the protocol's main components.

### Vaults {: #vaults }

[Vaults](https://docs.symbiotic.fi/modules/vault/introduction){target=\_blank} are the Symbiotic protocol's economic backbone. They manage liquidity and deposits from restakers, connect operators and networks, and set up delegation strategies.

Each vault is bound to a specific token that satisfies the [ERC20](https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md){target=\_blank} interface and is accepted as collateral. Internally, the funds within the vault are represented as shares, which provide a mechanism for tracking ownership and distributing rewards. However, the reward token may differ from the collateral token.

A vault comprises three key modules, each serving a distinct function: the slasher, the delegator, and the accounting module. The implementation of these modules can vary depending on the vault manager's decisions.

- **Slasher module** - implements the [slashing](#slashing-process) logic, which penalizes bad actors
- **Delegator module** - defines how funds are delegated across operators and networks. Several [strategies](https://docs.symbiotic.fi/modules/vault/delegator){target=\_blank} are available, allowing the vault manager to select which operators and networks they want to work with
- **Accounting module** - handles the vault's financial operations, including processing user deposits, managing withdrawal requests, tracking active balances and total supply, and implementing epoch-based accounting for withdrawals and slashing events. The accounting module's standard implementation is [ERC-4626](https://ethereum.org/developers/docs/standards/tokens/erc-4626/){target=\_blank}, which provides a vault with a shares system included

Since the operators get delegated stake from the vault and could potentially get slashed, they must be approved by the vault managers beforehand. On a similar note, vault managers analyze and authorize each network the vault will secure, considering, for example, the rewards the network offers.

Vault managers also designate [resolvers](https://docs.symbiotic.fi/modules/counterparties/resolvers){target=\_blank}, responsible for approving or vetoing [slashing events](https://docs.symbiotic.fi/modules/vault/slasher){target=\_blank} caused by operators on networks with [veto-slashing](https://docs.symbiotic.fi/modules/vault/slasher#veto-slashing){target=\_blank} support, like the Tanssi Network.

### Operators {: #operators }

[Node operators](/node-operators/){target=\_blank} are entities or individuals responsible for running the [nodes (also known as operators or validators)](https://docs.symbiotic.fi/modules/counterparties/operators){target=\_blank}, which are the computational components validating the networks' transactions. They are responsible for the nodes' configuration, hardware setup, uptime, and performance.

Node operators opt-in to provide services to networks, which must accept their request. Also, they opt-in to provide services in vaults, which must accept their request.

Once an operator has been accepted by a vault and a network connected to that vault, the node can start providing validation services to that network, receiving rewards in exchange.

### Networks {: #networks }

[Networks](https://docs.symbiotic.fi/modules/counterparties/networks){target=\_blank} are the actively validated services or networks. These application-specific blockchains can be a use case from a wide range of industries, such as Gaming, Defi, RWAs, and others, and are the platforms that, through dApps, the end users interact with.

Since operators opt-in to provide services to networks and the vault managers must accept the networks, the developers are responsible for defining, controlling, and adapting their methodology for onboarding, rewarding, and slashing operators.

!!! note
    Networks deployed through Tanssi don't need to work on the relation with vaults and operators since the Tanssi protocol deals with those complexities.

## Tanssi with Symbiotic {: #tanssi-symbiotic }

Developers launching networks through Tanssi benefit from [block production services](/learn/tanssi/network-services/block-production/){target=\_blank}, data retrievability as a service, and the shared security model derived from every vault opting-in to support the Tanssi protocol. This eliminates the hurdle of dealing with infrastructural and security components developers would need to take on otherwise.

Vault managers running vaults can apply to offer the restaked collaterals as economic security for the Tanssi Network. Since Tanssi networks run in a sandbox-like environment, and the Tanssi protocol manages all the networks-related responsibilities, vault managers only need to analyze and opt-in to the Tanssi protocol, regardless of the quality and the quantity of networks that are running through the Tanssi protocol at any given moment.

Operators opting-in to provide services to the Tanssi protocol (provided that they participate in a vault that supports the Tanssi protocol) have the benefit of running the same setup to provide block production and validation services to the Tanssi Network and, consequently, to every network deployed through Tanssi. This unique architecture facilitates all the tasks related to running and maintaining the operators since there are no changes in the setup when a new Tanssi network is launched or decommissioned.

!!! note
    The Tanssi protocol effectively abstracts the details of the active set of networks away from vault managers and operators. Networks particularities don't require any additional setup from operators nor pose risks to vault assets.

All things combined shape a functional and elegant ecosystem where developers can focus on creating and innovating. Tanssi handles the infrastructural components, guaranteeing liveness and performance, and Symbiotic provides the economic safeguards to ensure the validity of the operations.

```mermaid
flowchart LR
    subgraph Symbiotic
        direction LR
        Operators
        Vaults
    end
    Symbiotic  -- Validates/Secures --> tanssi["Tanssi Network"]
    tanssi -- Block Production Services--> Networks
    tanssi -- Security--> Networks
    tanssi -- Data Retrievability--> Networks

    class Symbiotic custom-container
```

### Tanssi-Ethereum Communication {: #tanssi-ethereum-communication }

It is important to learn how Tanssi and Ethereum exchange data to understand the mechanics of the protocol. They connect through a two-way bridge that lets them communicate with each other. Each protocol has a specific job in making cross-chain operations possible.

There are three key components between Symbiotic and Tanssi:

```mermaid
flowchart LR

Tanssi["Tanssi"] <--> Relayer 
Relayer <--> Gateway 
Gateway["Gateway"] <--> Middleware
Middleware <--> Symbiotic["Symbiotic"]

class Tanssi tanssiNode;

class Middleware middlewareNode;

class Gateway gatewayNode;

class Symbiotic symbioticNode;

class Relayer relayerNode;
```

- **`Relayer`** - is the software that continuously monitors both blockchains and transmits messages. Enabling reliable bidirectional communication between Tanssi and Ethereum, serving as the connection layer that ensures messages are correctly delivered across networks

- **`Gateway`** - operates on the Ethereum side of the bridge and serves three essential functions. It receives, verifies, and routes incoming messages from Tanssi to ensure they are correctly processed. The contract accepts outgoing messages destined for the Tanssi network, preparing them for relay. Finally, it handles higher-level application functionalities, most notably token transfers between the two networks, providing a secure interface for cross-chain asset movement

- **`Middleware`** - is Tanssi's implementation for handling network events and operations. It is the critical link between the `Gateway` and Tanssi's core protocol

The `Middleware` plays a central role in network coordination between Tanssi and Symbiotic. It distributes rewards to operators and vaults based on their network security and performance contributions. The contract sorts operators by stake to create a merit-based ranking system for their selection and transmits the list of sorted operator keys to Tanssi for assignment. Additionally, it facilitates operator registration processes and handles the reward and slashing protocols that maintain network incentive alignment.

#### From Ethereum to Tanssi {: #from-ethereum-tanssi }

The `Middleware` transmits operator set information to Tanssi for session assignment through the bridge. It sends details about active operators for each epoch, ordering them by their total stake aggregated across vaults. Tanssi then uses this information to assign operators for upcoming sessions, ensuring that the most economically aligned ones secure the network. This mechanism creates a stake-weighted operator selection process where economic security on Ethereum translates to operational security on Tanssi.

#### From Tanssi to Ethereum {: #from-tanssi-ethereum }

Tanssi sends operational data back to Ethereum through the same communication channel. This message includes reward information that enables proper distribution to stakeholders based on network performance. The network also transmits slashing event data when operators fail to perform correctly or violate protocol rules, allowing the protocol to apply penalties. Tanssi can also request new tokens to be created on Ethereum and register tokens, making managing assets between both networks easy.

### Rewards {: #rewards }

Well-behaved operators and restakers are rewarded for their participation with TANSSI tokens. The reward process consists of two main phases: [Reward Distribution Phase](#reward-distribution-phase) and [Reward Claiming Phase](#reward-claiming-phase).

#### Reward Distribution Phase {: #reward-distribution-phase }

The reward distribution phase calculates and allocates rewards through five key steps involving operators, restakers, and smart contracts. The steps are:

1. **Reward Calculation** - Tanssi calculates rewards based on the activity of operators and stakers and then creates a [Merkle root](https://en.wikipedia.org/wiki/Merkle_tree){target=\_blank}. This Merkle root is a cryptographic fingerprint that summarizes the reward allocations, indicating who receives what. Stakers are rewarded according to their stake in each vault
2. **Reward Data Sent via XCM** - reward allocation data is sent using [XCM](https://wiki.polkadot.com/learn/learn-xcm/){target=\_blank} (Cross-Consensus Messaging), a standardized protocol for blockchain communication. [Snowbridge](https://docs.snowbridge.network/){target=\_blank} acts as a trustless bridge between Tanssi and Ethereum
3. **Ethereum Message Reception** - once the message is relayed to the `Gateway` contract, this contract serves as Tanssi's authorized entry point on Ethereum for the Snowbridge bridge
4. **Message Processing and Validation** - the `Gateway` forwards the data to the [`Middleware`](https://github.com/moondance-labs/tanssi-symbiotic/blob/main/src/contracts/middleware/Middleware.sol){target=\_blank}, which is responsible for various tasks, including passing the information to the `OperatorReward` contract
5. **Reward Storage and Distribution** - this is the final destination for the data. The [`OperatorRewards`](https://github.com/moondance-labs/tanssi-symbiotic/blob/main/src/contracts/rewarder/ODefaultOperatorRewards.sol){target=\_blank} contract stores the Merkle tree of the reward allocations and handles the transfer of reward tokens when a claim is made

```mermaid
%%{init: {'sequence': {'mirrorActors': false}}}%%
sequenceDiagram
    participant Tanssi Network
    participant Snowbridge (XCM)
    participant Gateway
    participant Middleware
    participant OperatorRewards

    Tanssi Network->>Tanssi Network: 1. Calculate rewards and generate Merkle root
    Tanssi Network->>Snowbridge (XCM): 2. Reward data sent via XCM (Merkle root + data)
    Snowbridge (XCM)->>Gateway: 3. Relay message and sent to Ethereum 
    Gateway ->>Middleware: 4. Message processing and validation
    Middleware->>OperatorRewards: 5. Reward storage and distribution
```

#### Reward Claiming Phase {: #reward-claiming-phase }

In the reward-claiming phase, operators and stakers can claim rewards based on their participation in the network. Tanssi determines the share distribution for operators and stakers, currently setting it at 20% for operators and 80% for stakers.

1. **Operator Reward Claim** - operators can claim their share by calling the `OperatorRewards` contract by using a cryptographic receipt that verifies their entitlement
2. **Token Release** - the operator call triggers the token release, and the `OperatorRewards` sends the established amount to the operator
3. **Token Distribution to Stakers** - the remaining rewards are forwarded to the `StakerRewards` contract for further claiming of the staker
4. **Staker Allocation** - the remaining 80% of the rewards are automatically directed to the [`StakerRewards`](https://github.com/moondance-labs/tanssi-symbiotic/blob/main/src/contracts/rewarder/ODefaultStakerRewards.sol){target=\_blank} contract, where stakers can claim rewards proportional to their stake in the vaults

```mermaid
%%{init: {'sequence': {'mirrorActors': false}}}%%
sequenceDiagram
 participant Operator
 participant OperatorRewards
 participant StakerRewards
 participant Stakers

 Operator->>OperatorRewards: 1. Operator reward claim
 OperatorRewards->>Operator: 2. Release rewards to the operator
 OperatorRewards->>StakerRewards: 3. Forward the remainder to StakerRewards
 Stakers->>StakerRewards: 4. Stakers claim individual rewards
```

### Slashing {: #slashing }

The Tanssi protocol implements slashing to penalize operators for misbehavior. When a slashing event is triggered, the authorities designated as resolvers by the vault managers can either accept or revert this action.

The following actions can trigger slashing events:

- Producing invalid blocks (e.g., blocks that include invalid transactions)
- Invalid validation (e.g., double-signing or breaking protocol rules)
- Downtime or unavailability
- Consensus violations

!!!note
    Slashing events can only be triggered by operators' misbehavior within the Tanssi Network. Even if Tanssi networks are faulty or malicious, they operate in a sandboxed environment and cannot cause slashing.

#### Slashing Process {: #slashing-process }

The slashing process follows a path similar to that of rewards. When an operator misbehaves, the Tanssi Network sends a slashing request message to the trustless bridge (Snowbridge). The message passes through the `Gateway` and into the `Middleware` where the slashing method gets called.

The slashing method receives a unique identifier for the operator's identity, the severity of the slash as a percentage of the operator's assigned stake in each vault, and the time context within which the offense occurred.

The slashing process consists of the following steps:

1. **Slash Reported** - Tanssi sends the slash request to the `Middleware` with the parameters `operatorKey`, `percentage`, and `epoch`
2. **Operator Validation** - the `Middleware` validates the operator's identity and checks if the operator is subject to slashing
3. **Retrieve Active Vaults** - the `Middleware` iterates through all active vaults during the offense epoch, skipping any inactive vaults
4. **Retrieve Operator Stake** - for each active vault, the `Middleware` retrieves the stake of the misbehaving operator
5. **Calculate Slash Amount** - the `Middleware` calculates the slashing amount by applying the slashed percentage to the operator's stake in each vault
6. **Slashing** - depending on the vault's slashing implementation, there are two possible routes

    - **Instant Slashing** - if the vault uses instant slashing, the stake is immediately reduced

    - **Veto Slashing** - if the vault uses veto slashing, the `Middleware` requests the slashing from a resolver. A time-limited veto window is created (e.g., 7 days)

    The slashing is canceled if the resolver vetoes the request within the time window. Otherwise, the slashing penalty is executed if no veto occurs within the time window

This process ensures that each vault's slashing is handled independently, preventing cross-contamination, and offers both instant and time-delayed slashing with dispute resolution mechanisms.

```mermaid
%%{init: {'sequence': {'mirrorActors': false}}}%%
sequenceDiagram
    participant Network
    participant Middleware
    participant Vault
    participant Slasher
    
    Network->>Middleware: 1. Slash reported
    Middleware->>Middleware: 2. Operator validation
    loop Each Active Vault
        Middleware->>Vault: 3. Retrieve operator stake
        Vault-->>Middleware: 4. Retrieve vault stake
        Middleware->>Middleware: 5. Calculate slash amount
        alt Instant Slasher
            Middleware->>Slasher: 6.1 Slash
        else Veto Slasher
            Middleware->>Slasher: 6.2 Request slash
            opt If Not Vetoed
                Slasher->>Slasher: 6.2 Execute slash
            end
        end
    end
```

#### Burner {: #burner }

The `Burner` contract is an extension responsible for handling actions that follow a [slashing event](#slashing-process), notably the burning of slashed collateral. Once a slash is executed, the `Slasher` contract calls the `Burner` to carry out these post-slashing tasks.

Within the protocol, the `Burner` contract plays a crucial role in deciding what happens after slashing. While there are different ways to implement the burning process, the recommended approach is to burn the slashed assets.
When a slash is executed, the `Burner` contract's `onSlash` function is activated. This function kicks off the process of burning the slashed assets.

The vault manager chooses the specific implementation of the burning process during the vault's initialization phase, and once set, the vault manager cannot modify it. The exact design of the `Burner` contract may differ depending on the type of collateral asset involved. Below are some potential implementation options:

- **Burning Tokens** - if the slashed collateral is a regular ERC-20 token, the `Burner` destroys those tokens, permanently removing them from circulation
- **Unwrapping and Burning** - if the slashed tokens represent something like staked assets (e.g., liquid staking tokens) or liquidity provider (LP) tokens from a decentralized exchange (DEX), the `Burner` might convert them back into their original form before burning them
- **Cross-Chain Operations** - if the tokens are tied to assets on another blockchain, the `Burner` could unwrap them on Ethereum and trigger the burn process on the original network
- **Alternative Handling** - sometimes, burning isn't the best option. Instead, the `Burner` might redistribute the slashed assets to other operators, compensate affected users, or lock them in liquidity poolsâ€”whatever the system is designed to do

Burning slashed collateral is important because it penalizes misbehaving operators and reduces the total supply of tokens, which can have deflationary effects.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/glossary/
--- BEGIN CONTENT ---
---
title: Glossary
description: The Tanssi network's architecture is rich and complex. Here's a technical glossary for understanding Tanssi, including key terms, concepts, and definitions.
icon: octicons-book-24
---

# Glossary

## Introduction {: #introduction }

The Tanssi protocol offers a wide range of features and layered architecture, making it both rich and complex. There's a great deal of terminology specific to Tanssi, Appchains, Symbiotic, and the web3 space in general. We've compiled a list of terms you'll want to know as you review the Tanssi documentation.

## Appchain {: #appchain }

A customizable application-specific blockchain deployed through Tanssi that goes live in minutes, benefiting from shared security, block production services, built-in bridging, and other services.

## BEEFY {: #beefy }

BEEFY stands for _Bridge Efficiency Enabling Finality Yielder_. It is a consensus protocol that Tanssi utilizes for efficient, trustless bridging to Ethereum.

## Bridge {: #bridge }

A bridge in the web3 context connects two different sovereign blockchains. Tanssi offers a built-in bridge based on Snowbridge connecting the Tanssi network to Ethereum in a decentralized and trustless way.

## Dancelight {: #dancelight }

Tanssi's official TestNet for rapid network deployment and experimentation.

## Data Preservers {: #data-preservers }

Full archive nodes that ensure data availability and provide RPC infrastructure for Tanssi and Tanssi-powered networks.

## ECDSA {: #ecdsa }

ECDSA stands for _Elliptic Curve Digital Signature Algorithm_, which is the cryptographic scheme used for Ethereum accounts.

## Ed25519 {: #ed25519 }

It is the cryptographic scheme for producing digital signatures used by node operators for consensus mechanisms like block production.

## Gateway Contract {: #gateway }

One of the components of the Tanssi-Ethereum bridge. It serves as Ethereum's central messaging point that receives and validates messages from Tanssi.

## Light Client {: #light-client }

One of the components of the Tanssi-Ethereum bridge. It serves as an on-chain verifier for data legitimacy in a network.

A light client is a software that allows you to interact with a blockchain without having to download the entire data. It relies on a subset of information (such as block headers) and uses tools like Merkle proofs to verify transaction and data authenticity. This makes light clients more resource-efficient than full nodes.

## Merkle Root {: #merkle-root }

A single cryptographic hash that allows the verification of an entire set of data, such as all the transactions in a block.

## Operator {: #operator }

A node that validates transactions, providing security through a restaking protocol to Tanssi and all Tanssi-powered appchains.

## Relayer {: #relayer }

A stateless component that transports messages and proofs between different blockchain networks, such as Tanssi and Ethereum.

## Restaking {: #restaking }

The practice of using already-staked tokens to secure additional protocols or services.

## Sequencer {: #sequencer }

A node responsible for executing transactions and producing blocks for Tanssi-powered appchains.

## Session {: #session }

A period of time during which the same set of authorities (sequencers or validators) are active.

## Sr25519 {: #sr25519 }

The primary signature scheme that is used for most user-facing operations within the Tanssi network.

## Substrate {: #substrate }

A modular and performant blockchain development framework used to build Tanssi and Tanssi appchains.

## Symbiotic {: #symbiotic }

A restaking protocol based on Ethereum, providing restaking services and economic security to Tanssi and Tanssi-powered appchains.

## $TANSSI(Substrate) {: #tanssi-substrate }

The native utility token of the Tanssi protocol. It is used for staking, governance, network operations, and more.

## $TANSSI(ERC20) {: #tanssi-erc20 }

The ERC20 Ethereum representation of the Tanssi token. It is used for paying rewards to operators and more.

## Trustless {: #trustless }
 
As with a _trustless bridge_, it enables operation without requiring trust in centralized intermediaries, relying instead on cryptographic proofs.

## Vault {: #vault }

A Symbiotic component that receives and manages restaked collateral, delegating to operators and providing economic security to networks.

## Verifier {: #verifier }

The component that validates cryptographic proofs.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/
--- BEGIN CONTENT ---
---
title: Learn About Tanssi
description: Learn about Tanssi protocol and how it handles infrastructure complexities, making it easy for developers to deploy decentralized networks in minutes.
icon: octicons-star-24
template: index-page.html
---

# Learn About Tanssi

With Tanssi, developers can rely on seamless block production, integration with essential tools, and the flexibility to choose security providers that best fit their blockchain environment, empowering them to focus on innovation rather than technical hurdles.

Tanssi's modular framework, runtime customization, transaction management, and interoperability transform network development into an accessible and efficient process, drastically reducing time to market while ensuring high performance and scalability.

This section includes an overview of Tanssiâ€™s core capabilities that support network development, covering everything from infrastructure and security to essential integrations.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/network-features/
--- BEGIN CONTENT ---
---
title: Network Features
description: Explore Tanssi's network features like staking, governance, and treasury, supporting its role as a decentralized network orchestrator for the Web3 ecosystem.
icon: octicons-cpu-24
template: index-page.html
---

# Network Features

The network features in Tanssi are designed to provide the foundational mechanisms that support decentralization, security, and scalability. From securing networks through staking to future capabilities, this section outlines the core elements that empower Tanssiâ€™s network infrastructure.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/network-features/staking/
--- BEGIN CONTENT ---
---
title: Staking for Block Production
description: Learn how Tanssi implements a novel Staking mechanism to provide liveness via a decentralized and trustless set of sequencers to all Tanssi-powered networks.
icon: material-hand-coin-outline
categories: Basics
---

# Tanssi Staking for Block Production {: #tanssi-staking }

## Introduction {: #introduction }

One of Tanssi's core propositions is to simplify the infrastructure complexity for networks. A significant component is bootstrapping a decentralized set of sequencers, which Tanssi offers through its unique architecture and staking mechanics.

Tanssi staking mechanics guarantee that the sequencers for Tanssi-powered networks are selected through a trustless and decentralized mechanism. They also incentivize the community to delegate to top-performing or engaged sequencers.

This page covers the fundamental concepts of Tanssi's staking mechanics and how it secures a decentralized block production set that drives network liveness for Tanssi networks.

<div style="text-align: center; justify-content:center;" class="row hero-buttons">
  <a href="https://www.tanssi.network/post/staking-tanssi" aria-label="Learn How to Stake on Tanssi Apps" style="margin: .5em;">
    <button class="md-button primary-button" style="padding: 1em; font-size: 1em;">Learn How to Stake -></button>
  </a>
</div>

## Core Concepts {: #core-concepts }

Tanssi's staking module mechanics were inspired by the concept of liquidity pool tokens (LP tokens) in traditional Automated-Market-Makers (AMMs) like Uniswap V2.

Each sequencer has four liquidity pools through which delegators move as they perform different staking operations. In short, each liquidity pool represents a different state throughout the staking process: joining, staking through manual rewards, staking through auto-compound rewards, and leaving. Nevertheless, one core difference is that LP tokens in common AMMs are transferable while staking shares tokens are not.

A delegator has four simple transactions to go through the different states (liquidity pools): delegate (for manual or auto-compound rewards), undelegate, swap, and execute pending operations. For example, users who want to stake through either rewards pool can use the delegate call and join the Joining Pool immediately. After a delay, users (or anyone else) can execute the pending operation and enter the initially set rewards pool. Once there, users can swap between reward pools as often as they like. Lastly, users in a rewards pool can use the undelegate call to go into the Leaving Pool and unstake their tokens (or anyone else's) executing the pending operation after a given delay.

Liquidity pools have a set of shares that can be considered LP tokens in traditional AMMs. When users join a new liquidity pool, they are given several shares (LP tokens) that depend on the pool type, the number of tokens they staked, the total number of shares, and the total number of tokens staked in that pool.

Rewards are assigned to a sequencer's Manual or Auto-Compound Reward Pools when Tanssi attests that the specific block production slot that sequencer was assigned to has been fulfilled, and the block was produced successfully.

All rewards (for all pools) are stored in a protocol-owned account. Nevertheless, the protocol internally keeps track of the actual native tokens held by each pool. The core difference between staking through the Manual or Auto-Compound Rewards Pools is how rewards are distributed. In the Manual Rewards Pool, users have to claim any staking rewards they've accumulated manually. In contrast, in the Auto-Compound Rewards Pool, the rewards are automatically re-staked at each Tanssi block, where the protocol announces the sequencer for each block production assignment.

The delegate and undelegate operations need to be sent by the delegator itself. They signal the intent of the action to be taken and ask the protocol to perform the necessary checks to allow the delegator to delegate or undelegate. Consequently, these actions can be executed only after a certain number of sessions, but anyone in the network can perform this second operation through the execute pending operation transaction.

The following diagram summarizes the high-level flow of a delegator delegating and undelegating tokens to a sequencer. User actions are highlighted in cyan, while different pools are highlighted in coral.

![High-level overview of Tanssi Staking mechanics](/images/learn/tanssi/staking/staking-1.webp)

## Staking Parameters {: #staking-parameters }

=== "Tanssi MainNet"
    |   Variable    |                                                         Value                                                         |
    |:-------------:|:---------------------------------------------------------------------------------------------------------------------:|
    | Joining Delay | {{ networks.mainnet.staking.joining_delay_blocks }} blocks ({{ networks.mainnet.staking.joining_delay_hours }} hours) |
    | Leaving Delay | {{ networks.mainnet.staking.leaving_delay_blocks }} blocks ({{ networks.mainnet.staking.leaving_delay_hours }} hours) |
  
=== "Dancelight TestNet"
    |   Variable    |                                                            Value                                                            |
    |:-------------:|:---------------------------------------------------------------------------------------------------------------------------:|
    | Joining Delay | {{ networks.dancelight.staking.joining_delay_blocks }} blocks ({{ networks.dancelight.staking.joining_delay_hours }} hours) |
    | Leaving Delay | {{ networks.dancelight.staking.leaving_delay_blocks }} blocks ({{ networks.dancelight.staking.leaving_delay_hours }} hours) |

## Staking Pools {: #staking-pools}

The following section goes through each of the liquidity pools that represent a step throughout the staking process.

### Joining Pool {: $joining-pool}

When a user first delegates to start the staking process, it must state what staking rewards mechanism it wants: manual or auto-compound rewards (each being a separate pool). Once the joining transaction is executed, the user automatically enters the Joining Pool and is given shares of that pool directly correlated to the number of tokens being staked. This pool offers stability to the current set of sequencers by providing a delay between a delegator staking and receiving rewards. The delay is set to at least one entire session.

As a practical example, Alice starts the staking process targeting the Manual Rewards Pool and enters the Joining Pool halfway through a session; she must wait until the end of the next session to execute her pending operation to start receiving staking rewards.

Joining Pools for each sequencer have a one-to-one ratio of shares per token staked. Therefore, if Alice is staking 100 tokens, she will receive 100 shares (LP tokens) of the Joining Pool she entered. When her delegate pending operation is executed, the protocol consumes her shares of the Joining Pool in favor of native protocol tokens, which are immediately swapped to shares in either the Manual Rewards or Auto-Compound Rewards Pools.

The following diagrams assumes a user is staking into the Manual Rewards Pool.

![High-level overview of the Joining Pool when Staking](/images/learn/tanssi/staking/staking-2.webp)


### Manual Rewards Pool {: #manual-rewards-pool}

When a user joins the Manual Rewards Pool, the protocol destroys all Joining Pool shares they own in favor of the native protocol token. Next, in the same block, the protocol computes the amount of Manual Pool shares that can be minted with this amount based on the share's price. The price is calculated based on current pool conditions, that is, the number of native tokens and shares that exist:

```mathematica
SharePrice [Tokens/Shares] = NumberOfTokensInPool / NumberOfSharesInPool 
```

Shares don't have decimals. Consequently, any remaining native tokens when acquiring the pool's shares are refunded to the user. The share price is not impacted by users joining the pool, as the ratio is maintained. Once the user has Manual Rewards Pool shares, they earn staking rewards (that is, in the same session) that need to be claimed manually by the user delegating. 

In contrast to the Auto-Compound Rewards Pool, where reward distribution is done automatically to the specific pool, the distribution for the Manual Rewards Pools operates through a counter checkpoint rewards mechanism. This mechanism tracks the historical native token per share distribution rate assigned to you by the protocol for that particular Manual Reward Pool at a specific point in time. When Tanssi attests that a block was produced by a given sequencer, new rewards are assigned to that Manual Rewards Pool for users to claim, and the rewards counter increases. Therefore, rewards are reflected as the ratio of native tokens per share you receive as staking rewards, which is the difference between the current pool's rewards counter and your original rewards counter checkpoint.

Consequently, the native tokens per share rewards counter plays a vital role in the protocol's calculation of the tokens the user is due when they claim their rewards. Once the rewards are calculated, the protocol sends them from the protocol-owned account to the user. Simultaneously, the user's rewards counter checkpoint is reset to the current one set by the pool current counter value. This reset is necessary to ensure the user's new rewards counter aligns and that the due rewards are zero.

Similarly, when a user stakes or unstakes tokens, rewards are automatically claimed, and the user's checkpoint rewards counter is reset. Adding or removing a stake means that reward conditions for that specific amount differ from what the protocol has in storage. Consequently, the rewards counter checkpoint must be synced with the pool's rewards counter to ensure no imbalances.

![High-level overview of the Manual Rewards Pool when Staking](/images/learn/tanssi/staking/staking-3.webp)

### Auto-Compound Rewards Pool {: #autocompounded-rewards-pool}

When a user joins the Auto-Compound Rewards Pool, the protocol destroys all Joining Pool shares they own in favor of the native protocol token. Next, in the same block, the protocol computes the amount of Auto-Compound shares that can be minted with this amount based on the share's price. The price is calculated based on current pool conditions, that is, the amount of native tokens and shares that exist:

```mathematica
SharePrice [Tokens/Shares] = NumberOfTokensInPool / NumberOfSharesInPool 
```

Shares don't have decimals. Consequently, any remaining native tokens when acquiring the pool's shares are refunded to the user. The share price is not impacted by users joining the pool, as the ratio is maintained. Once the user has Auto-Compound Rewards Pool shares, they earn staking rewards (that is, in the same session).

In contrast to the Manual Rewards Pool, native token rewards in the Auto-Compound Rewards Pool are automatically assigned to the pool at each Tanssi block where the protocol attests the sequencer for each block production assignment in any Tanssi-powered network. Consequently, as the number of native tokens held in the pool increases but the number of shares stays constant, the share price increases (according to the formula). Therefore, if the users redeem their shares for native tokens, they will receive more native tokens per share than when they joined the pool.

![High-level overview of the Auto-Compound Rewards Pool when Staking](/images/learn/tanssi/staking/staking-4.webp)

Native token rewards are automatically assigned as new stake into the Auto-Compound Rewards Pool, hence the auto-compounding nature of this specific staking pool mechanism.

Nevertheless, when auto-compound staking rewards are assigned, they are not held in the user's reserved balance, as the protocol-owned account still has them. The increase in the delegator's stake is indirectly represented by the share price increase. However, in specific scenarios, a user might want to let the protocol know that they want that balance to be represented in their state as reserved balance, for example, for governance purposes. 

Consequently, the protocol offers a specific transaction any user can submit to update the reserve balance of any delegate. This call moves the auto-compound rewards for the specified user from the protocol-owned account to their reserve balance. This is also automatically executed by the protocol when a user removes liquidity from a Auto-Compound Rewards Pool.

### Leaving Pool {: #leaving-pool}

When a user decides to exit their staking positions from a Manual or Auto-Compound Reward Pool, they have the power to initiate an undelegation. This process, similar to when they initially entered the Joining Pool, is a two-step journey. The user signs an intent to remove a specific delegation and patiently waits for at least one entire session before the operation can be executed by anyone.

Upon executing the leaving transaction intent, the protocol exchanges shares of the specified pool for native tokens at the current pool price. For the Manual Rewards Pool, any unclaimed rewards are assigned to the user. Simultaneously, the protocol purchases Leaving Pool shares in a one-to-one ratio for the native tokens the user just received. This ensures that the user joins the Leaving Pool, acquiring shares that correspond to the number of native tokens they desire to unstake.

After an entire session passes, any user can execute the pending operation. Then, the protocol swaps Leaving Pool shares for native protocol tokens at a one-to-one ratio.

The primary purpose of the Leaving Pool is to provide a buffer for users leaving the staking mechanics. This buffer allows the implementation of slashing mechanisms to deter bad behavior. Slashing has not been implemented in Tanssi but could be implemented in the future.

The following diagrams assumes a user is unstaking from the Manual Rewards Pool.

![High-level overview of the Leaving Pool when Staking](/images/learn/tanssi/staking/staking-5.webp)

### Swapping Between Rewards Pools {: #swap-rewards-pool}

Tanssi's staking module allows users to swap their stake from one type of reward pool to another. Users can use this functionality to move partial or full amounts of the staked tokens in a specific pool. The main benefit is that users don't have to go through the Leaving Pool and the Joining Pool again to move their stake.

First, all pending Manual Rewards Pool rewards are claimed at a protocol level, as liquidity is either added or removed. Therefore, the checkpoint rewards counter needs to be synced with the pool. Next, shares from the original pool are consumed and exchanged in favor of native protocol tokens at the current pool price. Then, shares of the new pool are attained at that pool's price. Lastly, any dust tokens remaining are automatically exchanged in favor of Leaving Pool shares. Note that all of the above is executed in the same block, and users don't have to wait for delays to earn rewards in the new pool. The dust in the Leaving Pool can be claimed after the required delays have passed.

![High-level overview of Swapping between Manual and Auto-Compounded Pools when Staking](/images/learn/tanssi/staking/staking-6.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/network-services/block-production/
--- BEGIN CONTENT ---
---
title: Block Production Services
description: Tanssi abstracts away infrastructure complexities, such as block production, allowing developers to launch decentralized networks with Ethereum-grade security.
icon: octicons-container-24
categories: Basics
---

# Block Production Services {: #block-production-services }

## Introduction {: #introduction }

As presented in the [Overview](/learn/tanssi/overview/){target=\_blank} article, Tanssi is an infrastructure protocol that streamlines the deployment of decentralized networks with custom logic fitting a wide range of use cases, including DeFi, NFTs, Gaming, and any other use case development teams may want to address.

Infrastructure poses a huge challenge for developers, requiring them to bootstrap sequencers, data preservers, and RPC endpoints, while also managing integrations, interoperability, and security. This demands valuable time and resources, diverting focus from what truly matters: delivering value to their users.

Tanssi orchestrates resources, allowing developers to deploy decentralized networks (also known as actively validated services or AVSs) that are fully adaptable to any specific application or use case. In this analogy, the Tanssi network resembles [Kubernetes](https://kubernetes.io){target=\_blank} in its role as an orchestrator, managing resources to guarantee the liveness and performance of the networks.

The protocol also tackles the security front by allowing networks to select and connect to external security providers (like [Symbiotic](/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}), ensuring Ethereum-grade security right from the start.

This article covers the necessary aspects to consider when building and deploying your own modular blockchain, along with the most relevant technical aspects of the Tanssi protocol.

## Block Production as a Service {: #block-production-as-a-service }

The Tanssi protocol provides block production as a service, orchestrating a decentralized and trustless set of sequencers, ensuring the networks' liveness. To do so, the protocol bridges both ends:

- **Node operators**: Who run sequencers, offering their block production services to get rewards.
- **Developers**: Who launch networks, which require sequencers.

The protocol assigns a subset of sequencers to provide services to each network, rotating them after a period of time. The sequencers can serve any Tanssi-powered network, regardless of the custom logic they implement. On the other hand, networks deployed through Tanssi can customize their runtime as much as they need to fit their use case and upgrade the logic at any moment in a forkless fashion without worrying about the sequencer's setup.

The following diagram illustrates how Tanssi assigns two sequencers to each active network, selecting them from a decentralized set of sequencers.

```mermaid
flowchart TB
    subgraph network1 [Network 1]
        s1bis[Sequencer 1]
        s2bis[Sequencer 2]
    end

    subgraph network2 [Network 2]
        s3bis[Sequencer 3]
        s4bis[Sequencer 4]
    end

    Tanssi[Tanssi Network<br/>Orchestrator]

    subgraph sequencers [Sequencers Pool]
        direction LR
        s1[Sequencer 1]
        s2[Sequencer 2]
        s3[Sequencer 3]
        s4[Sequencer 4]
        sn[Sequencer N]

        s1 --- s2 --- s3 --- s4 --- sn
    end

    sequencers -- Managed by --> Tanssi
    Tanssi -- Assigns Sequencers --> network1
    Tanssi -- Assigns Sequencers --> network2
```

### Sequencer Selection Process {: #sequencer-selection-process}

At any given time, all Tanssi networks require a certain number of sequencers, depending on the number of active networks and the current block production configuration set in Tanssi. The configuration sets the maximum number of total sequencers in the set and the number of sequencers each network has to have assigned.

=== "Tanssi MainNet"
    |          Variable          |                                       Value                                        |
    |:--------------------------:|:----------------------------------------------------------------------------------:|
    |    Max. # of Sequencers    |     {{ networks.mainnet.sequencers.configuration.max_block_producers }}      |
    | # of Sequencers (Networks) | {{ networks.mainnet.sequencers.configuration.block_producer_per_container }} |

=== "Dancelight TestNet"
    |          Variable          |                                       Value                                        |
    |:--------------------------:|:----------------------------------------------------------------------------------:|
    |    Max. # of Sequencers    |     {{ networks.dancelight.sequencers.configuration.max_block_producers }}      |
    | # of Sequencers (Networks) | {{ networks.dancelight.sequencers.configuration.block_producer_per_container }} |

Once the required number of sequencers for a given session is known, Tanssi uses two mechanisms to decide the set of sequencers distributed among all networks. 

The first mechanism is through the *Invunerables* module, which sets a list of fixed sequencers prioritized by the protocol and ensures block production stability in certain scenarios, such as TestNets. 

The second mechanism is through the [Tanssi staking module](/learn/tanssi/network-features/staking/){target=\_blank}. The module helps create a decentralized set of sequencers for all Tanssi networks by providing the protocol with a sorted list of sequencers by staked amount. Tanssi appends the sorted list by stake of sequencers to the invulnerable ones (if any), then takes from the list only the exact amount of sequencers needed, starting from the top, leaving out of the next session those sequencers that have less staked value, to finally begin the sequencer assignation process.

### Sequencers Assignment {: #block_producers-assignment }

Once the sequencer set that will participate in the next session is known, Tanssi shuffles the list and assigns them to provide block production services to the active Tanssi networks.

The assignment algorithm will start distributing the sequencers serving the networks by the registration date on a first-come, first-served basis. Once the assignment is made, it will be upheld for at least one session, representing a period measured in blocks with a constant set of sequencers. In Tanssi MainNet, the default session duration is set to {{ networks.mainnet.session.blocks }} blocks, which, with an average block time of six seconds, translates to (roughly) {{ networks.mainnet.session.display }} hours.

Every new assignment works intentionally with a one-session delay, so the sequencers know in advance which one of the networks they are assigned to. Sequencers will start syncing the new network they'll have to serve in the next session with a special syncing mechanism called [warp sync](https://spec.polkadot.network/chap-sync#sect-sync-warp){target=\_blank}. Warp sync allows the sequencers to swiftly sync the new network without acting as an archive node.

When a new session starts, the Tanssi protocol will put the queued assignment into effect. Sequencers will automatically change and start producing blocks in the new Tanssi network they've been assigned to while discarding the chain state from the previous assignment. Tanssi will also calculate the new assignment, considering changes in Tanssi networks that might have been activated or deactivated and sequencers that might have been added or removed from the pool or changed the total staked value. This new assignment will be queued for the next session.

![Sessions](/images/learn/tanssi/network-services/block-production/block-production-1.webp)

### The Role of the Tanssi Network {: #tanssi-newtwork }

As previously discussed, the Tanssi protocol assigns sequencers to the Tanssi networks, and the result of this assignment is stored within the chain state.  Besides running the network node, the sequencers also run the Tanssi one. Hence, by accessing the data stored in the finalized blocks of the Tanssi Network, they can learn their assignation for the session, and the Tanssi networks can confirm that a certain group of sequencers have been assigned to them. 

As the Tanssi networks produce blocks, those blocks need to be validated and finalized by an external security provider. Once an operator verifies a block, a small proof of validity is produced and stored in Tanssi, keeping track of the proofs for each block of each chain. This small representation of the proof of validity is called [candidate receipt](https://wiki.polkadot.com/learn/learn-parachains-protocol/#candidate-receipts){target=\_blank} and is composed of a set of values, including the state root, which can be used to verify state proofs.

Finally, Tanssi can verify that the author of a network block was the expected one and reward accordingly.

The following diagram shows a simplified model of the data Tanssi stores in its internal state. For every active network (in this example, two), Tanssi stores the assigned sequencers, which are the only ones authorized to produce blocks on the network's behalf, proof of validity (candidate receipts) extended by the security provider's operators, the latest state root, and the latest sequencer. 

![Tanssi's internal state](/images/learn/tanssi/network-services/block-production/block-production-2.webp)

### The Role of the Tanssi-Powered Network {: #network }

As a sequencer assigned to a Tanssi-powered network includes built-in Tanssi node functionality, it is technically feasible to read the state from the Tanssi Network.

Leveraging this ability to access the states, the current sequencer with the authority to produce a block will read the state of the latest block produced in the Tanssi chain. It will proceed to include this state in the block of the network, the current set of sequencers assigned to the network, and its public signature, allowing Tanssi to know who produced the block and reward the node operator.

Once the block is filled with network transactions, it will be proposed as a candidate and handed over to the Tanssi chain, where the security provider's operators will ensure that the included state proofs match the state proofs from the latest state of Tanssi (preventing unauthorized block production) and that the transactions produced valid state transitions. Having verified the work of the sequencer, the operators will finalize the proposed block, including its candidate receipt in a Tanssi Network block.

![Tanssi-powered network block](/images/learn/tanssi/network-services/block-production/block-production-3.webp)

## Block Production Fees  {: #block-production-fees }

As presented in the [Introduction](#introduction), Tanssi is an infrastructure protocol that addresses the complexities and high costs associated with setting up and maintaining blockchain infrastructure, streamlining the deployment of networks. This protocol brings benefits for both participants:

- **Networks**: Teams can focus on the core logic of their product, the UX, and the UI without dealing with the challenges of infrastructure bootstrapping and its management.
- **Sequencers**: Bearing with the responsibility of keeping their hardware and software configuration in optimal conditions, they are incentivized to execute transactions and produce blocks on behalf of the Tanssi networks.

[Block production as a service](#block-production-as-a-service) carries associated costs that must be covered by the networks that want to leverage Tanssi for such a purpose. The following sections cover the general aspects of those costs and associated service payments.

### Service Payments {: #service-payments }

There are three main costs associated with block production as a service that any network must cover using Tanssi tokens to deploy successfully and get the block production services:

- **Registration deposit**: The initial deposit that is locked from the account that signs the network registration transaction.
- **Registration storage deposit**: The initial deposit that is locked from the account that signs the network registration transaction. It is a variable amount depending on the appchain's runtime size.
- **Sequencers assignment**: Every time the Tanssi protocol assigns sequencers, which happens once per session, a fixed fee is charged. This fee gives networks the right to be assigned sequencers and discourages networks whose runtime logic fails to produce valid transactions or blocks.
- **Block production**: Networks must pay for each block produced on their behalf. Since the protocol selects and assigns the sequencers on a per-session basis, networks must have enough funds to cover all the blocks to be produced in an entire session to be served.

The current configuration is set as follows:

=== "Tanssi MainNet"
    |           Variable           |                                                                   Value                                                                    |
    |:----------------------------:|:------------------------------------------------------------------------------------------------------------------------------------------:|
    |     Registration deposit     |                         {{ networks.mainnet.costs.registration_deposit_fee }} {{ networks.mainnet.token_symbol }}                          |
    | Registration storage deposit | {{ networks.mainnet.costs.registration_deposit_per_byte }} x 10<sup>-5</sup> {{ networks.mainnet.token_symbol }} per appchain runtime byte |
    |    Sequencers assignment     |                      {{ networks.mainnet.costs.cost_per_assignment }} {{ networks.mainnet.token_symbol }} per session                      |
    |       Block production       |                         {{ networks.mainnet.costs.cost_per_block }} {{ networks.mainnet.token_symbol }} per block                          |

=== "Dancelight TestNet"
    |       Variable        |                                                Value                                                |
    |:---------------------:|:---------------------------------------------------------------------------------------------------:|
    | Registration deposit  | {{ networks.dancelight.costs.registration_deposit_fee }} {{ networks.dancelight.token_symbol }} |
    | Registration storage deposit  | {{ networks.dancelight.costs.registration_deposit_per_byte }} x 10<sup>-5</sup> {{ networks.dancelight.token_symbol }} per appchain runtime byte |
    | Sequencers assignment |        {{ networks.dancelight.costs.cost_per_assignment }} x 10<sup>-6</sup> {{ networks.dancelight.token_symbol }} per session         |
    |   Block production    |            {{ networks.dancelight.costs.cost_per_block }} x 10<sup>-6</sup> {{ networks.dancelight.token_symbol }} per block            |

To ensure block production in the next session, the total balance must be at least enough to cover the sequencers assignment cost plus the cost to produce the {{ networks.mainnet.session.blocks }} blocks that comprise an entire session.

!!! note
    Although the sequencers assignment and block production costs are currently fixed, as protocol development progresses, they might become dynamic, varying in response to the network's workload.

### Tipping {: #tipping }

On some occasions, Tanssi might experience a high demand for its block production services that can not be met with the available resources. For example, if there are ten active networks for the next session and Tanssi can only serve eight, two networks will stall for the entire session duration.

To deal with these high-workload periods, the Tanssi protocol implements a tipping mechanism that allows networks to compete for a higher priority over the rest. Similar to Ethereum-compatible networks, where a priority fee can be set to outbid competing transactions and obtain preferential execution treatment, the Tanssi networks will be served according to the priority given by the tips they offer. Following the previous example, if there are ten active networks for the next session and Tanssi can only serve eight, then only the eight highest bidding networks will get sequencers assigned.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/network-services/
--- BEGIN CONTENT ---
---
title: Network Services
description: Learn about the Tanssi protocol value proposal, including critical features like block production and data availability as a service, bridging, and more.
icon: octicons-browser-24
template: index-page.html
---

# Network Services

Tanssi's network services provide the essential infrastructure for secure and efficient blockchain operations. At the core of these services, the Tanssi protocol offers block production as a service, ensuring the continuous performance and scalability of decentralized networks.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/overview/
--- BEGIN CONTENT ---
---
title: Overview
description: Tanssi is an infrastructure protocol that simplifies the process of deploying decentralized appchains, allowing developers to focus on creating their product.
icon: octicons-home-24
categories: Basics
---

# What is Tanssi? {: #what-is-tanssi }

Tanssi is a decentralized appchain infrastructure protocol that allows developers to launch their appchain in minutes. In other words, Tanssi reduces the six-to-twelve-month setup process typically required for any team to go live with a new chain to minutes.

You can think of Tanssi as _AWS for appchains_. Instead of dealing with all the networking infrastructure yourself, Tanssi handles all the hurdles, allowing you to focus on building your application logic, growing your community, and other tasks essential to your product's success.

Security is another significant obstacle that developers must deal with, taking on the responsibility of attracting staked assets to ensure consensus security and bootstrapping a validator set, which can be particularly challenging for projects in their early stages. All Tanssi-powered appchains benefit from Ethereum-grade security right from the start, and by leveraging Tanssi's decentralized design, appchains aren't exposed to single points of failure. 

Tanssi-powered appchains also benefit from a modular tech stack, providing ultimate control over the logic that powers the blockchain's runtime, offering an excellent way for projects to scale and build optimized solutions for their products. This complete control over the appchain's logic and governance mechanism suits perfectly a wide range of use cases, including DeFi Protocols, Real World Assets (RWA), Gaming Platforms, and others.

## The Problem with Appchains {: #the-problem-with-appchains }

Developers looking to build decentralized appchains typically have to deal with the following problems:

- **Complex Infrastructure Management**: Appchain deployments typically require handling numerous infrastructural components, including bootstrapping sequencers, operators (also known as validators), wallets, block explorers, oracles, indexers, RPC endpoints, and more. Properly managing these components are both time-consuming and resource-intensive.

- **Weak & Inefficient Security**: Appchains commonly suffer from having a small set of operators or weak economic security. Early-stage projects often lack sufficient economic backing to support a robust consensus mechanism. Moreover, developers often have to pay for full blockchain capacity validation even when they might not have achieved product-market fit, and blocks might be close to empty. This essentially means that operators are being overpaid, and there is a significant opportunity cost, as those resources could be used elsewhere to develop the protocol.

- **Cross-Chain and Interoperability**:  Appchains inherently lack cross-chain capabilities, which prevents them from connecting to other blockchain ecosystems. Furthermore, developing interoperability solutions requires specialized expertise and meticulous implementation.

- **Slow Time to Market**: The complexities of appchain infrastructure divert developers' focus from application logic, which is the key driver for intuitive interfaces and a seamless user experience, critical for adoption.

## What Tanssi Provides {: #what-tanssi-provides}

Tanssi addresses the most common appchain pain points by:

- **Sequencing as a Service**: Appchains built with Tanssi have their blocks produced by Tanssi's incentivized workers. Tanssi guarantees the appchain's liveness by orchestrating a decentralized set of sequencers.

- **Economic Security Through External Providers**: Appchains deployed through Tanssi leverage security from a provider of choice (for example, [Symbiotic](https://symbiotic.fi/){target=\_blank} for Ethereum). The protocol is designed to finalize transactions deterministically in seconds through a decentralized set of operators.

- **Tanssi/Ethereum Bridge**: Move liquidity to and from Ethereum using the [built-in bridge](/learn/tanssi/tanssi-ethereum-bridge/){target=\_blank} based on Snowbridge.

- **Key Integrations**: Appchains built with Tanssi can access key infrastructural components alongside block production in a fully automated and standardized way. Tanssi-powered appchains come with built-in support for essential tools, including wallets, block explorers, indexers, RPC providers, and more, saving developers the effort of integrating these components. 

- **Modular Blockchain Framework**: Appchains built with Tanssi can use a modular blockchain framework called [Substrate](https://docs.polkadot.com/develop/parachains/intro-polkadot-sdk/){target=\_blank}, which enables developers to quickly and easily build optimized and customizable blockchains for any use case. Tanssi handles most infrastructural complexities, allowing developers to focus on their appchain's custom logic.

In summary, appchains deployed through Tanssi are sovereign Layer 1 solutions designed to be highly modular and interconnected, with a focus on simplifying the deployment process and enabling customization of the appchain itself. This empowers developers to bring their blockchain applications to market faster, securely, and with greater potential for integration and interaction within the broader blockchain ecosystems.

### Key Aspects of Tanssi {: #tanssi-key-aspects }

The following table summarizes the main benefits Tanssi brings to your project:

| Aspect                   | The Tanssi Solution                                                                                                               |
|--------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| Deployment Time          | - Minutes to deploy<br/> - Faster time to market                                                                                          |
| Block production         | - Sequencing as a service<br/>- Decentralized set of sequencers by design                                                         |
| Security                 | - Ethereum-grade security from the start                                                                                          |
| Finality/Settlement      | - Deterministic<br/>- Finality in seconds                                                                                         |
| Cost                     | - Registration bond + Pay-as-you-go model                                                                                         |
| Customizability          | - Choose the governance mechanism that best suits your project<br/> - Modular framework<br/>- Full runtime customizability<br/> |
| Integrations and tooling | - Essential tools available from the start                                                                                        |

## General Architecture of Tanssi & Tanssi-powered Appchains {: #tanssi-architecture }

As previously discussed, appchains deployed through Tanssi are sovereign and customizable blockchains that, among other features, leverage sequencing as a service and inherit block finality from an external security provider.

A high-level overview of the architecture is presented below, featuring [Symbiotic](https://symbiotic.fi/){target=\_blank} as the security provider.

![High-level overview of an appchain & Tanssi](/images/learn/tanssi/overview/overview-1.webp)

The Tanssi protocol manages and orchestrates a decentralized set of sequencers assigned to provide block production services to Tanssi-powered appchains. The sequencers execute transactions and include them in blocks, which the security provider's operators then proceed to validate. Symbiotic's restaking protocol allows its operators to offer Ethereum-grade economic security. The mechanism of how this works is explained in two separate articles: [Block Production Services](/learn/tanssi/network-services/block-production/){target=\_blank} and [Ethereum with Symbiotic](/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}.

While the sequencers providing block production services are rotated and reassigned to a different appchain upon every session change, each appchain will have its own set of Data Preservers running full archive nodes, ensuring data availability. These Data Preservers will provide the RPC infrastructure for apps and users interacting with Tanssi-powered appchains.

![Data Preservers of an appchain & Tanssi](/images/learn/tanssi/overview/overview-2.webp)

## What's Next? {: #whats-next }

- Head to the [Tanssi dApp](https://apps.tanssi.network){target=\_blank} and launch your appchain.
- Interact with a live Tanssi-powered appchain: the [Tanssi Demo EVM appchain](/builders/tanssi-network/testnet/demo-evm-network/){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/learn/tanssi/tanssi-ethereum-bridge/
--- BEGIN CONTENT ---
---
title: Tanssi-Ethereum Bridge
description: Discover how Tanssi bridge enables secure, trustless cross-chain interoperability, facilitating asset and message transfers between Tanssi and Ethereum.
icon: octicons-link-24
categories: Basics
---

# Tanssi-Ethereum Bridge {: #tanssi-ethereum-bridge }

## Introduction {: #introduction }

Traditional blockchains often create silos, limiting asset and functional interoperability. The Tanssi-Ethereum bridge overcomes these limitations by enabling seamless cross-chain operations that benefit both ecosystems.

The bridge is more than an asset exchange. Itâ€™s a secure, standardized protocol for direct cross-chain interaction without centralized intermediaries. Its trustless design avoids the risks of central points of failure that many other bridges face.

This article introduces the Tanssi-Ethereum bridge as a key interoperability layer between the two networks. Youâ€™ll learn how it works, including its architecture, operator management, economic model, slashing mechanisms, and asset transfers.

You'll also learn about the consensus layers that secure communication (BEEFY on [Tanssi](https://docs.tanssi.network/learn/tanssi/){target=\_blank} and the [Ethereum Beacon Chain](https://ethereum.org/roadmap/beacon-chain/){target=\_blank}), and the roles of provers, verifiers, and relayers, giving you a clear view of how assets and messages move securely between Tanssi and Ethereum.

## Core Functions { : #core-functions }

The bridge facilitates several critical operations between Tanssi and Ethereum:

- **Operator Management** - maintains operator stake information on Ethereum via the [Symbiotic](/learn/tanssi/external-security-providers/symbiotic/#tanssi-symbiotic){target=\_blank} protocol, providing this data to Tanssi for selecting active, decentralized, and economically aligned operators each era
- **Economic Operations** - distributes [rewards](/learn/tanssi/external-security-providers/symbiotic/#rewards){target=\_blank} from Tanssi to Ethereum stakers and operators
- **Slashing** - processes [slashing requests](/learn/tanssi/external-security-providers/symbiotic/#slashing){target=\_blank} from Tanssi to Ethereum when operators violate protocol rules
- **Asset Transfer** - enables bilateral, trustless asset transfers between Tanssi and Ethereum, enhancing liquidity.

This interoperability expands the potential of decentralized applications and significantly enhances the liquidity and usability of blockchain assets.

## The Bridge Architecture { : #bridge-architecture }

Understanding the bridge's consensus functionality requires examining its core components: provers, verifiers, and relayers. Provers generate cryptographic proofs, verifiers validate them, and relayers move data between chains.

Provers include Tanssi's BEEFY module and Ethereum's Beacon Chain consensus. They produce consensus data transmitted by specialized relayers.

Each chain runs a [light client](https://ethereum.org/developers/docs/nodes-and-clients/light-clients/){target=\_blank} of the other, acting as an on-chain verifier for data legitimacy. For instance, when Tanssi sends a message to Ethereum, it generates compact proofs of events or state changes based on its consensus. Ethereum's light client verifies these proofs before acting. This efficient method avoids processing the entire sending chain's state, relying instead on concise cryptographic proof verification.

### Tanssi to Ethereum Consensus  { : #tanssi-ethereum-consensus }

BEEFY (Bridge Efficiency Enabling Finality Yielder) is Tanssi's consensus protocol, which acts as a prover. It's designed for efficient, trustless bridging to chains like Ethereum that are not natively built for interoperability.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Tanssi_Pallet as Tanssi <br/> BEEFY Pallet (prover)
    participant Beefy_Relayer as Relayer <br/> (Beefy)
    participant Eth_BeefyClient as Ethereum <br/> BEEFY Client (verifier)

    Tanssi_Pallet->>Beefy_Relayer: Generate BEEFY Commitment
    activate Beefy_Relayer
    Beefy_Relayer->>Eth_BeefyClient: Submit commitment/proof
    deactivate Beefy_Relayer

    activate Eth_BeefyClient
    Eth_BeefyClient->>Eth_BeefyClient: Verify commitment
    deactivate Eth_BeefyClient

```

### Ethereum to Tanssi Consensus { : #ethereum-tanssi-consensus }

For Ethereum-to-Tanssi bridging, Ethereum's Beacon Chain consensus is the prover. It provides Tanssi's on-chain light client with proof of Ethereum's finalized state, including events or messages for Tanssi.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Eth_BeaconCons as Ethereum <br/> Beacon Chain Consensus(Prover)
    participant Beacon_Relayer as Relayer <br/> (Beacon)
    participant Tanssi_EthClient as Tanssi <br/> Ethereum Light Client (verifier)

    Eth_BeaconCons->>Beacon_Relayer: Beacon chain update (Header/Proof)
    activate Beacon_Relayer
    Beacon_Relayer->>Tanssi_EthClient: Submit update/proof
    deactivate Beacon_Relayer

    activate Tanssi_EthClient
    Tanssi_EthClient->>Tanssi_EthClient: Verify update/proof
    deactivate Tanssi_EthClient
```

From a messaging perspective, the bridge uses its consensus verification layer for secure cross-chain communication. Dedicated relayers transport messages: the Execution Relay for Ethereum to Tanssi, and the Tanssi Relay for Tanssi to Ethereum.

Relayers are stateless and only submit proofs. They cannot forge messages or steal funds, as the consensus mechanism revalidates each proof on-chain. Multiple concurrent relayers improve responsiveness without centralizing power.

Ethereum's `Gateway` contract is the central messaging point. It receives messages from Tanssi via relayers, validates them using consensus proofs, and executes operations like token minting/unlocking or smart contract calls.

### Ethereum to Tanssi Inbound Messages { : #ethereum-tanssi-messages }

This section describes messages from Ethereum to Tanssi, using Ethereum's Beacon Chain consensus for proofs and an Execution Relay (or Beacon Relay).

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Eth_Gateway as Ethereum <br/> Gateway Contract
    participant Exec_Relay as Relayer <br/> (Execution Relay)
    participant Tanssi_InQueue as Tanssi <br/> Inbound Queue

    Note over Eth_Gateway: Message Ready / Event Occurs
    Eth_Gateway->>Exec_Relay: Message + Proof
    activate Exec_Relay
    Exec_Relay->>Tanssi_InQueue: Submit Message/Proof
    deactivate Exec_Relay

    activate Tanssi_InQueue
    Tanssi_InQueue->>Tanssi_InQueue: Process Inbound Message
    deactivate Tanssi_InQueue
```

### Tanssi to Ethereum Outbound Messages { : #tanssi-ethereum-messages }

This section describes messages from Tanssi to Ethereum, using BEEFY consensus to prove Tanssi's state and a Tanssi Relay for transmission.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Tanssi_OutQueue as Tanssi <br/> Outbound Queue
    participant Para_Relay as Relayer <br/> (Tanssi Relay)
    participant Eth_Gateway as Ethereum <br/> Gateway Contract

    Note over Tanssi_OutQueue: Message Ready / Proof Committed
    Tanssi_OutQueue->>Para_Relay: Message + Proof
    activate Para_Relay
    Para_Relay->>Eth_Gateway: Submit Message/Proof
    deactivate Para_Relay

    activate Eth_Gateway
    Eth_Gateway->>Eth_Gateway: Process Outbound Message
    deactivate Eth_Gateway
```

The `Gateway` manages Ethereum's outbound communications. For cross-chain transfers, it logs an event, locks tokens if necessary, and packages data for relay to Tanssi. Tanssi uses two queues for efficient message processing.

The `Outbound Queue` handles messages to Ethereum. It bundles them and adds a [Merkle root](https://en.wikipedia.org/wiki/Merkle_tree){target=\_blank} (cryptographic commitment) to each block header. This allows Ethereum's light client to verify message inclusion using consensus proofs efficiently.

The `Inbound Queue` processes messages from Ethereum. It receives and verifies proofs of Ethereum events via Tanssi's on-chain Ethereum light client. Verified events become internal instructions in Tanssi. This layered, consensus-secured architecture ensures trustless cross-chain interactions.

## Token Transfers Flow {: #token-transfers-flow }

This section explains how the bridge moves assets and messages. It involves locking/minting assets on one chain and a complementary action on the other, secured by verified proofs. The following describes the typical transfer sequences.

1. **Initiation (Source Chain)** - user initiates asset transfer
2. **Relay Proof** - off-chain relayers pick up the event and submit cryptographic proofs to the destination chain
3. **Verification (Destination Chain)** - on-chain light clients independently verify submitted proofs
4. **Execution** - upon successful verification, tokens are minted/unlocked on the destination chain

### Ethereum to Tanssi Transfer

This section outlines asset movement from Ethereum to Tanssi (as derivative assets).

1. **Lock on Ethereum** - a user deposits assets into Ethereum's Bridge contract. The contract locks the tokens and emits a deposit event
2. **Relay Proof to Tanssi** - an off-chain relayer detects the finalized event, creates a proof package (including Ethereum block header and Merkle proof of the deposit), and submits it to the Tanssi Bridge's `Inbound Queue`
3. **Verify on Tanssi** - Tanssi Bridge's `EthereumClient` module (an on-chain light client) receives the proof from the `Inbound Queue`. It verifies the Ethereum block header's finality/validity and the Merkle proof's authenticity
4. **Mint on Tanssi** - upon successful verification by the `EthereumClient`, the `Inbound Queue` is notified and mints the corresponding asset on Tanssi

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant User
    participant EBridge as Ethereum Bridge Contract
    participant Relayer
    participant TBP as Tanssi Bridge<br/> (Inbound Queue + ETH Client)
    participant TAH as Tanssi

    User->>EBridge: 1. Deposit Asset
    activate EBridge
    Note over EBridge: Lock Tokens & Emit Event
    deactivate EBridge

    Relayer->>Relayer: Observe Ethereum Event
    Relayer->>TBP: 2. Submit Header + Merkle Proof
    activate TBP
    Note over TBP: Receive Proof (Inbound Queue)
    TBP->>TBP: 3. Verify Proof (EthereumClient Pallet)
    TBP->>TAH: Send Mint Request
    deactivate TBP

    activate TAH
    TAH->>TAH:  4. Mint Asset
    TAH-->>User: (Asset appears in Recipient Account)
    deactivate TAH
```

### Tanssi to Ethereum Transfer

This flow describes the reverse process, moving assets from Tanssi to Ethereum.

1. **Initiate and Commit on Tanssi** - user initiates a transfer on Tanssi. A message with transfer details goes to the Bridge's `Outbound Queue`. The queue processes it, bundles the payload, and commits its Merkle root to the Tanssi block header, representing all outgoing messages in that block
2. **Relay Proof to Ethereum** - an off-chain relayer monitors Tanssi for finalized blocks with `Outbound Queue` Merkle roots. It retrieves proofs: a BEEFY commitment (signed statement of finalized Tanssi block headers) and a Merkle proof of the user's transfer payload under the committed root
3. **Submit Commitment in Ethereum** - the relayer submits the BEEFY commitment and Merkle proof to Ethereum's `Gateway` contract
4. **Verify on Ethereum** - Ethereum's Beefy Client contract (Tanssi's on-chain light client) receives the BEEFY commitment from the `Gateway` and verifies its validity (including signatures)
5. **Validate Payload** - after commitment verification, the `Gateway` validates the Merkle proof for the user's payload
6. **Execute on Ethereum** - with both proofs verified, the `Gateway` contract executes the action, usually releasing locked assets via the main Bridge contract to the recipient or executing a target contract call on Ethereum

The following diagram illustrates the initiation and commitment phase of the asset transfer process on the Tanssi side.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant User
    participant TAH as Tanssi
    participant TBP as Tanssi Bridge<br/> (Outbound Queue)
    participant Relayer

    User->>TAH: 1. Initiate Transfer & Deposit Asset
    activate TAH
    TAH->>TBP: Send message to Outbound Queue
    deactivate TAH

    activate TBP
    Note over TBP: Process message, Bundle, and<br/>Commit Merkle Root to Tanssi Header
    deactivate TBP

    Relayer->>Relayer: 2. Observe Tanssi Header /<br/>BEEFY Commitment & Get Proof
    Note over Relayer: Relayer is now ready to interact<br/>with Ethereum based on observed data.
```

The subsequent diagram details the relay, verification, and execution steps on the Ethereum side of the asset transfer.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Relayer
    participant EGateway as Ethereum Gateway Contract
    participant EBeefy as Ethereum Beefy Client Contract
    participant EBridge as Ethereum Bridge Contract
    participant User

    Relayer->>EGateway: 3. Submit BEEFY Commitment + Merkle Proof
    activate EGateway
    EGateway->>EBeefy: 4. Verify BEEFY Commitment
    activate EBeefy
    EBeefy-->>EGateway: Verification OK
    deactivate EBeefy

    EGateway->>EGateway: 5. Verify Merkle Proof for Payload
    Note over EGateway: Proof Validated

    EGateway->>EBridge: 6. Execute: Unlock Tokens / Call Target Contract
    activate EBridge
    Note over EBridge: Assets Transferred or<br/>Target Call Executed
    EBridge-->>User: (Tokens Received / Call Executed)
    deactivate EBridge
    deactivate EGateway
```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/
--- BEGIN CONTENT ---
---
title: Run Infrastructure on Tanssi
description: This section offers guides on setting up infrastructure and nodes for RPC services, block production, and validation within the Tanssi ecosystem.
template: root-index-page.html
---

# Node Operators

Operating nodes is a crucial part of maintaining a blockchain ecosystem, and Tanssi ensures that this process is as seamless as possible. From running network nodes and managing sequencers to onboarding operators, this section provides everything you need to get started and operate efficiently.

Whether you're setting up for the first time, handling operational tasks, or retiring your node, these guides offer clear and concise instructions to help you maintain secure and reliable operations.

### Node Types in the Tanssi Ecosystem

Understanding the roles of different nodes in the Tanssi-powered network helps you choose the right one based on your desired level of participation in the Tanssi ecosystem:

- [**Network nodes**](/node-operators/network-node/) - provide RPC endpoints and data availability services for smooth data flow and interaction between chains and users
- [**Sequencers**](/node-operators/sequencers/) - responsible for block production within the Tanssi ecosystem, sequencers collect transactions, execute them, and compile them in blocks, keeping liveness and operational continuity for all the Tanssi-powered networks
- [**Operators**](/node-operators/operators/) - also known as network validators, operators are responsible for securing the ecosystem. They verify every block produced by sequencers within Tanssi-powered networks, checking that the included transactions are valid. Operators must register and stake in the security provider (e.g., [Symbiotic](/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}). They also produce blocks for the Tanssi network itself, keeping its liveness

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/network-node/
--- BEGIN CONTENT ---
---
title: Run a Node
description: Learn how to set up and run nodes for Tanssi and Tanssi-powered networks. This will allow you to host your own RPC endpoints for chain interaction.
icon: octicons-globe-24
template: index-page.html
---

# Run a Node

Setting up a network node is essential for interacting with Tanssi or your Tanssi-powered network, providing a secure and dedicated RPC endpoint. This section offers step-by-step guides to help you configure and manage different types of nodes effectively.

- [**Tanssi Node**](/node-operators/network-node/tanssi) - a Tanssi node connects directly to the Tanssi network, allowing you to interact via RPC endpoint
- [**Tanssi-powered Network Node**](/node-operators/network-node/tanssi-powered-network) - run a node for your Tanssi-powered network, enabling you to maintain your own RPC endpoint

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/network-node/tanssi-powered-network/
--- BEGIN CONTENT ---
---
title: Run a Node on a Tanssi-Powered Network
description: Learn how to set up and run a node on a Tanssi-powered network using Docker or Systemd, which allows you to host your own RPC endpoint for chain interaction.
icon: octicons-globe-24
template: index-page.html
---

# Run a Node on a Tanssi-Powered Network

Setting up a network node is essential for interacting with your Tanssi-powered network and providing a secure and dedicated RPC endpoint. This section offers step-by-step guides to help you configure and manage your node effectively. Explore two different approaches for running your node:

- [**Using Docker**](/node-operators/network-node/tanssi-powered-network/rpc-docker/) - instructions to set up your node in a containerized environment for easy deployment and isolation
- [**Using Systemd**](/node-operators/network-node/tanssi-powered-network/rpc-systemd/) - guidance for configuring your node as a service, enabling automated management and system integration

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/network-node/tanssi-powered-network/rpc-docker/
--- BEGIN CONTENT ---
---
title: Run an Appchain Node Using Docker
description: Discover how to configure and operate a Tanssi-powered appchain node using Docker, enabling you to host your own RPC endpoint to interact with your appchain.
icon: material-docker
categories: RPC-Data-Preservers
---

# Run an Appchain Node Using Docker

## Introduction {: #introduction }

Running a Tanssi-powered appchain node allows you to connect to and interact with the appchain using your infrastructure via either HTTP or WebSocket protocols.

Nodes store block data and network state. However, developers can run different kinds of nodes:

 - **Full Archive Node** - a node storing the entire block data and network state at all block heights. Such nodes are helpful when querying historical data from old blocks. However, a full archive node takes up a lot of space

  - **Full Pruned Node** - a node storing block data and network state up to some specific number of blocks before the current block height. Such nodes are helpful when querying recent data or submitting transactions through your infrastructure. They require much less space than an archival node but don't store the full network state

In this guide, you'll learn how to quickly spin up a Tanssi appchain node using [Docker](https://www.docker.com){target=\_blank} on a Linux computer. However, it can be adapted to other operating systems.

!!! note
    It is not possible to run an RPC node for quick Trial appchains as they run on a private network, and their nodes are, therefore, unreachable for syncing.

## Checking Prerequisites {: #checking-prerequisites }

### Installing Docker {: #installing-docker}

To get started, you'll need access to a computer running a Linux OS and install [Docker](https://docs.docker.com/desktop/setup/install/linux/){target=\blank}.

Run the following command to install Docker on a Linux Ubuntu platform:

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

And the following command to check the installation:

```bash
sudo docker run hello-world
```

This is what a successful execution in the terminal looks like:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>sudo docker run hello-world</span>
  <span data-ty>
    <br> 
    <br> Hello from Docker!
    <br> This message shows that your installation appears to be working correctly.
    <br> 
    <br> To generate this message, Docker took the following steps:
    <br> 1. The Docker client contacted the Docker daemon.
    <br> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    <br>     (amd64)
    <br> 3. The Docker daemon created a new container from that image which runs the
    <br>     executable that produces the output you are currently reading.
    <br> 4. The Docker daemon streamed that output to the Docker client, which sent it
    <br>     to your terminal.
    <br>
    <br> To try something more ambitious, you can run an Ubuntu container with:
    <br> $ docker run -it ubuntu bash
    <br>
    <br> Share images, automate workflows, and more with a free Docker ID:
    <br> https://hub.docker.com/
    <br>
    <br> For more examples and ideas, visit:
    <br>  https://docs.docker.com/get-started/
  </span>
</div>

## Getting Specifications Files {: #getting-specifications-files }

An appchain node needs information about two different blockchains to run properly: the appchain and the Tanssi orchestration chain. 

That information is a file called chain specifications, and it holds, among other things, the genesis state of the blockchain, allowing the node to verify and sync properly the blocks and state it receives from other nodes.

To get the Tanssi specifications file, execute the following command:

=== "Tanssi MainNet"

    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json
    ```

=== "Dancelight TestNet"
    
    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json
    ```

To get the appchain specification file, download it from the dashboard in the [dApp](https://apps.tanssi.network){target=\_blank} by clicking the **Network Data** link

![Getting the chain specs](/images/node-operators/network-node/rpc-systemd/rpc-systemd-1.webp)

## Setup the Data Directory {: #setup-data-directory }

Running a sequencer or an appchain node require syncing with two chains: the Tanssi orchestration chain and the appchain it is working for.

Run the following command to create the directory where your node will store the databases containing blocks and chain states:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the Docker image to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    chown INSERT_DOCKER_USER /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    chown INSERT_DOCKER_USER /var/lib/dancelight-data
    ```

Or run the following command if you want to run the sequencer with the current logged-in user:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data
    ```

Move the chain specification file to the folder:

=== "Tanssi MainNet"

    ```bash
    mv ./starlight-raw-specs.json /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    mv ./dancelight-raw-specs.json /var/lib/dancelight-data
    ```

!!! note
    The directory is a parameter in the Docker start-up command. If you decide to create the directory elsewhere, update the command accordingly.

## Pulling the Docker Image {: #pulling-docker-image }

Two Docker images are built and published as part of the automated deployment process for every release: one for EVM-compatible appchains and the other for Substrate appchains.

These Docker images include all the binary files required to run the latest stable release of the [client node](/learn/framework/architecture/#architecture){target=\_blank}. 

Depending on the type of appchain you want to run the node for, pull the corresponding image.

### EVM-Compatible Appchains {: #pulling-evm-docker-image }

If the Tanssi-powered appchain was registered in the dApp choosing the EVM template or uploading a custom specification representing a Tanssi EVM-compatible appchain, then execute the following command to pull the Docker image:

=== "Tanssi MainNet"

    ```bash
    docker pull moondancelabs/container-chain-evm-template
    ```

=== "Dancelight TestNet"

    ```bash
    docker pull moondancelabs/container-chain-evm-template
    ```

The command will download and extract the image and show the status upon execution:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker pull moondancelabs/container-chain-evm-template</span>
  <span data-ty>
    <br> 
    <br> Using default tag: latest
    <br> latest: Pulling from moondancelabs/container-chain-evm-template
    <br> 31ad3619f756: Already exists 
    <br> 8f3d9759dcde: Pull complete 
    <br> de5eaba9b289: Pull complete 
    <br> Digest: sha256:4930d631a8ac7f7852754d4cf77bb3317229d768f44092a00295ba50641b2a33
    <br> Status: Downloaded newer image for moondancelabs/container-chain-evm-template
    <br> docker.io/moondancelabs/container-chain-evm-template:latest
  </span>
</div>

### Simple Substrate Appchains {: #pulling-substrate-docker-image }

If the appchain was registered in the dApp choosing the basic Substrate template or uploading a custom specification file representing a Substrate appchain, then execute the following command to pull the Docker image:

=== "Tanssi MainNet"

    ```bash
    docker pull moondancelabs/container-chain-simple-template
    ```

=== "Dancelight TestNet"

    ```bash
    docker pull moondancelabs/container-chain-simple-template
    ```

The command will download and extract the image and show the status upon execution, showing a similar output as the previous terminal image.

## Start-Up Command {: #start-up-command }

To spin up your node, you must run the Docker image with the `docker run` command. Note that you'll need to modify the following parameters:

- `Appchain specs file` - replace `INSERT_YOUR_APPCHAIN_SPECS_FILE` with your appchain specs file name, downloaded in the [Getting Specifications Files](#getting-specifications-files) step.
- `Bootnode` - a bootnode is a full archive node that is used to sync the network from scratch. You'll need to [retrieve your Tanssi network bootnode](#fetching-bootnode-information) and replace `INSERT_YOUR_NETWORK_BOOTNODES` with the actual bootnode information.

=== "Tanssi MainNet"

    === "EVM-compatible Appchain"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        moondancelabs/container-chain-evm-template \
        --chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \
--rpc-port=9944 \
--name=appchain \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--name=relay \
--chain=/data/starlight-raw-specs.json \
--rpc-port=9945 \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC
        ```

    === "Simple Substrate Appchain"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        moondancelabs/container-chain-simple-template \
        --chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \
--rpc-port=9944 \
--name=appchain \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--name=relay \
--chain=/data/starlight-raw-specs.json \
--rpc-port=9945 \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC
        ```

=== "Dancelight TestNet"

    === "EVM-compatible Appchain"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        moondancelabs/container-chain-evm-template \
        --chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \
--rpc-port=9944 \
--name=appchain \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--name=relay \
--chain=/data/dancelight-raw-specs.json \
--rpc-port=9945 \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT
        ```

    === "Simple Substrate Appchain"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        moondancelabs/container-chain-simple-template \
        --chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \
--rpc-port=9944 \
--name=appchain \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--name=relay \
--chain=/data/dancelight-raw-specs.json \
--rpc-port=9945 \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT
        ```

!!! note
    Only the historical state of the last 256 finalized blocks are kept in the local database by default. To run a full archive node, you must set the `--state-pruning archive` flag. More information is in the [flags section](#run-flags).

### Fetching Bootnode Information {: #fetching-bootnode-information}

Bootnode information can be read directly from Tanssi itself. For example, you can use the [developer portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/chainstate){target=\_blank} to get the bootnodes for a specific network in [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.

To do so, take the following steps:

1. Select **dataPreservers** as the module to query
2. Set the storage query to **bootNodes**
3. Provide your Tanssi network ID
4. Click on the **+** sign

![Getting the bootnode](/images/node-operators/network-node/rpc-docker-systemd-1.webp)

### Full Node Example for Demo EVM Appchain {: #example-demo-evm-appchain }

The following example spins up a full archive RPC node for the [demo EVM network](/builders/tanssi-network/testnet/demo-evm-network/){target=\_blank} deployed on Dancelight with an ID of `2001`. This example assumes that the specs files were downloaded and are located in the data folder.

=== "Demo EVM Appchain (Dancelight)"

    ```bash
    docker run --network="host" -v "/var/lib/dancelight-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    moondancelabs/container-chain-evm-template \
    --chain=/data/container-2001-raw-specs.json \
    --rpc-port=9944 \
    --name=demoAppchain \
    --state-pruning=archive \
    --blocks-pruning=archive \
    --database=paritydb \
    --unsafe-rpc-external \
    --bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \
    --bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \
    -- \
    --chain=/data/dancelight-raw-specs.json \
    --rpc-port=9945 \
    --name=relay \
    --sync=fast \
    --database=paritydb \
    --bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
    --bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
    --bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT
    ```

### Run Flags {: #run-flags }

The flags used in the `docker run` command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:

- `--name INSERT_NAME` - a human-readable name for this node
- `--rpc-port INSERT_PORT` - specifies the JSON-RPC TCP port the node listens on
- `--unsafe-rpc-external` - exposes the RPC service on all the interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the state), `archive-canonical` (which keeps only the state of finalized blocks), or any `number` (representing the number of blocks whose states are kept)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - specifies how many blocks should be kept in the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the blocks), `archive-canonical` (which keeps only finalized blocks), or any `number` (representing the amount of finalized blocks to keep)
- `--detailed-log-output` - enables detailed log output

!!! warning
    The `--unsafe-rpc-external` enables external access to your nodeâ€™s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.

For a complete list of available flags, their description, and possible values, run the following command:

=== "EVM-compatible Appchain"

    ```bash
    docker run -ti moondancelabs/container-chain-evm-template --help
    ```

=== "Simple Substrate Appchain"

    ```bash
    docker run -ti moondancelabs/container-chain-simple-template --help
    ```

## Syncing Your Node {: #syncing-your-node }

Once your node spins up, the syncing process displays a lot of log information from both the node and the Tanssi appchain. Some errors are expected to be displayed at the beginning of the process, disappearing once the chain gets synced to the last block.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker run ....</span>
  <span data-ty>
    <br> 2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] ðŸ’¤ Idle (0 peers), best: #0 (0x4a2bâ€¦7de3), finalized #0 (0x4a2bâ€¦7de3), â¬‡ 0 â¬† 0
    <br> 2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] âœ¨ Imported #14139635 (0x8c41â€¦8df6)    
    <br> 2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] ðŸ’¤ Idle (8 peers), best: #14139635 (0x8c41â€¦8df6), finalized #14139632 (0xa9a8â€¦cab9), â¬‡ 32.7kiB/s â¬†
  </span>
</div>

!!! note
    The length of the syncing process is directly proportional to the size of the chain you are syncing to.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/network-node/tanssi-powered-network/rpc-systemd/
--- BEGIN CONTENT ---
---
title: Run an Appchain Node Using Systemd
description: Learn how to set up and run a Tanssi-powered appchain node using Systemd, which allows you to have your own RPC endpoint to interact with your appchain.
icon: simple-linux
categories: RPC-Data-Preservers
---

# Run an Appchain Node Using Systemd

## Introduction {: #introduction }

Running a Tanssi-powered appchain node allows you to connect to and interact with the appchain using your infrastructure via either HTTP or WebSocket protocols.

Nodes store block data and network state. However, developers can run different kinds of nodes:

 - **Full Archive Node** - a node storing the entire block data and network state at all block heights. Such nodes are helpful when querying historical data from old blocks. However, a full archive node takes up a lot of space

  - **Full Pruned Node** - a node storing block data and network state up to some specific number of blocks before the current block height. Such nodes are helpful when querying recent data or submitting transactions through your infrastructure. They require much less space than an archival node but don't store the full network state

In this guide, you'll learn how to spin up a Tanssi appchain node using a binary executable file and manage the service with [Systemd](https://systemd.io){target=\_blank} on Linux systems.

The article follows the good practice of running the service with its own non-root account and granting that account write access to a specific directory. However, you can adapt this article's steps and instructions to your infrastructure configuration, preferences, and security policies.

!!! note
    It is not possible to run an RPC node for quick Trial appchains as they run on a private network, and their nodes are, therefore, unreachable for syncing.

## Checking Prerequisites {: #checking-prerequisites }

To get started, you'll need access to a computer running an Ubuntu Linux OS and root privileges. You will also need:

- **Node binary file** - the instructions in this guide execute the [latest](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank} official stable node release. If you want to build and run your own file, make sure to follow the instructions for [building your appchain node](/builders/build/customize/prerequisites/){target=\_blank}.

- **Chain specifications files** - the node needs information about two different blockchains to sync and run correctly. The following section will show you how to get those files.

## Getting Specifications Files {: #getting-specifications-files }

An appchain node needs information about two different blockchains to run properly: the appchain and the Tanssi orchestration chain. 

That information is a file called chain specifications, and it holds, among other things, the genesis state of the blockchain, allowing the node to verify and sync properly the blocks and state it receives from other nodes.

To get the Tanssi specifications file, execute the following command:

=== "Tanssi MainNet"

    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json
    ```

=== "Dancelight TestNet"
    
    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json
    ```

To get the appchain specification file, download it from the dashboard in the [dApp](https://apps.tanssi.network){target=\_blank} by clicking the **Network Data** link

![Getting the chain specs](/images/node-operators/network-node/rpc-systemd/rpc-systemd-1.webp)

## Download the Latest Release {: #download-latest-release }

Every new release includes two node binaries, one for EVM-compatible networks and another for Substrate networks. To get started, run the following command to get the latest release binary that matches your network type and make it executable:

=== "EVM-Compatible Network"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/container-chain-frontier-node && \
    chmod +x ./container-chain-frontier-node
    ```

=== "Substrate Network"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/container-chain-simple-node && \
    chmod +x ./container-chain-simple-node
    ```

!!! note
    It is recommended that you run the optimized binary versions for either Intel's [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} or AMD's [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} architectures for better performance.

## Setup the Systemd Service {: #setup-systemd-service }

[Systemd](https://systemd.io){target=\_blank} is a management system for Linux systems that manages services (daemons in Unix-like systems jargon), starting them automatically when the computer starts or reboots, or restarting them upon unexpected failures.

The following commands configure a new account, the directory, and move the previously downloaded files to the right location.

Create a new account to run the service:

=== "Tanssi MainNet"

    ```bash
    adduser tanssi_service --system --no-create-home
    ```

=== "Dancelight TestNet"

    ```bash
    adduser dancelight_service --system --no-create-home
    ```

Create a directory to store the required files and data:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the service to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R tanssi_service /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    sudo chown -R dancelight_service /var/lib/dancelight-data
    ```

Move the chain specification file to the folder:

=== "Tanssi MainNet"

    ```bash
    mv ./starlight-raw-specs.json /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mv ./dancelight-raw-specs.json /var/lib/dancelight-data
    ```

Move the node binary as well: 

=== "Tanssi MainNet"

    === "EVM-Compatible Appchain"

        ```bash
        mv ./container-chain-frontier-node /var/lib/tanssi-data
        ```

    === "Substrate Network"

        ```bash
        mv ./container-chain-simple-node /var/lib/tanssi-data
        ```

=== "Dancelight TestNet"

    === "EVM-Compatible Appchain"

        ```bash
        mv ./container-chain-frontier-node /var/lib/dancelight-data
        ```

    === "Substrate Network"

        ```bash
        mv ./container-chain-simple-node /var/lib/dancelight-data
        ```

Finally, move also your appchain's spec file to the same folder.

### Create the Systemd Service Configuration File {: #create-systemd-configuration }

The next step is to create the Systemd configuration file.

You can create the file by running the following command:

```bash
sudo touch /etc/systemd/system/appchain.service
```

Now, you can open the file using your favorite text editor (vim, emacs, nano, etc.) and add the configuration for the service.

Note that the `ExecStart` command  has some parameters that need to be changed to match your specific network:

- `Specification file` - replace `INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME` with your appchain's file name. Your path will look like `/var/lib/tanssi-data/YOUR_FILENAME.json`, for a MainNet appchain.
- `Bootnode` - a bootnode is a full archive node that is used to sync the network from scratch. You'll need to [retrieve your Tanssi network bootnode](#fetching-bootnode-information) and replace `INSERT_YOUR_NETWORK_BOOTNODES` with the actual bootnode information.

=== "Tanssi MainNet"

    === "EVM-Compatible Appchain"

        ```bash
        [Unit]
        Description="Appchain systemd service"
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        Restart=on-failure
        RestartSec=10
        User=tanssi_service
        SyslogIdentifier=network
        SyslogFacility=local7
        KillSignal=SIGHUP
        ExecStart=/var/lib/tanssi-data/container-chain-frontier-node \
        --chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \
--rpc-port=9944 \
--name=para \
--base-path=/var/lib/tanssi-data \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--chain=/var/lib/tanssi-data/starlight-raw-specs.json \
--rpc-port=9945 \
--name=relay \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC

        [Install]
        WantedBy=multi-user.target
        ```

    === "Substrate Network"

        ```bash
        [Unit]
        Description="Appchain systemd service"
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        Restart=on-failure
        RestartSec=10
        User=tanssi_service
        SyslogIdentifier=network
        SyslogFacility=local7
        KillSignal=SIGHUP
        ExecStart=/var/lib/tanssi-data/container-chain-simple-node \
        --chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \
--rpc-port=9944 \
--name=para \
--base-path=/var/lib/tanssi-data \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--chain=/var/lib/tanssi-data/starlight-raw-specs.json \
--rpc-port=9945 \
--name=relay \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC

        [Install]
        WantedBy=multi-user.target
        ```

=== "Dancelight TestNet"

    === "EVM-Compatible Network"

        ```bash
        [Unit]
        Description="Appchain systemd service"
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        Restart=on-failure
        RestartSec=10
        User=dancelight_service
        SyslogIdentifier=network
        SyslogFacility=local7
        KillSignal=SIGHUP
        ExecStart=/var/lib/dancelight-data/container-chain-frontier-node \
        --chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \
--rpc-port=9944 \
--name=para \
--base-path=/var/lib/dancelight-data \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \
--rpc-port=9945 \
--name=relay \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT

        [Install]
        WantedBy=multi-user.target
        ```

    === "Substrate Network"

        ```bash
        [Unit]
        Description="Appchain systemd service"
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        Restart=on-failure
        RestartSec=10
        User=dancelight_service
        SyslogIdentifier=network
        SyslogFacility=local7
        KillSignal=SIGHUP
        ExecStart=/var/lib/dancelight-data/container-chain-simple-node \
        --chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \
--rpc-port=9944 \
--name=para \
--base-path=/var/lib/dancelight-data \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \
--rpc-port=9945 \
--name=relay \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT

        [Install]
        WantedBy=multi-user.target
        ```

### Fetching Bootnode Information {: #fetching-bootnode-information}

Bootnode information can be read directly from Tanssi itself. For example, you can use the [developer portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/chainstate){target=\_blank} to get the bootnodes for a specific network in [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.

To do so, take the following steps:

1. Select **dataPreservers** as the module to query
2. Set the storage query to **bootNodes**
3. Provide your Tanssi network ID
4. Click on the **+** sign

![Getting the bootnode](/images/node-operators/network-node/rpc-docker-systemd-1.webp)

### Full Node Configuration Example for the Demo EVM Network {: #example-demo-evm-network}

The following example deploys a fully functional full archive node for the [demo EVM network](/builders/tanssi-network/testnet/demo-evm-network/){target=\_blank} deployed on Dancelight with an ID of `2001`.

The raw chain specification file for the demo network is required to run the node, and can be downloaded from this [public GitHub repository](https://github.com/papermoonio/external-files/blob/main/Tanssi/Demo-EVM-Appchain){target=\_blank}. Download the file and place it in the `/var/lib/dancelight-data/` directory.

=== "Demo EVM Appchain (Dancelight)"

    ```bash
    [Unit]
    Description="Appchain systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    Type=simple
    Restart=on-failure
    RestartSec=10
    User=dancelight_service
    SyslogIdentifier=network
    SyslogFacility=local7
    KillSignal=SIGHUP
    ExecStart=/var/lib/dancelight-data/container-chain-frontier-node \
    --chain=/var/lib/dancelight-data/container-2001-raw-specs.json \
    --rpc-port=9944 \
    --name=para \
    --state-pruning=archive \
    --blocks-pruning=archive \
    --base-path=/var/lib/dancelight-data \
    --database=paritydb \
    --unsafe-rpc-external \
    --bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \
    --bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \
    -- \
    --chain=/var/lib/dancelight-data/dancelight-raw-specs.json \
    --rpc-port=9945 \
    --name=relay \
    --sync=fast \
    --database=paritydb \
    --bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
    --bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
    --bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT

    [Install]
    WantedBy=multi-user.target
    ```

### Run Flags {: #run-flags }

The flags used in the `ExecStart` command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:

- `--name INSERT_NAME` - a human-readable name for this node
- `--rpc-port INSERT_PORT` - specifies the JSON-RPC TCP port the node listens on
- `--unsafe-rpc-external` - exposes the RPC service on all the interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the state), `archive-canonical` (which keeps only the state of finalized blocks), or any `number` (representing the number of blocks whose states are kept)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - specifies how many blocks should be kept in the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the blocks), `archive-canonical` (which keeps only finalized blocks), or any `number` (representing the amount of finalized blocks to keep)
- `--detailed-log-output` - enables detailed log output

!!! warning
    The `--unsafe-rpc-external` enables external access to your nodeâ€™s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.

For a complete list of available flags, their description, and possible values, run the following command:

=== "EVM-compatible Network"

    ```bash
    /var/lib/dancelight-data/container-chain-frontier-node --help
    ```

=== "Simple Substrate Network"

    ```bash
    /var/lib/dancelight-data/container-chain-simple-node --help
    ```

## Run the Service {: #run-the-service }

Finally, enable the service and start it for the first time:

```bash
systemctl enable appchain.service && \
systemctl start appchain.service
```

You can verify that the service is up and running correctly running:

```bash
systemctl status appchain.service
```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>systemctl status network.service</span>
  <span data-ty>
    <br> â— network.service - "Network systemd service"
    <br>&nbsp;&nbsp;&nbsp;Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)
    <br>&nbsp;&nbsp;&nbsp;Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago
    <br>&nbsp;&nbsp;Main PID: 4045278 (container-chain)
    <br>&nbsp;&nbsp;&nbsp;&nbsp;Tasks: 44 (limit: 9462)
    <br>&nbsp;&nbsp;&nbsp;Memory: 6.5G
    <br>&nbsp;&nbsp;&nbsp;CGroup: /system.slice/network.service
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â””â”€4045278 4045278 /var/lib/network-data/container-chain- ...
  </span>
</div>

And check the logs, if needed, with the following command:

```bash
journalctl -f -u appchain.service
```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>journalctl -f -u network.service</span>
  <span data-ty>
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 Parachain Collator Template
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 âœŒï¸  version 0.1.0-3b1fbbfdfe7
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 â¤ï¸  by Moondance Labs,     <br> 2020-2024
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ðŸ“‹ Chain specification: Frontier Container 2001
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ðŸ·  Node name: para
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ðŸ‘¤ Role: FULL
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ðŸ’¾ Database: RocksDb at /var/lib/network-data/chains/frontier_container_2001/db/full
    <br> Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain id: Id(2001)
    <br> Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain Account: 5Ec4AhPQLGvfWywVhJZwufTDvknLT3BVPQcbV977JmBDUsHP
    <br> Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V0: 0x000000000000000000000000000000000000000000000000000000000000000000e1324cc53e66
    <br> Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V1: 0x000000000000000000000000000000000000000000000000000000000000000000327cfde8482b
  </span>
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/network-node/tanssi/
--- BEGIN CONTENT ---
---
title: Run a Tanssi Node
description: Learn how to set up and run a Tanssi node using Docker or Systemd to interact with the Tanssi network.
icon: octicons-server-24
template: index-page.html
categories: RPC-Data-Preservers
---

# Run a Tanssi Node

Setting up a Tanssi Node is an important step in interacting with and querying the Tanssi network. You have two options for configuration: using _Docker_ or _Systemd_. Whichever path you choose, we provide step-by-step tutorials to guide you through the process.

## Hardware Requirements

Appropriate hardware is essential for running a Tanssi node successfully. A performant setup ensures reliable service and quick response to queries.

Recommended hardware:

- **Recommended Configuration** - bare metal hardware running Linux Debian or Ubuntu
- **Recommended CPUs** - Intel Ice Lake or newer (Xeon or Core series), AMD Zen3 or newer (EPYC or Ryzen). Eight Physical cores @ 3.4 GHz with hyperthreading disabled (SMT for AMD processors)
- **Recommended NVMe** - 500 GB NVMe SSD
- **Recommended RAM** - 32 GB ECC RAM
- **Recommended Network** - 1 Gbps connection

!!! warning
    Maintaining your Tanssi Node's performance, keeping it updated, and ensuring its security are critical for reliable operation.

### Required Network Ports

To ensure proper communication with the Tanssi network, make sure the following port is open for incoming connections:

| Network          | Port        |
|------------------|-------------|
| Tanssi Chain     | 30333 (TCP) |

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/network-node/tanssi/tanssi-node-docker/
--- BEGIN CONTENT ---
---
title: Run a Tanssi Node Using Docker
description: Learn how to set up and run a node for Tanssi network using Docker to provide API endpoints for applications and users.
icon: simple-docker
categories: RPC-Data-Preservers
---

# Run a Tanssi Node Using Docker

## Introduction {: #introduction }

In this guide, you'll learn how to spin up a Tanssi node using the official image release with [Docker](https://www.docker.com){target=\_blank} on Linux systems. Nodes are crucial for the Tanssi ecosystem as they provide stable API endpoints that applications and users can connect to for chain data and transaction submission.

## Checking Prerequisites {: #checking-prerequisites }

### Installing Docker {: #installing-docker}

To get started, you'll need access to a computer running a Linux OS and install [Docker](https://docs.docker.com/desktop/setup/install/linux/){target=\blank}.

Run the following command to install Docker on a Linux Ubuntu platform:

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

And the following command to check the installation:

```bash
sudo docker run hello-world
```

This is what a successful execution in the terminal looks like:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>sudo docker run hello-world</span>
  <span data-ty>
    <br> 
    <br> Hello from Docker!
    <br> This message shows that your installation appears to be working correctly.
    <br> 
    <br> To generate this message, Docker took the following steps:
    <br> 1. The Docker client contacted the Docker daemon.
    <br> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    <br>     (amd64)
    <br> 3. The Docker daemon created a new container from that image which runs the
    <br>     executable that produces the output you are currently reading.
    <br> 4. The Docker daemon streamed that output to the Docker client, which sent it
    <br>     to your terminal.
    <br>
    <br> To try something more ambitious, you can run an Ubuntu container with:
    <br> $ docker run -it ubuntu bash
    <br>
    <br> Share images, automate workflows, and more with a free Docker ID:
    <br> https://hub.docker.com/
    <br>
    <br> For more examples and ideas, visit:
    <br>  https://docs.docker.com/get-started/
  </span>
</div>

### Pull the Docker Image {: #pull-docker-image }

For every release, a Docker image is built and published. It contains all the necessary dependencies a Tanssi node requires and the binary file itself.

A Docker image combines the binary corresponding to the latest stable release of the [client node](/learn/framework/architecture/#architecture){target=\_blank}, along with the Tanssi orchestrator specification file.

Run the following command to pull the Docker image:

=== "Tanssi MainNet"

    ```bash
    docker pull {{ networks.dancelight.operator_docker_image }}
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    docker pull {{ networks.dancelight.operator_docker_image }}
    ```

The command will download and extract the image and show the status upon execution:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker pull moondancelabs/starlight</span>
  <span data-ty>
    <br> 
    <br> Using default tag: latest
    <br> latest: Pulling from moondancelabs/starlight
    <br> e1caac4eb9d2: Pull complete 
    <br> 1d4409959e6d: Pull complete 
    <br> b8beed19c122: Pull complete 
    <br> c0fab1f18601: Pull complete 
    <br> Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c
    <br> Status: Downloaded newer image for moondancelabs/starlight
    <br> docker.io/moondancelabs/starlight
  </span>
</div>

### Set Up the Data Directory {: #set-up-data-directory }

Running a node requires syncing with the Tanssi chain and storing its state.

Run the following command to create the directory where your node will store the databases containing blocks and chain states:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the Docker image to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    chown INSERT_DOCKER_USER /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    chown INSERT_DOCKER_USER /var/lib/dancelight-data
    ```

Or run the following command if you want to run the node with the current logged-in user:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data
    ```

!!! note
    The directory is a parameter in the Docker start-up command. If you decide to create the directory elsewhere, update the command accordingly.

### Generate the Node Key {: #generate-node-key }

To generate and store on disk the session keys that will be referenced in the start-up command, run the following command:

=== "Tanssi MainNet"

    ```bash
    docker run --network="host" -v "/var/lib/tanssi-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ networks.dancelight.operator_docker_image }} key generate-node-key --file /data/node-key
    ```

=== "Dancelight TestNet"

    ```bash
    docker run --network="host" -v "/var/lib/dancelight-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ networks.dancelight.operator_docker_image }} key generate-node-key --file /data/node-key
    ```

!!! note
    This step could be avoided using the `--unsafe-force-node-key-generation` parameter in the start-up command, although this is not the recommended practice.

## Start Your Node {: #start-your-node }

To spin up your node, you must run the Docker image with the `docker run` command.

Replace `INSERT_YOUR_TANSSI_NODE_NAME` with a human-readable name and set `INSERT_YOUR_IP_ADDRESS` with your public IP address.

!!! note
    It is recommended that you run the optimized binary versions for either Intel's [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} or AMD's [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} architectures for better performance.

=== "Tanssi MainNet"

    === "Generic"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

=== "Dancelight TestNet"

    === "Generic"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

### Run Flags {: #run-flags }

The flags used in the `docker run` command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:

- **--state-pruning=archive** - keeps all state data, which is necessary for historical state queries
- **--blocks-pruning=archive** - keeps all blocks, necessary for historical block data
- **--database=paritydb** - uses ParityDB as the database backend, which is optimized for RPC node performance
- **--unsafe-rpc-external** - allows external connections to the RPC server. This is required for the node to be accessible externally, but exposing RPC endpoints carries security risks. Ensure appropriate firewall and security measures are in place (see warning below)

!!! warning
    The `--unsafe-rpc-external` flag opens your RPC node to external connections. In production environments, you should implement additional security measures like a reverse proxy with rate limiting and authentication.

You can view all available flags by running:

=== "Tanssi MainNet"

    ```bash
    docker run -ti {{ networks.dancelight.operator_docker_image }} --help
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    docker run -ti {{ networks.dancelight.operator_docker_image }} --help
    ```

## Syncing Your Node {: #syncing-your-node }

The first time your node spins up, the syncing process displays lots of log information from the node configuration and the chain blocks being synced. Some errors are expected to be displayed at the beginning of the process, disappearing once the chain gets synced to the last block.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker run ....</span>
  <span data-ty>
    <br> 2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] ðŸ’¤ Idle (0 peers), best: #0 (0x4a2bâ€¦7de3), finalized #0 (0x4a2bâ€¦7de3), â¬‡ 0 â¬† 0
    <br> 2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] âœ¨ Imported #14139635 (0x8c41â€¦8df6)    
    <br> 2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] ðŸ’¤ Idle (8 peers), best: #14139635 (0x8c41â€¦8df6), finalized #14139632 (0xa9a8â€¦cab9), â¬‡ 32.7kiB/s â¬†
  </span>
</div>

When the syncing process is finished, your node is ready to serve API requests.

## Testing Your Node {: #testing-your-rpc-node }

After your node is fully synced, you can verify that the RPC endpoint is working correctly by making a simple request. You can use curl to test the connection:

```bash
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method":"chain_getHeader", "params":[]}' http://localhost:9944
```

If the RPC endpoint is working correctly, you should receive a JSON response containing the latest block header information.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/network-node/tanssi/tanssi-node-systemd/
--- BEGIN CONTENT ---
---
title: Run a Tanssi Node Using Systemd
description: Learn how to set up and run a Node for Tanssi networks using Systemd, allowing you to provide API endpoints for applications and users.
icon: simple-linux
categories: RPC-Data-Preservers
---

# Run a Tanssi Node Using Systemd

## Introduction {: #introduction }

In this guide, you'll learn how to spin up a Tanssi Node using the latest stable binary file release and manage the service using [Systemd](https://systemd.io){target=\_blank} on Linux systems. Nodes provide essential API endpoints for applications and users to interact with the Tanssi network.

The article follows the good practice of running the service with its own non-root account and granting that account write access to a specific directory. However, you can adapt this article's steps and instructions to your infrastructure configuration, preferences, and security policies.

## Checking Prerequisites {: #checking-prerequisites }

To get started, you'll need access to a computer running an Ubuntu Linux OS with [Landlock](https://docs.kernel.org/security/landlock.html){target=\_blank} enabled and root privileges. You will also need:

- **Node binary files** - a node requires three binary files: `tanssi-relay`, `tanssi-relay-execute-worker`, and `tanssi-relay-prepare-worker`
``

The instructions in this guide execute the [latest](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank} official stable release. However, you can build your own file by compiling the [source code](https://github.com/moondance-labs/tanssi){target=\_blank}.

## Check Landlock Support {: #check-landlock }

Tanssi nodes use the Linux kernel's Landlock feature as a security measure to restrict access to system resources, limiting the damage if the application is compromised.

Check the Landlock feature support in your system by running the following command:

```bash
sudo dmesg | grep landlock || journalctl -kg landlock
```

The output should look like:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>sudo dmesg | grep landlock || journalctl -kg landlock</span>
    <span data-ty>[    0.240344] landlock: Up and running.</span>
</div>

If Landlock is disabled in your system, upgrade the kernel to version 5.13 or above.

## Download the Latest Release {: #download-latest-release }

To get started, download the latest binary release and make it executable by running the following command:

!!! note
    It is recommended that you run the optimized binary versions for either Intel's [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} or AMD's [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} architectures for better performance.

=== "Generic"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "Intel Skylake"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-skylake -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "AMD Zen3"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-znver3 -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

## Set Up the Systemd Service {: #set-up-systemd-service }

[Systemd](https://systemd.io){target=\_blank} is a management system for Linux systems that manages services (daemons in Unix-like systems jargon), starting them automatically when the computer starts or reboots, or restarting them upon unexpected failures.

The following commands configure a new account, create the directory, and move the previously downloaded files to the right location.

1. Create a new account to run the service:

    === "Tanssi MainNet"

        ```bash
        adduser tanssi_service --system --no-create-home
        ```

    === "Dancelight TestNet"
        
        ```bash
        adduser dancelight_service --system --no-create-home
        ```

2. Create a directory to store the required files and data:

    === "Tanssi MainNet"

        ```bash
        mkdir /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        mkdir /var/lib/dancelight-data
        ```

3. Set the folder's ownership to the account that will run the service to ensure writing permission:

    === "Tanssi MainNet"

        ```bash
        chown -R tanssi_service /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        chown -R tanssi_service /var/lib/dancelight-data
        ```

4. Move the binaries to the folder:

    === "Tanssi MainNet"

        ```bash
        mv ./tanssi-relay* /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        mv ./tanssi-relay* /var/lib/dacelight-data
        ```

### Generate the Node Key {: #generate-node-key }

To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key
    ```

=== "Dancelight TestNet"
    
    ```bash
    /var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key
    ```

!!! note
    This step could be avoided using the `--unsafe-force-node-key-generation` parameter in the start-up command, although this is not the recommended practice.

### Create the Systemd Service Configuration File {: #create-systemd-configuration }

The next step is to create the Systemd configuration file.

You can create the file by running the following command:

=== "Tanssi MainNet"

    ```bash
    sudo touch /etc/systemd/system/tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    sudo touch /etc/systemd/system/dancelight.service
    ```

Now you can open the file using your favorite text editor (vim, emacs, nano, etc.) and add the configuration for the service, replacing the `INSERT_YOUR_TANSSI_NODE_NAME` tag with a human-readable name and `INSERT_YOUR_IP_ADDRESS` with your public IP address. The name will come in handy for connecting the log entries and metrics with the node that generates them.

=== "Tanssi MainNet"

    ```bash
    [Unit]
    Description="Tanssi systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    User=tanssi_service
    Type=simple
    Restart=always
    RestartSec=10
    SyslogIdentifier=tanssi
    SyslogFacility=local7
    KillSignal=SIGHUP
    LimitNOFILE=100000
    ExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \
    --base-path /var/lib/tanssi-data/ \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /var/lib/tanssi-data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
    
    [Install]
    WantedBy=multi-user.target
    ```

=== "Dancelight TestNet"

    ```bash
    [Unit]
    Description="Dancelight systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    User=dancelight_service
    Type=simple
    Restart=always
    RestartSec=10
    SyslogIdentifier=dancelight
    SyslogFacility=local7
    KillSignal=SIGHUP
    LimitNOFILE=100000
    ExecStart=/var/lib/dancelight-data/tanssi-relay --chain=dancelight \
    --base-path /var/lib/tanssi-data/ \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /var/lib/tanssi-data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'

    [Install]
    WantedBy=multi-user.target
    ```

### Run Flags {: #run-flags }

The flags used in the `ExecStart` command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:

- **--state-pruning=archive** - keeps all state data, which is necessary for historical state queries
- **--blocks-pruning=archive** - keeps all blocks, necessary for historical block data
- **--database=paritydb** - uses ParityDB as the database backend, which is optimized for RPC node performance
- **--unsafe-rpc-external** - allows external connections to the RPC server. This is required for the node to be accessible externally, but exposing RPC endpoints carries security risks. Ensure appropriate firewall and security measures are in place (see warning below)

!!! warning
    The `--unsafe-rpc-external` flag opens your RPC node to external connections. In production environments, you should implement additional security measures like a reverse proxy with rate limiting and authentication.

You can view all available flags by running:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-relay --help
    ```

=== "Dancelight TestNet"
    
    ```bash
    /var/lib/dancelight-data/tanssi-relay --help
    ```

## Run the Service {: #run-the-service }

Finally, enable the service and start it for the first time:

=== "Tanssi MainNet"

    ```bash
    systemctl enable tanssi.service && \
    systemctl start tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    systemctl enable dancelight.service && \
    systemctl start dancelight.service
    ```

You can verify that the service is up and running correctly by executing the following command:

=== "Tanssi MainNet"

    ```bash
    systemctl status tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    systemctl status dancelight.service
    ```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>systemctl status network.service</span>
  <span data-ty>
    <br> â— network.service - "Network systemd service"
    <br>&nbsp;&nbsp;&nbsp;Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)
    <br>&nbsp;&nbsp;&nbsp;Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago
    <br>&nbsp;&nbsp;Main PID: 4045278 (container-chain)
    <br>&nbsp;&nbsp;&nbsp;&nbsp;Tasks: 44 (limit: 9462)
    <br>&nbsp;&nbsp;&nbsp;Memory: 6.5G
    <br>&nbsp;&nbsp;&nbsp;CGroup: /system.slice/network.service
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â””â”€4045278 4045278 /var/lib/network-data/container-chain- ...
  </span>
</div>

Check the logs, if needed, with the following command:

=== "Tanssi MainNet"

    ```bash
    journalctl -f -u tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    journalctl -f -u dancelight.service
    ```

## Testing Your Node {: #testing-your-rpc-node }

After your node is fully synced, you can verify that the RPC endpoint is working correctly by making a simple request. You can use curl to test the connection:

```bash
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method":"chain_getHeader", "params":[]}' http://localhost:9944
```

If the RPC endpoint is working correctly, you should receive a JSON response containing the latest block header information.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/
--- BEGIN CONTENT ---
---
title: Tanssi Operators
description: Learn how to set up, run, and manage network operators to participate in the Tanssi infrastructure protocol, verifying transactions and earning rewards.
icon: octicons-server-24
template: index-page.html
---

# Tanssi Operators

Operators (also known as validators) are responsible for maintaining security within all the Tanssi-powered networks, verifying the integrity and validity of their transactions. They participate in a DPoS (Delegated Proof-of-Stake) consensus mechanism, which improves decentralization and fosters good behavior via economic incentives.

This section provides everything you need to get started, from initial setup to operational best practices and account management.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/offboarding/
--- BEGIN CONTENT ---
---
title: Offboard Your Operator Node
description: Learn how to properly offboard your operator, including pausing operations, opting out from the network, and removing yourself from the registry.
icon: octicons-arrow-down-right-24
template: index-page.html
---

# Offboarding an Operator from Tanssi

Stepping down as an operator requires following the proper procedures to ensure a smooth transition. This section provides clear instructions on offboarding your operator from the Tanssi network.

[timeline left (tanssi-docs/.snippets/text/node-operators/operators/offboarding/offboarding-timeline.json)]

!!! tip "Rejoining as an Operator"
    If you decide to return as a Tanssi validator in the future, you can easily onboard again by following the steps outlined in the [Onboarding](/node-operators/operators/onboarding/) guide.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/offboarding/opt-out-from-tanssi/
--- BEGIN CONTENT ---
---
title: Opt Out from Tanssi
description: Learn how to initiate the offboarding process from a Tanssi network by opting out using various methods and how to verify your status.
icon: octicons-sign-out-24
template: main.html
categories: Operators
---

# Opt Out from Tanssi

## Introduction {: #introduction }

The ability to manage node operators' participation within the Tanssi ecosystem is crucial. This guide addresses the initial step in the offboarding process: opting out of the Tanssi network. This action signals your intent to withdraw and allows the Tanssi protocol to verify your identity as the legitimate operator.

During the onboarding process, one step was opting in to the Tanssi network to become an operator. This guide will walk you through the process of opting out. There are several ways to interact with the smart contracts involved. Refer to the [prerequisites article](/node-operators/operators/offboarding/prerequisites/){target=\_blank} to evaluate which alternative suits you best.

!!! note "Identity Validation"
    When opting out, you sign the transaction using the private key or Ledger device associated with your operator account. This signature serves as cryptographic proof that you are the legitimate owner of the operator account, ensuring that only authorized operators can initiate the offboarding process.

## Methods for Opting Out from a Tanssi Network {: #methods-for-opting-out }

To opt out of the Tanssi network, you must interact with a smart contract. Below are the different methods available to perform this action. Choose the one that best fits your setup and security preferences.

### Using the Symbiotic CLI {: #opt-out-network-with-cli }

The Symbiotic CLI provides a straightforward way to opt out of the network. Choose the appropriate command based on your network and signing method.

Using a Ledger device:

=== "MainNet"

    ```bash
    python3 symb.py opt-out-network {{ networks.symbiotic.contracts.mainnet.tanssi_network }}  --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-out-network {{ networks.symbiotic.contracts.sepolia.tanssi_network }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

For signing with a private key:

=== "MainNet"

    ```bash
    python3 symb.py opt-out-network {{ networks.symbiotic.contracts.mainnet.tanssi_network }} --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-out-network {{ networks.symbiotic.contracts.sepolia.tanssi_network }} --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Note that this method requires you to expose your private key; therefore, it is not recommended.

### Using Etherscan {: #opt-out-network-with-etherscan }

You can interact directly with the smart contract through Etherscan using a browser wallet like MetaMask.

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.network_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.network_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.network_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.network_registry }}#writeContract){target=\_blank}

Make sure to select **Contract** and **Write Contract**, then click on **Connect to Web3**, and select your preferred wallet (e.g., MetaMask):
![Connect to Web3 step](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-1.webp)

1. Expand the **optOut** function
2. Insert the `TANSSI_NETWORK_ADDRESS` in the **where** field. If you are opting out of Tanssi MainNet, use `{{ networks.symbiotic.contracts.mainnet.tanssi_network }}`. For TestNet use `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}`
3. Click **Write** and sign the transaction

![Opt out operator](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-2.webp)

!!! warning
    After submitting your opt out transaction, save the transaction hash. You'll need this hash later for verification in the [operation offboarding form](https://www.tanssi.network/operator-offboarding){target=_blank}.

### Using Safe for Multisig Setups {: #opt-out-network-with-safe }

For [Safe](https://app.safe.global/){target=\_blank} accounts, use the **Transaction Builder** with these addresses:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.network_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.network_registry }}

Finally, pick the optOut function, insert the `TANSSI_NETWORK_ADDRESS` to which your node is currently registered (`{{ networks.symbiotic.contracts.mainnet.tanssi_network }}` for Tanssi MainNet and `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}` for TestNet), and sign the transaction.

## Verifying Your Opt-Out Status {: #verify-opt-out-status }

After submitting the opt-out transaction, it's important to confirm that the action was successful and your operator is no longer opted into the network. You can verify this status using the methods outlined below.

### Using Etherscan to Verify {: #verify-opt-out-etherscan }

You can check your opt-out status on Etherscan by querying the smart contract:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.network_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.network_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.network_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.network_registry }}#readContract){target=\_blank}

On the contract's page:

1. Make sure to select the **Read Contract** tab
2. Locate and expand the **isOptedIn** function
3. Paste your operator's account address in the **who** field.
4. Insert the `TANSSI_NETWORK_ADDRESS` in the **where** field. If you are opting out of Tanssi MainNet, use `{{ networks.symbiotic.contracts.mainnet.tanssi_network }}`. For TestNet use `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}`
5. Click on **Query**

![Check the registration status](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-3.webp)

You'll get a `false` result if your operator has successfully opted out, and `true` if they are still opted in.

### Using the Symbiotic CLI to Verify {: #verify-opt-out-cli }

You can also verify your opt-out status using the Symbiotic CLI:

=== "MainNet"

    ```bash
    python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.mainnet.tanssi_network }}
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.tanssi_network }}
    ```

The output will show `false` if you have successfully opted out and `true` if you are still opted in.

## Contact Tanssi Team {: #contact-tanssi-team }

Following the network opt-out, the next stage of offboarding your Tanssi operator involves formally notifying the Tanssi team. This page guides you through submitting the required offboarding form and explaining what to expect during the final removal process.

After opting out from the network, notify the Tanssi team of your intention to stop running an operator. To do so, complete the [operator offboarding form](https://www.tanssi.network/operator-offboarding){target=_blank} and wait for confirmation of request completion from the Tanssi team.

Upon receiving your request, your operator's removal will be scheduled. This step is semi-automated and may take time to complete. You will be notified by email when it is safe to decommission the node. Please do not decommission your node until you receive this notification.

!!! note "Provide feedback"
    Consider providing feedback in the offboarding [form](https://www.tanssi.network/operator-offboarding){target=_blank} about your experience to help improve the Tanssi network.

## Pause Operations (Optional) {: #pause-operations }

Once you receive confirmation of your operator's removal from the Tanssi team, you can safely stop any running services related to your operator. If needed, back up important configuration files, logs, or any relevant data before deleting them. Afterward, you may repurpose, terminate, or shut down your infrastructure entirely.

## Next Steps (Optional) {: #next-steps-vault-opt-out }

After you have opted out of the network and informed the Tanssi team by submitting the offboarding form, you can take an additional optional step and [opt out of any specific vaults](/node-operators/operators/offboarding/vault-opt-out/){target=\_blank} your operator might be associated with.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/offboarding/prerequisites/
--- BEGIN CONTENT ---
---
title: Prerequisites for Offboarding
description: Before offboarding your Tanssi operator, ensure you have wallet access and sufficient ETH for gas. This guide outlines crucial prerequisites.
icon: octicons-arrow-down-right-24
template: main.html
categories: Operators
---

# Prerequisites for Offboarding

## Introduction {: #introduction }

Operator offboarding is the formal process by which node operators safely and transparently exit the Tanssi protocol. It ensures network integrity, security, and stability by providing clear steps for operators who wish to cease participation.

Operators play a critical role in consensus and network operations. Abruptly shutting down a node without following the proper procedures can negatively impact operators, potentially resulting in slashing.

This guide outlines the **prerequisites** for offboarding, and subsequent guides will walk you through the process.

If you have questions during any part of the offboarding process, the Tanssi team can support you on [Discord](https://discord.com/invite/Jm2KH8xT7J){target=\_blank}.

## Prerequisites {: #prerequisites}

Before starting the offboarding process, ensure you have the following:

- Access to the Ethereum (EVM) wallet that controls your operator account
- Sufficient ETH in your wallet to cover gas fees for transactions

### Why Smart Contract Interaction is Required {: #why-smart-contracts }

Like many decentralized systems, the Tanssi protocol utilizes smart contracts on the Ethereum blockchain to manage critical operations, including operator registration and staking. When an operator decides to offboard, they change their status and relationship with these core protocol contracts.
Key offboarding steps, such as signaling your intent to exit or formally unregistering, involve transactions that update the state recorded in these smart contracts.

### Interaction Methods

There are several ways to interact with the smart contracts:

- Using the [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank}
- Using [Etherscan](https://etherscan.io/){target=\_blank}
- Using [Safe](https://safe.global/){target=\_blank} for multisig setups

In any case, you'll need to sign the transaction using the account you intend to use for the node. You can choose between different options to do so:

- Using the account's private key directly (although this method is not recommended)
- Using a hot wallet, such as [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}
- Using a cold wallet, such as [Ledger](https://www.ledger.com/){target=\_blank}

The following section outlines the steps for installing the Symbiotic CLI, if that's your method of preference.

### Set Up the Symbiotic CLI {: #set-up-the-cli }

The [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank} is a tool for interacting with Symbiotic's core smart contracts. It is written in [Python](https://www.python.org/){target=\_blank}, so you'll need to install the Python interpreter and [pip](https://pypi.org/project/pip/){target=\_blank}, Python's package installer:

=== "Linux (Ubuntu/Debian)"

    ```bash
     sudo apt-get install python3 && \
     sudo apt install python3-pip
    ```

=== "MacOS"

    ```bash
    brew install python3
    ```

Now, with Python installed, download the Symbiotic CLI and its dependencies:

```bash
git clone https://github.com/symbioticfi/cli.git && \
cd cli && \
pip3 install -r requirements.txt
```

Run the following command to check if the installation was successful:

```bash
python3 symb.py --help
```

The terminal should show a long list of the CLI available commands:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py --help</span>
    <span data-ty>Usage: symb.py [OPTIONS] COMMAND [ARGS]...</span>
    <br>
<span data-ty>Options:</></span>
  <span data-ty>&emsp;--chain CHAIN    Chain ID to use.  [default: mainnet]</span>
  <span data-ty>&emsp;--provider TEXT  Ethereum provider URL [http(s)].</span>
  <span data-ty>&emsp;--help           Show this message and exit.</span>
  <br>
<span data-ty>Commands:
<span data-ty>&emsp;active-balance-of&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Get an active balance of a given account...</span>
<span data-ty>&emsp;check-opt-in-network&emsp;&emsp;&ensp; Check if operator is opted in to a network.</span>
<span data-ty>&emsp;check-opt-in-vault&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Check if operator is opted in to a vault.</span>
<span data-ty>&emsp;claim&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Claim a withdrawal for some epoch at the...</span>
<span data-ty>&emsp;deposit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Deposit to the vault.</span>
<span data-ty>&emsp;.......&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;..........</span>
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/offboarding/vault-opt-out/
--- BEGIN CONTENT ---
---
title: Vault Opt Out
description: Optionally opt out of a Tanssi vault. Learn how using CLI, Etherscan, or Safe, and verify your vault opt out status.
icon: octicons-sign-out-24
template: main.html
categories: Operators
---

# Vault Opt Out (Optional)

## Introduction {: #introduction }

This page details the optional final step in the Tanssi offboarding process: opting out of a specific vault. While not mandatory, this action allows operators to disassociate their accounts from individual vaults. Before you go ahead with this step, please make sure you have met all the conditions outlined in our [prerequisites](/node-operators/operators/offboarding/prerequisites/){target=\_blank} guide.

This guide provides instructions for opting out using one of several available methods and for verifying the successful completion of this action.

## Opting Out of a Vault {: #opting-out-of-a-vault }

To proceed with opting out of a vault, you can utilize one of the methods detailed in the following sections.

### Using the Symbiotic CLI {: #opt-out-vault-with-cli }

Using a Ledger device:

=== "MainNet"

    ```bash
    python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-out-vault {{ networks.symbiotic.contracts.sepolia.vault }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

For signing with a private key:

=== "MainNet"

    ```bash
    python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-out-vault {{ networks.symbiotic.contracts.sepolia.vault }} --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Note that this method requires you to expose your private key; therefore, it is not recommended.

### Using Etherscan {: #opt-out-vault-with-etherscan }

Access the contract through Etherscan:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.vault_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.vault_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.vault_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.vault_registry }}#writeContract){target=\_blank}

Make sure to select **Contract** and **Write Contract**, then click on **Connect to Web3**, and select your preferred wallet (e.g., MetaMask):
![Connect to Web3 step](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-4.webp)

1. Expand the **optOut** function
2. Insert the `VAULT_ADDRESS` in the **where** field (e.g., `{{ networks.symbiotic.contracts.sepolia.vault }}` on Sepolia TestNet)
3. Click **Write** and sign the transaction

![Opt out operator](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-5.webp)

### Using Safe {: #opt-out-vault-with-safe }

For Safe accounts, use these contract addresses in the **Transaction Builder**:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.vault_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.vault_registry }}

Finally, pick the optOut function, insert the `VAULT_ADDRESS` to which your node is currently registered (e.g., `{{ networks.symbiotic.contracts.sepolia.vault }}` on Sepolia TestNet), and sign the transaction.

## Verify Vault Opt Out Status {: #verify-vault-opt-out-status }

After submitting the vault opt out transaction, you can verify your opt out status using one of the methods in the following sections.

### Using Etherscan

You can check your vault opt out status on Etherscan:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.vault_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.vault_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.vault_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.vault_registry }}#readContract){target=\_blank}

On the contract's page:

Make sure to select **Contract** and **Write Contract**, then click on **Connect to Web3**, and select your preferred wallet (e.g., MetaMask):

1. Select the **isOptedIn** function
2. Paste your operator's account in the **who** field
3. Insert the vault address in the **where** field
4. Click on **Query**

You'll get a `false` result if your operator has successfully opted out of the vault, and `true` if they are still opted in.

![Check the registration status](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-6.webp)

### Using the Symbiotic CLI

You can also verify your vault opt out status using the Symbiotic CLI:

=== "MainNet"

    ```bash
    python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.vault }}
    ```

The output will show `false` if you have successfully opted out of the vault and `true` if you are still opted in.

## Next Steps

After completing the offboarding process, if you plan to return in the future, you can follow the [onboarding process](/node-operators/operators/onboarding/){target=\_blank} again.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/onboarding/account-setup/
--- BEGIN CONTENT ---
---
title: Set Up an Operator Account
description: Learn how to map your node's account with your stash account, making your node eligible to secure Tanssi and the Tanssi-powered networks and receive rewards.
icon: octicons-tools-24
categories: Operators
---

# Set Up Your Account to Secure the Tanssi Ecosystem

## Introduction {: #introduction }

As presented in the [onboarding section](/node-operators/operators/onboarding/){target=\_blank}, once you've successfully [opted into a Tanssi-enabled vault](/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults){target=\_blank}, [opted into the Tanssi network](/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi){target=\_blank}, and [filled out the application form](https://www.tanssi.network/node-operators-application){target=\_blank}, this is the sixth step of the process. After this step, your node will be able to participate in the Tanssi protocol.

In this step, you'll map your Substrate stash account (the one keeping track of your rewards) to your node's session keys (the ones used for communication and consensus), allowing the protocol to include your node in the active set. 

This guide walks you through generating session keys for your node, mapping them to your account through the Tanssi developer portal, and verifying that the association has been established correctly. 

## Checking Prerequisites {: #checking-prerequisites }

Before setting up your account, make sure that:

- You have a node correctly [set up and running](/node-operators/operators/onboarding/run-an-operator/){target=\_blank}
- You [have registered as an operator](/node-operators/operators/onboarding/register-in-symbiotic/){target=\_blank} in the Symbiotic registry 
- You [have opted in to Tanssi Network and a Tanssi-enabled vault](/node-operators/operators/onboarding/opt-in-to-tanssi/){target=\_blank}

## Map an Account to Your Node {: #map-account }

The first step is a two-step process that generates and maps the session keys to your account. Session keys can be compared to the node's ID, and are used to perform network operations, such as signing validity proofs, whereas your account keeps track of your work and related rewards, and could have an on-chain identity. By mapping the session key to your account, you create an association between your account and your node.

You will need to create session keys for your primary and backup servers. Each server should have its own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.

### Generate Session Keys {: #generate-session-keys }

To generate session keys, send an RPC call using the `author_rotateKeys` method to your node's HTTP endpoint. For reference, if your node's HTTP endpoint is at port `9944`, the JSON-RPC call might look like this:

```bash
curl http://127.0.0.1:9944 -H \
"Content-Type:application/json;charset=utf-8" -d \
  '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"author_rotateKeys",
    "params": []
  }'
```

Your hex-encoded session keys will be printed to the terminal in the `"result"` field.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>curl http://127.0.0.1:9944 -H \
    <br>  "Content-Type:application/json;charset=utf-8" -d \
    <br>    '{
    <br>        "jsonrpc":"2.0",
    <br>        "id":1,
    <br>        "method":"author_rotateKeys",
    <br>        "params": []
    <br>    }'
  </span>
  <span data-ty>{"jsonrpc":"2.0","id":1,"result":</span>
  <span data-ty>
  "0xca17757962a065eeebec2c6e0d2dc7fb24b56967fd9003e4d22bf4981da86fd4ac7cd701462730a76ab539d5a48f4fd2821acf07743335e56eef84d1544686480ada0ff0f38dfccee43515e619e03b0de95a08c74fcbb2da26af55ad144d5f54829a57d7d77bb9333cf9301eaa5d20c384f67388f36b402e33a03b949148325e80b812699fb22d9e4b4976e1d0e9964034489cb0b5b6b70c37d227fb54ffe50b444434b488361038b8b6949c36f0073c6bd52f2907c0991e32257d96bb946c590320539c343fc1f2e1dd1951a0ff38c6c9ea2f93a263e81ee95da1de0697e47e32"}</span>
</div>

!!! note
    Make sure you write down your session keys. In the next section, you'll need to map them to your account.

### Map Session Keys {: #map-session-keys }

To perform the next step and map your session keys to your account, open the developer portal and head to the **Developer** tab, **Extrinsics** section. The following link will take you right there:

=== "Tanssi MainNet"

    [Mainnet developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/extrinsics){target=\_blank}

=== "Dancelight TestNet"

    [TestNet developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}

Now, take the following steps:

1. Select your account, which should be the same account that you previously registered with Tanssi
2. Select the **session** module and the **setKeys** extrinsic
3. For **keys**, enter your session keys
4. For **proof**, enter `0x`
5. Click **Submit Transaction** and sign and send the transaction from your wallet

![Create and submit a transaction to set session keys on Polkadot.js Apps](/images/node-operators/operators/onboarding/account-setup/account-setup-1.webp)

## Verify the Keys Mapping {: #verify-keys-mapping }

Using the `session.keyOwner` method allows you to verify that your session keys have been mapped to your account as expected. This method is accessible through the developer portal, in the **Developer** tab, **Chain state** section. The following link will take you right there:

=== "Tanssi MainNet"

    [Mainnet developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/chainstate){target=\_blank}

=== "Dancelight TestNet"

    [TestNet developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}

Now, take the following steps:

1. Select the **session** module and the **keyOwner** query
2. Enter `gran` in the **SpCoreCryptoKeyTypeId** field
3. For **Bytes**, enter the first sixty six hex-encoded characters from your session keys (e.g., `0x00a12170e0925a9bf98f31bbdd7988550c1bf587766a2d2735e969aa5b4291dc`)
4. Click the **+** button next to the extrinsic field
5. The account associated with the session keys, which should be your account, will be displayed at the bottom of the page

![Create and submit query to verify session keys on the developer portal](/images/node-operators/operators/onboarding/account-setup/account-setup-2.webp)

And that's it! You've successfully mapped your account, and your node is now eligible to participate in the protocol.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/onboarding/
--- BEGIN CONTENT ---
---
title: Run an Operator Node
description: Learn how to run an operator (validator) to verify transactions across Tanssi-powered networks, providing security and earning rewards for your contribution.
icon: octicons-arrow-up-right-24
template: index-page.html
---

# Onboarding

One of Tanssi's core propositions for builders is that it provides Ethereum-grade economic security to every Tanssi-powered network, regardless of its TVL, userbase, or the specifics of the use case. Tanssi's design offers developers a shared security model, alleviating them from having to source enough economic security or negotiate with operators to run nodes opting in for their networks. 

The Tanssi protocol achieves this by integrating with [external security providers](/learn/tanssi/external-security-providers/){target=\_blank}, such as [Symbiotic](/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}. In this model, different [vaults](/learn/tanssi/external-security-providers/symbiotic/#vaults){target=\_blank} associated with Tanssi provide economic security, and reliable operators provide validation services to the Tanssi network.

Follow these steps to set up your node and prepare your account for active participation in the Tanssi protocol. 

[timeline left (tanssi-docs/.snippets/text/node-operators/operators/onboarding/onboarding-timeline.json)]

Once you've fully onboarded, check out the [operational tasks](/node-operators/operators/operational-tasks/){target=\_blank} related to the maintenance of your node.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/onboarding/opt-in-to-tanssi/
--- BEGIN CONTENT ---
---
title: Opt In to Tanssi
description: Learn how to opt in with your registered node to Tanssi-enabled Symbiotic vaults and the Tanssi network to participate in the protocol and earn rewards.
icon: octicons-plus-circle-24
categories: Operators
---

# Opt In to Tanssi

## Introduction {: #introduction }

After successfully [registering your node in the Symbiotic protocol](/node-operators/operators/onboarding/register-in-symbiotic/){target=\_blank}, the next steps are to opt in to both Tanssi-enabled vaults and the Tanssi network itself. As presented in the [onboarding section](/node-operators/operators/onboarding/){target=\_blank}, these are the third and fourth steps.

This guide will walk through the steps to successfully opt into a Tanssi-enabled vault and the Tanssi network, allowing you to choose between multiple methods, including using the Symbiotic CLI, interacting directly with smart contracts through Etherscan, or utilizing Safe for multisig configurations. 

## Checking Prerequisites {: #checking-prerequisites }

Before opting into a Tanssi-enabled vault and the Tanssi network, make sure that:

- You have a node correctly [set up and running](/node-operators/operators/onboarding/run-an-operator/){target=\_blank}
- You [have registered as an operator](/node-operators/operators/onboarding/register-in-symbiotic/){target=\_blank} in the Symbiotic registry 

To follow this guide, you must interact with smart contracts, one from Symbiotic's core protocol and the other from Tanssi's integration with Symbiotic.

There are several ways to interact with the smart contracts:

- Using the [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank}
- Using [Etherscan](https://etherscan.io/){target=\_blank}
- Using [Safe](https://safe.global/){target=\_blank} for multisig setups

In any case, you'll need to sign the transaction using the account you intend to use for the node. You can choose between different options to do so:

- Using the account's private key directly (although this method is not recommended)
- Using a hot wallet, such as [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}
- Using a cold wallet, such as [Ledger](https://www.ledger.com/){target=\_blank}

The following section outlines the steps for installing the Symbiotic CLI, if that's your method of preference.

### Set Up the Symbiotic CLI {: #set-up-the-cli }

The [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank} is a tool for interacting with Symbiotic's core smart contracts. It is written in [Python](https://www.python.org/){target=\_blank}, so you'll need to install the Python interpreter and [pip](https://pypi.org/project/pip/){target=\_blank}, Python's package installer:

=== "Linux (Ubuntu/Debian)"

    ```bash
     sudo apt-get install python3 && \
     sudo apt install python3-pip
    ```

=== "MacOS"

    ```bash
    brew install python3
    ```

Now, with Python installed, download the Symbiotic CLI and its dependencies:

```bash
git clone https://github.com/symbioticfi/cli.git && \
cd cli && \
pip3 install -r requirements.txt
```

Run the following command to check if the installation was successful:

```bash
python3 symb.py --help
```

The terminal should show a long list of the CLI available commands:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py --help</span>
    <span data-ty>Usage: symb.py [OPTIONS] COMMAND [ARGS]...</span>
    <br>
<span data-ty>Options:</></span>
  <span data-ty>&emsp;--chain CHAIN    Chain ID to use.  [default: mainnet]</span>
  <span data-ty>&emsp;--provider TEXT  Ethereum provider URL [http(s)].</span>
  <span data-ty>&emsp;--help           Show this message and exit.</span>
  <br>
<span data-ty>Commands:
<span data-ty>&emsp;active-balance-of&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Get an active balance of a given account...</span>
<span data-ty>&emsp;check-opt-in-network&emsp;&emsp;&ensp; Check if operator is opted in to a network.</span>
<span data-ty>&emsp;check-opt-in-vault&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Check if operator is opted in to a vault.</span>
<span data-ty>&emsp;claim&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Claim a withdrawal for some epoch at the...</span>
<span data-ty>&emsp;deposit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Deposit to the vault.</span>
<span data-ty>&emsp;.......&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;..........</span>
</div>

## Opt In to Tanssi-Enabled Vaults {: #opt-in-tanssi-vaults }

Before enabling your operator to be active within the Tanssi network, you must opt in to at least one of the Tanssi-enabled vaults. The following sections describe several ways to opt into the vaults.

### Opt In Using the Symbiotic CLI {: #opt-in-tanssi-vaults-with-cli }

If you have correctly installed the [Symbiotic CLI](#set-up-the-cli) and you want to sign the transaction using a Ledger device, then run the following command, replacing `INSERT_VAULT_ADDRESS` with the specific one you want to join and `INSERT_OPERATOR_ADDRESS` with your account:

=== "MainNet"

    ```bash
    python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-in-vault {{ networks.symbiotic.contracts.sepolia.vault }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

If you want to sign the transaction directly using the operator's account private key, then run the following command, replacing the `INSERT_PRIVATE_KEY` parameter:

=== "MainNet"

    ```bash
    python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-in-vault {{ networks.symbiotic.contracts.sepolia.vault }} --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Note that this method requires you to expose your private key; therefore, it is not recommended.

### Opt In Using Etherscan {: #opt-in-tanssi-vaults-with-etherscan }

You can interact with Symbiotic's smart contracts using Etherscan, and sign the transaction using a browser wallet ([MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}, for example). 

To open the contract's page, open the link:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.vault_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.vault_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.vault_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.vault_registry }}#writeContract){target=\_blank}

Click on **Connect to Web3**, and select your preferred wallet (e.g. MetaMask):

![Connect to Web3 step](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-1.webp)

!!! note
    You can configure MetaMask to use a cold wallet.

Once connected:

1. Expand the **`optin`** function
2. Insert the `VAULT_ADDRESS` (`{{ networks.symbiotic.contracts.sepolia.vault }}` on Sepolia TestNet)
3. Click on **Write**, and sign the transaction

![Register the operator](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-2.webp)

### Opt In Using Safe for Multisig Setups {: #opt-in-tanssi-vaults-with-safe }

If you have a [Safe](https://app.safe.global/){target=\_blank} account, then open the **Transaction builder** and insert the following contract address:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.vault_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.vault_registry }}

Finally, pick the **`optin`** function, insert the `VAULT_ADDRESS` (`{{ networks.symbiotic.contracts.sepolia.vault }}` on Sepolia TestNet), and sign the transaction.

### Check the Registration Status {: #check-vault-registration }

You can quickly check your registration status on Etherscan. Open the following link:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.vault_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.vault_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.vault_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.vault_registry }}#readContract){target=\_blank}

In the contract's page:

1. Select the **`isOptedIn`** function
2. Paste your operator's account in the **who** field
3. Insert the `VAULT_ADDRESS` in the **where** field
4. Click on **Query**

 You'll get a `true` result if your operator was registered correctly and `false` otherwise.

![Check the registration status](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-3.webp)

You can also verify your registration status using the Symbiotic CLI running the following command, which prints `true` or `false` for any given operator address in a Tanssi-enabled vault:

=== "MainNet"
    
    ```bash
    python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.vault }}
    ```

And the output looks like:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS</span>
    <span data-ty>Connected to chain ID 1</span>
    <span data-ty>True</span>
    <br>
</div>

## Opt In to the Tanssi Network {: #opt-in-tanssi }

Before enabling your operator to be a active within the Tanssi network, you must opt into the network and be approved by the Tanssi team. The following sections describe several ways to opt into the network.

!!! note
    The MainNet Tanssi Network address will be disclosed upon launch.

### Opt In Using the Symbiotic CLI {: #opt-in-tanssi-with-cli }

If you have correctly installed the [Symbiotic CLI](#set-up-the-cli) and you want to sign the transaction using a Ledger device, then run the following command, replacing `INSERT_OPERATOR_ADDRESS`:

=== "MainNet"

    ```bash
    python3 symb.py opt-in-network {{ networks.symbiotic.contracts.mainnet.tanssi_network }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-in-network {{ networks.symbiotic.contracts.sepolia.tanssi_network }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

If you want to sign the transaction directly using the operator's account private key, then run the following command, replacing the `INSERT_PRIVATE_KEY` parameter:

=== "MainNet"

    ```bash
    python3 symb.py opt-in-network {{ networks.symbiotic.contracts.mainnet.tanssi_network }} --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-in-network {{ networks.symbiotic.contracts.sepolia.tanssi_network }} --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Note that this method requires you to expose your private key; therefore, it is not recommended.

### Opt In Using Etherscan {: #opt-in-tanssi-with-etherscan }

You can interact with Symbiotic's smart contracts using Etherscan and sign the transaction using a browser wallet ([MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}, for example). 

Go to the contract's page by opening the link:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.network_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.network_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.network_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.network_registry }}#writeContract){target=\_blank}

Click on **Connect to Web3**, and select your preferred wallet (e.g. MetaMask):

![Connect to Web3 step](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-4.webp)

!!! note
    You can configure MetaMask to use a cold wallet.

Once connected:

1. Expand the **`optin`** function
2. Insert the `TANSSI_NETWORK_ADDRESS`. If you are opting in for Tanssi MainNet, use `{{ networks.symbiotic.contracts.mainnet.tanssi_network }}`. For TestNet use `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}`
3. Click on **Write**, and sign the transaction

![Register the operator](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-5.webp)

### Opt In Using Safe for Multisig Setups {: #opt-in-tanssi-with-safe }

If you have a [Safe](https://app.safe.global/){target=\_blank} account, then open the **Transaction builder** and insert the following contract address:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.network_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.network_registry }}

Finally, pick the **`optin`** function, insert Tanssi Network's address (`{{ networks.symbiotic.contracts.mainnet.tanssi_network }}` for Tanssi MainNet and `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}` for TestNet), and sign the transaction.

### Check the Registration Status {: #check-tanssi-registration }

You can quickly check your registration status on Etherscan. Open the following link:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.network_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.network_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.network_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.network_registry }}#readContract){target=\_blank}

On the contract's page:

1. Select the **`isOptedIn`** function
2. Paste your operator's account in the **who** field
3. Insert the `TANSSI_NETWORK_ADDRESS` in the **where** field. If you are opting in for Tanssi MainNet, use `{{ networks.symbiotic.contracts.mainnet.tanssi_network }}`. For TestNet use `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}`
4. Click on **Query**

You'll get a `true` result if your operator was registered correctly and `false` otherwise.

![Check the registration status](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-6.webp)

You can also verify your registration status using the Symbiotic CLI running the following command, which prints `true` or `false` for any given operator address in the Tanssi Network:

=== "MainNet"
    
    ```bash
    python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.mainnet.tanssi_network }}
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.tanssi_network }} 
    ```

And the output looks like:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.tanssi_network }}</span>
    <span data-ty>Connected to chain ID 1</span>
    <span data-ty>True</span>
    <br>
</div>

!!! note
    Opting in to the Tanssi Networks requires approval by the Tanssi team. Requests to join could take up to one week.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/onboarding/register-in-symbiotic/
--- BEGIN CONTENT ---
---
title: Register in Symbiotic
description: Learn how to register your node in the Symbiotic registry as a first step to participate in the protocol, securing Tanssi-powered networks and earning rewards.
icon: octicons-shield-check-24
categories: Operators
---

# Register in Symbiotic

## Introduction {: #introduction }

As presented in the [onboarding section](/node-operators/operators/onboarding/){target=\_blank}, registering in Symbiotic is the second step of the process. You should already have the node synced and running, whether using [Docker](/node-operators/operators/onboarding/run-an-operator/operators-docker/){target=\_blank} or [Systemd](/node-operators/operators/onboarding/run-an-operator/operators-systemd/){target=\_blank}. 

The Tanssi protocol provides its appchains with Ethereum-grade security from the start by relying on external security providers, such as [Symbiotic](/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}. To participate as an operator in the Tanssi ecosystem, you must first register your node in the Symbiotic protocol. The registration process establishes your node as a recognized operator.

This guide will walk you through the steps to successfully register your node as a Symbiotic operator, allowing you to choose between multiple methods, including using the Symbiotic CLI, interacting directly with smart contracts through Etherscan, or utilizing Safe for multisig configurations.

## Checking Prerequisites {: #checking-prerequisites }

Before registering as an operator, ensure you have already [set up the node](/node-operators/operators/onboarding/run-an-operator/){target=\_blank} and it is running.

To follow this guide, you must interact with smart contracts.
There are several ways to interact with the smart contracts:

- Using the [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank}
- Using [Etherscan](https://etherscan.io/){target=\_blank}
- Using [Safe](https://safe.global/){target=\_blank} for multisig setups

In any case, you'll need to sign the transaction using the account you intend to use for the node. You can choose between different options to do so:

- Using the account's private key directly (although this method is not recommended)
- Using a hot wallet, such as [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}
- Using a cold wallet, such as [Ledger](https://www.ledger.com/){target=\_blank}

The following section outlines the steps for installing the Symbiotic CLI, if that's your method of preference.

### Set Up the Symbiotic CLI {: #set-up-the-cli }

The [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank} is a tool for interacting with Symbiotic's core smart contracts. It is written in [Python](https://www.python.org/){target=\_blank}, so you'll need to install the Python interpreter and [pip](https://pypi.org/project/pip/){target=\_blank}, Python's package installer:

=== "Linux (Ubuntu/Debian)"

    ```bash
     sudo apt-get install python3 && \
     sudo apt install python3-pip
    ```

=== "MacOS"

    ```bash
    brew install python3
    ```

Now, with Python installed, download the Symbiotic CLI and its dependencies:

```bash
git clone https://github.com/symbioticfi/cli.git && \
cd cli && \
pip3 install -r requirements.txt
```

Run the following command to check if the installation was successful:

```bash
python3 symb.py --help
```

The terminal should show a long list of the CLI available commands:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py --help</span>
    <span data-ty>Usage: symb.py [OPTIONS] COMMAND [ARGS]...</span>
    <br>
<span data-ty>Options:</></span>
  <span data-ty>&emsp;--chain CHAIN    Chain ID to use.  [default: mainnet]</span>
  <span data-ty>&emsp;--provider TEXT  Ethereum provider URL [http(s)].</span>
  <span data-ty>&emsp;--help           Show this message and exit.</span>
  <br>
<span data-ty>Commands:
<span data-ty>&emsp;active-balance-of&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Get an active balance of a given account...</span>
<span data-ty>&emsp;check-opt-in-network&emsp;&emsp;&ensp; Check if operator is opted in to a network.</span>
<span data-ty>&emsp;check-opt-in-vault&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Check if operator is opted in to a vault.</span>
<span data-ty>&emsp;claim&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Claim a withdrawal for some epoch at the...</span>
<span data-ty>&emsp;deposit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Deposit to the vault.</span>
<span data-ty>&emsp;.......&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;..........</span>
</div>

## Register as an Operator {: #registering-operator }

The Symbiotic protocol keeps a registry of all operators. Before being able to secure Tanssi-powered networks, node operators must register as operators in the Symbiotic protocol using one of the methods described in the following sections.

### Register Using the Symbiotic CLI {: #register-with-cli }

If you correctly installed the [Symbiotic CLI](#set-up-the-cli) and you want to sign the transaction using a Ledger device, then run the following command, replacing `INSERT_OPERATOR_ADDRESS` with your account:

=== "MainNet"

    ```bash
    python3 symb.py register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS 
    ```

If you want to sign the transaction directly using the account private key, then run the following command, replacing the `INSERT_PRIVATE_KEY` parameter:

=== "MainNet"

    ```bash
    python3 symb.py register-operator --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia register-operator --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Note that this method requires you to expose your private key; therefore, it is not recommended.

### Register Using Etherscan {: #register-with-etherscan }

You can interact with Symbiotic's smart contracts using Etherscan and sign the transaction using a browser wallet ([MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}, for example). 

Go to the contract's page by opening the link:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.operators_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.operators_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.operators_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.operators_registry }}#writeContract){target=\_blank}

Click on **Connect to Web3**, and select your preferred wallet (e.g. MetaMask):

![Connect to Web3 step](/images/node-operators/operators/onboarding/register-in-symbiotic/register-in-symbiotic-1.webp)

!!! note
    You can configure MetaMask to use a cold wallet.

Once connected:

1. Expand the **`registerOperator`** function
2. Click on **Write**, and sign the transaction

![Register the operator](/images/node-operators/operators/onboarding/register-in-symbiotic/register-in-symbiotic-2.webp)

### Register Using Safe for Multisig Setups {: #register-with-safe }

If you have a [Safe](https://app.safe.global/){target=\_blank} account, then open the **Transaction builder** and insert the following contract address:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.operators_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.operators_registry }}

Finally, pick the **`registerOperator`** function and sign the transaction.

## Check the Registration Status {: #check-registration }

You can quickly check your registration status on Etherscan. Open the following link:

=== "MainNet"

    [Contract address: {{ networks.symbiotic.contracts.mainnet.operators_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.operators_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [Contract address: {{ networks.symbiotic.contracts.sepolia.operators_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.operators_registry }}#readContract){target=\_blank}

On the contract's page:

1. Select the **`isEntity`** function
2. Paste your operator's account
3. Click on **Query**

If your operator was registered correctly, you'll get a `true` result, and otherwise, `false`

![Check the registration status](/images/node-operators/operators/onboarding/register-in-symbiotic/register-in-symbiotic-3.webp)

You can also verify your registration status using the Symbiotic CLI running the following command, which prints `true` or `false` for any given operator address:

=== "MainNet"
    
    ```bash
    python3 symb.py isop INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia isop INSERT_OPERATOR_ADDRESS 
    ```

And the output looks like:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py isop INSERT_OPERATOR_ADDRESS</span>
    <span data-ty>Connected to chain ID 1</span>
    <span data-ty>True</span>
    <br>
</div>

## Submit Metadata {: #submitting-metadata }

Once your operator is successfully registered, you can add metadata (e.g., logo) to improve its visibility on the [Symbiotic website](https://app.symbiotic.fi){target=\_blank}.

To submit your operator's metadata, head to the Symbiotic metadata repository:

=== "MainNet"

    [MainNet repository](https://github.com/symbioticfi/metadata-mainnet){target=\_blank}

Create a fork of this repo and, within the `operators` directory, create a new directory named after your operator's address. Within your operator's directory, add your `logo.png` and a file named `info.json` with the following fields, replacing the values with your own:

```json title="info.json"
{
	"name": "INSERT_YOUR_OPERATOR_NAME",
	"description": "INSERT_YOUR_OPERATOR_DESCRIPTION",
	"tags": [
		"operator"
	],
	"links": [
		{
			"type": "website",
			"name": "Website",
			"url": "https://INSERT_YOUR_WEBSITE_URL"
		},
		{
			"type": "website",
			"name": "X",
			"url": "https://INSERT_YOUR_X_URL"
		}
	]
}
```

!!! note
    The `links` parameter is an array. Add as many links as you need.

Finally, open a pull request. The Symbiotic team will review it and merge it.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/onboarding/run-an-operator/
--- BEGIN CONTENT ---
---
title: Run an Operator
description: Learn how to set up and run an operator node (also referred to as validators) using Docker or Systemd to participate in the protocol securing the ecosystem.
icon: octicons-server-24
template: index-page.html
---

# Run an Operator Node

Setting up an operator node is an important step to participate in the Tanssi network. You have two options for configuration: using _Docker_ or _Systemd._ Whichever path you choose, we provide step-by-step tutorials to guide you through the process and ensure your node meets the necessary requirements to validate the Tanssi-powered network's transactions and provide security to the ecosystem.

### Hardware Requirements

To run an operator node successfully, high-performance hardware is essential. Suboptimal configurations can lead to delays, unavailability, and ultimately, lost rewards and/or penalizations. Since the validation process relies heavily on single-threaded performance, prioritizing CPUs with strong single-thread capabilities over higher core counts is recommended.

Recommended hardware:

- **Recommended Configuration** - Bare metal hardware running linux debian or ubuntu
 - **Recommended CPUs** - Intel Ice Lake or newer (Xeon or Core series) or AMD Zen3 or newer (EPYC or Ryzen). Eight Physical cores @ 3.4 Ghz with hyperthreading disabled (SMT for AMD processors) 
- **Recommended NVMe** - 500 GB NVMe SSD
- **Recommended RAM** - 32 GB ECC RAM
- **Recommended Network** - 1 Gbps connection 

!!! warning 
    As an operator, you are responsible for both your own stake and that of your delegators. Maintaining your node's performance, keeping it updated, and ensuring its security are critical for maximizing rewards and building a strong reputation within the Tanssi network.

### Required Network Ports

A successful operator must be able to synchronize and interact with one peer-to-peer (P2P) network. To ensure proper communication within the Tanssi ecosystem, make sure the following port is open for incoming:

| Network          | Port        |
|------------------|-------------|
| Tanssi Chain     | 30333 (TCP) |

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/onboarding/run-an-operator/operators-docker/
--- BEGIN CONTENT ---
---
title: Run an Operator Node Using Docker
description: Learn how to set up and run an operator (aka validator) for Tanssi network using Docker to participate in the protocol, secure networks, and earn rewards.
icon: simple-docker
categories: Operators
---

# Run an Operator Node Using Docker

## Introduction {: #introduction }

Operators are a crucial component of the Tanssi ecosystem, providing security and validation services for Tanssi-powered networks. As an operator, you participate in the consensus mechanism that secures the network while earning rewards for your contribution.

As presented in the [onboarding section](/node-operators/operators/onboarding/){target=\_blank}, running the actual node is the first step towards your active participation in the protocol.

In this guide, you'll learn how to spin up a Tanssi operator using the official image release with [Docker](https://www.docker.com){target=\_blank} on Linux systems.

## Checking Prerequisites {: #checking-prerequisites }

### Installing Docker {: #installing-docker}

To get started, you'll need access to a computer running a Linux OS and install [Docker](https://docs.docker.com/desktop/setup/install/linux/){target=\blank}.

Run the following command to install Docker on a Linux Ubuntu platform:

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

And the following command to check the installation:

```bash
sudo docker run hello-world
```

This is what a successful execution in the terminal looks like:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>sudo docker run hello-world</span>
  <span data-ty>
    <br> 
    <br> Hello from Docker!
    <br> This message shows that your installation appears to be working correctly.
    <br> 
    <br> To generate this message, Docker took the following steps:
    <br> 1. The Docker client contacted the Docker daemon.
    <br> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    <br>     (amd64)
    <br> 3. The Docker daemon created a new container from that image which runs the
    <br>     executable that produces the output you are currently reading.
    <br> 4. The Docker daemon streamed that output to the Docker client, which sent it
    <br>     to your terminal.
    <br>
    <br> To try something more ambitious, you can run an Ubuntu container with:
    <br> $ docker run -it ubuntu bash
    <br>
    <br> Share images, automate workflows, and more with a free Docker ID:
    <br> https://hub.docker.com/
    <br>
    <br> For more examples and ideas, visit:
    <br>  https://docs.docker.com/get-started/
  </span>
</div>

### Pull the Docker Image {: #pull-docker-image }

A Docker image is built and published in every release, containing all the necessary dependencies a Tanssi operator requires and the binary file itself.

A Docker image combines the binary corresponding to the latest stable release of the [client node](/learn/framework/architecture/#architecture){target=\_blank}, along with the Tanssi orchestrator specification file.

The following command to pull the Docker image:

=== "Tanssi MainNet"

    ```bash
    docker pull {{ networks.dancelight.operator_docker_image }}
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    docker pull {{ networks.dancelight.operator_docker_image }}
    ```

The command will download and extract the image and show the status upon execution:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker pull moondancelabs/starlight</span>
  <span data-ty>
    <br> 
    <br> Using default tag: latest
    <br> latest: Pulling from moondancelabs/starlight
    <br> e1caac4eb9d2: Pull complete 
    <br> 1d4409959e6d: Pull complete 
    <br> b8beed19c122: Pull complete 
    <br> c0fab1f18601: Pull complete 
    <br> Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c
    <br> Status: Downloaded newer image for moondancelabs/starlight
    <br> docker.io/moondancelabs/starlight
  </span>
</div>

### Set Up the Data Directory {: #set-up-data-directory }

Running a node requires syncing with the Tanssi chain and storing its state.

Run the following command to create the directory where your node will store the databases containing blocks and chain states:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the Docker image to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    chown INSERT_DOCKER_USER /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    chown INSERT_DOCKER_USER /var/lib/dancelight-data
    ```

Or run the following command if you want to run the node with the current logged-in user:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data
    ```

!!! note
    The directory is a parameter in the Docker start-up command. If you decide to create the directory elsewhere, update the command accordingly.

### Generate the Node Key {: #generate-node-key }

To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:

=== "Tanssi MainNet"

    ```bash
    docker run --network="host" -v "/var/lib/tanssi-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ networks.dancelight.operator_docker_image }} key generate-node-key --file /data/node-key
    ```

=== "Dancelight TestNet"

    ```bash
    docker run --network="host" -v "/var/lib/dancelight-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ networks.dancelight.operator_docker_image }} key generate-node-key --file /data/node-key
    ```

!!! note
    This step could be avoided using the `--unsafe-force-node-key-generation` parameter in the start-up command, although this is not the recommended practice.

## Start Your Node {: #start-your-node }

To spin up your node, you must run the Docker image with the `docker run` command. 

Replace `INSERT_YOUR_TANSSI_NODE_NAME` with a human-readable name and set `INSERT_YOUR_IP_ADDRESS` with your public IP address.

!!! note
    It is recommended that you run the optimized binary versions for either Intel's [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} or AMD's [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} architectures for better performance.

=== "Tanssi MainNet"

    === "Generic"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

=== "Dancelight TestNet"

    === "Generic"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

### Run Flags {: #run-flags }

The flags used in the `docker run` command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:

- `--name INSERT_NAME` - a human-readable name for this node
- `--rpc-port INSERT_PORT` - specifies the JSON-RPC TCP port the node listens on
- `--unsafe-rpc-external` - exposes the RPC service on all the interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the state), `archive-canonical` (which keeps only the state of finalized blocks), or any `number` (representing the number of blocks whose states are kept)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - specifies how many blocks should be kept in the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the blocks), `archive-canonical` (which keeps only finalized blocks), or any `number` (representing the amount of finalized blocks to keep)
- `--detailed-log-output` - enables detailed log output

!!! warning
    The `--unsafe-rpc-external` enables external access to your nodeâ€™s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.

For a complete list of available flags, their description, and possible values, run the following command:

=== "Tanssi MainNet"

    ```bash
    docker run -ti {{ networks.dancelight.operator_docker_image }} --help
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    docker run -ti {{ networks.dancelight.operator_docker_image }} --help
    ```

## Syncing Your Node {: #syncing-your-node }

The first time your node spins up, the syncing process displays lots of log information from the node configuration and the chain blocks being synced. Some errors are expected to be displayed at the beginning of the process, disappearing once the chain gets synced to the last block.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker run ....</span>
  <span data-ty>
    <br> 2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] ðŸ’¤ Idle (0 peers), best: #0 (0x4a2bâ€¦7de3), finalized #0 (0x4a2bâ€¦7de3), â¬‡ 0 â¬† 0
    <br> 2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] âœ¨ Imported #14139635 (0x8c41â€¦8df6)    
    <br> 2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] ðŸ’¤ Idle (8 peers), best: #14139635 (0x8c41â€¦8df6), finalized #14139632 (0xa9a8â€¦cab9), â¬‡ 32.7kiB/s â¬†
  </span>
</div>

When the syncing process is finished, your node is ready for the next steps.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/onboarding/run-an-operator/operators-systemd/
--- BEGIN CONTENT ---
---
title: Run an Operator Node Using Systemd
description: Learn how to set up and run an operator (validator) node for Tanssi networks using Systemd, allowing you to participate in the protocol and earn rewards.
icon: simple-linux
categories: Operators
---

# Run an Operator Node Using Systemd

## Introduction {: #introduction }

Operators are a crucial component of the Tanssi ecosystem, providing security and validation services for Tanssi-powered networks. As an operator, you participate in the consensus mechanism that secures the network while earning rewards for your contribution.

As presented in the [onboarding section](/node-operators/operators/onboarding/){target=\_blank}, running the actual node is the first step towards your active participation in the protocol.

In this guide, you'll learn how to spin up a Tanssi operator using the latest stable binary file release and manage the service using [Systemd](https://systemd.io){target=\_blank} on Linux systems.

The article follows the good practice of running the service with its own non-root account and granting that account write access to a specific directory. However, you can adapt this article's steps and instructions to your infrastructure configuration, preferences, and security policies.

## Checking Prerequisites {: #checking-prerequisites }

To get started, you'll need access to a computer running an Ubuntu Linux OS with [Landlock](https://docs.kernel.org/security/landlock.html){target=\_blank} enabled and root privileges. You will also need:

- **Node binary files** - an operator requires three binary files: `tanssi-relay`, `tanssi-relay-execute-worker`, and `tanssi-relay-prepare-worker`.

The instructions in this guide execute the [latest](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank} official stable release. However, you can build your own file compiling the [source code](https://github.com/moondance-labs/tanssi){target=\_blank}.

## Check Landlock Support {: #check-landlock }

Tanssi operators use the Linux kernel's Landlock feature as a security measure to restrict its own access to system resources, limiting the damage if the application is compromised.

Check the Landlock feature support in your system running the following command:

```bash
sudo dmesg | grep landlock || journalctl -kg landlock
```

The output should look like:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>sudo dmesg | grep landlock || journalctl -kg landlock</span>
    <span data-ty>[    0.240344] landlock: Up and running.</span>
</div>

If Landlock is disabled in your system, upgrade the kernel to version 5.13 or above.

## Download the Latest Release {: #download-latest-release }

To get started, download the latest binary release and make it executable by running the following command:

!!! note
    It is recommended that you run the optimized binary versions for either Intel's [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} or AMD's [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} architectures for better performance.

=== "Generic"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "Intel Skylake"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-skylake -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "AMD Zen3"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-znver3 -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

## Set Up the Systemd Service {: #set-up-systemd-service }

[Systemd](https://systemd.io){target=\_blank} is a management system for Linux systems that manages services (daemons in Unix-like systems jargon), starting them automatically when the computer starts or reboots, or restarting them upon unexpected failures.

The following commands configure a new account, create the directory, and move the previously downloaded files to the right location.

1. Create a new account to run the service:

    === "Tanssi MainNet"

        ```bash
        adduser tanssi_service --system --no-create-home
        ```

    === "Dancelight TestNet"
        
        ```bash
        adduser dancelight_service --system --no-create-home
        ```

2. Create a directory to store the required files and data:

    === "Tanssi MainNet"

        ```bash
        mkdir /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        mkdir /var/lib/dancelight-data
        ```

3. Set the folder's ownership to the account that will run the service to ensure writing permission:

    === "Tanssi MainNet"

        ```bash
        chown -R tanssi_service /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        chown -R tanssi_service /var/lib/dancelight-data
        ```

4. Move the binaries to the folder:

    === "Tanssi MainNet"

        ```bash
        mv ./tanssi-relay* /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        mv ./tanssi-relay* /var/lib/dacelight-data
        ```

### Generate the Node Key {: #generate-node-key }

To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key
    ```

=== "Dancelight TestNet"
    
    ```bash
    /var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key
    ```

!!! note
    This step could be avoided using the `--unsafe-force-node-key-generation` parameter in the start-up command, although this is not the recommended practice.

### Create the Systemd Service Configuration File {: #create-systemd-configuration }

The next step is to create the Systemd configuration file.

You can create the file by running the following command:

=== "Tanssi MainNet"

    ```bash
    sudo touch /etc/systemd/system/tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    sudo touch /etc/systemd/system/dancelight.service
    ```

Now you can open the file using your favorite text editor (vim, emacs, nano, etc.) and add the configuration for the service, replacing the `INSERT_YOUR_TANSSI_NODE_NAME` tag with a human-readable name and `INSERT_YOUR_IP_ADDRESS` with your public IP address. The name will come in handy for connecting the log entries and metrics with the node that generates them.

=== "Tanssi MainNet"

    ```bash
    [Unit]
    Description="Tanssi systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    User=tanssi_service
    Type=simple
    Restart=always
    RestartSec=10
    SyslogIdentifier=tanssi
    SyslogFacility=local7
    KillSignal=SIGHUP
    LimitNOFILE=100000
    ExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \
    --base-path=/var/lib/tanssi-data/ \
--node-key-file /var/lib/tanssi-data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
    
    [Install]
    WantedBy=multi-user.target
    ```

=== "Dancelight TestNet"

    ```bash
    [Unit]
    Description="Tanssi systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    User=tanssi_service
    Type=simple
    Restart=always
    RestartSec=10
    SyslogIdentifier=tanssi
    SyslogFacility=local7
    KillSignal=SIGHUP
    LimitNOFILE=100000
    ExecStart=/var/lib/tanssi-data/tanssi-relay --chain=dancelight \
    --base-path=/var/lib/tanssi-data/ \
--node-key-file /var/lib/tanssi-data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator

    [Install]
    WantedBy=multi-user.target
    ```

### Run Flags {: #run-flags }

The flags used in the `ExecStart` command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:

- `--name INSERT_NAME` - a human-readable name for this node
- `--rpc-port INSERT_PORT` - specifies the JSON-RPC TCP port the node listens on
- `--unsafe-rpc-external` - exposes the RPC service on all the interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the state), `archive-canonical` (which keeps only the state of finalized blocks), or any `number` (representing the number of blocks whose states are kept)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - specifies how many blocks should be kept in the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the blocks), `archive-canonical` (which keeps only finalized blocks), or any `number` (representing the amount of finalized blocks to keep)
- `--detailed-log-output` - enables detailed log output

!!! warning
    The `--unsafe-rpc-external` enables external access to your nodeâ€™s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.

For a complete list of available flags, their description, and possible values, run the following command:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-relay --help
    ```

=== "Dancelight TestNet"
    
    ```bash
    /var/lib/dancelight-data/tanssi-relay --help
    ```

## Run the Service {: #run-the-service }

Finally, enable the service and start it for the first time:

=== "Tanssi MainNet"

    ```bash
    systemctl enable tanssi.service && \
    systemctl start tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    systemctl enable dancelight.service && \
    systemctl start dancelight.service
    ```

You can verify that the service is up and running correctly by executing the following command:

=== "Tanssi MainNet"

    ```bash
    systemctl status tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    systemctl status dancelight.service
    ```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>systemctl status network.service</span>
  <span data-ty>
    <br> â— network.service - "Network systemd service"
    <br>&nbsp;&nbsp;&nbsp;Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)
    <br>&nbsp;&nbsp;&nbsp;Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago
    <br>&nbsp;&nbsp;Main PID: 4045278 (container-chain)
    <br>&nbsp;&nbsp;&nbsp;&nbsp;Tasks: 44 (limit: 9462)
    <br>&nbsp;&nbsp;&nbsp;Memory: 6.5G
    <br>&nbsp;&nbsp;&nbsp;CGroup: /system.slice/network.service
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â””â”€4045278 4045278 /var/lib/network-data/container-chain- ...
  </span>
</div>

Check the logs, if needed, with the following command:

=== "Tanssi MainNet"

    ```bash
    journalctl -f -u tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    journalctl -f -u dancelight.service
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/operational-tasks/
--- BEGIN CONTENT ---
---
title: Operational Tasks - Operators
description: Learn how to manage your activities as an operator in the Tanssi network protocol, including managing your account, upgrading your node, and more.
icon: octicons-arrow-switch-24
template: index-page.html
---

# Operational Tasks

Keeping your operator running requires regular maintenance to ensure consistent performance and secure account management. Regular updates are essential to keep your node compatible with the latest Tanssi protocol changes. At the same time, tools such as proxy accounts provide an extra layer of security by allowing you to delegate specific tasks without exposing your primary account credentials. This section provides the steps to keep your operations smooth, reliable, and secure.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/operational-tasks/proxy-accounts/
--- BEGIN CONTENT ---
---
title: Set Up an Operator Proxy Account
description: Follow this step-by-step guide to enable proxy accounts to securely perform operational tasks (such as keys rotation) on behalf of your operator account.
icon: octicons-shield-lock-24
categories: Operators
---

# Set Up an Operator Proxy Account

## Introduction {: #introduction }

Proxy accounts can be set up to perform a limited number of actions on behalf of primary accounts and help keep the underlying accounts safe. As an operator on Tanssi, it's beneficial to use proxy accounts to interact with the network in place of your account.

The `SessionKeyManagement` proxy type conveniently allows the account to rotate session keys on behalf of the primary account. It transforms it into a "hot wallet" that performs regular maintenance duties on behalf of your "cold wallet" operator account. For added safety, you can regularly rotate your proxy account.

Proxy accounts can also help you implement the principle of least privilege for access control. For example, if you have multiple team members, you can give them the minimum access required to carry out their duties via a specific proxy account.

This tutorial will walk you through configuring a `SessionKeyManagement` proxy account on [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank} specifically for operator-related actions and demonstrate how to rotate your newly created keys using the proxy.

## Checking Prerequisites {: #checking-prerequisites }

To follow along with this tutorial, you will need to:

- Open the developer portal

    === "Tanssi MainNet"

        [Mainnet developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/){target=\_blank}

    === "Dancelight TestNet"

        [TestNet developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/){target=\_blank}

- Create or have two accounts accessible in the developer portal
- Both accounts will need to be funded with tokens

If you need help importing your accounts into the developer portal, please check out the [Connecting to the Developer Portal](/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs){target=\_blank} guide.

## Create a Proxy Account {: #create-a-proxy-account }

There are a couple of ways you can create proxy accounts in the developer portal, either from the **Extrinsics** page or the **Accounts** page. However, you must use the **Extrinsics** page to create a time-delayed proxy. The delay provides an additional layer of security for proxies by specifying a delay period based on the number of blocks. This setting prevents the proxy account from executing a transaction until the delay period ends, allowing the primary account that controls the proxy to review or cancel pending transactions.

You can also create a proxy of type `Any`, which grants the proxy account full and unrestricted control over the primary account. The proxy account can transfer funds and perform any arbitrary action. The following demo will showcase how to configure a `SessionKeyManagement` proxy, which is more restrictive than an `Any` proxy, as it limits functionality to activities that pertain to mapping session keys.

### Using the Extrinsics Section {: #creating-proxy-account-using-extrinsics }

To start creating your proxy account, head to the **Developer** tab and select **Extrinsics** from the dropdown. Next, you will need to take the following steps:

1. Select the primary account
2. From the **submit the following extrinsic** dropdown, select **proxy**
3. Choose the **addProxy** extrinsic
4. Choose **Id** from the **AccountIdLookupOf** dropdown
5. Select the **delegate** account for the proxy
6. From the **proxyType** dropdown, choose **SessionKeyManagement**
7. Optionally, you can add a time delay using a specified number of blocks to add an additional layer of security for the primary account to review the pending transaction
8. Click **Submit Transaction**

![Add a proxy account from the Extrinsics page of the developer portal](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-1.webp)

You will then be prompted to authorize and sign the transaction. Click **Sign and Submit** to create the proxy relationship. Once the transaction has been successfully submitted, you will receive some notifications confirming the transaction.

### Using the Accounts Section {: #creating-proxy-account-using-accounts }

Another method for creating a proxy is by using the **Accounts** section of the developer portal. To do so, navigate to the **Accounts** page and take the following steps:

1. Select the three vertical dots next to the primary account
2. Select **Add proxy**

![Select the Add proxy menu item from the Accounts page of the developer portal](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-2.webp)

!!! note
    If the account already has a proxy, **Manage proxies** will be displayed as an option instead of **Add proxy**.

A pop-up will appear where you can enter the required information, such as the proxied/primary account, the proxy account, and the type of proxy to create a proxy account. First, click **Add proxy**.

![Add a proxy account from the Accounts page of the developer portal](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-3.webp)

Then, take the following steps:

1. Select the account you would like to set as a proxy
2. Select the proxy type
3. Click **Submit** and sign the transaction

![Add the details of the proxy account, including the proxy account and type](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-4.webp)

In the next section, you will learn how to verify if your proxy account was set up successfully.

## Verify Your Proxy Account {: #verify-your-proxy-account }

You can verify that your proxy account has been successfully set up in two ways: through the **Accounts** page or via the **Chain state** page.

### Using the Chain State Section {: #verifying-your-proxy-account-chain-state }

To check your proxy accounts from the **Chain state** section of the developer portal, you can take the following steps:

1. From the **selected state query** dropdown, select **proxy**
2. Choose the **proxies** entry from the list
3. Select or paste your primary/proxied account
4. Click on the **+** button to send the query

![Verify your proxy accounts via the chain state page of the developer portal](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-5.webp)

The result will appear on the page showing you information about your proxies, including the delegate/proxy account address, the proxy type, the delay period if one was specified, and the total bond amount for all of your proxies, expressed in Planck units.

### Using the Accounts Section {: #verifying-your-proxy-account-accounts-section }

You can also check your proxy accounts from the **Accounts** section of the developer portal. To do so, navigate to the **Accounts** page and take the following steps:

1. Select the three vertical dots next to the primary account
2. Select **Manage proxy**

!!! note
    There should be a proxy symbol next to the primary account. To achieve the same effect, hover over the icon and click **Manage proxies**.

![Manage your proxies via the Accounts page of the developer portal](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-6.webp)

A pop-up will appear where you can see an overview of your proxy accounts.

![Review your proxy accounts](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-7.webp)

## Execute a Proxy Transaction {: #execute-a-proxy-transaction }

Now that you have created a proxy account and verified that it was successfully set up, you can execute a transaction using the proxy on behalf of your primary account. The following example will set keys for a node. The proxy configuration shown is a realistic example of how you might have your own proxy configured for your developer portal primary account.

To execute a transaction, you can navigate back to the **Extrinsics** page and take the following steps:

1. Select the proxy account to submit the transaction from the **using the select account** dropdown
2. From the **submit the following extrinsic** menu, select **proxy**
3. Choose the **proxy** extrinsic
4. Choose **Id** from the **AccountIdLookupOf** dropdown
5. Select the primary account from the **real** dropdown
6. Select the **Session** call
7. Choose the **setKeys** entry
8. Enter the node keys you want to map to your operator's account
9. Enter `0x` in **proof**
10. Click **Submit Transaction**

![Execute a proxy transaction from the Extrinsics page of Polkadot.js Apps](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-8.webp)

A pop-up will appear asking you to authorize and sign the transaction; click on **Sign and Submit**.

That's it! You've successfully executed a transaction using a proxy account on behalf of your primary operator account.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/operational-tasks/upgrade-your-node/
--- BEGIN CONTENT ---
---
title: Upgrade an Operator Node
description: Follow these steps to update your node to the latest version of the Tanssi client software, ensuring seamless operations on the Tanssi network protocol.
icon: octicons-rocket-24
template: index-page.html
---

# Upgrade an Operator Node

Keeping your node updated is critical to maintaining compatibility with the latest Tanssi protocol changes and ensuring optimal performance. Outdated nodes can lead to desynchronization, reduced efficiency, or even an inability to participate in the protocol. By staying current with client releases, you can ensure your node operates securely and reliably within the network.

!!! tip "Subscribe to Release Notifications" 
    Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  

    To subscribe, visit the [Tanssi GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} repository and click **Watch**. Select **Custom notifications** and ensure the box for **Releases** is checked.

## Explore What This Section Covers

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/
--- BEGIN CONTENT ---
---
title: Upgrade Your Sequencer Docker Node
description: Follow these instructions to update your Tanssi sequencer node running via Docker to the latest version of the Tanssi client software.
icon: simple-docker
categories: Operators
---

# Upgrade Your Node Running via Docker

## Introduction {: #introduction }

Keeping your node up-to-date is an important part of being a Tanssi operator. Not only does it help ensure that your node stays healthy, but it also contributes to keeping the entire Tanssi Network running smoothly.

This tutorial covers upgrading your Tanssi operator node that was configured using Docker. It assumes you have already set up your account and launched an [operator node using Systemd](/node-operators/operators/onboarding/run-an-operator/operators-systemd/){target=\_blank}.

!!! tip "Subscribe to Release Notifications" 
    Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  

    To subscribe, visit the [Tanssi GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} repository and click **Watch**. Select **Custom notifications** and ensure the box for **Releases** is checked.

## Upgrade Docker Nodes {: #upgrading-docker-nodes }

Upgrading your node is as simple as stopping the running container and restarting it with the new version tag.

First, get the container ID of your Tanssi operator node with the following command:

```bash
docker ps -a
```

The container ID is the first column and if you're running multiple Docker containers, you can identify it by the image name of `{{ networks.dancelight.operator_docker_image }}`. You can run the stop command as follows:

```bash
docker stop INSERT_YOUR_CONTAINER_ID
```

Your terminal interaction will resemble the following:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker ps -a</span>
  <span data-ty>
    <br> 
    <br> CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES
    <br> aa751703d6aa moondancelabs/dancelight-chain:2 "/chain-network/tansâ€¦" 56 seconds ago  Up 56 seconds             determined_darwin
    <br> 
    <span data-ty="input"><span class="file-path"></span>docker stop aa751703d6aa</span>
    <br> aa751703d6aa
  </span>
</div>

To restart the node, you can use the same command you used when launching your node the first time. The command pulls the image and the node will resume syncing blocks from where it left off when the Docker process was stopped.

=== "Tanssi MainNet"

    === "Generic"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

=== "Dancelight TestNet"

    === "Generic"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

!!! note
    It is recommended that you run the optimized binary versions for either Intel's [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} or AMD's [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} architectures for better performance.

### Specify a Version Tag {: #specifying-a-version-tag }

To use a specific [version tag](https://hub.docker.com/r/moondancelabs/tanssi/tags){target=\_blank}, append it to the image name. For example, to fetch the version tagged `latest` (which is the default), append `:latest` to `{{ networks.dancelight.operator_docker_image }}`.

And that's it! You've successfully upgraded your Tanssi node.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/
--- BEGIN CONTENT ---
---
title: Upgrade Your Operator Systemd Node
description: Follow these instructions to update your Tanssi operator node running via Systemd to the latest version of the Tanssi client software.
icon: simple-linux
categories: Operators
---

# Upgrade Your Node Running via Systemd

## Introduction {: #introduction }

Keeping your node up-to-date is an important part of being a Tanssi operator. Not only does it help ensure that your node stays healthy, but it also contributes to keeping the entire Tanssi Network running smoothly.

This tutorial covers upgrading your Tanssi operator node that was configured using Systemd. It assumes you have already set up your account and launched a [operator node using Systemd](/node-operators/operators/onboarding/run-an-operator/operators-systemd/){target=\_blank}.

!!! tip "Subscribe to Release Notifications" 
    Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  

    To subscribe, visit the [Tanssi GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} repository and click **Watch**. Select **Custom notifications** and ensure the box for **Releases** is checked.

## Upgrading Your Systemd Node {: #upgrading-your-systemd-node }

If you're running your operator via the Systemd service, you must take steps to upgrade your node correctly. In short, you'll need to stop the service, replace the Tanssi binary with the updated version, and restart the service.

You can stop your Tanssi Systemd service with the following command:

```bash
systemctl stop tanssi.service
```

Then, navigate to the directory where your Tanssi binaries are stored and remove them.

```bash
cd /var/lib/tanssi-data
```

If you haven't changed your Tanssi binary file names, they will be named `tanssi-relay`, `tanssi-relay-execute-worker`, and `tanssi-relay-prepare-worker`. Otherwise, you can replace `tanssi-relay*` in the command below with the correct names of your Tanssi binary files.

```bash
rm tanssi-relay*
```

To download the latest release and change permissions on it so the Tanssi service can use it, run the following command that corresponds to your environment:

=== "Generic"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "Intel Skylake"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-skylake -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "AMD Zen3"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-znver3 -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

You can restart your Tanssi Systemd service with the following command:

```bash
systemctl start tanssi.service
```

The node will resume syncing blocks from where it left off when the Systemd service was stopped. To verify that it is running correctly, you can use the following command to check the logs:

```bash
systemctl status tanssi.service
```

And that's it! You've successfully upgraded your Tanssi node.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/
--- BEGIN CONTENT ---
---
title: Tanssi Sequencers
description: Learn how to set up, run, and manage sequencers (block producers) to participate in the Tanssi infrastructure protocol and earn rewards.
icon: octicons-server-24
template: index-page.html
---

# Tanssi Sequencers

Sequencers play a critical role in maintaining the liveness and performance of the Tanssi ecosystem. They are responsible for producing blocks, executing transactions, and ensuring the network's smooth operation. This section provides everything you need to get started, from initial setup to operational best practices and account management.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/offboarding/account/
--- BEGIN CONTENT ---
---
title: Decommissioning Your Sequencer
description: In these step-by-step instructions, learn how to properly offboard as a Tanssi sequencer, including unmapping your session keys and unstaking your bond.
icon: octicons-arrow-down-right-24
categories: Sequencers
---

# Offboard as a Tanssi Sequencer

## Introduction {: #introduction }

As a sequencer, there may come a time when you need to gracefully exit the network. Decommissioning your account involves a two-step process to ensure that your node is properly disassociated from your account and that you receive your bond back.

This guide will show you how to wind down your operations as a Tanssi sequencer properly. This includes undelegating your self-delegation to reclaim your bond and unmapping your session keys to sever the connection between your node and your account. Naturally, this guide assumes that you're an existing Tanssi sequencer with a [sequencer node](/node-operators/sequencers/onboarding/run-a-sequencer/){target=\_blank} and mapped [session keys](https://wiki.polkadot.com/learn/learn-cryptography/#session-keys){target=\_blank}.

## Request Undelegation {: #request-undelegation }

When you set up your Tanssi sequencer, you had to submit a delegation bond (at least `{{ networks.mainnet.sequencers.minimum_self_delegation }}` {{ networks.mainnet.token_symbol }} for Tanssi MainNet). To get that back and remove your sequencer from the list of eligible candidates, you'll need to take steps similar to those in the onboarding process.

### View Existing Stake {: #viewing-existing-stake }

Before undelegating, it is helpful first to see how much you have staked, as you'll need to provide this figure later. To do so, head to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, click on the **Developer** tab, select **Chain State** from the dropdown, and take the following steps:

1. Select the **pooledStaking** module
2. Select the **pools** query
3. Enter your sequencer account
4. Ensure that the **include option** slider is toggled on
5. In the **option** field, you select **JoiningShares**
6. Click the **+** button next to the extrinsic field

![Check existing stake on the developer portal](/images/node-operators/sequencers/offboarding/account/account-1.webp)

Note, **JoiningShares** returns only the initial amount you delegated when configuring your sequencer. To get your total amount staked, you'll need to repeat the above steps for either **ManualRewardShares** or **ManualRewardSharesHeldStake** if you didn't select Autocompounding, and either **AutoCompoundingShares** or **AutoCompoundingSharesHeldStake** if you configured Autocompounding. Then add your autocompounding or manual shares value to **JoiningShares** to get your total delegation outstanding.

As an example, the total stake of an autocompounding sequencer can be calculated by adding **JoiningShares** to **AutoCompoundingShares**. Note this amount, as you'll need it in the next section.

### Submit Undelegation Request {: #submit-undelegation-request }

Head to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, click on the **Developer** tab, select **Extrinsics** from the dropdown, and take the following steps:

1. Select the account from which you want to send the transaction. This account must be your existing sequencer account that you initially delegated from
2. Select the **pooledStaking** module
3. Select the **requestUndelegate** extrinsic
4. Enter your account, which is, again, the same account you are sending the extrinsic from and the account you want to decommission as a sequencer
5. Choose the target pool that you originally used when configuring your delegation (either **Autocompounding** or **Manual**)
6. Select **Stake** or **Shares** from the dropdown
7. Enter the amount to unstake. If you selected **Shares**, simply enter the number of Shares. If you selected **Stake**, you'll need to submit the value, including the twelve decimal places used by the Tanssi Network. As a reminder, the minimum stake amount is `{{ networks.mainnet.sequencers.minimum_self_delegation }}` {{ networks.mainnet.token_symbol }}. If you delegated the minimum amount and didn't accumulate additional rewards, you'll need to enter `{{ networks.mainnet.sequencers.minimum_self_delegation }}000000000000`
8. Click **Submit Transaction** and sign and send the transaction from your wallet

![Create and submit an extrinsic to un-delegate on the developer portal](/images/node-operators/sequencers/offboarding/account/account-2.webp)

### Execute the Pending Request {: #execute-pending-request }

You'll need to wait before executing the pending request. In the case of Tanssi MainNet, the waiting period is configured to at least {{ networks.mainnet.staking.leaving_delay_sessions_text }} sessions. Each session is comprised of `{{ networks.mainnet.session.blocks }}` blocks and translates to about {{ networks.mainnet.session.hours }} hour per session. So, {{ networks.mainnet.staking.leaving_delay_sessions_text }} sessions correspond to approximately {{ networks.mainnet.staking.leaving_delay_hours_text }} hours.

Before executing the pending request, you'll need to retrieve the session at which you submitted the request to delegate. To do so, head to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, click on the **Developer** tab, select **Chain state** from the dropdown, and take the following steps:

1. Select the **pooledStaking** module
2. Select the **pendingOperations** query
3. Enter your sequencer account
4. Toggle the **include option** slider off
5. Click the **+** button next to the extrinsic field
6. The pending request will be displayed at the bottom of the page

![Query the pending undelegation request on the developer portal](/images/node-operators/sequencers/offboarding/account/account-3.webp)

In the example in the above image, the undelegate request to leave the auto-compounding pool was submitted during session `5,037`. So, the request can be executed starting at session `5,039`. Take note of the operation and the session index at which you submitted the request, as you'll need both values to execute the pending request.

You can run another query from the **Chain state** page to check the current session. To do so, you can:

1. Select the **session** module
2. Select the **currentIndex** query
3. Click the **+** button next to the extrinsic field
4. The current session will be displayed at the bottom of the page

![Query the current session index on the developer portal](/images/node-operators/sequencers/offboarding/account/account-4.webp)

If at least two sessions have passed from the session you submitted the extrinsic, the request is ready to be executed. To do so, select **Extrinsics** from the **Developer** dropdown and take the following steps:

1. Select the account from which you want to send the extrinsic
2. Select the **pooledStaking** module
3. Select the **executePendingOperations** extrinsic
4. For **delegator**, enter your account, which is the same account you sent the self-delegate request from
5. For **operation**, select **Leaving**
6. For **candidate**, enter the same account as you did in the **delegator** field
7. For **at**, enter the session index at which you submitted the delegate request
8. Click **Submit Transaction** and sign and send the transaction from your wallet

![Create and submit an extrinsic to execute the pending self-delegation request on the developer portal](/images/node-operators/sequencers/offboarding/account/account-5.webp)

### Verify That Your Account Is Not in the List of Eligible Candidates {: #verify }

If you'd like, you can verify that your sequencer is no longer in the list of eligible candidates. To do so, go to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, click on the **Developer** tab, select **Chain state** from the dropdown, and take the following steps:

1. Select the **pooledStaking** module and the **sortedEligibleCandidates** query
2. Click the **+** button next to the extrinsic field
3. A list of the eligible candidates and their stakes will be displayed at the bottom of the page. You can search for your address to ensure that it does not exist in the list

![Query the current list of eligible candidates on the developer portal](/images/node-operators/sequencers/offboarding/account/account-6.webp)

## Unmap Session Keys {: #unmap-session-keys }

Session keys are used to perform network operations, such as signing blocks, whereas your sequencer account holds the staked funds and has an on-chain identity. By unmapping the session key to your account, you sever the association between your sequencer account and your sequencer node.

The unmapping step is taken only as part of the offboarding process. If you need to rotate/change your session keys, you'll need to follow the [generating and mapping new session keys](/node-operators/sequencers/onboarding/account-setup/#map-session-keys){target=\_blank}. You should not purge your keys during the session key rotation process.

To unmap your session keys, head to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, click on the **Developer** tab, select **Extrinsics** from the dropdown, and take the following steps:

1. Select your Tanssi sequencer account
2. Select the **session** module
3. Select **purgeKeys** extrinsic
4. Click **Submit Transaction** and sign and send the transaction from your wallet

![Unmap session keys on the developer portal](/images/node-operators/sequencers/offboarding/account/account-7.webp)

Using the `session.keyOwner` method, you can verify that your session keys have been unmapped from your account as expected. To do this on the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, click on the **Developer** tab, select **Chain state** from the dropdown, and take the following steps:

1. Select the **session** module
2. Select the **keyOwner** query
3. Enter `nmbs` in the **SpCoreCryptoKeyTypeId** field
4. For **Bytes**, enter your hex-encoded session keys
5. Click the **+** button next to the extrinsic field
6. The query should return none

![Verifying Unmapping was successful](/images/node-operators/sequencers/offboarding/account/account-8.webp)

And that's it! You have successfully offboarded a Tanssi sequencer. If you change your mind at any point and want to onboard back as a Tanssi sequencer, you can follow the steps in the [onboarding guide](/node-operators/sequencers/onboarding/account-setup/){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/offboarding/
--- BEGIN CONTENT ---
---
title: Offboard Your Sequencer Node
description: Learn how to properly offboard your sequencer node (also known as block producers) including clearing session keys and undelegating funds.
icon: octicons-arrow-down-right-24
template: index-page.html
---

# Offboarding

Stepping down as a sequencer requires following the proper procedures to ensure a smooth transition. This section provides clear instructions to unmap your session keys and undelegate your self-bonded stake, allowing you to safely reclaim your funds and disconnect your account from the network.

What youâ€™ll learn:

- [**Removing your self-delegation**](/node-operators/sequencers/offboarding/account/#request-undelegation) - steps to remove your self-bonded stake and ensure your sequencer is no longer listed as an eligible participant
- [**Unmapping session keys**](/node-operators/sequencers/offboarding/account/#unmap-session-keys) - how to unmap your session keys, properly severing the connection between your node and your account

!!! tip "Rejoining as a Sequencer" 
    If you decide to return as a Tanssi sequencer in the future, you can easily onboard again by following the steps outlined in the [Onboarding](/node-operators/sequencers/onboarding/) guide.

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/onboarding/account-setup/
--- BEGIN CONTENT ---
---
title: Setup an Account to Produce Blocks
description: Follow these step-by-step instructions on becoming eligible to produce blocks on Tanssi-powered networks and setting up your account for rewards payouts.
icon: octicons-person-add-24
categories: Sequencers
---

# Set Up Your Account to Produce Blocks on Tanssi

## Introduction {: #introduction }

Before you can start producing blocks on Tanssi-powered networks, you'll need to set up your account and establish your eligibility.

You must have spun up a [Sequencer node](/node-operators/sequencers/onboarding/run-a-sequencer/){target=\_blank} to tackle the account setup steps in this guide.

You'll need to set up your account by generating [session keys](https://wiki.polkadot.com/learn/learn-cryptography/#session-keys){target=\_blank} and mapping those session keys to your account.  This account is the one to which delegators will choose to delegate and where your rewards will be distributed. You can optionally [establish a proxy account](/node-operators/sequencers/operational-tasks/proxy-accounts/){target=\_blank} for additional security. 

To establish eligibility, you must delegate yourself as a sequencer and meet the minimum bond requirements.

By following the steps outlined in this guide, you'll learn everything you need to know to get started producing blocks within the Tanssi ecosystem.

## Important Variables {: #important-variables }

When establishing eligibility to produce blocks, there are a couple of variables to be aware of:

- **Minimum self-delegation** - there is a minimum amount you must self-delegate to be considered eligible
- **Session** - a period that has a constant set of sequencers
- **Network sequencers per session** - the number of sequencers assigned to a Tanssi-powered network per session

=== "Tanssi MainNet"
    |            Variable            |                                             Value                                             |
    |:------------------------------:|:---------------------------------------------------------------------------------------------:|
    |    Minimum self-delegation     | {{ networks.mainnet.sequencers.minimum_self_delegation }} {{ networks.mainnet.token_symbol }} |
    |            Session             |                         {{ networks.mainnet.session.blocks }} blocks                          |
    | Network sequencers per session |    {{ networks.mainnet.sequencers.configuration.block_producer_per_container }} sequencers    |
  
=== "Dancelight TestNet"
    |            Variable            |                                             Value                                             |
    |:------------------------------:|:---------------------------------------------------------------------------------------------:|
    |    Minimum self-delegation     | {{ networks.dancelight.sequencers.minimum_self_delegation }} {{ networks.dancelight.token_symbol }} |
    |            Session             |                         {{ networks.dancelight.session.blocks }} blocks                          |
    | Network sequencers per session |    {{ networks.dancelight.sequencers.configuration.block_producer_per_container }} sequencers    |

## Map an Account to Your Sequencer Node {: #map-account }

The first step is a two-step process that generates [session keys](https://wiki.polkadot.com/learn/learn-cryptography/#session-keys){target=\_blank} and maps the session keys to your account. Session keys are used to perform network operations, such as signing blocks, whereas your account holds the staked funds and has an on-chain identity. By mapping the session key to your account, you create an association between your account and your sequencer.

You will need to create session keys for your primary and backup servers. Each of your servers, your primary and backup, should have its own unique keys. Since the keys never leave your servers, you can consider them a unique ID for that server.

### Generate Session Keys {: #generate-session-keys }

Before generating session keys, you must be [running a sequencer node](/node-operators/sequencers/onboarding/run-a-sequencer/){target=\_blank}.

To generate session keys, you'll send an RPC call, using the `author_rotateKeys` method, to your node's HTTP endpoint. For reference, if your sequencer's HTTP endpoint is at port `9945`, the JSON-RPC call might look like this:

```bash
curl http://127.0.0.1:9945 -H \
"Content-Type:application/json;charset=utf-8" -d \
  '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"author_rotateKeys",
    "params": []
  }'
```

Your hex-encoded session keys will be printed to the terminal in the `"result"` field.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>curl http://127.0.0.1:9944 -H \
    <br>  "Content-Type:application/json;charset=utf-8" -d \
    <br>    '{
    <br>        "jsonrpc":"2.0",
    <br>        "id":1,
    <br>        "method":"author_rotateKeys",
    <br>        "params": []
    <br>    }'
  </span>
  <span data-ty>{"jsonrpc":"2.0","result":</span>
  <span data-ty>
  "0x76afaf334bd33b82d0b8fbd6a2845cb3b9b785edf1dce4ccefd4973fa79fed2b","id":1}</span>
</div>

Make sure you write down your session keys; you'll need to map your session keys to your account in the next section.

### Map Session Keys {: #map-session-keys }

To perform the next step and map your session keys to your account, head to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, click on the **Developer** tab, select **Extrinsics** from the dropdown, and take the following steps:

1. Select your account, which should be the same account that you previously self-delegated
2. Select the **session** module and the **setKeys** extrinsic
3. For **keys**, enter your session keys
4. For **proof**, enter `0x`
5. Click **Submit Transaction** and sign and send the transaction from your wallet

![Create and submit a transaction to set session keys on Polkadot.js Apps](/images/node-operators/sequencers/onboarding/account-setup/setup-1.webp)

Using the `session.keyOwner` method, you can verify that your session keys have been mapped to your account as expected. To do this on the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, click on the **Developer** tab, select **Chain state** from the dropdown, and take the following steps:

1. Select the **session** module and the **keyOwner** query
2. Enter `nmbs` in the **SpCoreCryptoKeyTypeId** field
3. For **Bytes**, enter your hex-encoded session keys
4. Click the **+** button next to the extrinsic field
5. The account associated with the session keys, which should be your account, will be displayed at the bottom of the page

![Create and submit query to verify session keys on the developer portal](/images/node-operators/sequencers/onboarding/account-setup/setup-2.webp)

## Submit Self-Delegation {: #submit-self-delegation }

The next step towards becoming eligible to produce blocks on Tanssi-powered networks is to delegate to your own account. To do this, you'll be required to submit a minimum of tokens, as listed in the [important variables](#important-variables) section.

After you've submitted the request to delegate, you'll need to wait for a minimum of sessions before you can execute the pending request. In the case of Tanssi MainNet, the number of sessions is configured to {{ networks.mainnet.staking.joining_delay_sessions_text }}. There are {{ networks.mainnet.session.blocks }} blocks in a session. So, {{ networks.mainnet.staking.joining_delay_sessions_text }} sessions are {{ networks.mainnet.staking.joining_delay_blocks }} blocks, which can take around {{ networks.mainnet.staking.joining_delay_hours_text }} hours.

Sequencers are assigned upon each session. The sequencers participating in the session are picked from the list of candidates ordered by total stake until the total number of sequencers required is covered. So, you'll need to ensure that your total stake is enough to fill one of the slots, which may require more than the minimum self delegation.

### Request Delegate {: #request-delegate }

Head to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, click on the **Developer** tab, select **Extrinsics** from the dropdown, and take the following steps:

1. Select the account from which you want to send the transaction. This account must be the same account that you are delegating to and is the account that you want to become a sequencer
2. Select the **pooledStaking** module and the **requestDelegate** extrinsic
3. Enter your account, which is, again, the same account you are sending the transaction from and the account you want to become a sequencer
4. Choose the target pool. The pool can either be the auto-compounding pool, which auto-compounds delegation rewards, or the manual rewards pool, in which all actions related to rewards are manual
5. Enter the amount to stake. This amount must meet the minimum, which is {{ networks.mainnet.sequencers.minimum_self_delegation }} {{ networks.mainnet.token_symbol }} tokens for Tanssi MainNet. Tanssi Network uses twelve decimal places, so when submitting the value make sure you add the decimal places to the self delegation. For MainNet, the value would be `{{ networks.mainnet.sequencers.minimum_self_delegation }}000000000000`
6. Click **Submit Transaction** and sign and send the transaction from your wallet

![Create and submit a transaction to self-delegate on Polkadot.js Apps](/images/node-operators/sequencers/onboarding/account-setup/setup-3.webp)

### Execute the Pending Request {: #execute-pending-request }

Before executing the pending request, you'll need to retrieve the session at which you submitted the request to delegate. To do so, head to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, click on the **Developer** tab, select **Chain state** from the dropdown, and take the following steps:

1. Select the **pooledStaking** module and the **pendingOperations** query
2. Enter your account
3. Toggle the **include option** slider off
4. Click the **+** button next to the extrinsic field
5. The pending request will be displayed at the bottom of the page

![Query the pending self-delegation request on the developer portal](/images/node-operators/sequencers/onboarding/account-setup/setup-4.webp)

In the example in the above image, the delegate request to join the auto-compounding pool was submitted during session 4,829. So, the request can be executed starting at session 4,831.

Take note of the operation and the session number at which you submitted the request, as you'll need both values to execute the pending request.

You can run another query from the **Chain state** page to check the current session. To do so, you can:

1. Select the **session** module and the **currentIndex** query
2. Click the **+** button next to the extrinsic field
3. The current session will be displayed at the bottom of the page

![Query the current session index on the developer portal](/images/node-operators/sequencers/onboarding/account-setup/setup-5.webp)

If the request can be executed, select **Extrinsics** from the **Developer** dropdown and take the following steps:

1. Select the account from which you want to send the transaction
2. Select the **pooledStaking** module and the **executePendingOperations** transaction
3. For **delegator**, enter your account, which is the same account you sent the self-delegate request from
4. For **operation**, select the type of operation to execute. This should be either **JoiningAutoCompounding** or **JoiningManualRewards**, depending on the target pool you selected at the time of submitting the self-delegation request
5. For **candidate**, enter the same account as you did in the **delegator** field
6. For **at**, enter the session id at which you submitted the delegate request
7. Click **Submit Transaction** and sign and send the transaction from your wallet

![Create and submit a transaction to execute the pending self-delegation request on the developer portal](/images/node-operators/sequencers/onboarding/account-setup/setup-6.webp)

Now, you have completed all of the necessary account setup to be eligible to produce blocks!

## Verify That Your Account Is in the List of Eligible Candidates {: #verify }

If you've followed all of the steps in this guide and have fully synced your sequencer, you are now eligible to produce blocks. To verify that you are in the list of eligible candidates, you can go to the [developer portal](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, click on the **Developer** tab, select **Chain state** from the dropdown, and take the following steps:

1. Select the **pooledStaking** module and the **sortedEligibleCandidates** query
2. Click the **+** button next to the extrinsic field
3. A list of the eligible candidates and their stake will be displayed at the bottom of the page. You can search for your address to ensure you are eligible to produce blocks

![Query the current list of eligible candidates on the developer portal](/images/node-operators/sequencers/onboarding/account-setup/setup-7.webp)

Remember that you'll need to be in the top candidates by total stake to produce blocks, and this is based on the number of [sequencers required for each network and Tanssi](#important-variables).
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/onboarding/
--- BEGIN CONTENT ---
---
title: Onboard to Run a Sequencer Node
description: Learn how to get started to run a sequencer using Docker or Systemd to participate in the protocol, provide block production services, and earn rewards.
icon: octicons-arrow-up-right-24
template: index-page.html
---

# Onboarding

Your journey as a sequencer begins here. Follow these steps to set up your node and prepare your account for active participation in the Tanssi network.

[timeline left (tanssi-docs/.snippets/text/node-operators/sequencers/onboarding/onboarding-timeline.json)]

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/onboarding/run-a-sequencer/
--- BEGIN CONTENT ---
---
title: Run a Sequencer
description: Learn how to set up and run a sequencer node using Docker or Systemd to participate in the protocol, providing block production services and earning rewards.
icon: octicons-server-24
template: index-page.html
---

# Run a Sequencer Node

Setting up a sequencer node is an important step to participate in the Tanssi network. You have two options: _Docker_ or _Systemd_. Whichever path you choose, we provide step-by-step tutorials to guide you through the process and ensure your node meets the necessary requirements to produce blocks and maintain a secure connection to the network.

### Hardware Requirements

To run a sequencer node successfully, using high-performance hardware is essential. Suboptimal configurations can lead to delays, missed authoring rounds, and lost rewards. Since the block production and import process relies heavily on single-threaded performance, prioritizing CPUs with strong single-thread capabilities over higher core counts is recommended.

Recommended Hardware:

- **Recommended CPUs** - Intel Xeon E-2386/2388 or Ryzen 9 5950x/5900x
- **Recommended NVMe** - 1 TB NVMe
- **Recommended RAM** - 32 GB RAM

!!! warning 
    As a sequencer, you are responsible for both your own stake and that of your delegators. Maintaining your node's performance, keeping it updated, and ensuring its security are critical for maximizing rewards and building a strong reputation within the Tanssi network.

### Required Network Ports

For successful block production, your node must synchronize and interact with two peer-to-peer (P2P) networks. To ensure proper communication within the Tanssi ecosystem, make sure the following ports are open for incoming:

| Network          | Port        |
|------------------|-------------|
| Tanssi Chain     | 30334 (TCP) |
| Assigned Network | 30333 (TCP) |

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/
--- BEGIN CONTENT ---
---
title: Run a Sequencer Using Docker
description: Learn how to set up and run a sequencer (aka block producer) for Tanssi-powered appchains using Docker to participate in the protocol and earn rewards.
icon: simple-docker
categories: Sequencers
---

# Run a Sequencer in Tanssi Using Docker

## Introduction {: #introduction }

One of Tanssi's core propositions is that it provides decentralized and trustless block production for its networks. Tanssi's runtime handles sequencer assignments to all the active networks in the Tanssi ecosystem.

Each time, the assignment algorithm distributes the available set of sequencers per session, assigning them to a random chain. Consequently, they would be producing blocks for the same network only for a relatively short period, increasing the overall security of the ecosystem.

To this end, Tanssi's binary file (the software used to run nodes) already has an embedded mechanism to switch block production automatically to the assigned chain without requiring the node operator to make any changes. The binary includes the logic to sync the new chain and produce blocks when the session changes. Consequently, sequencers need to run the Tanssi binary file, and not that of the networks (like full nodes do).

In this guide, you'll learn how to spin up a Tanssi sequencer to be part of the shared pool of sequencers using [Docker](https://www.docker.com){target=\_blank} on a Linux computer. However, it can be adapted to other operating systems.

## Checking Prerequisites {: #checking-prerequisites }

### Installing Docker {: #installing-docker}

To get started, you'll need access to a computer running a Linux OS and install [Docker](https://docs.docker.com/desktop/setup/install/linux/){target=\blank}.

Run the following command to install Docker on a Linux Ubuntu platform:

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

And the following command to check the installation:

```bash
sudo docker run hello-world
```

This is what a successful execution in the terminal looks like:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>sudo docker run hello-world</span>
  <span data-ty>
    <br> 
    <br> Hello from Docker!
    <br> This message shows that your installation appears to be working correctly.
    <br> 
    <br> To generate this message, Docker took the following steps:
    <br> 1. The Docker client contacted the Docker daemon.
    <br> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    <br>     (amd64)
    <br> 3. The Docker daemon created a new container from that image which runs the
    <br>     executable that produces the output you are currently reading.
    <br> 4. The Docker daemon streamed that output to the Docker client, which sent it
    <br>     to your terminal.
    <br>
    <br> To try something more ambitious, you can run an Ubuntu container with:
    <br> $ docker run -it ubuntu bash
    <br>
    <br> Share images, automate workflows, and more with a free Docker ID:
    <br> https://hub.docker.com/
    <br>
    <br> For more examples and ideas, visit:
    <br>  https://docs.docker.com/get-started/
  </span>
</div>

## Pulling the Docker Image {: #pulling-docker-image }

A Docker image is built and published in every release, containing all the necessary dependencies a Tanssi sequencer requires and the binary file itself.

A Docker image combines the binary corresponding to the latest stable release of the [client node](/learn/framework/architecture/#architecture){target=\_blank}, along with the Tanssi orchestrator specification file.

The following command to pull the Docker image:

=== "Tanssi MainNet"

    ```bash
    docker pull {{ node_versions.docker_sequencer_image_name }}
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    docker pull {{ node_versions.docker_sequencer_image_name }}
    ```

The command will download and extract the image and show the status upon execution:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker pull moondancelabs/tanssi</span>
  <span data-ty>
    <br> 
    <br> Using default tag: latest
    <br> latest: Pulling from moondancelabs/tanssi
    <br> e1caac4eb9d2: Pull complete 
    <br> 1d4409959e6d: Pull complete 
    <br> b8beed19c122: Pull complete 
    <br> c0fab1f18601: Pull complete 
    <br> d9dcf3cddfc5: Pull complete 
    <br> Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c
    <br> Status: Downloaded newer image for moondancelabs/tanssi
    <br> docker.io/moondancelabs/tanssi
  </span>
</div>

## Download the Tanssi Chain Specs File {: #download-tanssi-specs }

The node binary file also includes the necessary code to run a Tanssi orchestration chain node. When launching a sequencer, it will also be required to provide the Tanssi orchestration chain specification file as a parameter.

Download the Tanssi orchestration chain specification file by executing the following:

=== "Tanssi MainNet"

    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json
    ```

=== "Dancelight TestNet"
    
    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json
    ```

## Setup the Data Directory {: #setup-data-directory }

Running a sequencer or an appchain node require syncing with two chains: the Tanssi orchestration chain and the appchain it is working for.

Run the following command to create the directory where your node will store the databases containing blocks and chain states:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the Docker image to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    chown INSERT_DOCKER_USER /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    chown INSERT_DOCKER_USER /var/lib/dancelight-data
    ```

Or run the following command if you want to run the sequencer with the current logged-in user:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data
    ```

Move the chain specification file to the folder:

=== "Tanssi MainNet"

    ```bash
    mv ./starlight-raw-specs.json /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    mv ./dancelight-raw-specs.json /var/lib/dancelight-data
    ```

!!! note
    The directory is a parameter in the Docker start-up command. If you decide to create the directory elsewhere, update the command accordingly.

## Generate the Node Key {: #generate-node-key }

Starting from [runtime 700 release](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank}, Tanssi sequencer nodes don't generate the session keys automatically on start-up. To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:

=== "Tanssi MainNet"

    ```bash
    docker run --network="host" -v "/var/lib/tanssi-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ node_versions.docker_sequencer_image_name }} key generate-node-key --file /data/node-key
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    docker run --network="host" -v "/var/lib/dancelight-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ node_versions.docker_sequencer_image_name }} key generate-node-key --file /data/node-key
    ```

!!! note
    This step could be avoided using the `--unsafe-force-node-key-generation` parameter in the start-up command, although this is not the recommended practice.

## Start-Up Command {: #start-up-command }

To spin up your node, you must run the Docker image with the `docker run` command. 

Note that the command contains two sections, divided by `-- \`:

- **Tanssi protocol section** - it contains the flags to run the Tanssi node
- **Sequencer section** - it contains the flags to run the sequencer node. It is abstract enough to be dynamically adapted in runtime to the specific chain the node will serve

Name each of the sections with a human-readable name by replacing the `INSERT_YOUR_TANSSI_NODE_NAME` and `INSERT_YOUR_SEQUENCER_NODE_NAME` tags in the `--name` flags. These names will come in handy for connecting the log entries and metrics with the node that generates them.

!!! note
    It is recommended that you run the optimized binary versions for either Intel's [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} or AMD's [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} architectures for better performance.

=== "Tanssi MainNet"

    === "Generic"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/starlight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC"
        ```

    === "Intel Skylake"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node-skylake solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/starlight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC"
        ```

    === "AMD Zen3"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node-znver3 solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/starlight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC"
        ```

=== "Dancelight TestNet"

    === "Generic"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
        ```

    === "Intel Skylake"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node-skylake solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
        ```

    === "AMD Zen3"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node-znver3 solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
        ```

### Run Flags {: #run-flags }

The flags used in the `docker run` command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:

- `--name INSERT_NAME` - a human-readable name for this node
- `--rpc-port INSERT_PORT` - specifies the JSON-RPC TCP port the node listens on
- `--unsafe-rpc-external` - exposes the RPC service on all the interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the state), `archive-canonical` (which keeps only the state of finalized blocks), or any `number` (representing the number of blocks whose states are kept)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - specifies how many blocks should be kept in the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the blocks), `archive-canonical` (which keeps only finalized blocks), or any `number` (representing the amount of finalized blocks to keep)
- `--detailed-log-output` - enables detailed log output

!!! warning
    The `--unsafe-rpc-external` enables external access to your nodeâ€™s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.

For a complete list of available flags, their description, and possible values, run the following command:

=== "Tanssi MainNet"

    ```bash
    docker run {{ node_versions.docker_sequencer_image_name }} --help
    ```

=== "Dancelight TestNet"

    ```bash
    docker run {{ node_versions.docker_sequencer_image_name }} --help
    ```

## Syncing Your Node {: #syncing-your-node }

The first time your node spins up, the syncing process displays lots of log information from the node configuration and the node itself. Some errors are expected to be displayed at the beginning of the process, disappearing once the chain gets synced to the last block.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker run ....</span>
  <span data-ty>
    <br> 2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] ðŸ’¤ Idle (0 peers), best: #0 (0x4a2bâ€¦7de3), finalized #0 (0x4a2bâ€¦7de3), â¬‡ 0 â¬† 0
    <br> 2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] âœ¨ Imported #14139635 (0x8c41â€¦8df6)    
    <br> 2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] ðŸ’¤ Idle (8 peers), best: #14139635 (0x8c41â€¦8df6), finalized #14139632 (0xa9a8â€¦cab9), â¬‡ 32.7kiB/s â¬†
  </span>
</div>

When the syncing with the Tanssi orchestrator is finished, the node will still need to sync with the network it has been assigned to. The syncing with the chain served by the sequencer node will happen every time the sequencer is rotated.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/
--- BEGIN CONTENT ---
---
title: Run a Tanssi Sequencer
description: Learn how to set up and run a sequencer (block producer) node for Tanssi networks using Systemd, allowing you to participate in the protocol and earn rewards.
icon: simple-linux
categories: Sequencers
---

# Run a Sequencer Node Using Systemd

## Introduction {: #introduction }

One of Tanssi's core propositions is that it provides decentralized and trustless block production for its networks. Tanssi's runtime handles sequencer assignments to all the active networks in the Tanssi ecosystem.

Each time, the assignment algorithm distributes the available set of sequencers per session, assigning them to a random chain. Consequently, they would be producing blocks for the same network only for a relatively short period, increasing the overall security of the ecosystem.

To this end, Tanssi's binary file (the software used to run nodes) already has an embedded mechanism to switch block production automatically to the assigned chain without requiring the node operator to make any changes. The binary includes the logic to sync the new chain and produce blocks when the session changes. Consequently, sequencers need to run the Tanssi binary file, and not that of the networks (like full nodes do).

In this guide, you'll learn how to spin up a Tanssi sequencer to be part of the shared pool of sequencers using the latest stable binary file release and managing the service with [Systemd](https://systemd.io){target=\_blank} on Linux systems.

The article follows the good practice of running the service with its own non-root account and granting that account write access to a specific directory. However, you can adapt this article's steps and instructions to your infrastructure configuration, preferences, and security policies.

## Checking Prerequisites {: #checking-prerequisites }

To get started, you'll need access to a computer running an Ubuntu Linux OS and root privileges. You will also need:

- **Node binary file** - the instructions in this guide execute the [latest](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank} official stable `tanssi-node` release. However, you can build your own file compiling the [source code](https://github.com/moondance-labs/tanssi){target=\_blank}
- **Tanssi chain specifications file** - the Tanssi chain specification file can be downloaded from this [public GitHub repository](https://github.com/papermoonio/external-files/blob/main/Tanssi/Dancelight){target=\_blank}

## Download the Latest Release {: #download-latest-release }

To get started, download and make executable the latest binary release by running the following command:

!!! note
    It is recommended that you run the optimized binary versions for either Intel's [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} or AMD's [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} architectures for better performance.

=== "Tanssi MainNet"

    === "Generic"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node && \
        chmod +x ./tanssi-node
        ```

    === "Intel Skylake"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-skylake -O tanssi-node && \
        chmod +x ./tanssi-node
        ```

    === "AMD Zen3"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-znver3 -O tanssi-node && \
        chmod +x ./tanssi-node
        ```
    
=== "Dancelight TestNet"
    
    === "Generic"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node && \
        chmod +x ./tanssi-node
        ```

    === "Intel Skylake"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-skylake -O tanssi-node && \
        chmod +x ./tanssi-node
        ```

    === "AMD Zen3"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-znver3 -O tanssi-node && \
        chmod +x ./tanssi-node
        ```

## Download the Tanssi Chain Specs File {: #download-tanssi-specs }

The node binary file also includes the necessary code to run a Tanssi orchestration chain node. When launching a sequencer, it will also be required to provide the Tanssi orchestration chain specification file as a parameter.

Download the Tanssi orchestration chain specification file by executing the following:

=== "Tanssi MainNet"

    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json
    ```

=== "Dancelight TestNet"
    
    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json
    ```

## Setup the Systemd Service {: #setup-systemd-service }

[Systemd](https://systemd.io){target=\_blank} is a management system for Linux systems that manages services (daemons in Unix-like systems jargon), starting them automatically when the computer starts or reboots, or restarting them upon unexpected failures.

The following commands configure a new account, the directory, and move the previously downloaded files to the right location.

Create a new account to run the service:

=== "Tanssi MainNet"

    ```bash
    adduser tanssi_service --system --no-create-home
    ```

=== "Dancelight TestNet"

    ```bash
    adduser dancelight_service --system --no-create-home
    ```

Create a directory to store the required files and data:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the service to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R tanssi_service /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    sudo chown -R dancelight_service /var/lib/dancelight-data
    ```

Move the chain specification file to the folder:

=== "Tanssi MainNet"

    ```bash
    mv ./starlight-raw-specs.json /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mv ./dancelight-raw-specs.json /var/lib/dancelight-data
    ```

And finally, move the binary to the folder:

=== "Tanssi MainNet"

    ```bash
    mv ./tanssi-node /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mv ./tanssi-node /var/lib/dancelight-data
    ```

### Generate the Node Key {: #generate-node-key }

Starting from [runtime 700 release](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank}, Tanssi sequencer nodes don't generate the session keys automatically on start-up. To generate and store on disk the session keys that will be referenced on the start-up command, run the following command:


=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-node key generate-node-key --file /var/lib/tanssi-data/node-key
    ```

=== "Dancelight TestNet"

    ```bash
    /var/lib/dancelight-data/tanssi-node key generate-node-key --file /var/lib/dancelight-data/node-key
    ```

!!! note
    This step could be avoided using the `--unsafe-force-node-key-generation` parameter in the start-up command, although this is not the recommended practice.

### Create the Systemd Service Configuration File {: #create-systemd-configuration }

The next step is to create the Systemd configuration file.

You can create the file by running the following command:

=== "Tanssi MainNet"

    ```bash
    sudo touch /etc/systemd/system/tanssi.service
    ```

=== "Dancelight TestNet"

    ```bash
    sudo touch /etc/systemd/system/dancelight.service
    ```

Now you can open the file using your favorite text editor (vim, emacs, nano, etc) and add the configuration for the service, replacing the `INSERT_YOUR_TANSSI_NODE_NAME` and `INSERT_YOUR_SEQUENCER_NODE_NAME` tags with a human-readable text in the `--name` flags. These names will come in handy for connecting the log entries and metrics with the node that generates them.

=== "Tanssi MainNet"

    ```bash
    [Unit]
    Description="Tanssi systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    Type=simple
    Restart=on-failure
    RestartSec=10
    User=tanssi_service
    SyslogIdentifier=tanssi
    SyslogFacility=local7
    KillSignal=SIGHUP
    ExecStart=/var/lib/tanssi-data/tanssi-node solo-chain \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
    --base-path=/var/lib/tanssi-data/container \
    --node-key-file=/var/lib/tanssi-data/node-key \
    --telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
    --pool-type=fork-aware \
    --database=paritydb \
    --rpc-port=9944 \
    --prometheus-port=9615 \
    --prometheus-external \
    --listen-addr=/ip4/0.0.0.0/tcp/30333 \
    --state-pruning=2000 \
    --blocks-pruning=2000 \
    --db-cache=1024 \
    --trie-cache-size=1073741824 \
    --collator \
    --in-peers=100 \
    --detailed-log-output \
    -- \
    --chain=/var/lib/tanssi-data/starlight-raw-specs.json \
    --name=INSERT_YOUR_TANSSI_NODE_NAME \
    --sync=fast \
    --base-path=/var/lib/tanssi-data/relay \
    --node-key-file=/var/lib/tanssi-data/node-key \
    --keystore-path=/var/lib/tanssi-data/session \
    --database=paritydb \
    --rpc-port=9945 \
    --prometheus-port=9616 \
    --prometheus-external \
    --listen-addr=/ip4/0.0.0.0/tcp/30334 \
    --pool-limit=0 \
    --db-cache=128 \
    --out-peers=15 \
    --state-pruning=2000 \
    --blocks-pruning=2000 \
    --telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
    --bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
    --bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
    --bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
    --bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
    --bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC

    [Install]
    WantedBy=multi-user.target
    ```

=== "Dancelight TestNet"

    ```bash
    [Unit]
    Description="Dancelight systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    Type=simple
    Restart=on-failure
    RestartSec=10
    User=dancelight_service
    SyslogIdentifier=dancelight
    SyslogFacility=local7
    KillSignal=SIGHUP
    ExecStart=/var/lib/dancelight-data/tanssi-node solo-chain \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
    --base-path=/var/lib/dancelight-data/container \
    --node-key-file=/var/lib/dancelight-data/node-key \
    --telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
    --pool-type=fork-aware \
    --database=paritydb \
    --rpc-port=9944 \
    --prometheus-port=9615 \
    --prometheus-external \
    --listen-addr=/ip4/0.0.0.0/tcp/30333 \
    --state-pruning=2000 \
    --blocks-pruning=2000 \
    --db-cache=1024 \
    --trie-cache-size=1073741824 \
    --collator \
    --in-peers=100 \
    --detailed-log-output \
    -- \
    --chain=/var/lib/dancelight-data/dancelight-raw-specs.json \
    --name=INSERT_YOUR_TANSSI_NODE_NAME \
    --sync=fast \
    --base-path=/var/lib/dancelight-data/relay \
    --node-key-file=/var/lib/dancelight-data/node-key \
    --keystore-path=/var/lib/dancelight-data/session \
    --database=paritydb \
    --rpc-port=9945 \
    --prometheus-port=9616 \
    --prometheus-external \
    --listen-addr=/ip4/0.0.0.0/tcp/30334 \
    --pool-limit=0 \
    --db-cache=128 \
    --out-peers=15 \
    --state-pruning=2000 \
    --blocks-pruning=2000 \
    --telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
    --bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
    --bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
    --bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT

    [Install]
    WantedBy=multi-user.target
    ```

### Run Flags {: #run-flags }

The flags used in the ExecStart command can be adjusted according to your preferences and hardware configuration. The following ones are some of the most note-worthy:

- `--name INSERT_NAME` - a human-readable name for this node
- `--rpc-port INSERT_PORT` - specifies the JSON-RPC TCP port the node listens on
- `--unsafe-rpc-external` - exposes the RPC service on all the interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the state), `archive-canonical` (which keeps only the state of finalized blocks), or any `number` (representing the number of blocks whose states are kept)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - specifies how many blocks should be kept in the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the blocks), `archive-canonical` (which keeps only finalized blocks), or any `number` (representing the amount of finalized blocks to keep)
- `--detailed-log-output` - enables detailed log output

!!! warning
    The `--unsafe-rpc-external` enables external access to your nodeâ€™s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.

For a complete list of available flags, their description, and possible values, run the following command:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-node  --help
    ```

=== "Dancelight TestNet"

    ```bash
    /var/lib/dancelight-data/tanssi-node  --help
    ```

## Run the Service {: #run-the-service }

Finally, enable the service and start it for the first time:

=== "Tanssi MainNet"

    ```bash
    systemctl enable tanssi.service && \
    systemctl start tanssi.service
    ```

=== "Dancelight TestNet"

    ```bash
    systemctl enable dancelight.service && \
    systemctl start dancelight.service
    ```

You can verify that the service is up and running correctly running:

=== "Tanssi MainNet"

    ```bash
    systemctl status tanssi.service
    ```

=== "Dancelight TestNet"

    ```bash
    systemctl status dancelight.service
    ```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>systemctl status network.service</span>
  <span data-ty>
    <br> â— network.service - "Network systemd service"
    <br>&nbsp;&nbsp;&nbsp;Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)
    <br>&nbsp;&nbsp;&nbsp;Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago
    <br>&nbsp;&nbsp;Main PID: 4045278 (container-chain)
    <br>&nbsp;&nbsp;&nbsp;&nbsp;Tasks: 44 (limit: 9462)
    <br>&nbsp;&nbsp;&nbsp;Memory: 6.5G
    <br>&nbsp;&nbsp;&nbsp;CGroup: /system.slice/network.service
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â””â”€4045278 4045278 /var/lib/network-data/container-chain- ...
  </span>
</div>

And check the logs, if needed, with the following command:

=== "Tanssi MainNet"

    ```bash
    journalctl -f -u tanssi.service
    ```

=== "Dancelight TestNet"

    ```bash
    journalctl -f -u dancelight.service
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/operational-tasks/
--- BEGIN CONTENT ---
---
title: Sequencers Operational Tasks
description: Learn how to manage your activities as a sequencer in the Tanssi network protocol, including managing your account, upgrading your node, and more.
icon: octicons-arrow-switch-24
template: index-page.html
---

# Operational Task

Keeping your sequencer up and running is more than just setup - it requires regular maintenance to ensure consistent performance and secure management of your accounts. Regular updates are essential to keep your node compatible with the latest Tanssi protocol changes, while tools such as proxy accounts provide an extra layer of security by allowing you to delegate certain tasks without exposing your primary account credentials. This section provides the necessary steps to keep your operations smooth, reliable, and secure.


## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/operational-tasks/proxy-accounts/
--- BEGIN CONTENT ---
---
title: Set Up a Sequencer Proxy Account
description: Follow these step-by-step instructions to configure a proxy account to manage sequencer activities on behalf of your primary sequencer account.
icon: octicons-shield-lock-24
categories: Sequencers
---

# Set Up a Proxy Account

## Introduction {: #introduction }

Proxy accounts can be set up to perform a limited number of actions on behalf of primary accounts and help keep the underlying accounts safe. As a sequencer on Tanssi, it's a good idea to take advantage of proxy accounts to interact with the network in place of your sequencer account.

The staking proxy type conveniently allows the proxy account to manage staking activities, such as delegating and rotating session keys, on behalf of the primary sequencer account, effectively transforming it into a "hot wallet" for performing regular maintenance duties on behalf of your "cold wallet" sequencer account. For added safety, you can regularly rotate the proxy account.

Proxy accounts can also help you implement the principle of least privilege for access control. For example, if you have multiple team members, you can give them the minimum access required to carry out their duties via a specific proxy account.

This tutorial will walk you through configuring a staking proxy account on [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank} specifically for operations as a sequencer. Then, it will demonstrate initiating a delegation using the newly created staking proxy.

## Checking Prerequisites {: #checking-prerequisites }

To follow along with this tutorial, you will need to have:

- The [developer portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} open and connected to Dancelight
- Create or have two accounts accessible in the developer portal
- Both accounts will need to be funded, and the sequencer account will need at least the minimum self delegation required to become an active sequencer ({{ networks.dancelight.sequencers.minimum_self_delegation }} {{ networks.dancelight.token_symbol }} for Dancelight)

If you need help importing your accounts into the developer portal, please check out the [Connecting to the Developer Portal](/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs){target=\_blank} guide.

## Creating a Staking Proxy Account {: #creating-a-staking-proxy-account }

There are a couple of ways you can create proxy accounts in the [developer portal](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank}, either from the **Extrinsics** page or the **Accounts** page. However, to create a time-delayed proxy, you will need to use the **Extrinsics** page. A time delay provides an additional layer of security to proxies by specifying a delay period based on the number of blocks. This will prevent the proxy account from executing a transaction until the delay period ends. The delay allows time for the primary account that controls the proxy to review pending transactions and provides a limited period of time to cancel any actions.

You also have the option of creating a proxy of type **Any** which grants the proxy account full and unrestricted control over the primary account. This means that the proxy account can transfer funds, and perform any arbitrary action. The following demo will showcase configuring a **Staking** proxy, which is more restrictive than an **Any** proxy, as it limits functions to activities that pertain to staking, such as delegating, undelegating, and mapping session keys.

To get started creating your proxy account, head to the **Developer** tab and select [**Extrinsics**](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank} from the dropdown. Next, you will need to take the following steps:

1. Select the primary account
2. From the **submit the following extrinsic** dropdown, select **proxy**
3. Choose the **addProxy** extrinsic
4. Choose **Id** from the **AccountIdLookupOf** dropdown
5. Select the **delegate** account for the proxy
6. From the **proxyType** dropdown, choose **Staking**
7. Optionally, you can add a time delay using a specified number of blocks to add an additional layer of security for the primary account to review the pending transaction
8. Click **Submit Transaction**

![Add a proxy account from the Extrinsics page of the developer portal](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-1.webp)

You will then be prompted to authorize and sign the transaction. Click **Sign and Submit** to create the proxy relationship. Once the transaction has been successfully submitted, you will receive some notifications confirming the transaction.

As previously mentioned, you can also create a proxy from the **Accounts** page. To do so, navigate to the **Accounts** page and take the following steps:

1. Select the three vertical dots next to the primary account
2. Select **Add proxy**

![Select the Add proxy menu item from the Accounts page of the developer portal](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-2.webp)

!!! note
    If the account already has a proxy, **Manage proxies** will be displayed as an option instead of **Add proxy**.

A pop-up will appear and you can enter the required information, such as the proxied/primary account, the proxy account, and the type of proxy to create a proxy account. First, click **Add proxy**.

![Add a proxy account from the Accounts page of the developer portal](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-3.webp)

Then, take the following steps:

1. Select the account you would like to set as a proxy
2. Select the proxy type
3. Click **Submit** and sign the transaction

![Add the details of the proxy account, including the proxy account and type](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-4.webp)

In the next section, you will learn how to verify that your proxy account was set up successfully.

## Verifying Your Proxy Account {: #verifying-your-proxy-account }

You can verify that your proxy account has been successfully set up in a couple of ways: either through the **Accounts** page or via the **Chain state** page.

To check your proxy accounts from the [**Chain state** page](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, you can take the following steps:

1. From the **selected state query** dropdown, select **proxy**
2. Choose the **proxies** extrinsic
3. Select your primary/proxied account
4. Click on the **+** button to send the query

![Verify your proxy accounts via the Extrinsics page of the developer portal](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-5.webp)

The result will appear on the page showing you information about all of your proxies, including the delegate/proxy account address, the proxy type, the delay period if one was specified, and the total bond amount for all of your proxies in Planck.

You can also check your proxy accounts from the **Accounts** page. To do so, navigate to the **Accounts** page, and there should be a Proxy symbol next to the primary account. Hover over the icon and click on **Manage proxies** to review your proxies.

![Hover over the proxy icon to manage your proxies via the Accounts page of Polkadot.js Apps](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-6.webp)

A pop-up will appear where you can see an overview of all of your proxy accounts.

![Review your proxy accounts](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-7.webp)

## Executing a Proxy Transaction {: #executing-a-proxy-transaction }

Now that you have created a proxy account and verified that it was successfully set up, you can execute a transaction using the staking proxy account on behalf of your sequencer account, also known as the primary account or the account that is being proxied. The following example will demonstrate initiating a self-delegation. The proxy configuration shown is a realistic example of how you might have your own proxy configured for your developer portal primary account.

To execute a transaction, you can navigate back to the [**Extrinsics** page](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank} and take the following steps:

1. Select the proxy account to submit the transaction from the **using the select account** dropdown
2. From the **submit the following extrinsic** menu, select **proxy**
3. Choose the **proxy** extrinsic
4. Choose **Id** from the **AccountIdLookupOf** dropdown
5. Select the primary account from the **real** dropdown
6. Select the **pooledStaking** call
7. Choose the **requestDelegate** extrinsic
8. Enter the **candidate** address, which is the sequencer account
9. Select **AutoCompounding** or **ManualRewards** for the **pool** field
10. Enter the amount to stake. This amount must meet the minimum, which, for Dancelight, is {{ networks.dancelight.sequencers.minimum_self_delegation }} {{ networks.dancelight.token_symbol }} tokens. You'll need to submit the value including the twelve decimal places the Tanssi Network uses, so for a value of {{ networks.dancelight.sequencers.minimum_self_delegation }}, you'll need to enter `{{ networks.dancelight.sequencers.minimum_self_delegation }}000000000000`
11. Click **Submit Transaction**

![Execute a proxy transaction from the Extrinsics page of Polkadot.js Apps](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-8.webp)

A pop-up will appear for you to authorize and sign the transaction. Enter your password for the proxy account and click **Sign and Submit**. To confirm the delegation request, you'll need to execute the pending request after two sessions have passed. Please refer to the instructions for [executing pending requests](/node-operators/sequencers/onboarding/account-setup/#execute-pending-request){target=\_blank} for a step-by-step guide. You can also [map your session keys to your sequencer account](/node-operators/sequencers/onboarding/account-setup/#map-session-keys){target=\_blank} via proxy.

After you've mapped your session keys and executed the pending delegation request, you can [verify that your sequencer is in the list of eligible candidates](/node-operators/sequencers/onboarding/account-setup/#verify){target=\_blank}.

That's it! You've successfully executed a transaction using a proxy account on behalf of your primary sequencer account.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/operational-tasks/upgrade-your-node/
--- BEGIN CONTENT ---
---
title: Upgrade Sequencers Node
description: Follow these steps to update your node to the latest version of the Tanssi client software, ensuring seamless block production on the Tanssi network protocol.
icon: octicons-rocket-24
template: index-page.html
---

# Upgrade Sequencers Node

Keeping your node updated is critical to maintaining compatibility with the latest Tanssi protocol changes and ensuring optimal performance. Outdated nodes can lead to desynchronization, reduced efficiency, or even an inability to participate in block production. By staying current with client releases, you can ensure your node operates securely and reliably within the network.

!!! tip "Subscribe to Release Notifications" 
    Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  

    To subscribe, visit the [Tanssi GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} repository and click **Watch**. Select **Custom notifications** and ensure the box for **Releases** is checked.

## Explore What This Section Covers

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/
--- BEGIN CONTENT ---
---
title: Upgrade Your Sequencer Docker Node
description: Follow these instructions to update your Tanssi sequencer node running via Docker to the latest version of the Tanssi client software.
icon: simple-docker
categories: Sequencers
---

# Upgrade Your Node Running via Docker

## Introduction {: #introduction }

Keeping your node up-to-date is an important part of being a Tanssi sequencer. Not only does it help to ensure that your sequencer node stays healthy, it also contributes to keeping the entire Tanssi Network running smoothly.

This tutorial covers upgrading your Tanssi sequencer that was configured using Docker. It assumes you have already set up your account and launched a [sequencer using Docker](/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/){target=\_blank}.

!!! tip "Subscribe to Release Notifications" 
    Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  

    To subscribe, visit the [Tanssi GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} repository and click **Watch**. Select **Custom notifications** and ensure the box for **Releases** is checked.

## Upgrading Docker Nodes {: #upgrading-docker-nodes }

If you're running your sequencer with Docker, updating your node is as simple as stopping the running container and restarting it with the new version tag.

First, get the container ID of your Tanssi sequencer node with the following command:

```bash
docker ps -a
```

The container ID is the first column and if you're running multiple Docker containers, you can identify it by the image name of `{{ node_versions.docker_sequencer_image_name }}`. You can run the stop command as follows:

```bash
docker stop INSERT_YOUR_CONTAINER_ID
```

Your terminal interaction will resemble the following:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker ps -a</span>
  <span data-ty>
    <br> 
    <br> CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES
    <br> aa751703d6aa moondancelabs/tanssi:v0.6.1 "/tanssi/tanssi-nodeâ€¦" 56 seconds ago  Up 56 seconds             focused_chaum
    <br> 
    <span data-ty="input"><span class="file-path"></span>docker stop aa751703d6aa</span>
    <br> aa751703d6aa
  </span>
</div>

To restart the node, you can use the same command you used when launching your node the first time. The command pulls the image and the node will resume syncing blocks from where it left off when the Docker process was stopped.

=== "Generic"

    ```bash
    docker run --network="host" -v "/var/lib/dancebox:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ node_versions.docker_sequencer_image_name }} \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
    ```

=== "Intel Skylake"

    ```bash
    docker run --network="host" -v "/var/lib/dancebox:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    --entrypoint "/tanssi/tanssi-node-skylake" \
    {{ node_versions.docker_sequencer_image_name }} \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
    ```
=== "AMD Zen3"

    ```bash
    docker run --network="host" -v "/var/lib/dancebox:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    --entrypoint "/tanssi/tanssi-node-znver3" \
    {{ node_versions.docker_sequencer_image_name }} \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
    ```

### Specifying a Version Tag {: #specifying-a-version-tag }

If you wanted to specify a [particular version tag](https://hub.docker.com/r/moondancelabs/tanssi/tags){target=\_blank}, you can do so by replacing the version tag appended to the image name. For example, if you wanted to fetch version `3`, you would replace the `2` in `{{ node_versions.docker_sequencer_image_name }}`.

And that's it! You've successfully upgraded your Tanssi node.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/
--- BEGIN CONTENT ---
---
title: Upgrade Your Sequencer Systemd Node
description: Follow these instructions to update your Tanssi sequencer node running via Systemd to the latest version of the Tanssi client software.
icon: simple-linux
categories: Sequencers
---

# Upgrade Your Node Running via Systemd

## Introduction {: #introduction }

Keeping your node up-to-date is an important part of being a Tanssi sequencer. Not only does it help to ensure that your sequencer node stays healthy, it also contributes to keeping the entire Tanssi Network running smoothly.

This tutorial covers upgrading your Tanssi sequencer node that was configured using Systemd. It assumes you have already set up your account and launched a [sequencer node using Systemd](/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/){target=\_blank}.

!!! tip "Subscribe to Release Notifications" 
    Staying informed about new client releases is essential for maintaining an up-to-date node. Node maintainers can subscribe to GitHub notifications to be alerted for new client release versions.  

    To subscribe, visit the [Tanssi GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} repository and click **Watch**. Select **Custom notifications** and ensure the box for **Releases** is checked.

## Upgrading Your Systemd Node {: #upgrading-your-systemd-node }

If you're running your sequencer via the Systemd service, you'll need to take a few steps to properly upgrade your node. In short, you'll need to stop the service, replace the Tanssi binary with the updated version, and then start the service.

You can stop your Tanssi Systemd service with the following command:

```bash
systemctl stop tanssi.service
```

Then, navigate to the directory where your Tanssi binary is stored and remove it.

```bash
cd /var/lib/tanssi-data
```

Your Tanssi binary file will most likely be named `tanssi-node`. If not, you can replace `tanssi-node` below with the correct name of your Tanssi binary file.

```bash
rm tanssi-node
```

To download the latest release and change permissions on it so the Tanssi service can use it, run the following command that corresponds to your environment:

=== "Generic"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node && \
    chmod +x ./tanssi-node
    ```

=== "Intel Skylake"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-skylake -O tanssi-node && \
    chmod +x ./tanssi-node
    ```

=== "AMD Zen3"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-znver3 -O tanssi-node && \
    chmod +x ./tanssi-node
    ```

You can restart your Tanssi Systemd service with the following command:

```bash
systemctl start tanssi.service
```

The node will resume syncing blocks from where it left off when the Systemd service was stopped. To verify that it is running correctly, you can use the following command to check the logs:

```bash
systemctl status tanssi.service
```

And that's it! You've successfully upgraded your Tanssi node.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/ai-resources/ai-resources/
--- BEGIN CONTENT ---
---
title: Recursos de IA
description: Baixe arquivos otimizados para LLM com a documentaÃ§Ã£o Tanssi, incluindo conteÃºdo completo e recursos por categoria para agentes de IA.
---

# Recursos de IA

A Tanssi fornece arquivos `.txt` contendo o conteÃºdo da documentaÃ§Ã£o e a estrutura de navegaÃ§Ã£o, otimizados para uso com modelos de linguagem (LLMs) e ferramentas de IA. Esses recursos ajudam a criar assistentes de IA, potencializam buscas em cÃ³digo ou permitem ferramentas personalizadas treinadas na documentaÃ§Ã£o da Tanssi.

Cada arquivo por categoria inclui o conteÃºdo bÃ¡sico das categorias **Basics** e **Reference** para garantir que os LLMs tenham o contexto necessÃ¡rio.

## Baixar Arquivos para LLM

| Categoria          | DescriÃ§Ã£o                                                                                                                               | Arquivo                        | AÃ§Ãµes                                                                                                                                                                                                  |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------|--------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Ãndice             | Ãndice de navegaÃ§Ã£o de todas as pÃ¡ginas da documentaÃ§Ã£o Tanssi                                                                          | `llms.txt`                     | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms.txt" } [:octicons-download-16:](/llms.txt){ download="llms.txt" }                                                                    |
| DocumentaÃ§Ã£o Completa | ConteÃºdo completo de todas as pÃ¡ginas da documentaÃ§Ã£o                                                                                   | `llms-full.txt`                | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-full.txt" } [:octicons-download-16:](/llms-full.txt){ download="llms-full.txt" }                                                     |
| Basics             | Framework, arquitetura e componentes centrais da Tanssi para formar a base de conhecimento geral                                       | `llms-basics.txt`              | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-basics.txt" } [:octicons-download-16:](/llms-files/llms-basics.txt){ download="llms-basics.txt" }                                    |
| Reference          | Material de referÃªncia, incluindo endpoints de rede, mÃ©todos JSON RPC e endereÃ§os de contratos ou tokens                                | `llms-reference.txt`           | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-reference.txt"} [:octicons-download-16:](/llms-files/llms-reference.txt){ download="llms-reference.txt" }                            |
| Appchain           | Como lanÃ§ar e gerenciar uma appchain via dApp ou portal do desenvolvedor                                                               | `llms-appchain.txt`            | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-appchain.txt" } [:octicons-download-16:](/llms-files/llms-appchain.txt){ download="llms-appchain.txt" }                              |
| Runtime Personalizado | Como personalizar o runtime da sua appchain                                                                                             | `llms-custom-runtime.txt`      | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-custom-runtime.txt" } [:octicons-download-16:](/llms-files/llms-custom-runtime.txt){ download="llms-custom-runtime.txt" }            |
| Template EVM       | Use o template EVM para lanÃ§ar appchains compatÃ­veis com Ethereum e conhecer seu tooling associado (carteiras, integraÃ§Ãµes etc.)       | `llms-evm-template.txt`        | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-evm-template.txt" } [:octicons-download-16:](/llms-files/llms-evm-template.txt){ download="llms-evm-template.txt" }                  |
| Template Substrate | Use o template Substrate bÃ¡sico e o tooling associado (carteiras, integraÃ§Ãµes etc.) para lanÃ§ar appchains                              | `llms-substrate-template.txt`  | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-substrate-template.txt" } [:octicons-download-16:](/llms-files/llms-substrate-template.txt){ download="llms-substrate-template.txt" }|
| Operators         | Como configurar e executar um nÃ³ para proteger o ecossistema Tanssi                                                                    | `llms-operators.txt`           | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-operators.txt" } [:octicons-download-16:](/llms-files/llms-operators.txt){ download="llms-operators.txt" }                           |
| Sequencers     | Como executar um sequencer para fornecer serviÃ§os de produÃ§Ã£o de blocos Ã s appchains                                                   | `llms-sequencers.txt`          | [:octicons-copy-16:](){ .llms data-action="copy" data-value="llms-sequencers.txt" } [:octicons-download-16:](/llms-files/llms-sequencers.txt){ download="llms-sequencers.txt" }                        |

!!! note
    O arquivo `llms-full.txt` pode exceder o limite de entrada de alguns Templates de linguagem devido ao seu tamanho. Se vocÃª encontrar limitaÃ§Ãµes, considere usar os arquivos por categoria.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/account-management/identity/
--- BEGIN CONTENT ---
---
title: Definir uma Identidade de Conta
description: Siga estas instruÃ§Ãµes para estabelecer uma identidade, incluindo um nome de exibiÃ§Ã£o para que vocÃª possa ser mais facilmente reconhecido na cadeia do orquestrador Tanssi.
icon: octicons-person-24
categories: Basics, Appchain
---

# Configurar uma Identidade On-Chain

## IntroduÃ§Ã£o {: #introduction }

O [Substrate](/pt/learn/framework/overview/#substrate-framework){target=\_blank} Identity [module](/pt/learn/framework/modules/){target=\_blank} Ã© uma soluÃ§Ã£o pronta para uso para adicionar informaÃ§Ãµes pessoais Ã  sua conta on-chain. O estabelecimento de uma identidade torna mais fÃ¡cil para sua conta ser reconhecida por outros, pois seu nome de exibiÃ§Ã£o preencherÃ¡ automaticamente quando alguÃ©m colar seu endereÃ§o em um campo no [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/accounts){target=\_blank}.

A identidade que vocÃª configura vai alÃ©m de um simples nome de exibiÃ§Ã£o. As informaÃ§Ãµes pessoais podem incluir campos padrÃ£o, como seu nome legal, nome de exibiÃ§Ã£o, site, identificador do Twitter, Discord e nome do Riot (agora conhecido como Element). VocÃª tambÃ©m pode usar campos personalizados para incluir quaisquer outras informaÃ§Ãµes relevantes.

Este guia demonstrarÃ¡ como configurar uma identidade com um nome de exibiÃ§Ã£o e parÃ¢metros adicionais, aprimorando sua visibilidade e reconhecimento.

## DefiniÃ§Ãµes Gerais {: #general-definitions }

Para armazenar suas informaÃ§Ãµes on-chain, vocÃª deve vincular alguns fundos, que, eventualmente, serÃ£o devolvidos assim que a identidade for limpa. Existem duas categorias de campos: padrÃ£o e personalizado. Uma quantia bÃ¡sica de depÃ³sito Ã© reservada apÃ³s a criaÃ§Ã£o da identidade e um depÃ³sito de armazenamento Ã© necessÃ¡rio para cada byte adicional de dados armazenados on-chain.

- **Campos padrÃ£o incluem** - seu nome legal, nome de exibiÃ§Ã£o, site, identificador do Twitter, Discord, nome do Riot (agora conhecido como Element)

- **Campos personalizados incluem** - quaisquer outras informaÃ§Ãµes relevantes

- **Subcontas** - VocÃª pode vincular subcontas sob uma conta primÃ¡ria. Por exemplo, um serviÃ§o de Sequencer que estÃ¡ executando vÃ¡rios nÃ³s de Sequencer diferentes pode estabelecer subcontas para demonstrar um link oficial entre os nÃ³s

=== "Tanssi MainNet"

    |       VariÃ¡vel        |                                    DefiniÃ§Ã£o                                    |                                        Valor                                         |
    |:---------------------:|:--------------------------------------------------------------------------------:|:------------------------------------------------------------------------------------:|
    |     DepÃ³sito bÃ¡sico   | O valor mantido em depÃ³sito para a definiÃ§Ã£o de uma identidade                  |  {{ networks.mainnet.identity.basic_deposit }} {{ networks.mainnet.token_symbol }}   |
    |   DepÃ³sito por byte   | O valor mantido em depÃ³sito por byte de armazenamento on-chain usado na definiÃ§Ã£o de uma identidade | {{ networks.mainnet.identity.per_byte_deposit }} {{ networks.mainnet.token_symbol }} |
    | Campos adicionais mÃ¡x.| NÃºmero mÃ¡ximo de campos adicionais que podem ser armazenados em um ID           |                      {{ networks.mainnet.identity.max_fields }}                      |
    |    Subcontas mÃ¡x.     | NÃºmero mÃ¡ximo de subcontas que podem ser definidas sob uma identidade de conta  |                   {{ networks.mainnet.identity.max_subaccounts }}                    |

=== "Dancelight TestNet"

    |       VariÃ¡vel        |                                    DefiniÃ§Ã£o                                    |                                           Valor                                            |
    |:---------------------:|:--------------------------------------------------------------------------------:|:------------------------------------------------------------------------------------------:|
    |     DepÃ³sito bÃ¡sico   | O valor mantido em depÃ³sito para a definiÃ§Ã£o de uma identidade                  |  {{ networks.dancelight.identity.basic_deposit }} {{ networks.dancelight.token_symbol }}   |
    |   DepÃ³sito por byte   | O valor mantido em depÃ³sito por byte de armazenamento on-chain usado na definiÃ§Ã£o de uma identidade | {{ networks.dancelight.identity.per_byte_deposit }} {{ networks.dancelight.token_symbol }} |
    | Campos adicionais mÃ¡x.| NÃºmero mÃ¡ximo de campos adicionais que podem ser armazenados em um ID           |                       {{ networks.dancelight.identity.max_fields }}                        |
    |    Subcontas mÃ¡x.     | NÃºmero mÃ¡ximo de subcontas que podem ser definidas sob uma identidade de conta  |                     {{ networks.dancelight.identity.max_subaccounts }}                     |

## Verificando os PrÃ©-requisitos {: #checking-prerequisites }

Para acompanhar este guia, vocÃª precisarÃ¡ do seguinte:

=== "Tanssi MainNet"

    - O [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/accounts){target=\_blank} aberto e conectado Ã  Tanssi MainNet.
    - Pelo menos uma conta financiada com tokens `{{ networks.mainnet.token_symbol }}`.

=== "Dancelight TestNet"
    
    - O [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} aberto e conectado ao [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.
    - Pelo menos uma conta financiada com tokens `{{ networks.dancelight.token_symbol }}`.

Se precisar de ajuda para importar suas contas para o portal do desenvolvedor, consulte o guia [Conectando-se ao portal do desenvolvedor](/pt/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs){target=\_blank}.

## Comece {: #get-started }

Dependendo das informaÃ§Ãµes a serem incluÃ­das, existem algumas maneiras diferentes de definir e limpar uma identidade usando o portal do desenvolvedor. Se vocÃª pretende registrar sua identidade usando apenas os campos padrÃ£o, pode seguir as instruÃ§Ãµes da pÃ¡gina [Gerenciando uma Identidade via Contas](#manage-via-accounts). **Esta Ã© a Maneira Recomendada de Definir e Gerenciar Sua Identidade**.

Se vocÃª deseja adicionar campos personalizados alÃ©m dos campos padrÃ£o, siga as instruÃ§Ãµes para a pÃ¡gina [Gerenciando uma Identidade via Extrinsics](#manage-via-extrinsics).

!!! note
    Observe que o uso da pÃ¡gina **Contas** no portal do desenvolvedor Ã© recomendado para gerenciar sua identidade, pois ela fornece uma interface fÃ¡cil de usar que impÃµe limites de caracteres. Se vocÃª usar a pÃ¡gina **Extrinsics**, esteja ciente de que sua entrada para cada campo (ou seja, nome, e-mail, etc.) deve ter 32 caracteres ou menos; caso contrÃ¡rio, suas informaÃ§Ãµes serÃ£o cortadas.

## Gerenciar uma Identidade via Contas {: #manage-via-accounts }

### Definir uma Identidade {: #set-identity-via-accounts }
Para comeÃ§ar a definir uma identidade usando a pÃ¡gina Contas, vÃ¡ para a guia [**Contas**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/accounts){target=\_blank} do portal do desenvolvedor.

VocÃª jÃ¡ deve ter uma conta conectada, entÃ£o vocÃª pode clicar no nome da sua conta para verificar e observar seus saldos. Depois de enviar a transaÃ§Ã£o para definir uma identidade, os depÃ³sitos que vocÃª enviou serÃ£o movidos do seu saldo transferÃ­vel para seu saldo reservado.

![Saldos iniciais da conta](/images/builders/account-management/identity/identity-1.webp)

Para definir sua identidade, vocÃª precisarÃ¡:

1. Clique nos trÃªs pontos verticais ao lado da conta para a qual deseja definir uma identidade
2. Um menu aparecerÃ¡. Clique em **Set on-chain identity**

![Definir identidade on-chain](/images/builders/account-management/identity/identity-2.webp)

Em seguida, o menu para registrar e definir sua identidade aparecerÃ¡ e vocÃª poderÃ¡ comeÃ§ar a preencher suas informaÃ§Ãµes. VocÃª nÃ£o Ã© obrigado a inserir informaÃ§Ãµes para todos os campos; vocÃª pode escolher preencher apenas um campo ou todos eles; a escolha Ã© sua. Para este exemplo:

1. Defina seu nome de exibiÃ§Ã£o
2. Clique no botÃ£o **include field** para e-mail e depois insira seu e-mail
3. Clique no botÃ£o **include field** para web e depois insira a URL do seu site
4. Clique no botÃ£o **include field** para Twitter e depois insira seu identificador do Twitter
5. Reveja os campos de dados anteriores e clique em **Set Identity**

![Definir sua identidade](/images/builders/account-management/identity/identity-3.webp)

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o. Se tudo estiver correto, assine-a.

VocÃª deve ver as notificaÃ§Ãµes de status aparecerem no canto superior direito. Depois que a transaÃ§Ã£o for confirmada, vocÃª pode clicar no nome da sua conta novamente, e o painel deslizarÃ¡ para fora no lado direito da pÃ¡gina. Seus saldos terÃ£o sido alterados e vocÃª tambÃ©m verÃ¡ suas novas informaÃ§Ãµes de identidade.

![Saldos da conta atualizados](/images/builders/account-management/identity/identity-4.webp)

Se as informaÃ§Ãµes de identidade corresponderem ao que vocÃª inseriu, vocÃª definiu com sucesso uma identidade!

Depois de limpar sua identidade, o depÃ³sito em seu saldo reservado serÃ¡ transferido de volta para seu saldo transferÃ­vel. Se vocÃª precisar alterar sua identidade, pode passar pelo processo de configuraÃ§Ã£o da sua identidade novamente. Observe que vocÃª deve garantir que todos os campos sejam reinseridos, mesmo que apenas um campo precise ser alterado, ou eles serÃ£o substituÃ­dos. VocÃª nÃ£o precisarÃ¡ pagar outro depÃ³sito, a menos que campos personalizados sejam usados, mas precisarÃ¡ pagar taxas de gÃ¡s.

## Gerenciar uma Identidade via Extrinsics {: #manage-via-extrinsics}

### Definir uma Identidade {:#set-identity-extrinsics }

Para registrar uma identidade usando a pÃ¡gina de extrÃ­nsecos, navegue atÃ© a pÃ¡gina [**Extrinsics**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/extrinsics){target=\_blank} do portal do desenvolvedor. Certifique-se de que sua entrada nÃ£o exceda 32 caracteres para cada campo de identidade. Para concluir sua identidade, siga as etapas a seguir:

1. Selecione sua conta
2. Selecione identidade no menu suspenso **enviar o seguinte extrÃ­nseco**
3. Em seguida, selecione a funÃ§Ã£o **setIdentity(info)**
4. Selecione **Raw** como o formato de dados para inserir seu **Nome de ExibiÃ§Ã£o**
5. Insira os dados para **ExibiÃ§Ã£o** no formato selecionado
6. Selecione **Raw** como o formato de dados para inserir seu endereÃ§o da web
7. Insira a URL do seu site no formato selecionado
8. Selecione **Raw** como o formato de dados para inserir seu e-mail
9. Insira seu endereÃ§o de e-mail no formato selecionado
10. Selecione **Raw** como o formato de dados para inserir seu identificador do Twitter
11. Insira seu Twitter no formato selecionado. Insira apenas o nome de usuÃ¡rio, comeÃ§ando com o sÃ­mbolo `@`
12. Reveja os campos preparados e pressione **Enviar TransaÃ§Ã£o**
![Definir identidade on-chain](/images/builders/account-management/identity/identity-5.webp)

Opcionalmente, se vocÃª quiser inserir campos personalizados, siga as seguintes etapas:

1. Role para o topo e clique em **Add item**
2. Dois campos aparecerÃ£o: o primeiro para o nome do campo e o segundo para o valor. Selecione **Raw** como o formato de dados para inserir o nome do campo
3. Insira o nome do campo no formato especificado
4. Selecione **Raw** como o formato de dados para inserir o valor personalizado
5. Insira o valor personalizado no formato especificado

![Adicionar campos personalizados](/images/builders/account-management/identity/identity-6.webp)

Finalmente, depois que todas as informaÃ§Ãµes de identidade forem adicionadas, vocÃª pode rolar para a parte inferior da pÃ¡gina e clicar em **Submit Transaction**.

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o. Lembre-se, um depÃ³sito adicional Ã© necessÃ¡rio para cada campo personalizado adicional. Se tudo estiver correto, assine a transaÃ§Ã£o.

VocÃª deve ver as notificaÃ§Ãµes de status aparecerem no canto superior direito confirmando a transaÃ§Ã£o. Se bem-sucedido, vocÃª definiu uma identidade! ParabÃ©ns! Para garantir que tudo tenha sido concluÃ­do e que suas informaÃ§Ãµes de identidade tenham uma boa aparÃªncia, vocÃª pode verificar sua identidade.

### Confirmar uma Identidade {: #confirm-identity-extrinsics }

Para verificar a adiÃ§Ã£o de suas informaÃ§Ãµes de identidade, vocÃª pode clicar na guia **Developer** e, em seguida, navegar atÃ© o [**Chain state**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/chainstate){target=\_blank}.

Na pÃ¡gina **Chain State**, certifique-se de que **Storage** esteja selecionado. Em seguida, vocÃª pode comeÃ§ar a solicitar suas informaÃ§Ãµes de identidade:

1. Defina a **selected state query** como **identity**
2. Selecione a funÃ§Ã£o **identityOf(AccountId)**
3. Selecione sua conta
4. Clique no botÃ£o **+** para obter suas informaÃ§Ãµes de identidade

![Solicitar informaÃ§Ãµes de identidade](/images/builders/account-management/identity/identity-7.webp)

VocÃª pode ver agora que vocÃª definiu com sucesso uma identidade! Depois de limpar sua identidade, o depÃ³sito em seu saldo reservado serÃ¡ transferido de volta para seu saldo transferÃ­vel. Se vocÃª precisar alterar sua identidade, pode passar pelo processo de configuraÃ§Ã£o da sua identidade novamente. Observe que vocÃª deve garantir que todos os campos sejam reinseridos, mesmo que apenas um campo precise ser alterado, ou eles serÃ£o substituÃ­dos. VocÃª nÃ£o precisarÃ¡ pagar outro depÃ³sito, a menos que campos personalizados sejam usados, mas precisarÃ¡ pagar taxas de gÃ¡s.

## Limpar uma Identidade {: #clear-identity-extrinsics }

Para limpar sua identidade, siga as seguintes etapas na guia **Extrinsics** do portal do desenvolvedor:

1. Selecione sua conta no menu suspenso **usando a conta selecionada**
2. Selecione **identity** no menu suspenso **enviar o seguinte extrÃ­nseco**
3. Em seguida, selecione a funÃ§Ã£o **clearIdentity()**
4. Clique em **Enviar TransaÃ§Ã£o**

![Limpar uma identidade](/images/builders/account-management/identity/identity-8.webp)

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o. Se tudo estiver correto, assine-a. VocÃª deve ver as notificaÃ§Ãµes de status no canto superior direito confirmando a transaÃ§Ã£o.

Para confirmar se suas informaÃ§Ãµes de identidade foram removidas com sucesso, revise as etapas descritas na seÃ§Ã£o [Confirmar uma Identidade](#confirm-identity-extrinsics). Desta vez, em vez de exibir seus detalhes de identidade, a resposta deve indicar **none**, confirmando que nenhuma informaÃ§Ã£o de identidade estÃ¡ atualmente vinculada Ã  sua conta. AlÃ©m disso, ao verificar seus saldos, vocÃª descobrirÃ¡ que o depÃ³sito inicialmente feito para definir sua identidade foi creditado de volta ao seu saldo transferÃ­vel. Isso conclui o processo de limpeza da sua identidade.

![ConfirmaÃ§Ã£o de limpeza de identidade](/images/builders/account-management/identity/identity-9.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/account-management/
--- BEGIN CONTENT ---
---
title: Gerenciamento de Contas
description: Aprenda a gerenciar todas as atividades relacionadas Ã  conta, como a criaÃ§Ã£o, manutenÃ§Ã£o e remoÃ§Ã£o de proxies e identidades.
icon: octicons-person-add-24
template: index-page.html
---

# Gerenciamento de Contas

O gerenciamento de contas on-chain oferece aos usuÃ¡rios e desenvolvedores maior flexibilidade e controle sobre como suas contas interagem com uma rede descentralizada. VocÃª pode ajustar suas configuraÃ§Ãµes de conta para uma integraÃ§Ã£o perfeita dentro do ecossistema, gerenciando funÃ§Ãµes, permissÃµes e identidades diretamente na blockchain.

Esta seÃ§Ã£o descreve algumas das ferramentas e recursos relacionados ao gerenciamento de contas.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/account-management/proxy-accounts/
--- BEGIN CONTENT ---
---
title: Configurar e Gerenciar Contas de Proxy
description: Siga estas instruÃ§Ãµes passo a passo para entender como as proxies funcionam e como criar, visualizar, atualizar e remover contas de proxy a partir das contas primÃ¡rias (proxiadas).
icon: octicons-shield-lock-24
categories: Basics, Appchain
---

# Contas Proxy

## IntroduÃ§Ã£o {: #introduction }

As contas proxy podem ser configuradas para executar um nÃºmero limitado de aÃ§Ãµes em nome das contas primÃ¡rias e sÃ£o Ãºteis para manter as contas subjacentes seguras. Sua conta proxy pode atuar como uma "carteira quente" para interagir com a rede em nome de sua conta de "carteira fria". Para maior seguranÃ§a, vocÃª pode rotacionar regularmente a conta proxy.

As contas proxy tambÃ©m podem ajudÃ¡-lo a implementar o princÃ­pio do privilÃ©gio mÃ­nimo para controle de acesso. Por exemplo, se vocÃª tiver vÃ¡rios membros da equipe, poderÃ¡ fornecer a eles o nÃ­vel mÃ­nimo de acesso necessÃ¡rio para realizar suas tarefas por meio de um tipo especÃ­fico de conta proxy.

Este tutorial o guiarÃ¡ pela configuraÃ§Ã£o de uma conta proxy na Dancelight, o Tanssi TestNet, especificamente para transferÃªncias de saldo. Em seguida, demonstrarÃ¡ como realizar uma transferÃªncia de saldo usando o proxy recÃ©m-criado.

## Verificando os PrÃ©-requisitos {: #verifying-prerequisites }

Para acompanhar este tutorial, vocÃª precisarÃ¡ ter:

- [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} aberto e conectado ao [Dancelight](/pt/builders/tanssi-network/testnet/dancelight/){target=\_blank}.
- Crie ou tenha duas contas acessÃ­veis no portal do desenvolvedor.
- Pelo menos uma das contas precisarÃ¡ ser financiada com tokens `{{ networks.dancelight.token_symbol }}`.

Se precisar de ajuda para importar suas contas para o Polkadot.js Apps, consulte o guia [Conectando-se ao Polkadot.js](/pt/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs){target=\_blank}.

## DefiniÃ§Ãµes Gerais {: #general-definitions }

Ao configurar uma conta proxy, uma garantia para o proxy Ã© retirada de seu saldo livre e movida para seu saldo reservado. A garantia Ã© necessÃ¡ria, pois a adiÃ§Ã£o de um proxy requer espaÃ§o de armazenamento na cadeia e Ã© recalculada para cada proxy que vocÃª adiciona ou remove. A garantia Ã© devolvida ao seu saldo livre apÃ³s a remoÃ§Ã£o de todos os proxies da sua conta.

O depÃ³sito Ã© calculado com base em uma base de depÃ³sito e um fator de depÃ³sito:

- **Base do depÃ³sito** - o valor a ser reservado para uma conta ter uma lista de proxies.
- **Fator de depÃ³sito** - o valor adicional a ser reservado para cada proxy que a conta primÃ¡ria tiver.

A equaÃ§Ã£o para calcular o depÃ³sito Ã©:

```text
base do depÃ³sito + fator de depÃ³sito * nÃºmero de proxies
```

VocÃª pode encontrar cada uma das variÃ¡veis relevantes abaixo.

=== "Tanssi MainNet"
    |    VariÃ¡vel    |                                      Valor                                       |
    |:--------------:|:--------------------------------------------------------------------------------:|
    |  Base do depÃ³sito  |  {{ networks.mainnet.proxy.deposit_base }} {{ networks.mainnet.token_symbol }}  |
    | Fator de depÃ³sito | {{ networks.mainnet.proxy.deposit_factor }} {{ networks.mainnet.token_symbol }} |
    |  MÃ¡x. de proxies   |                 {{ networks.mainnet.proxy.max_proxies }} proxies                 |

=== "Dancelight TestNet"
    |    VariÃ¡vel    |                                         Valor                                          |
    |:--------------:|:--------------------------------------------------------------------------------------:|
    |  Base do depÃ³sito  |  {{ networks.dancelight.proxy.deposit_base }} {{ networks.dancelight.token_symbol }}  |
    | Fator de depÃ³sito | {{ networks.dancelight.proxy.deposit_factor }} {{ networks.dancelight.token_symbol }} |
    |  MÃ¡x. de proxies   |                  {{ networks.dancelight.proxy.max_proxies }} proxies                   |

## Tipos de Proxy {:  #proxy-types }

Ao criar uma conta proxy, vocÃª deve escolher um tipo de proxy que definirÃ¡ como o proxy pode ser usado. As opÃ§Ãµes disponÃ­veis sÃ£o:

- **`Any`** - permite que a conta proxy use qualquer funÃ§Ã£o suportada pela palete proxy. NÃ£o hÃ¡ filtragem de chamadas.
- **`NonTransfer`** - este tipo de conta proxy Ã© permitido para enviar qualquer tipo de transaÃ§Ã£o, com exceÃ§Ã£o de transferÃªncias de saldo.
- **`Balances`** - permite que a conta proxy faÃ§a apenas transaÃ§Ãµes relacionadas ao envio de fundos.
- **`Governance`** - permite que a conta proxy faÃ§a apenas transaÃ§Ãµes relacionadas Ã  palete de governanÃ§a, como votaÃ§Ã£o ou criaÃ§Ã£o de propostas de democracia. Observe que a governanÃ§a ainda nÃ£o estÃ¡ habilitada na Tanssi. VocÃª pode criar contas proxy de governanÃ§a, mas elas nÃ£o poderÃ£o tomar nenhuma aÃ§Ã£o atÃ© que a governanÃ§a seja habilitada.
- **`Registrar`** - permite que a conta proxy faÃ§a apenas transaÃ§Ãµes relacionadas Ã  palete do registrador.
- **`SudoRegistrar`** - permite que a conta proxy faÃ§a apenas transaÃ§Ãµes relacionadas Ã  palete do registrador que precisam ser chamadas por Sudo.
- **`CancelProxy`** - permite que a conta proxy rejeite e remova quaisquer chamadas proxy anunciadas.
- **`Staking`** - permite que a conta proxy execute transaÃ§Ãµes relacionadas a staking, como funÃ§Ãµes de Sequencer e `session()`.
- **`SessionKeyManagement`** - permite que a conta proxy faÃ§a transaÃ§Ãµes relacionadas ao gerenciamento de chaves incluÃ­das na palete de sessÃ£o.

Para este guia, vocÃª configurarÃ¡ uma conta proxy usando o tipo de proxy de saldos. Como este tipo permite que o proxy gaste fundos em nome da conta primÃ¡ria, vocÃª deve ter cuidado e fornecer acesso apenas a contas em que confia. O proxy terÃ¡ acesso para transferir todos os fundos dentro da conta primÃ¡ria e, se nÃ£o for confiÃ¡vel, o proxy poderÃ¡ drenar a conta primÃ¡ria. Certifique-se de manter a supervisÃ£o de suas contas proxy e remover todos os proxies que nÃ£o forem mais necessÃ¡rios.

## Criando uma Conta Proxy {: #creating-a-proxy-account   }

HÃ¡ algumas maneiras de criar contas proxy no [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/accounts){target=\_blank}, seja na pÃ¡gina **Extrinsics** ou na pÃ¡gina **Accounts**. No entanto, para criar um proxy com atraso de tempo, vocÃª precisarÃ¡ usar a pÃ¡gina **Extrinsics**. Um atraso de tempo fornece uma camada adicional de seguranÃ§a para proxies, especificando um perÃ­odo de atraso com base no nÃºmero de blocos. Isso impedirÃ¡ que a conta proxy execute uma transaÃ§Ã£o atÃ© o final do perÃ­odo de atraso. O atraso permite tempo para a conta primÃ¡ria que controla o proxy revisar as transaÃ§Ãµes pendentes, possivelmente para aÃ§Ãµes maliciosas, e cancelar, se necessÃ¡rio, antes da execuÃ§Ã£o.

A seguinte demonstraÃ§Ã£o mostrarÃ¡ como configurar um proxy Balances, que permite a transferÃªncia de fundos, tornando-o perfeito para fins de demonstraÃ§Ã£o. Depois de configurar seu proxy de saldos, vocÃª pode tentar transferir fundos da conta primÃ¡ria via proxy.

Para comeÃ§ar a criar sua conta proxy, vÃ¡ para a aba **Developer** e selecione [**Extrinsics**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank} no menu suspenso. Em seguida, vocÃª precisarÃ¡ seguir as seguintes etapas:

1. Selecione a conta primÃ¡ria.
2. No menu suspenso **submit the following extrinsic**, selecione **proxy**.
3. Escolha a extrÃ­nseca **addProxy**.
4. Escolha **Id** no menu suspenso **AccountIdLookupOf**.
5. Selecione a conta **delegate** para o proxy.
6. No menu suspenso **proxyType**, escolha **Balances**.
7. Opcionalmente, vocÃª pode adicionar um atraso de tempo usando um nÃºmero especificado de blocos para adicionar uma camada adicional de seguranÃ§a para que a conta primÃ¡ria revise a transaÃ§Ã£o pendente.
8. Clique em **Submit Transaction**.

![Adicionar uma conta proxy da pÃ¡gina Extrinsics do Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-1.webp)

VocÃª serÃ¡ solicitado a autorizar e assinar a transaÃ§Ã£o. Clique em **Sign and Submit** para criar o relacionamento proxy. Depois que a transaÃ§Ã£o for enviada com sucesso, vocÃª receberÃ¡ algumas notificaÃ§Ãµes confirmando a transaÃ§Ã£o.

Como mencionado anteriormente, vocÃª tambÃ©m pode criar um proxy na pÃ¡gina **Accounts**. Para fazer isso, navegue atÃ© a pÃ¡gina **Accounts** e siga as seguintes etapas:

1. Selecione os trÃªs pontos verticais ao lado da conta primÃ¡ria.
2. Selecione **Add proxy**.

![Selecione o item de menu Add proxy da pÃ¡gina Accounts do Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-2.webp)

!!! note
    Se a conta jÃ¡ tiver um proxy, **Manage proxies** serÃ¡ exibido como uma opÃ§Ã£o em vez de **Add proxy**.

AparecerÃ¡ um pop-up e vocÃª poderÃ¡ inserir as informaÃ§Ãµes necessÃ¡rias, como a conta proxy/primÃ¡ria, a conta proxy e o tipo de proxy para criar uma conta proxy. Primeiro, clique em **Add Proxy**.

![Adicionar uma conta proxy da pÃ¡gina Accounts do Polkadot.js Apps](/images/builders/account-management/proxy/proxy-3.webp)

Em seguida, siga as seguintes etapas:

1. Selecione a conta que deseja definir como proxy.
2. Selecione o tipo de proxy.
3. Clique em **Submit** e assine a transaÃ§Ã£o.

![Adicione os detalhes da conta proxy, incluindo a conta proxy e o tipo.](/images/builders/account-management/proxy/proxy-4.webp)

Na prÃ³xima seÃ§Ã£o, vocÃª aprenderÃ¡ como verificar se sua conta proxy foi configurada com sucesso.

## Verificando sua Conta Proxy {: #verifying-your-proxy-account }

VocÃª pode verificar se sua conta proxy foi configurada com sucesso de algumas maneiras: na pÃ¡gina **Accounts** ou na pÃ¡gina **Chain state**.

Para verificar suas contas proxy na pÃ¡gina [**Chain state**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, vocÃª pode seguir as seguintes etapas:

1. No menu suspenso **selected state query**, selecione **proxy**.
2. Escolha a extrÃ­nseca **proxies**.
3. Selecione sua conta primÃ¡ria/proxy.
4. Clique no botÃ£o **+** para enviar a consulta.

![Verifique suas contas proxy na pÃ¡gina Extrinsics do Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-5.webp)

O resultado aparecerÃ¡ na pÃ¡gina, mostrando informaÃ§Ãµes sobre todos os seus proxies, incluindo o endereÃ§o da conta delegate/proxy, o tipo de proxy, o perÃ­odo de atraso, se um foi especificado, e o valor total da garantia para todos os seus proxies em Planck.

VocÃª tambÃ©m pode verificar suas contas proxy na pÃ¡gina **Accounts**. Para fazer isso, navegue atÃ© a pÃ¡gina **Accounts** e deverÃ¡ haver um sÃ­mbolo Proxy ao lado da conta primÃ¡ria. Passe o mouse sobre o Ã­cone e clique em **Manage proxies** para revisar seus proxies.

![Passe o mouse sobre o Ã­cone do proxy para gerenciar seus proxies na pÃ¡gina Accounts do Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-6.webp)

AparecerÃ¡ um pop-up onde vocÃª poderÃ¡ ver uma visÃ£o geral de todas as suas contas proxy.

![Revise suas contas proxy.](/images/builders/account-management/proxy/proxy-7.webp)

## Executando uma TransaÃ§Ã£o Proxy {: #executando-uma-transaÃ§Ã£o-proxy }

Agora que vocÃª criou uma conta proxy e verificou se ela foi configurada com sucesso, vocÃª pode executar uma transaÃ§Ã£o usando a conta proxy em nome da conta primÃ¡ria.

Para executar uma transaÃ§Ã£o, vocÃª pode voltar para a pÃ¡gina [**Extrinsics**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank} e seguir as seguintes etapas:

1. Selecione a conta proxy para enviar a transaÃ§Ã£o pelo menu suspenso **using the select account**.
2. No menu **submit the following extrinsic**, selecione **proxy**.
3. Escolha a extrÃ­nseca **proxy**.
4. Escolha **Id** no menu suspenso **AccountIdLookupOf**.
5. Selecione a conta primÃ¡ria no menu suspenso **real**.
6. Selecione a chamada **balances**.
7. Escolha a extrÃ­nseca **transferKeepAlive**.
8. Escolha **Id** no menu suspenso **AccountIdLookupOf**.
9. No campo **dest**, insira o endereÃ§o para o qual vocÃª gostaria de enviar fundos.
10. No campo **value**, insira a quantidade de tokens `{{ networks.dancelight.token_symbol }}` para enviar. Para este exemplo, vocÃª pode enviar `2` tokens `{{ networks.dancelight.token_symbol }}`.
11. Clique em **Submit Transaction**.

![Execute uma transaÃ§Ã£o proxy da pÃ¡gina Extrinsics do Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-8.webp)

AparecerÃ¡ um pop-up para vocÃª autorizar e assinar a transaÃ§Ã£o. Insira sua senha para a conta proxy e clique em **Sign and Submit**.

Se a transaÃ§Ã£o for bem-sucedida, vocÃª deverÃ¡ ver alguns pop-ups de notificaÃ§Ã£o. Se vocÃª for para a pÃ¡gina **Accounts**, verÃ¡ que o saldo de sua conta primÃ¡ria diminuiu. Se vocÃª verificar o saldo da conta para onde enviou os fundos, notarÃ¡ que o saldo aumentou.

![Verifique o saldo na pÃ¡gina das contas do Polkadot.js Apps](/images/builders/account-management/proxy/proxy-9.webp)

Ã‰ isso! VocÃª executou com sucesso uma transaÃ§Ã£o usando uma conta proxy em nome de sua conta primÃ¡ria.

## Removendo uma Conta Proxy {: #removing-a-proxy-account }

Semelhante Ã  adiÃ§Ã£o de uma conta proxy, hÃ¡ algumas maneiras de remover uma conta proxy, seja na pÃ¡gina **Extrinsics** ou na pÃ¡gina **Accounts**. Independentemente de qual pÃ¡gina vocÃª usar, vocÃª pode optar por remover uma Ãºnica conta proxy ou todos os proxies associados Ã  sua conta primÃ¡ria.

Para remover um proxy da pÃ¡gina [**Extrinsics**](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, vocÃª pode seguir as seguintes etapas:

1. No menu suspenso **using the selected account**, selecione sua conta primÃ¡ria.
2. Em seguida, selecione **proxy**.
3. Escolha **removeProxy** para remover um Ãºnico proxy ou **removeProxies** para remover todos os proxies associados.
4. Escolha **Id** no menu suspenso **AccountIdLookupOf**.
5. Se estiver removendo um Ãºnico proxy, insira a conta proxy a ser removida no campo **delegate**.
6. Selecione o **proxyType** a ser removido, neste caso, escolha **Balances**.
7. Opcionalmente, selecione um perÃ­odo de atraso em nÃºmero de blocos.
8. Clique em **Submit Transaction**.

![Remova uma conta proxy da pÃ¡gina Extrinsics do Polkadot.js Apps](/images/builders/account-management/proxy/proxy-10.webp)

AparecerÃ¡ um pop-up pedindo que vocÃª autorize e assine a transaÃ§Ã£o. VocÃª pode assinar e enviar a transaÃ§Ã£o da conta primÃ¡ria ou proxy, mas a chamada para remover o proxy deve ser enviada da conta primÃ¡ria. Insira sua senha e clique em **Sign and Submit**.

Para verificar se o proxy ou as contas proxy foram removidos, siga as etapas na seÃ§Ã£o [Verificando sua Conta Proxy](#verifying-your-proxy-account).

Como mencionado anteriormente, vocÃª tambÃ©m pode remover um proxy da pÃ¡gina **Accounts**. Para fazer isso, na pÃ¡gina **Accounts**, selecione os trÃªs pontos verticais ao lado da conta primÃ¡ria e selecione **Manage Proxies**.

![Clique no botÃ£o Manage Proxies para revisar e gerenciar suas contas proxy.](/images/builders/account-management/proxy/proxy-11.webp)

AparecerÃ¡ um pop-up mostrando uma visÃ£o geral de suas contas proxy. Para remover todos os proxies, vocÃª pode clicar em **Clear all**, e serÃ¡ automaticamente solicitado que vocÃª insira sua senha e envie a transaÃ§Ã£o. Para remover um Ãºnico proxy, siga as seguintes etapas:

1. Clique no botÃ£o **X** ao lado do proxy para remover
2. Pressione **Submit**

![Remova uma conta proxy da pÃ¡gina Accounts do Polkadot.js Apps.](/images/builders/account-management/proxy/proxy-12.webp)

Na tela de confirmaÃ§Ã£o da transaÃ§Ã£o, siga as seguintes etapas:

1. Certifique-se de nÃ£o usar um proxy para esta chamada (como este exemplo Ã© um proxy de saldos, a chamada para remover o proxy precisa vir da conta primÃ¡ria, em vez da conta proxy).
2. Insira sua senha para a conta respectiva.
3. Pressione **Sign and Submit**.

![Remova uma conta proxy da pÃ¡gina Accounts do Polkadot.js Apps, confirmaÃ§Ã£o](/images/builders/account-management/proxy/proxy-13.webp)

Depois que a transaÃ§Ã£o for enviada com sucesso, vocÃª pode revisar seus proxies atuais ou, se removeu todos os proxies, notarÃ¡ que o Ã­cone do proxy nÃ£o estÃ¡ mais sendo exibido ao lado da conta primÃ¡ria. E Ã© isso! VocÃª criou com sucesso um proxy, revisou todas as contas proxy associadas Ã  sua conta primÃ¡ria, executou uma transaÃ§Ã£o proxy e removeu uma conta proxy!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/customize/adding-built-in-module/
--- BEGIN CONTENT ---
---
title: Adicionando MÃ³dulos Substrate Embutidos
description: Aprenda a aproveitar os mÃ³dulos prÃ©-construÃ­dos e prontos para uso do Substrate para adicionar novas funcionalidades Ã  sua rede de forma eficiente, sem precisar criar tudo do zero.
icon: octicons-package-24
categories: Custom-Runtime
---

# Adicionando um MÃ³dulo Embutido {: #adding-builtin-module }

## IntroduÃ§Ã£o {: #introduction }

Substrate Ã© uma estrutura de desenvolvimento de software poderosa e modular incluÃ­da nos SDKs Polkadot para construir blockchains. Ele fornece um conjunto abrangente de ferramentas e bibliotecas que abstraem funcionalidades complexas de blockchain, permitindo que os desenvolvedores se concentrem na construÃ§Ã£o de recursos e aplicaÃ§Ãµes inovadoras, focando no runtime, que contÃ©m a lÃ³gica central e as regras da transiÃ§Ã£o de estado para o caso de uso.

O que diferencia o Substrate Ã© sua arquitetura modular, que permite a integraÃ§Ã£o perfeita de [mÃ³dulos embutidos](https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame){target=\_blank} e a criaÃ§Ã£o de mÃ³dulos personalizados, facilitando o desenvolvimento de protocolos de blockchain.

Para casos que exigem apenas compatibilidade com EVM (Ethereum Virtual Machine), o template fornecido no [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi#container-chain-templates){target=\_blank} atende aos requisitos sem outras modificaÃ§Ãµes. No entanto, as equipes que desejam construir uma rede Substrate devem adicionar e configurar mÃ³dulos embutidos e personalizados dentro do runtime. Isso envolve compilar, gerar a especificaÃ§Ã£o da cadeia e implantar por meio do protocolo Tanssi para transformÃ¡-lo em uma rede ao vivo powered by Tanssi.

Este artigo enfoca as etapas necessÃ¡rias para adicionar um mÃ³dulo embutido ao template EVM.

## Verificando PrÃ©-requisitos {: #verifying-prerequisites }

Para seguir as etapas deste guia, vocÃª precisarÃ¡ ter o seguinte:

- Um ambiente de desenvolvimento saudÃ¡vel com o compilador Rust e o gerenciador de pacotes Cargo
- O [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi){target=\_blank}, clonado do GitHub

VocÃª pode ler mais sobre como instalar os componentes necessÃ¡rios no [artigo de prÃ©-requisitos](/pt/builders/build/customize/prerequisites/){target=\_blank}.

Como este artigo Ã© baseado no template EVM, certifique-se de que ele compile corretamente antes de continuar, executando o seguinte comando:

```bash
cargo build -p container-chain-frontier-node --release
```

## Adicionando um MÃ³dulo Embutido ao Runtime {: #adding-builtin-module-to-runtime }

Como introduzido no artigo de [modularidade](/pt/learn/framework/modules/){target=\_blank}, o framework Substrate jÃ¡ inclui muitos mÃ³dulos embutidos que abordam uma ampla gama de funcionalidades, prontos para serem usados em seu runtime.

Os mÃ³dulos sÃ£o projetados para fornecer a funcionalidade necessÃ¡ria em casos de uso muito diferentes, como DeFi, NFTs ou qualquer outro, e, portanto, sÃ£o blocos de construÃ§Ã£o bÃ¡sicos que sÃ£o inerentemente abstratos e podem ser configurados de acordo com as necessidades especÃ­ficas da rede powered by Tanssi.

Para adicionar um mÃ³dulo, as seguintes etapas sÃ£o necessÃ¡rias:

1. Tornar a dependÃªncia disponÃ­vel dentro do projeto, declarando-a em [Cargo](https://doc.rust-lang.org/cargo){target=\_blank}, o gerenciador de pacotes da linguagem Rust
2. Tornar os recursos padrÃ£o (`std`) do mÃ³dulo disponÃ­veis para o compilador
3. Configurar o mÃ³dulo
4. Adicionar o mÃ³dulo ao runtime
5. Adicionar a configuraÃ§Ã£o padrÃ£o Ã  especificaÃ§Ã£o da cadeia

No exemplo a seguir, o popular mÃ³dulo Substrate `pallet-assets` Ã© adicionado ao runtime do template EVM fornecido, encontrado no [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi){target=\_blank}, especificamente na pasta `container-chains/templates/frontier/`.

### Declarar a DependÃªncia {: #declare-dependency }

Cada pacote contÃ©m um arquivo de manifesto chamado `Cargo.toml` que declara, entre outras coisas, todas as dependÃªncias em que o pacote se baseia, e o runtime da rede powered by Tanssi nÃ£o Ã© exceÃ§Ã£o.

Portanto, a primeira etapa Ã© declarar a dependÃªncia e tornÃ¡-la disponÃ­vel para o runtime. Abra o arquivo `Cargo.toml` localizado na pasta `container-chains/templates/frontier/runtime` com um editor de texto e adicione o mÃ³dulo, referenciando o cÃ³digo no Polkadot SDK:

```toml
[dependencies]
...
pallet-assets = { 
   git = "https://github.com/moondance-labs/polkadot-sdk", 
   branch = "{{ repository.tanssi.release_branch }}", 
   default-features = false 
}
...
```

!!! note
      Nossa equipe de engenharia contribui ativamente para o desenvolvimento do Substrate, corrigindo problemas e aprimorando funcionalidades. Como resultado, o repositÃ³rio fork Tanssi frequentemente fica Ã  frente do oficial. Ã‰ por isso que este exemplo faz referÃªncia a um mÃ³dulo embutido de um repositÃ³rio Tanssi em vez do oficial.

### Tornar os Recursos PadrÃ£o DisponÃ­veis para o Compilador {: #standard-features }

No Cargo, as flags de â€œrecursosâ€ fornecem um mecanismo para dizer ao compilador para incluir ou omitir determinadas partes do cÃ³digo, o que Ã© um mecanismo Ãºtil para otimizar o tempo de compilaÃ§Ã£o, minimizar os tamanhos dos arquivos binÃ¡rios ou desabilitar determinado comportamento (por exemplo, nÃ£o incluir testes unitÃ¡rios ou funcionalidade de benchmarking no runtime pretendido para produÃ§Ã£o).

Para compilar os recursos padrÃ£o para o mÃ³dulo Assets dentro do runtime, o mesmo arquivo `Cargo.toml` na pasta `runtime` deve ser editado, ativando a flag. Tudo o que estÃ¡ listado nesta seÃ§Ã£o garantirÃ¡ que esteja disponÃ­vel para o compilador ao construir o binÃ¡rio do runtime, que Ã©, em Ãºltima anÃ¡lise, o arquivo que contÃ©m todas as informaÃ§Ãµes para executar sua rede powered by Tanssi inicialmente.

```toml
[features]
default = [
	"std",
]
std = [
	...,
	"pallet-assets/std",
   ...
]
```

### Configurar o MÃ³dulo {:#configure-the-module }

Com a dependÃªncia declarada no projeto, o mÃ³dulo agora pode ser configurado e adicionado ao runtime. Para fazer isso, vocÃª precisa editar o arquivo `lib.rs` que estÃ¡ localizado em:

```text
container-chains/templates/frontier/runtime/src/lib.rs
```

A configuraÃ§Ã£o de novos mÃ³dulos requer a implementaÃ§Ã£o de um `trait` de configuraÃ§Ã£o para o mÃ³dulo (neste exemplo, para Assets) no runtime, expresso em Rust da seguinte forma:

```rust
// Implementa o trait pallet_assets::Config no runtime
impl pallet_assets::Config for Runtime { ... }
```

[Traits](https://doc.rust-lang.org/book/ch10-02-traits.html){target=\_blank} sÃ£o uma forma de definir comportamento compartilhado em Rust e, neste caso, eles permitem que um novo runtime se beneficie da funcionalidade que o mÃ³dulo Assets fornece apenas implementando seu trait de configuraÃ§Ã£o e parÃ¢metros.

Alguns dos parÃ¢metros que o trait precisa definir podem ser valores constantes; nesse caso, eles precisam ser definidos e incluÃ­dos na macro `parameter_types!`, o que nos ajuda a reduzir o esforÃ§o de desenvolvimento, expandindo o cÃ³digo e convertendo cada uma das constantes no tipo de struct correto com funÃ§Ãµes que permitem que o runtime leia seu tipo e valores de forma padronizada.

O seguinte trecho de cÃ³digo mostra um exemplo das definiÃ§Ãµes de constantes a serem usadas na configuraÃ§Ã£o do mÃ³dulo:

```rust
parameter_types! {
   // A quantidade de fundos que devem ser reservados para um ativo
	pub const AssetDeposit: Balance = 100;
   // A quantidade de fundos que deve ser reservada ao criar 
   // uma nova aprovaÃ§Ã£o de transferÃªncia
	pub const ApprovalDeposit: Balance = 1;
   // A quantidade bÃ¡sica de fundos que deve ser reservada ao adicionar metadados 
   // ao seu ativo
	pub const MetadataDepositBase: Balance = 10;
   // Os fundos adicionais que devem ser reservados para o nÃºmero de bytes 
   // que vocÃª armazena em seus metadados
	pub const MetadataDepositPerByte: Balance = 1;

   // Comprimento mÃ¡ximo para o sÃ­mbolo do ativo e nome amigÃ¡vel
   pub const StringLimit: u32 = 50;
}
```

Ã‰ importante notar que cada mÃ³dulo embutido tem um propÃ³sito diferente e, portanto, cada um deles tem necessidades diferentes em termos dos parÃ¢metros que devem ser configurados. O seguinte trecho de cÃ³digo implementa o trait e configura o mÃ³dulo Assets, usando tipos e as constantes definidas anteriormente na macro `parameter_types!`:

```rust
// Implementando o trait de configuraÃ§Ã£o de Ativos para o runtime
impl pallet_assets::Config for Runtime {
   
   // Armazena os saldos em um inteiro sem sinal de 128bits
	type Balance = u128;
   // O ID de um ativo pode ser definido como um inteiro sem sinal de 64 bits
	type AssetId = u64;
   // Usa o mÃ³dulo Balances como mecanismo para operaÃ§Ãµes de moeda
	type Currency = Balances;

   // Configurar o mÃ³dulo referenciando a anteriormente
   // constantes definidas

	type AssetDeposit = AssetDeposit;
	type MetadataDepositBase = MetadataDepositBase;
	type MetadataDepositPerByte = MetadataDepositPerByte;
	type ApprovalDeposit = ApprovalDeposit;
	type StringLimit = StringLimit;
   
   // Mais configuraÃ§Ã£o
   ...
}
```

??? code "Ver o script completo"

    ```rust
    parameter_types! {
    // The amount of funds that must be reserved for an asset
    pub const AssetDeposit: Balance = 100;
    // The amount of funds that must be reserved when creating 
    // a new transfer approval
    pub const ApprovalDeposit: Balance = 1;
    // The basic amount of funds that must be reserved when adding metadata 
    // to your asset
    pub const MetadataDepositBase: Balance = 10;
    // The additional funds that must be reserved for the number of bytes 
    // you store in your metadata
    pub const MetadataDepositPerByte: Balance = 1;
    // Maximum lenght for the asset symbol and friendly name
    pub const StringLimit: u32 = 50;
}

// Implementing the Assets config trait for the runtime
impl pallet_assets::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;

    // Stores the balances in an unsigned integer of 128bits
    type Balance = u128;
    // The id of an asset can be defined as an unsigned integer of 64 bits
    type AssetId = u64;
    // Uses module Balances as mechanism for currency operations
    type Currency = Balances;

    // Configure the module by referencing the previously
    // defined constants
    type AssetDeposit = AssetDeposit;
    type MetadataDepositBase = MetadataDepositBase;
    type MetadataDepositPerByte = MetadataDepositPerByte;
    type ApprovalDeposit = ApprovalDeposit;
    type StringLimit = StringLimit;

    // More configuration
    type AssetIdParameter = u64;
    // Defines the allowed origins to create assets
    type CreateOrigin = 
        frame_support::traits::AsEnsureOriginWithArg<frame_system::EnsureSigned<AccountId>>;
    // Root can create assets
    type ForceOrigin = EnsureRoot<AccountId>;
    type AssetAccountDeposit = frame_support::traits::ConstU128<1>;
    type Freezer = ();
    type Extra = ();
    type WeightInfo = pallet_assets::weights::SubstrateWeight<Runtime>;
    type RemoveItemsLimit = frame_support::traits::ConstU32<1000>;
    #[cfg(feature = "runtime-benchmarks")]
    type BenchmarkHelper = ();
    type CallbackHandle = ();
}
    ```


A configuraÃ§Ã£o completa do mÃ³dulo contÃ©m mais parÃ¢metros; para ver uma descriÃ§Ã£o detalhada de cada um deles, consulte o [trait de configuraÃ§Ã£o oficial para a documentaÃ§Ã£o do mÃ³dulo Assets](https://paritytech.github.io/substrate/master/pallet_assets/pallet/trait.Config.html){target=\_blank}.

### Adicionar o MÃ³dulo ao Runtime {:#add-module-to-runtime}

In the same `lib.rs` file referenced in the previous section, there is a segment enclosed in the macro `construct_runtime!()`. This is where the pallet must be added to be included in the runtime. Since the example is based on the EVM template, the runtime is already configured to include many modules, including the modules for system support, the modules to add the Ethereum compatibility layer, the modules to support the Tanssi protocol, balances, and now also Assets:
      

```rust
construct_runtime!(
   pub enum Runtime where
      Block = Block,
      NodeBlock = opaque::Block,
      UncheckedExtrinsic = UncheckedExtrinsic,
   {
      // Coisas de suporte do sistema.
      System: frame_system = 0,
      ParachainSystem: cumulus_pallet_parachain_system = 1,
      Timestamp: pallet_timestamp = 2,
      ParachainInfo: parachain_info = 3,
      Sudo: pallet_sudo = 4,
      Utility: pallet_utility = 5,
      ...
      Balances: pallet_balances = 10,
      // MÃ³dulo Assets Ã© adicionado aqui
      Assets: pallet_assets = 11,
      ...
   }
```

### Configurar o MÃ³dulo na EspecificaÃ§Ã£o da Cadeia {: #configure-chain-specs }

Finally, add the configuration in the chain specification for the genesis state in the file `chain_spec.rs` located at:

```text
container-chains/templates/frontier/node/src/`chain_spec.rs`
```

A funÃ§Ã£o `testnet_genesis`, apresentada no seguinte trecho de cÃ³digo, define o estado inicial para os mÃ³dulos incluÃ­dos no runtime (como contas financiadas inicialmente, por exemplo). Depois de adicionar o mÃ³dulo Assets, Ã© necessÃ¡rio inicializÃ¡-lo tambÃ©m e, no exemplo a seguir, seus valores padrÃ£o sÃ£o definidos.

Mais detalhes sobre a especificaÃ§Ã£o da cadeia e como configurÃ¡-la serÃ£o abordados no artigo [Personalizando EspecificaÃ§Ãµes de Cadeia](/pt/builders/build/customize/customizing-chain-specs/){target=_blank}.

```rust hl_lines="14"

fn testnet_genesis(
   endowed_accounts: Vec<AccountId>,
   id: ParaId,
   root_key: AccountId,
) -> container_chain_template_frontier_runtime::GenesisConfig {
   container_chain_template_frontier_runtime::GenesisConfig {
      system: container_chain_template_frontier_runtime::SystemConfig {
         code: container_chain_template_frontier_runtime::WASM_BINARY
               .expect("O binÃ¡rio WASM nÃ£o foi construÃ­do, por favor, construa-o!")
               .to_vec(),
      },
      ...
      // Adicione o estado padrÃ£o para este mÃ³dulo no estado de gÃªnese
      assets: Default::default()
      ...
}
```

Com o mÃ³dulo incluÃ­do, esta nova versÃ£o do runtime desbloqueou um novo conjunto de funcionalidades prontas para serem compostas com ainda mais dos mÃ³dulos embutidos do Substrate ou personalizados.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/customize/adding-custom-made-module/
--- BEGIN CONTENT ---
---
title: Adicionar um MÃ³dulo Personalizado
description: Descubra como incorporar mÃ³dulos feitos sob medida para adicionar recursos Ãºnicos ou especializados Ã  sua rede que vÃ£o alÃ©m das capacidades dos mÃ³dulos embutidos.
icon: octicons-terminal-24
categories: Custom-Runtime
---
  
# Adicionar um MÃ³dulo Personalizado {: #adding-custom-made-module }
  
## IntroduÃ§Ã£o {:  #introduction }
  
Ao fornecer uma biblioteca abrangente de mÃ³dulos prÃ©-construÃ­dos que abordam muitos requisitos comuns, a estrutura simplifica enormemente o processo de construÃ§Ã£o de um blockchain e acelera a implantaÃ§Ã£o e evoluÃ§Ã£o em uma rede powered by Tanssi. No entanto, abordar um caso de uso inovador geralmente exige um esforÃ§o de desenvolvimento para atender totalmente aos requisitos e, no Substrate, adicionar lÃ³gica personalizada se traduz em escrever e integrar mÃ³dulos de Runtime.
  
O exemplo apresentado no artigo [Modularidade](/pt/learn/framework/modules/#custom-module-example){target=\_blank} mostra um mÃ³dulo de loteria simples que expÃµe duas transaÃ§Ãµes:
  
- **Buy tickets** - esta funÃ§Ã£o gerencia a entrada de um usuÃ¡rio na loteria. Essencialmente, ela verifica se o participante tem saldo suficiente, nÃ£o estÃ¡ participando e cuida da transferÃªncia de fundos para registrar o usuÃ¡rio na loteria
- **Award prize** - esta funÃ§Ã£o que lida com um usuÃ¡rio que entra na loteria. Em alto nÃ­vel, ela busca um nÃºmero pseudo-aleatÃ³rio para obter um vencedor e lida com a distribuiÃ§Ã£o do prÃªmio
  
A implementaÃ§Ã£o dessas transaÃ§Ãµes tambÃ©m usa armazenamento, emite eventos, define erros personalizados e depende de outros mÃ³dulos para lidar com a moeda (para cobrar pelos bilhetes e transferir o valor total para o vencedor) e aleatorizar a seleÃ§Ã£o do vencedor.
  
Neste artigo, as seguintes etapas, necessÃ¡rias para construir e adicionar o mÃ³dulo de exemplo ao Runtime, serÃ£o abordadas:

1. Criar os arquivos do mÃ³dulo de loteria (pacote).
2. Configurar as dependÃªncias do mÃ³dulo.
3. Adicionar lÃ³gica personalizada.
4. Configurar o Runtime com o novo mÃ³dulo.

Ã‰ importante ressaltar que nenhum dos cÃ³digos apresentados neste artigo se destina ao uso em produÃ§Ã£o.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para seguir as etapas deste guia, vocÃª precisarÃ¡ ter o seguinte:

- Clonar o [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi){target=\_blank} do Github
- Compilador Rust e gerenciador de pacotes Cargo

VocÃª pode ler mais sobre como instalar o Rust e o Cargo no artigo de [prÃ©-requisitos](/pt/builders/build/customize/prerequisites/#installing-rust){target=\_blank}.

## Criando os Arquivos do MÃ³dulo de Loteria {: #creating-lottery-module-files }

Antes de iniciar seu processo de codificaÃ§Ã£o, Ã© essencial criar os arquivos que contÃªm sua lÃ³gica. Os mÃ³dulos Substrate sÃ£o abstratos e destinados ao reaproveitamento em diferentes tempos de execuÃ§Ã£o com vÃ¡rias personalizaÃ§Ãµes. Para conseguir isso, vocÃª usarÃ¡ o Cargo, o gerenciador de pacotes do Rust, para criar o mÃ³dulo como um novo pacote.

Como mencionado na seÃ§Ã£o de prÃ©-requisitos, a primeira etapa Ã© clonar o [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi){target=\_blank} e, na pasta raiz, navegar atÃ© `pallets`, onde o mÃ³dulo serÃ¡ criado.


```bash
cd container-chains/pallets
```

Em seguida, crie o pacote do mÃ³dulo com o Cargo:

```bash
cargo new lottery-example
```

Por padrÃ£o, o Cargo cria o novo pacote em uma pasta com o nome fornecido (`lottery-example`, neste caso), contendo um arquivo de manifesto, `Cargo.toml` e uma pasta `src` com um arquivo `main.rs`. Para respeitar a convenÃ§Ã£o de nomenclatura usada no Substrate, o arquivo `main.rs` Ã© renomeado para `lib.rs`:

```bash
mv lottery-example/src/main.rs lottery-example/src/lib.rs
```

Depois de executar todos os comandos, o mÃ³dulo Ã© criado e estÃ¡ pronto para conter a lÃ³gica personalizada que vocÃª adicionarÃ¡ nas seÃ§Ãµes a seguir.

## Configurar as DependÃªncias do MÃ³dulo {: #configure-module-dependencies}

Como o mÃ³dulo funciona como um pacote independente, ele tem seu prÃ³prio arquivo Cargo.toml, onde vocÃª deve especificar os atributos e dependÃªncias do mÃ³dulo.

Por exemplo, vocÃª pode usar atributos para especificar detalhes como o nome do mÃ³dulo, versÃ£o, autores e outras informaÃ§Ãµes relevantes. Por exemplo, no mÃ³dulo `lottery-example`, o arquivo `Cargo.toml` pode ser configurado da seguinte forma:

```toml
#[pallet::storage]
#[pallet::getter(fn get_participants)]
pub(super) type Participants<T: Config> = StorageValue<
    _,
    BoundedVec<T::AccountId, T::MaxParticipants>,
    OptionQuery
>;
```

Este arquivo tambÃ©m define as dependÃªncias do mÃ³dulo, como a funcionalidade principal que permite a integraÃ§Ã£o perfeita com o Runtime e outros mÃ³dulos, acesso ao armazenamento, emissÃ£o de eventos e muito mais.

O exemplo completo do arquivo `Cargo.toml` define, alÃ©m dos atributos, as dependÃªncias exigidas pelo Substrate:

??? code "Ver o arquivo Cargo.toml completo"

    ```rust   
    [package]
name = "module-lottery-example"
version = "4.0.0-dev"
description = "Simple module example"
authors = [""]
homepage = ""
edition = "2021"
publish = false

[package.metadata.docs.rs]
targets = ["x86_64-unknown-linux-gnu"]

[dependencies]
codec = { package = "parity-scale-codec", version = "3.6.1", default-features = false, features = [
	"derive",
] }
scale-info = { version = "2.5.0", default-features = false, features = ["derive"] }
frame-benchmarking = { 
	version = "4.0.0-dev", 
	default-features = false, 
	optional = true, 
	git = "https://github.com/paritytech/substrate.git", 
	branch = "polkadot-v1.0.0" 
}
frame-support = { 
	version = "4.0.0-dev", 
	default-features = false, 
	git = "https://github.com/paritytech/substrate.git", 
	branch = "polkadot-v1.0.0" 
}
frame-system = { 
	version = "4.0.0-dev", 
	default-features = false, 
	git = "https://github.com/paritytech/substrate.git", 
	branch = "polkadot-v1.0.0" 
}

[dev-dependencies]
sp-core = { version = "21.0.0", git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v1.0.0" }
sp-io = { version = "23.0.0", git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v1.0.0" }
sp-runtime = { version = "24.0.0", git = "https://github.com/paritytech/substrate.git", branch = "polkadot-v1.0.0" }

[features]
default = ["std"]
std = [
	"codec/std",
	"frame-benchmarking?/std",
	"frame-support/std",
	"frame-system/std",
	"scale-info/std",
]
runtime-benchmarks = ["frame-benchmarking/runtime-benchmarks"]
try-runtime = ["frame-support/try-runtime"]
    ```

## Adicionando LÃ³gica Personalizada {: #adding-custom-logic}

Conforme apresentado na seÃ§Ã£o [mÃ³dulo personalizado](/pt/learn/framework/modules/#custom-modules){target=\_blank} do artigo sobre modularidade, a criaÃ§Ã£o de um mÃ³dulo envolve a implementaÃ§Ã£o das seguintes macros de atributo, das quais as trÃªs primeiras sÃ£o obrigatÃ³rias:

- **`#[frame_support::pallet]`** - atributo de entrada que marca o mÃ³dulo como utilizÃ¡vel no runtime
- **`#[pallet::pallet]`** - aplicado a uma estrutura usada para recuperar informaÃ§Ãµes do mÃ³dulo com facilidade
- **`#[pallet::config]`** - atributo obrigatÃ³rio para definir a configuraÃ§Ã£o dos tipos de dados do mÃ³dulo
- **`#[pallet::call]`** - macro usada para definir funÃ§Ãµes expostas como transaÃ§Ãµes, permitindo que sejam despachadas para o runtime; aqui os desenvolvedores adicionam transaÃ§Ãµes e lÃ³gica personalizadas
- **`#[pallet::error]`** - como transaÃ§Ãµes podem falhar (por exemplo, fundos insuficientes) e, por seguranÃ§a, um mÃ³dulo nÃ£o deve gerar exceÃ§Ãµes, todos os possÃ­veis erros devem ser identificados e listados em um enum para serem retornados em uma execuÃ§Ã£o malsucedida
- **`#[pallet::event]`** - eventos podem ser definidos e usados para fornecer mais informaÃ§Ãµes ao usuÃ¡rio
- **`#[pallet::storage]`** - macro usada para definir elementos que serÃ£o persistidos em storage; como recursos sÃ£o escassos em uma blockchain, deve ser usada com parcimÃ´nia para armazenar apenas informaÃ§Ãµes essenciais

### Implementando a Estrutura BÃ¡sica do MÃ³dulo {: #implementing-basic-structure }

As duas primeiras macros obrigatÃ³rias, `#[frame_support::pallet]` e `#[pallet::pallet]`, fornecem a estrutura bÃ¡sica do mÃ³dulo e sÃ£o necessÃ¡rias para habilitar o mÃ³dulo a ser usado em um Runtime Substrate.

A seguir, Ã© apresentada a estrutura geral de um mÃ³dulo Substrate personalizado.

```rust
#[frame_support::pallet(dev_mode)]
pub mod pallet {
    ...
    #[pallet::pallet]
    pub struct Pallet<T>(_); 

       // Toda a lÃ³gica vai aqui
}
```

A prÃ³xima etapa seria adicionar a terceira macro obrigatÃ³ria (`#[pallet::config]`) e toda a lÃ³gica personalizada, conforme mostrado nas seÃ§Ãµes a seguir.

### Implementando a ConfiguraÃ§Ã£o do MÃ³dulo {: #implementing-module-configuration }

Para tornar os mÃ³dulos altamente adaptÃ¡veis, sua configuraÃ§Ã£o Ã© abstrata o suficiente para permitir que sejam adaptados aos requisitos especÃ­ficos do caso de uso que o Runtime implementa.

A implementaÃ§Ã£o da macro `#[pallet::config]` Ã© obrigatÃ³ria e define a dependÃªncia do mÃ³dulo em outros mÃ³dulos e os tipos e valores especificados pelas configuraÃ§Ãµes especÃ­ficas do Runtime.

No mÃ³dulo `lottery-example` personalizado que vocÃª estÃ¡ construindo, o mÃ³dulo depende de outros mÃ³dulos para gerenciar a moeda e a funÃ§Ã£o aleatÃ³ria para selecionar o vencedor. O mÃ³dulo tambÃ©m lÃª e usa o preÃ§o do bilhete e o nÃºmero mÃ¡ximo de participantes diretamente das configuraÃ§Ãµes do Runtime. Consequentemente, a configuraÃ§Ã£o precisa incluir essas dependÃªncias:

- **Events** - o mÃ³dulo depende da definiÃ§Ã£o de um evento do Runtime para poder emiti-los
- **Currency** - o mÃ³dulo `lottery-example` precisa poder transferir fundos, portanto, precisa da definiÃ§Ã£o do sistema monetÃ¡rio do Runtime
- **Randomness** - este mÃ³dulo Ã© usado para selecionar de forma justa o vencedor do prÃªmio da lista de participantes. Ele gera os nÃºmeros aleatÃ³rios usando os hashes de bloco anteriores e o nÃºmero do bloco atual como semente
- **Ticket coste** - o preÃ§o a ser cobrado dos compradores que participam da loteria
- **Maximum number of participants** - o limite mÃ¡ximo de participantes permitido em cada rodada da loteria
- **Module Id** - o identificador exclusivo do mÃ³dulo Ã© necessÃ¡rio para acessar a conta do mÃ³dulo para manter os fundos dos participantes atÃ© serem transferidos para o vencedor

A implementaÃ§Ã£o da configuraÃ§Ã£o descrita para este exemplo Ã© mostrada no seguinte trecho de cÃ³digo:

```rust
#[pallet::config]
pub trait Config: frame_system::Config {

    // DefiniÃ§Ã£o do evento
    type RuntimeEvent: From<Event<Self>>
        + IsType<<Self as frame_system::Config>::RuntimeEvent>;
               
    // Moeda
    type Currency: Currency<Self::AccountId>;
                
    // Aleatoriedade
    type MyRandomness: Randomness<Self::Hash, BlockNumberFor<Self>>;
    
    // Custo do bilhete
    #[pallet::constant]
    type TicketCost: Get<BalanceOf<Self>>;
    
    // NÃºmero mÃ¡ximo de participantes
    #[pallet::constant]
    type MaxParticipants: Get<u32>;
    
    // ID do mÃ³dulo
    #[pallet::constant]
    type PalletId: Get<PalletId>;
}
```

Esta definiÃ§Ã£o abstrata de dependÃªncias Ã© crucial para evitar o acoplamento a um caso de uso especÃ­fico e para permitir que os mÃ³dulos sirvam como blocos de construÃ§Ã£o bÃ¡sicos para as redes Substrate.

### Implementando TransaÃ§Ãµes {: #implementing-transactions }

Chamadas representam o comportamento que um Runtime expÃµe na forma de transaÃ§Ãµes que podem ser despachadas para processamento, expondo a lÃ³gica personalizada adicionada ao mÃ³dulo.

Cada chamada estÃ¡ incluÃ­da na macro `#[pallet::call]` e apresenta os seguintes elementos:

- **Call Index** - Ã© um identificador exclusivo obrigatÃ³rio para cada chamada despachÃ¡vel
- **Weight** - Ã© uma medida do esforÃ§o computacional que uma extrÃ­nseca leva ao ser processada. Mais sobre pesos estÃ¡ na [documentaÃ§Ã£o do Polkadot](https://docs.polkadot.com/polkadot-protocol/parachain-basics/blocks-transactions-fees/fees/#how-fees-are-calculated){target=\_blank}
- **Origin** - identifica a conta de assinatura que estÃ¡ fazendo a chamada
- **Result** - o valor de retorno da chamada, que pode ser um `Erro` se alguma coisa der errado

A seguinte trecho apresenta a estrutura geral da implementaÃ§Ã£o da macro mencionada e os elementos de chamada:

```rust
#[pallet::call]
impl<T: Config> Pallet<T> {

    #[pallet::call_index(0)]
    #[pallet::weight(0)]
    pub fn one_call(origin: OriginFor<T>) -> DispatchResult { }
            
    #[pallet::call_index(1)]
    #[pallet::weight(0)]
    pub fn another_call(origin: OriginFor<T>) -> DispatchResult { }
                        
    // Outras chamadas
}
```

Neste mÃ³dulo `lottery-example`, definimos duas chamadas com a seguinte lÃ³gica:
                            
```rust
#[pallet::call]
impl<T: Config> Pallet<T> {

    #[pallet::call_index(0)]    
    #[pallet::weight(0)]
    pub fn buy_ticket(origin: OriginFor<T>) -> DispatchResult {
        
        // 1. Valida a assinatura de origem
        // 2. Verifica se o usuÃ¡rio tem saldo suficiente para pagar o preÃ§o do bilhete
        // 3. Verifica se o usuÃ¡rio jÃ¡ nÃ£o estÃ¡ participando
        // 4. Adiciona o usuÃ¡rio como um novo participante do prÃªmio
        // 5. Transfere o custo do bilhete para a conta do mÃ³dulo, para ser mantido atÃ© ser transferido para o vencedor
        // 6. Notifica o evento
    }
                                                            
    #[pallet::call_index(1)]
    #[pallet::weight(0)]
    pub fn award_prize(origin: OriginFor<T>) -> DispatchResult {
        // 1. Valida a assinatura de origem
        // 2. ObtÃ©m um nÃºmero aleatÃ³rio do mÃ³dulo de aleatoriedade
        // 3. Seleciona o vencedor da lista de participantes
        // 4. Transfere o prÃªmio total para a conta do vencedor
        // 5. Redefine a lista de participantes e prepara-se para outra rodada da loteria
    }
}
```
        
Essas chamadas tambÃ©m emitem eventos para manter o usuÃ¡rio informado e podem retornar erros caso alguma das validaÃ§Ãµes dÃª errado.
        
Aqui estÃ¡ a implementaÃ§Ã£o completa das chamadas com a lÃ³gica da loteria personalizada:
        
??? code "Ver o cÃ³digo de chamadas completo"
        
    ```rust
    #[pallet::call]
impl<T: Config> Pallet<T> {

    #[pallet::call_index(0)]
    #[pallet::weight(0)]
    pub fn buy_ticket(origin: OriginFor<T>) -> DispatchResult {

        // 1. Validates the origin signature
        let buyer = ensure_signed(origin)?;

        // 2. Checks that the user has enough balance to afford the ticket price
        ensure!(
            T::Currency::free_balance(&buyer) >= T::TicketCost::get(),
            Error::<T>::NotEnoughCurrency
        );

        // 3. Checks that the user is not already participating
        if let Some(participants) = Self::get_participants() {
            ensure!(
                !participants.contains(&buyer),
                Error::<T>::AccountAlreadyParticipating
            );
        }

        // 4. Adds the user as a new participant for the prize
        match Self::get_participants() {
            Some(mut participants) => { 
                ensure!(
                    participants.try_push(buyer.clone()).is_ok(), 
                    Error::<T>::CanNotAddParticipant
                );
                Participants::<T>::set(Some(participants));
            }, 
            None => {
                let mut participants = BoundedVec::new();
                ensure!(
                    participants.try_push(buyer.clone()).is_ok(), 
                    Error::<T>::CanNotAddParticipant
                );
                Participants::<T>::set(Some(participants));
            }
        };

        // 5. Transfers the ticket cost to the module's account
        // to be hold until transferred to the winner
        T::Currency::transfer(
            &buyer, 
            &Self::get_pallet_account(), 
            T::TicketCost::get(), 
            ExistenceRequirement::KeepAlive)?;
        
        // 6. Notify the event
        Self::deposit_event(Event::TicketBought { who: buyer });
        Ok(())
    }

    #[pallet::call_index(1)]
    #[pallet::weight(0)]
    pub fn award_prize(origin: OriginFor<T>) -> DispatchResult {

        // 1. Validates the origin signature
        let _who = ensure_root(origin)?;

        match Self::get_participants() {
            Some(participants) => { 
                
                // 2. Gets a random number from the randomness module
                let nonce = Self::get_and_increment_nonce();
                let (random_seed, _) = T::MyRandomness::random(&nonce);
                let random_number = <u32>::decode(&mut random_seed.as_ref())
                    .expect("secure hashes should always be bigger than u32; qed");
                
                // 3. Selects the winner from the participants lit
                let winner_index = random_number as usize % participants.len();
                let winner = participants.as_slice().get(winner_index).unwrap();

                // 4. Transfers the total prize to the winner's account
                let prize = T::Currency::free_balance(&Self::get_pallet_account());
                T::Currency::transfer(
                    &Self::get_pallet_account(), 
                    &winner, 
                    prize, 
                    ExistenceRequirement::AllowDeath)?;

                // 5. Resets the participants list, and gets ready for another lottery round
                Participants::<T>::kill();

                // 6. Notify the event
                Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );
            }, 
            None => {
                // Notify the event (No participants)
                Self::deposit_event(Event::ThereAreNoParticipants);
            }
        };

        Ok(())
    }
}
    ```
                    
### Implementando Erros Personalizados {: #implementing-custom-errors}

A macro `#[pallet::error]` Ã© usada para anotar uma enumeraÃ§Ã£o de erros potenciais que poderiam ocorrer durante a execuÃ§Ã£o. Ã‰ crucial para a seguranÃ§a garantir que todas as situaÃ§Ãµes de erro sejam tratadas com elegÃ¢ncia, sem causar a falha do Runtime.

O exemplo a seguir desta implementaÃ§Ã£o de macro mostra os erros que podem ocorrer no mÃ³dulo da loteria:

```rust
// Erros informam aos usuÃ¡rios que algo deu errado.
#[pallet::error]
pub enum `Error`<T> {
    NotEnoughCurrency,
    AccountAlreadyParticipating,
    CanNotAddParticipant,
}
```

### Implementando Eventos {: #implementing-events }

A macro `#[pallet::event]` Ã© aplicada a uma enumeraÃ§Ã£o de eventos para informar o usuÃ¡rio sobre quaisquer alteraÃ§Ãµes no estado ou aÃ§Ãµes importantes que ocorreram durante a execuÃ§Ã£o no Runtime.

Como exemplo, para o mÃ³dulo `lottery-example`, esta macro pode ser configurada com os seguintes eventos:

```rust
#[pallet::event]
#[pallet::generate_deposit(pub(super) fn deposit_event)]
pub enum Event<T: Config> {

    // Evento emitido quando um bilhete Ã© comprado
    TicketBought { who: T::AccountId },
    // Evento emitido quando o prÃªmio Ã© concedido
    PrizeAwarded { winner: T::AccountId },
    // Evento emitido quando nÃ£o hÃ¡ participantes  
    ThereAreNoParticipants,
    }
```
    
### Implementando o Armazenamento para PersistÃªncia de Estado {: #implementing-storage }

A macro `#[pallet::storage]` inicializa uma estrutura de armazenamento de Runtime. No ambiente altamente restrito de blockchains, decidir o que armazenar e qual estrutura usar pode ser fundamental em termos de desempenho. Mais sobre esse tÃ³pico Ã© abordado na [documentaÃ§Ã£o Substrate](https:/docs.polkadot.com/develop/parachains/customize-parachain/make-custom-pallet/#pallet-storage){target=\_blank}.

Neste exemplo, o mÃ³dulo `lottery-example` precisa de uma estrutura de armazenamento de valor bÃ¡sica para persistir a lista de participantes em um vetor de capacidade limitada ([BoundedVec](https:/crates.parity.io/frame_support/storage/bounded_vec/struct.BoundedVec.html){target=\_blank}). Isso pode ser inicializado da seguinte forma:

```rust
#[pallet::storage]
#[pallet::getter(fn get_participants)]
pub(super) type Participants<T: Config> = StorageValue<
    _,
    BoundedVec<T::AccountId, T::MaxParticipants>,
    OptionQuery
>;
```

### O MÃ³dulo Completo {: #complete-module }

Para juntar todas as peÃ§as, apÃ³s implementar todas as macros necessÃ¡rias e adicionar a lÃ³gica personalizada, o mÃ³dulo agora estÃ¡ completo e pronto para ser usado no Runtime.

??? code "Ver o arquivo do mÃ³dulo completo"
    
    ```rust    
    #![cfg_attr(not(feature = "std"), no_std)]

/// Learn more about FRAME and the core library of Substrate FRAME pallets:
/// <https://docs.substrate.io/reference/frame-pallets/>
pub use pallet::*;

#[frame_support::pallet(dev_mode)]
pub mod pallet {

	use super::*;
	use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};
	use frame_system::pallet_prelude::*;
	use scale_info::prelude::vec::Vec;

	use frame_support::
	{
		sp_runtime::traits::AccountIdConversion,
		traits:: {
			Currency, ExistenceRequirement, Randomness
		},
		PalletId,
	};

	type BalanceOf<T> = 
		<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

	#[pallet::pallet]
	pub struct Pallet<T>(_);

	/// Configure the module by specifying the parameters and types on which it depends.
	#[pallet::config]
	pub trait Config: frame_system::Config {

		// Event definition
		type RuntimeEvent: From<Event<Self>> 
			+ IsType<<Self as frame_system::Config>::RuntimeEvent>;

		// Currency 
		type Currency: Currency<Self::AccountId>;

		// Randomness
		type MyRandomness: Randomness<Self::Hash, BlockNumberFor<Self>>;

		// Ticket cost
		#[pallet::constant]
		type TicketCost: Get<BalanceOf<Self>>;

		// Maximum number of participants
		#[pallet::constant]
		type MaxParticipants: Get<u32>;

		// Module Id
		#[pallet::constant]
		type PalletId: Get<PalletId>;
	}

	// The pallet's runtime storage items.
	#[pallet::storage]
	#[pallet::getter(fn get_participants)]
	pub(super) type Participants<T: Config> = StorageValue<
		_,
		BoundedVec<T::AccountId, T::MaxParticipants>,
		OptionQuery
	>;

	#[pallet::storage]
	#[pallet::getter(fn get_nonce)]
	pub(super) type Nonce<T: Config> = StorageValue<
		_,
		u64,
		ValueQuery
	>;

	// Pallets use events to inform users when important changes are made.
	// https://docs.substrate.io/main-docs/build/events-errors/
	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		/// Event emitted when a ticket is bought
		TicketBought { who: T::AccountId },
		/// Event emitted when the prize is awarded
		PrizeAwarded { winner: T::AccountId },
		/// Event emitted when the prize is to be awarded, but there are no participants
		ThereAreNoParticipants,
	}

	// Errors inform users that something went wrong
	#[pallet::error]
	pub enum Error<T> {
		NotEnoughCurrency,
		AccountAlreadyParticipating,
		CanNotAddParticipant,
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {

		#[pallet::call_index(0)]
		#[pallet::weight(0)]
		pub fn buy_ticket(origin: OriginFor<T>) -> DispatchResult {

			// 1. Validates the origin signature
			let buyer = ensure_signed(origin)?;

			// 2. Checks that the user has enough balance to afford the ticket price
			ensure!(
				T::Currency::free_balance(&buyer) >= T::TicketCost::get(),
				Error::<T>::NotEnoughCurrency
			);

			// 3. Checks that the user is not already participating
			if let Some(participants) = Self::get_participants() {
				ensure!(
					!participants.contains(&buyer),
					Error::<T>::AccountAlreadyParticipating
				);
			}

			// 4. Adds the user as a new participant for the prize
			match Self::get_participants() {
				Some(mut participants) => { 
					ensure!(
						participants.try_push(buyer.clone()).is_ok(), 
						Error::<T>::CanNotAddParticipant
					);
					Participants::<T>::set(Some(participants));
				}, 
				None => {
					let mut participants = BoundedVec::new();
					ensure!(
						participants.try_push(buyer.clone()).is_ok(), 
						Error::<T>::CanNotAddParticipant
					);
					Participants::<T>::set(Some(participants));
				}
			};

			// 5. Transfers the ticket cost to the module's account
			// to be hold until transferred to the winner
			T::Currency::transfer(
				&buyer, 
				&Self::get_pallet_account(), 
				T::TicketCost::get(), 
				ExistenceRequirement::KeepAlive)?;
			
			// 6. Notify the event
			Self::deposit_event(Event::TicketBought { who: buyer });
			Ok(())
		}

		#[pallet::call_index(1)]
		#[pallet::weight(0)]
		pub fn award_prize(origin: OriginFor<T>) -> DispatchResult {

			// 1. Validates the origin signature
			let _who = ensure_root(origin)?;

			match Self::get_participants() {
				Some(participants) => { 
					
					// 2. Gets a random number from the randomness module
					let nonce = Self::get_and_increment_nonce();
					let (random_seed, _) = T::MyRandomness::random(&nonce);
					let random_number = <u32>::decode(&mut random_seed.as_ref())
						.expect("secure hashes should always be bigger than u32; qed");
					
					// 3. Selects the winner from the participants lit
					let winner_index = random_number as usize % participants.len();
					let winner = participants.as_slice().get(winner_index).unwrap();

					// 4. Transfers the total prize to the winner's account
					let prize = T::Currency::free_balance(&Self::get_pallet_account());
					T::Currency::transfer(
						&Self::get_pallet_account(), 
						&winner, 
						prize, 
						ExistenceRequirement::AllowDeath)?;

					// 5. Resets the participants list, and gets ready for another lottery round
					Participants::<T>::kill();

					// 6. Notify the event
					Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );
				}, 
				None => {
					// Notify the event (No participants)
					Self::deposit_event(Event::ThereAreNoParticipants);
				}
			};

			Ok(())
		}
	}

	impl<T: Config> Pallet<T> {

		fn get_pallet_account() -> T::AccountId {
			T::PalletId::get().into_account_truncating()
		}

		fn get_and_increment_nonce() -> Vec<u8> {
			let nonce = Nonce::<T>::get();
			Nonce::<T>::put(nonce.wrapping_add(1));
			nonce.encode()
		}
	}
}
    ```
    
## Configurar o Runtime {: #configure-runtime }

Finalmente, com o mÃ³dulo finalizado, ele pode ser incluÃ­do no Runtime. Ao fazer isso, as transaÃ§Ãµes `buy_tickets` e `award_prize` serÃ£o chamÃ¡veis pelos usuÃ¡rios. Isso tambÃ©m significa que a [API Polkadot.js](pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/){target=\_blank} serÃ¡ decorada com este mÃ³dulo e todas as chamadas disponÃ­veis que ele contÃ©m.\n\nPara configurar o Runtime, abra o arquivo `lib.rs`, que contÃ©m a definiÃ§Ã£o para o Runtime do Template incluÃ­do e estÃ¡ localizado (no caso de usar o compatÃ­vel com EVM) na pasta:

```text
*/container-chains/templates/frontier/runtime/src/
```

Para adicionar o mÃ³dulo da loteria, configure os mÃ³dulos da seguinte forma:

```rust

// Adicione a configuraÃ§Ã£o para o mÃ³dulo de aleatoriedade. Nenhum parÃ¢metro necessÃ¡rio.
impl pallet_insecure_randomness_collective_flip::Config for Runtime {
}

// // ID de mÃ³dulo personalizado
 parameter_types! {
    pub const PalletId: PalletId = PalletId(*b"loex5678");
}

// Adicione a configuraÃ§Ã£o para o mÃ³dulo da loteria
impl pallet_lottery_example::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type Currency = Balances;
    type TicketCost = ConstU128<1000000000000000>;
    type PalletId = PalletId;
    type MaxParticipants = ConstU32<500>;
    type MyRandomness = RandomCollectiveFlip;
    }
```
Com os mÃ³dulos configurados, adicione a macro `construct_runtime!` (que define os mÃ³dulos que serÃ£o incluÃ­dos ao construir o Runtime) e os mÃ³dulos de aleatoriedade e loteria.
    
    
```rust
construct_runtime!(
    pub struct Runtime {
        ...
        // Inclua a lÃ³gica personalizada do pallet-template no Runtime.
        RandomCollectiveFlip: pallet_insecure_randomness_collective_flip,
        Lottery: pallet_lottery_example,
        ...
}
)
```

Com tudo definido, a rede agora tem suporte para uma implementaÃ§Ã£o bÃ¡sica de uma loteria.
    
<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/customize/adding-external-module/
--- BEGIN CONTENT ---
---
title: Adicionar MÃ³dulos Externos
description: Aprenda a resolver problemas de referÃªncia duplicada de dependÃªncias ao personalizar seu template de rede Powered by Tanssi com a ferramenta em Rust chamada Diener.
icon: octicons-plug-24
categories: Custom-Runtime
---

# Adicionar um MÃ³dulo Externo {: #adding-external-module }

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores construindo sobre os [Templates oferecidos pela Tanssi](/pt/builders/build/templates/){target=\_blank} podem querer adicionar alguns mÃ³dulos/dependÃªncias externos em seu Runtime para expandir certas funcionalidades.

O repositÃ³rio Tanssi e os Templates pegam todas as dependÃªncias de [um fork](https://github.com/moondance-labs/polkadot-sdk){target=\_blank} do repositÃ³rio oficial do Polkadot SDK. Este fork Ã© mantido pela equipe de engenharia da Tanssi, que geralmente contribui ativamente para o desenvolvimento da Substrate, corrigindo problemas e aprimorando funcionalidades, e, como resultado, o repositÃ³rio do fork frequentemente fica temporariamente Ã  frente do oficial.

Um problema de dupla referÃªncia pode surgir ao adicionar uma dependÃªncia externa, como uma pallet de terceiros. Isso acontece se um mÃ³dulo Tanssi faz referÃªncia a uma dependÃªncia do repositÃ³rio fork do Polkadot SDK, e a terceiros faz referÃªncia Ã  mesma dependÃªncia do repositÃ³rio oficial do Polkadot SDK. Para resolver esse problema, as referÃªncias Ã s dependÃªncias devem ser unificadas.

## Resolvendo Conflitos de DependÃªncias com Diener {: #solving-dependencies-conflicts-diener }

Para lidar de forma eficiente com as dependÃªncias e suas origens, vocÃª pode conferir a ferramenta [diener](https://github.com/paritytech/diener){target=\_blank}.

Se o arquivo executÃ¡vel `diener`, o [repositÃ³rio do Polkadot SDK](https://github.com/paritytech/polkadot-sdk){target=\_blank} clonado e seu fork Tanssi estiverem localizados na mesma pasta, entre na pasta do fork Tanssi e execute o seguinte comando:

```bash
../diener patch --crates-to-patch ../polkadot-sdk \
    --target https://github.com/paritytech/polkadot-sdk \
    --point-to-git https://github.com/moondance-labs/polkadot-sdk \
    --point-to-git-branch {{ repository.tanssi.release_branch }}
```

Este comando aplica as alteraÃ§Ãµes ao arquivo `Cargo.toml`, corrigindo as dependÃªncias e resolvendo os problemas de dupla referÃªncia.

VocÃª pode visitar a [documentaÃ§Ã£o do diener](https://docs.rs/crate/diener/latest){target=\_blank} para saber mais sobre a ferramenta e outras funÃ§Ãµes extras que ela oferece.

## Exemplo do Problema de Dupla ReferÃªncia {: #double-reference-issue }

Para ilustrar a situaÃ§Ã£o, as seguintes etapas adicionam um [mÃ³dulo externo](https://github.com/papermoonio/pallet-toggle){target=\_blank} de demonstraÃ§Ã£o a um Runtime personalizado com base no [Template de rede powered by Tanssi de linha de base](/pt/builders/build/templates/substrate/){target=\_blank}. Uma maneira de seguir este tutorial Ã© clonar o [repositÃ³rio Tanssi Github](https://github.com/moondance-labs/tanssi){target=\_blank}, que atuarÃ¡ como o repositÃ³rio raiz do projeto.

Este tutorial gerarÃ¡ um erro de tempo de compilaÃ§Ã£o de referÃªncia mÃºltipla. Finalmente, as etapas mostrarÃ£o como corrigir o erro de compilaÃ§Ã£o corrigindo as dependÃªncias com a ferramenta `diener`, o Runtime serÃ¡ compilado com sucesso e funcionarÃ¡ conforme o esperado.

### Adicionar uma DependÃªncia de Terceiros {: #add-third-party-dependency }

Semelhante ao que Ã© descrito no artigo [mÃ³dulo embutido](/pt/builders/build/customize/adding-built-in-module/#adding-a-built-in-module-to-runtime){target=\_blank}, a adiÃ§Ã£o de um mÃ³dulo de terceiros requer as seguintes etapas:

1. Declare a dependÃªncia no arquivo `Cargo.toml` raiz
2. Torne as caracterÃ­sticas padrÃ£o disponÃ­veis para o compilador
3. Configure e adicione o mÃ³dulo ao Runtime

Se o mÃ³dulo de terceiros fizer referÃªncia a alguma dependÃªncia jÃ¡ referenciada de uma fonte ou versÃ£o distinta, a compilaÃ§Ã£o falharÃ¡.

O diagrama a seguir mostra como duas referÃªncias diferentes para a mesma dependÃªncia estÃ£o sendo incluÃ­das no Runtime, fazendo com que a compilaÃ§Ã£o falhe:

![Dupla referÃªncia](/images/builders/build/external-module/external-module-1.webp)

Para resolver este problema, serÃ¡ necessÃ¡rio aplicar um patch para que as referÃªncias para a dependÃªncia sejam unificadas:

![ReferÃªncia corrigida](/images/builders/build/external-module/external-module-2.webp)

### Declarando a DependÃªncia {: #declaring-dependency }

A primeira etapa para reproduzir o problema de dupla referÃªncia Ã© declarar a dependÃªncia no arquivo `Cargo.toml` localizado na pasta raiz do repositÃ³rio, na seÃ§Ã£o `[dependencies]`. Para este exemplo, um simples [mÃ³dulo de alternÃ¢ncia](https://github.com/papermoonio/pallet-toggle){target=\_blank} Ã© usado.

Este mÃ³dulo `toggle`, construÃ­do para fins de teste e educacionais, adiciona lÃ³gica bÃ¡sica ao Runtime, permitindo que os usuÃ¡rios alternem um estado entre verdadeiro e falso.

```toml
[dependencies]
...
pallet-toggle = { 
    git = "https://github.com/papermoonio/pallet-toggle", 
    default-features = false 
}
...
```

### Tornando os Recursos PadrÃ£o DisponÃ­veis para o Compilador {: #add-standard-features }

Tendo declarado o mÃ³dulo no arquivo `Cargo.toml` do espaÃ§o de trabalho, a dependÃªncia pode agora ser adicionada ao arquivo `Cargo.toml` do Template especÃ­fico, que, para este exemplo que usa o repositÃ³rio Tanssi GitHub, estÃ¡ localizado na pasta `container-chains/templates/simple/runtime`.

```toml
[dependencies]
...
pallet-toggle = { workspace = true }
...
```

No mesmo arquivo `Cargo.toml`, adicione os seguintes recursos.

```toml
[features]
default = [
	"std",
]
std = [
	...,
	"pallet-toggle/std",
   ...
]
...
runtime-benchmarks = [
	...,
	"pallet-toggle/runtime-benchmarks",
]

try-runtime = [
	...,
	"pallet-toggle/try-runtime",
]
```

### Configurar e Adicionar o MÃ³dulo ao Runtime {: #configure-module-in-the-runtime }

Em seguida, adicione o seguinte snippet ao arquivo `lib.rs` dentro da pasta de Runtime. Isso configura o mÃ³dulo e adiciona o mÃ³dulo dentro da macro `construct_runtime!`.

```rust
...
impl pallet_toggle::Config for Runtime {
    type RuntimeEvent = RuntimeEvent;
    type WeightInfo = pallet_toggle::weights::SubstrateWeight<Runtime>;
}

construct_runtime!(
    pub enum Runtime
    {
        ...
        ...
        Toggle: pallet_toggle,
    }
);
```

### Compilar o Runtime {: #compile-runtime }

ApÃ³s concluir as etapas anteriores, o mÃ³dulo Ã© declarado uma dependÃªncia no projeto, configurado e adicionado ao Runtime.

Compile o Template usando o seguinte comando:

```bash
cargo build -p container-chain-simple-node --release
```

A saÃ­da do terminal exibirÃ¡ um erro, semelhante ao seguinte, causado por diferentes mÃ³dulos referenciando diferentes versÃµes da mesma dependÃªncia:

```bash
error: failed to select a version for `syn`.
```

### DependÃªncias de Patch {: #patch-dependencies }

Finalmente, a execuÃ§Ã£o do [comando](#solving-dependencies-conflicts-diener) `diener` adicionarÃ¡ uma seÃ§Ã£o `patch` ao seu arquivo `Cargo.toml` do espaÃ§o de trabalho, substituindo as dependÃªncias e unificando as origens e versÃµes.

Ã‰ assim que a execuÃ§Ã£o no terminal se parece:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>../diener patch --crates-to-patch ../polkadot-sdk \
    <br> --target https://github.com/paritytech/polkadot-sdk \
    <br> --point-to-git https://github.com/moondance-labs/polkadot-sdk \
    <br> --point-to-git-branch tanssi-polkadot-v1.3.0
    </span>
  <span data-ty>
    <br> [2024-01-10T23:26:27Z INFO diener] Running diener v0.4.7 
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bridge-runtime-common.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-header-chain'
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'bp-runtime'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'frame-support-procedural-tools-derive'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core-hashing'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-api-proc-macro' .
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-core'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-debug-derive'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-externalities'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-std'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-storage'.
    <br> [2024-01-10T23:26:42Z INFO diener::patch] Adding patch for 'sp-runtime-interface'.
  </span>
</div>

Como mostrado na saÃ­da do terminal, `diener` adiciona um patch para as dependÃªncias, criando uma seÃ§Ã£o `patch` em seu `toml` substituindo sua origem:

```toml
[patch."https://github.com/paritytech/polkadot-sdk"]
bridge-runtime-common = { git = "https://github.com/moondance-labs/polkadot-sdk" , branch = "tanssi-polkadot-v1.3.0" }
bp-header-chain = { git = "https://github.com/moondance-labs/polkadot-sdk" , branch = "tanssi-polkadot-v1.3.0" }
bp-runtime = { git = "https://github.com/moondance-labs/polkadot-sdk" , branch = "tanssi-polkadot-v1.3.0" }
...
```

Finalmente, a compilaÃ§Ã£o terÃ¡ sucesso e o mÃ³dulo serÃ¡ integrado ao seu Runtime.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/customize/customizing-chain-specs/
--- BEGIN CONTENT ---
---
title: Customizando as EspecificaÃ§Ãµes da Cadeia
description: Revise as seÃ§Ãµes e atributos de um arquivo de especificaÃ§Ã£o de cadeia e como obtÃª-lo para lanÃ§ar sua rede powered by Tanssi com uma especificaÃ§Ã£o personalizada.
icon: octicons-link-24
categories: Appchain
---

# Customizando as EspecificaÃ§Ãµes da Cadeia {: #customizing-chain-specifications }

## IntroduÃ§Ã£o {: #introduction }

A especificaÃ§Ã£o da cadeia refere-se a um conjunto de parÃ¢metros e configuraÃ§Ãµes que definem as caracterÃ­sticas e o comportamento de uma nova rede powered by Tanssi. Ela define as configuraÃ§Ãµes e o estado iniciais sobre os quais todos os nÃ³s participantes da rede devem concordar para alcanÃ§ar o consenso e produzir blocos. Muitas configuraÃ§Ãµes iniciais nÃ£o podem ser alteradas apÃ³s o lanÃ§amento da rede sem gerar uma cadeia completamente diferente.

A especificaÃ§Ã£o contÃ©m duas seÃ§Ãµes principais:

- **The client specification** - inclui os parÃ¢metros de rede, por exemplo, os nÃ³s de inicializaÃ§Ã£o com os quais o cliente se conecta ao ingressar na rede
- **The client specification** - representa o estado inicial em que todas as transaÃ§Ãµes e transiÃ§Ãµes de estado ocorrem. Inclui detalhes como as contas registradas iniciais e seus saldos, bem como a conta com privilÃ©gios de administrador (sudo, se aplicÃ¡vel), entre outras informaÃ§Ãµes relevantes

Essas informaÃ§Ãµes que a especificaÃ§Ã£o da cadeia contÃ©m podem ser armazenadas em um arquivo Rust (que pode ser encontrado nos [templates](/pt/builders/build/templates/overview/){target=\_blank} incluÃ­dos no repositÃ³rio Tanssi) ou em um arquivo JSON.

Este artigo aborda as seÃ§Ãµes e atributos dentro de um arquivo de especificaÃ§Ã£o de cadeia e explica como obtÃª-lo, caso vocÃª queira lanÃ§ar sua rede Tanssi carregando um arquivo de especificaÃ§Ãµes personalizadas.

!!! note "Nota do Editor (AtualizaÃ§Ã£o de 2025)"
    Este guia explica como personalizar os arquivos de especificaÃ§Ã£o da cadeia em redes baseadas em Substrate. Alguns campos (por exemplo, cadeia de retransmissÃ£o, ID da parachain) vÃªm do SDK do Substrate e sÃ£o incluÃ­dos para fins de compatibilidade ou Template.

    Esses atributos nÃ£o significam que uma rede powered by Tanssi Ã© uma parachain Polkadot. Tanssi Ã© um protocolo de infraestrutura de appchain independente, construÃ­do com Substrate e alinhado com a seguranÃ§a apoiada pelo Ethereum. VocÃª pode encontrar termos relacionados ao Polkadot em arquivos de configuraÃ§Ã£o por causa das origens compartilhadas do Substrate, mas as appchains powered by Tanssi nÃ£o exigem slots Polkadot ou mecÃ¢nica de cadeia de retransmissÃ£o.

## A EspecificaÃ§Ã£o do Cliente {: #client-specification }

A especificaÃ§Ã£o do cliente contÃ©m a configuraÃ§Ã£o da rede e outras configuraÃ§Ãµes (excluindo as relacionadas ao estado do Runtime):

- **Name** - nome para as especificaÃ§Ãµes
- **Id** - um ID simples exclusivo para a rede usado para definir o caminho de armazenamento no nÃ³
- **Fork ID** - parÃ¢metro opcional para um identificador de fork de rede
- **Chain type** - um parÃ¢metro que pode ser definido para definir o tipo de cadeia e exibir informaÃ§Ãµes adicionais ou habilitar recursos adicionais (pode ser definido como Desenvolvimento, Local, Live ou um tipo personalizado)
- **Boot Nodes** - conjunto de nÃ³s de inicializaÃ§Ã£o que serÃ£o usados â€‹â€‹quando o novo nÃ³ entrar na rede e sincronizar
- **Telemetry Endpoints** - uma lista opcional de endpoints para enviar informaÃ§Ãµes e monitorar a operaÃ§Ã£o da rede
- **Protocol ID** - um nome exclusivo que define o protocolo de rede
- **Relay Chain** - define a ID da cadeia de orquestraÃ§Ã£o com a qual a rede Tanssi interage
- **Parachain ID** - define uma ID exclusiva que identifica a rede Tanssi
- **Code Substitutes** - um recurso de emergÃªncia para substituir o Runtime quando uma rede Tanssi nÃ£o consegue executar uma atualizaÃ§Ã£o de Runtime
- **Properties** - propriedades chave-valor que podem ser personalizadas e sÃ£o Ãºteis para melhorar a experiÃªncia do usuÃ¡rio

No atributo `properties`, as seguintes configuraÃ§Ãµes sÃ£o usadas por vÃ¡rias bibliotecas front-end, incluindo a [API Polkadot.js](/pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/){target=\_blank}:

- **SÃ­mbolo do Token** - um nome para o sÃ­mbolo do token da sua prÃ³pria rede Tanssi
- **Formato SS58** - um inteiro que identifica exclusivamente as contas em sua rede. A [codificaÃ§Ã£o SS58](https://docs.polkadot.com/polkadot-protocol/parachain-basics/accounts/#address-formats){target=\_blank} transforma a conta subjacente de 32 bytes em uma representaÃ§Ã£o especÃ­fica da rede. Este atributo nÃ£o se aplica nem interfere nas contas Ethereum ECDSA em redes compatÃ­veis com EVM
- **Decimais do Token** - representam o quÃ£o divisÃ­vel um token pode ser e qual Ã© a menor representaÃ§Ã£o do token. Ele Ã© definido como `18` para redes compatÃ­veis com EVM
- **Ã‰ Ethereum** - um booleano que identifica a rede como compatÃ­vel com EVM ou nÃ£o

## O Estado da GÃªnese {: #genesis-state }

Todos os Sequencers atribuÃ­dos Ã  rede Tanssi devem concordar com o estado inicial para que possam executar as extrÃ­nsecas de entrada, chegar aos mesmos resultados e, finalmente, chegar a um consenso sobre o novo estado vÃ¡lido.

Este estado da gÃªnese definirÃ¡ o ponto de partida da rede Tanssi. Ele inclui um valor inicial para os elementos que os mÃ³dulos incluÃ­dos no Runtime precisam persistir e o cÃ³digo Wasm inicial do Runtime, que Ã© armazenado na cadeia.

Por exemplo, nos Templates incluÃ­dos, a especificaÃ§Ã£o da cadeia define as contas iniciais e os saldos de tokens no mÃ³dulo `Balances`. AlÃ©m disso, o template tambÃ©m tem uma conta sudo (que **deve ser modificado**) para o mÃ³dulo `Sudo`, que fornece privilÃ©gios exclusivos Ã  conta fornecida, e que pode ser removido assim que um mÃ³dulo de democracia na cadeia for conectado.

## Gerando um Arquivo de EspecificaÃ§Ã£o de Cadeia JSON {: #generating-json-chain-specs}

Os seguintes comandos construirÃ£o e gerarÃ£o a especificaÃ§Ã£o da cadeia para o Template compatÃ­vel com EVM com base na configuraÃ§Ã£o expressa em `chain_spec.rs`, localizado em `*/container-chains/templates/frontier/node/src/chain_spec.rs`. Este exemplo pode ser adaptado a qualquer outro Template ou Runtime personalizado.

Para construir e gerar as especificaÃ§Ãµes da cadeia, siga estas etapas:

1. Clone o cÃ³digo Tanssi hospedado no GitHub

    ```bash
    git clone https://github.com/moondance-labs/tanssi
    ```

2. Entre na pasta do projeto

    ```bash
    cd tanssi
    ```

3. Construa o Template da rede compatÃ­vel com EVM Tanssi

    ```bash
    cargo build -p container-chain-frontier-node --release
    ```

   Esta etapa Ã© bastante detalhada e pode levar um tempo para ser concluÃ­da. A captura de tela a seguir mostra o terminal apÃ³s concluir com sucesso o processo de construÃ§Ã£o (observe que o tempo de conclusÃ£o Ã© superior a 35 minutos):

   ![Criando o Template](/images/builders/build/customize/customizing-chain-specs/customizing-chain-specs-1.webp)

4. Gerar a especificaÃ§Ã£o da cadeia

    ```bash
    ./target/release/container-chain-frontier-node \
        build-spec > chain_spec.json
    ```

ApÃ³s executar a Ãºltima etapa, o terminal exibe apenas uma linha de log:

![Gerando a especificaÃ§Ã£o da cadeia](/images/builders/build/customize/customizing-chain-specs/customizing-chain-specs-2.webp)

E agora o arquivo `chain_spec.json` contendo a especificaÃ§Ã£o do cliente e o estado da gÃªnese Ã© criado na pasta atual.

!!! note
    As especificaÃ§Ãµes da cadeia JSON podem ser geradas em duas versÃµes diferentes: a legÃ­vel por humanos, que Ã© a gerada seguindo as etapas anteriores, e a versÃ£o bruta, que Ã© a necessÃ¡ria para implantar a rede por meio da Tanssi. Mais sobre como gerar a versÃ£o bruta [posteriormente](#generating-raw-specs-file) neste artigo.

### Editando o Arquivo de EspecificaÃ§Ã£o da Cadeia JSON {: #editing-json-chain-specs }

O arquivo `chain_spec.json` gerado reflete os parÃ¢metros definidos no arquivo de especificaÃ§Ãµes da cadeia Rust. Sendo um arquivo JSON, Ã© fÃ¡cil de ler e, caso algum parÃ¢metro precise ser alterado, fÃ¡cil de editar.

Por exemplo, o seguinte trecho de cÃ³digo mostra alguns dos atributos das especificaÃ§Ãµes do cliente:

```json
{
    // Define o nome da especificaÃ§Ã£o desta rede
    "name": "Rede Frontier 1000",
    // Defina um ID para as especificaÃ§Ãµes desta rede
    "id": "frontier_network_1000",
    // A rede estarÃ¡ ativa
    "chainType": "Live",
    "bootNodes": [
        // nÃ³s de inicializaÃ§Ã£o serÃ£o adicionados automaticamente durante a implantaÃ§Ã£o
    ],
    // Atributo opcional, o padrÃ£o Ã© nulo
    "telemetryEndpoints": null,
    // Defina um identificador de protocolo para esta rede
    "protocolId": "network-chain-1000",
    // Defina propriedades para definir o token e a compatibilidade com ethereum
    "properties": {
        "isEthereum": true,
        "ss58Format": 42,
        "tokenDecimals": 18,
        "tokenSymbol": "UNIT"
    },
    // Defina a cadeia de retransmissÃ£o stagenet
    "relay_chain": "westend_moonbase_relay_stagenet",
    // Defina o ID da parachain reservado na cadeia de retransmissÃ£o
    "para_id": 3333,
    // Sem necessidade
    "codeSubstitutes": {},
    "genesis": { 
        ... 
    }
}
```

A outra seÃ§Ã£o importante do arquivo estÃ¡ dentro do atributo `genesis`, que contÃ©m o estado da gÃªnese. No seguinte trecho JSON, os valores e a configuraÃ§Ã£o padrÃ£o para alguns mÃ³dulos sÃ£o apresentados como exemplo:

```json
{
    ...
    "genesis": {
        "runtime": {
            ...
            // Define a conta que terÃ¡ privilÃ©gios sudo
            "sudo": {
                "key": "0xf24ff3a9cf04c71dbc94d0b566cac"
            },
            // Define os saldos iniciais para algumas contas
            "balances": {
                "balances": [
                [
                    "0x3cd0a705a2dc65e5b1e1205896baa2be8a07c6e0",
                    1208925819614629174706176
                ],
                [
                    "0x773539d4ac0e786233d90a233654ccee26a613d9",
                    1208925819614629174706176
                ],
                [
                    "0x798d4ba9baf0064ec19eb4f0a1a45785ae9d6dfc",
                    1208925819614629174706176
                ],
                [
                    "0xf24ff3a9cf04c71dbc94d0b566cac",
                    1208925819614629174706176
                ]
                ]
            },
            // Define os saldos para as contas EVM
            "evm": {
                "accounts": {
                "0x1000000000000000000000000000000000000001": {
                    "nonce": "0x1",
                    "balance": "0xd3c21bcecceda1000000",
                    "storage": {},
                    "code": [
                    0
                    ]
                },
                "0x6be02d1d3665660d22ff9624b7be0551ee1ac91b": {
                    "nonce": "0x0",
                    "balance": "0xffffffffffffffffffffffffffffffff",
                    "storage": {},
                    "code": []
                },
                "0xd43593c715fdd31c61141abd04a99fd6822c8558": {
                    "nonce": "0x0",
                    "balance": "0xffffffffffffffffffffffffffffffff",
                    "storage": {},
                    "code": []
                }
                }
            },
        }
    }
    ...
}
```

Um exemplo de um atributo nÃ£o editÃ¡vel manualmente Ã© o Runtime Wasm (na seÃ§Ã£o de estado da gÃªnese), que Ã© uma representaÃ§Ã£o hexadecimal de um blob binÃ¡rio gerado pelo compilador. Ainda assim, alÃ©m disso, a maioria das propriedades sÃ£o fÃ¡ceis de editar antes de iniciar a rede.

## Gerando um Arquivo de EspecificaÃ§Ã£o de Cadeia JSON Bruto {: #generating-raw-specs-file }

Uma etapa final antes de implantar a rede Tanssi Ã© converter o arquivo de especificaÃ§Ã£o JSON em um formato bruto, que Ã© uma versÃ£o compacta e menos legÃ­vel do mesmo arquivo, necessÃ¡ria para inicializar um nÃ³.

Depois de passar pelas [etapas para gerar o arquivo de especificaÃ§Ã£o da cadeia JSON](#generating-json-chain-specs) e editar seus valores, o seguinte comando converterÃ¡ o arquivo de especificaÃ§Ãµes da cadeia no formato bruto necessÃ¡rio:

```bash
./target/release/container-chain-frontier-node \
    build-spec --chain=chain_spec.json --raw > raw_chain_spec.json
```

Agora que este arquivo foi configurado e personalizado e estÃ¡ no formato JSON bruto correto, ele pode ser carregado para inicializar uma nova rede na Tanssi.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/customize/
--- BEGIN CONTENT ---
---
title: Personalize Sua Rede com Tanssi
description: Configure seu ambiente e comece a usar os templates para construir sua rede com Substrate, um framework de blockchain modular e poderoso, baseado em Rust.
icon: octicons-code-24
template: index-page.html
---

# Personalize Sua Rede com Tanssi

Adapte sua rede para atender aos requisitos exclusivos da sua aplicaÃ§Ã£o. Esta seÃ§Ã£o fornece orientaÃ§Ãµes sobre como modificar e estender a funcionalidade da sua rede, oferecendo instruÃ§Ãµes e as melhores prÃ¡ticas para ajudÃ¡-lo a alinhÃ¡-la com os objetivos do seu projeto.

## Processo para Personalizar Sua Rede

O diagrama abaixo fornece um resumo simplificado das etapas essenciais para comeÃ§ar a construir e personalizar sua rede com Tanssi.

```mermaid
flowchart LR
    A[Instale os prÃ©-requisitos de software] --> B[Crie e adicione mÃ³dulos]
    B --> C[Personalize e gere as especificaÃ§Ãµes da cadeia]
```

Para prosseguir, consulte a seÃ§Ã£o a seguir, onde vocÃª pode encontrar guias detalhados, passo a passo, para cada uma dessas etapas.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/customize/prerequisites/
--- BEGIN CONTENT ---
---
title: PrÃ©-requisitos para a ConstruÃ§Ã£o de uma Rede
description: Instale o conjunto bÃ¡sico de ferramentas e software para configurar um ambiente de desenvolvimento local e ser capaz de compilar, executar e testar sua appchain.
icon: octicons-checkbox-24
Categories: Custom-Runtime
---

# PrÃ©-requisitos para a ConstruÃ§Ã£o de uma Rede {: #prerequisites}

## IntroduÃ§Ã£o {: #introduction }

A implantaÃ§Ã£o de uma rede atravÃ©s da Tanssi Ã© um passo bastante simples, onde o Ãºnico requisito Ã© ter uma [especificaÃ§Ã£o de cadeia](https://docs.polkadot.com/develop/parachains/deployment/generate-chain-specs/){target=\_blank} vÃ¡lida para fazer upload.

Embora a Tanssi forneÃ§a especificaÃ§Ãµes de cadeia para os [Templates disponÃ­veis](/pt/learn/decentralized-networks/included-templates/), pode ser necessÃ¡rio gerar uma nova para corresponder a quaisquer alteraÃ§Ãµes que o caso de uso possa precisar ser implementado no Runtime.

As seÃ§Ãµes a seguir deste artigo cobrirÃ£o o software mÃ­nimo necessÃ¡rio e seu processo de instalaÃ§Ã£o para obter um ambiente de desenvolvimento adequado para compilar um nÃ³ Substrate e gerar a especificaÃ§Ã£o da cadeia.

## InstalaÃ§Ã£o do Rust {: #installing-rust }

[Rust](/pt/learn/framework/overview/#rust-programming-language){target=\_blank} Ã© uma linguagem de programaÃ§Ã£o moderna, portÃ¡til e de alto desempenho que Ã© a base da estrutura de desenvolvimento de blockchain Substrate.

Para compilar a rede Tanssi, o compilador rust, `rustc`, e o gerenciador de pacotes, `cargo`, devem ser instalados no sistema.

De acordo com as instruÃ§Ãµes na [documentaÃ§Ã£o oficial do Rust](https://rust-lang.org/tools/install/){target=\_blank}, para sistemas Linux ou macOS, execute o seguinte comando:

=== "Linux"

    ```bash
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    ```

=== "MacOS"

    ```bash
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    ```

Quando o processo de instalaÃ§Ã£o for concluÃ­do, executar o seguinte comando verifica se o compilador recÃ©m-instalado funciona corretamente, mostrando o nÃºmero da versÃ£o:
 
=== "Linux"

    ```bash
    rustc --version
    ```

=== "MacOS"

    ```bash
    rustc --version
    ```

HÃ¡ outros mÃ©todos para instalar o Rust, como usar um gerenciador de pacotes. Outras opÃ§Ãµes podem ser encontradas no [site oficial do Rust](https://forge.rust-lang.org/infra/other-installation-methods.html){target=\_blank}.

## InstalaÃ§Ã£o do Git {: #installing-git }

[Git](https://git-scm.com){target=\_blank} Ã© recomendado para clonar o [repositÃ³rio de cÃ³digo](https://github.com/moondance-labs/tanssi){target=\_blank} da Tanssi, onde os Templates de nÃ³ podem ser encontrados. O Git provavelmente Ã© fornecido na configuraÃ§Ã£o de instalaÃ§Ã£o padrÃ£o do sistema operacional ou incluÃ­do em outras ferramentas, como o Xcode no MacOS.

Se o Git nÃ£o estiver presente no sistema, o seguinte comando o instalarÃ¡ usando um gerenciador de pacotes:

=== "Linux"

    ```bash
    apt-get install git
    ```

=== "MacOS"

    ```bash
    brew install git
    ```     

Para verificar a instalaÃ§Ã£o correta do Git, executar o seguinte comando em um terminal deve exibir a versÃ£o do Git:

=== "Linux"

    ```bash
    git --version
    ```

=== "MacOS"

    ```bash
    git --version
    ```

## Construindo um Template Tanssi {: #building-tanssi-template  }

Para construir um nÃ³ Substrate, como os Templates incluÃ­dos no [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi){target=\_blank}, Ã© necessÃ¡rio instalar componentes de desenvolvimento adicionais no sistema:

=== "Linux"

    ```bash
    apt-get install -y build-essential protobuf-compiler clang libssl-dev pkg-config
    ```
    
=== "MacOS"

    ```bash
    brew install protobuf openssl
    ```

1. Clone the Tanssi code hosted on GitHub
```bash
git clone https://github.com/moondance-labs/tanssi
```

2. Entre na pasta do projeto
```bash
cd tanssi
```

3. Construa o Template de rede Tanssi
=== "Baseline EVM"

    ```bash
    cargo build -p container-chain-frontier-node --release
    ```

=== "Baseline Substrate"

    ```bash
    cargo build -p container-chain-simple-node --release
    ```

Ter um ambiente de desenvolvimento saudÃ¡vel serÃ¡ necessÃ¡rio para construir um Runtime personalizado e, finalmente, gerar o arquivo de especificaÃ§Ã£o da cadeia que serÃ¡ usado para implantar sua rede Tanssi.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/
--- BEGIN CONTENT ---
---
title: Construa Sua Rede
description: Instale o software para compilar sua rede powered by Tanssi, configure o estado genesis e as funÃ§Ãµes principais, teste localmente e prepare-se para a implantaÃ§Ã£o.
icon: material-widgets-outline
template: index-page.html
---

# Construa Sua Rede

LanÃ§ar sua rede powered by Tanssi oferece a flexibilidade de escolher entre Templates prÃ©-configurados ou soluÃ§Ãµes totalmente personalizadas. Estaja vocÃª buscando simplicidade ou controle refinado, a Tanssi fornece as ferramentas e orientaÃ§Ãµes para transformar sua visÃ£o em realidade. Esta seÃ§Ã£o cobre tudo, desde a seleÃ§Ã£o de um Template atÃ© a personalizaÃ§Ã£o de mÃ³dulos, testes e implantaÃ§Ã£o de sua rede.

## O Caminho para ImplantaÃ§Ã£o

A implantaÃ§Ã£o de uma rede com Tanssi pode ser direta ou altamente personalizÃ¡vel, dependendo de suas necessidades. O diagrama abaixo fornece uma clara divisÃ£o dessas opÃ§Ãµes para orientar sua decisÃ£o.

```mermaid
flowchart TD
    Start[Escolha um Template]
    Start --> Path1[O Template Ã© suficiente]
    Start --> Path2[O Template precisa de personalizaÃ§Ã£o]

    Path1 --> Deploy1[Implantar via Tanssi dApp]

    Path2 --> Fork[Fork o repositÃ³rio Tanssi]
    Fork --> Customize[Personalize sua rede]
    Customize --> Test[Executar testes]
    Test --> Deploy2[Implantar via Tanssi dApp]
```

Agora que vocÃª explorou os caminhos de implantaÃ§Ã£o, o prÃ³ximo passo Ã© [aprender mais sobre cada Template](/pt/builders/build/templates) para que vocÃª possa escolher aquele que melhor se adapta Ã s suas necessidades.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/templates/custom-runtime/
--- BEGIN CONTENT ---
---
title: Runtime Personalizado
description: Qualquer runtime personalizado pode ser adaptado para ser implantado pela Tanssi, desde que mÃ³dulos especÃ­ficos sejam implementados e as configuraÃ§Ãµes necessÃ¡rias sejam definidas.
icon: octicons-file-binary-24
categories: Custom-Runtime
---

# Runtime Personalizado

## IntroduÃ§Ã£o {: #introduction }

Para as equipes que trabalham em um projeto de framework Substrate existente, serÃ¡ necessÃ¡rio incluir alguns mÃ³dulos e configuraÃ§Ãµes obrigatÃ³rias no runtime. Isso garantirÃ¡ que o runtime existente possa se tornar um runtime de rede Tanssi sem problemas, alinhando-se com as [regras do protocolo](/pt/builders/build/templates/overview/#base-setup-supporting-tanssi){target=\_blank}.

A falha em fazÃª-lo pode levar Ã  interoperabilidade reduzida e exposiÃ§Ã£o desnecessÃ¡ria a vulnerabilidades.

## Requisitos MÃ­nimos

Runtimes Substrate jÃ¡ existentes precisam implementar pelo menos o [framework](#adding-cumulus-support) para se comunicar dentro do ecossistema Tanssi, juntamente com os [mÃ³dulos especÃ­ficos da Tanssi](#adding-tanssi-support).

No entanto, as equipes podem jÃ¡ ter implementado certos mÃ³dulos que podem colidir com algumas funcionalidades relacionadas Ã  Tanssi, por exemplo, produÃ§Ã£o de blocos, atribuiÃ§Ã£o de autoridade de bloco e consenso.

Os seguintes mÃ³dulos sÃ£o incluÃ­dos por padrÃ£o em muitos Templates populares e devem ser removidos junto com sua configuraÃ§Ã£o:

```rust
Authorship: pallet_authorship = 20,
CollatorSelection: pallet_collator_selection = 21,
Session: pallet_session = 22,
Aura: pallet_aura = 23,
AuraExt: cumulus_pallet_aura_ext = 24,
```

Em qualquer caso, certifique-se de verificar seu runtime e remover todos os mÃ³dulos que podem interferir na produÃ§Ã£o de blocos como um recurso de serviÃ§o antes de iniciar o processo de registro.

## Integrando Sua Cadeia Stand-Alone {: #adding-cumulus-support }

Se seu runtime existente estiver configurado como uma cadeia stand-alone, vocÃª precisarÃ¡ adicionar um mecanismo de consenso para integrar no ecossistema Tanssi. Verifique qualquer um dos Templates disponÃ­veis no [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi){target=\_blank} para uma configuraÃ§Ã£o de referÃªncia ou a [documentaÃ§Ã£o do framework](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/cumulus/index.html){target=\_blank}.

## Adicionando Suporte ao Protocolo Tanssi {: #adding-tanssi-support }
Para suportar o protocolo Tanssi, serÃ¡ necessÃ¡rio adicionar dois mÃ³dulos atravÃ©s das seguintes etapas:

1. Inclua as dependÃªncias no manifesto `Cargo.toml` (geralmente localizado na pasta raiz). Abra o arquivo `Cargo.toml` e adicione os mÃ³dulos na seÃ§Ã£o `dependencies`

    ```toml
    [dependencies]
    ...
    pallet-cc-authorities-noting = { 
        git = "https://github.com/moondance-labs/tanssi", 
        branch = "master", default-features = false 
    }
    pallet_authorities_noting = {
        git = "https://github.com/moondance-labs/moonkit",
        branch = "tanssi-polkadot-v0.9.43", default-features = false
    }
    ...
    ```

2. Configure os mÃ³dulos. Abra o arquivo `lib.rs` localizado na pasta `*/runtime/src` e adicione a configuraÃ§Ã£o para ambos os mÃ³dulos:

    ```rust
        impl pallet_author_inherent::Config for Runtime {
            type AuthorId = NimbusId;
            type AccountLookup = tp_consensus::NimbusLookUp;
            type CanAuthor = pallet_cc_authorities_noting::CanAuthor<Runtime>;
            type SlotBeacon = tp_consensus::AuraDigestSlotBeacon<Runtime>;
            type WeightInfo = 
                pallet_author_inherent::weights::SubstrateWeight<Runtime>;
        }

        impl pallet_cc_authorities_noting::Config for Runtime {
            type RuntimeEvent = RuntimeEvent;
            type SelfParaId = parachain_info::Pallet<Runtime>;
            type RelayChainStateProvider = 
                cumulus_pallet_parachain_system::RelaychainDataProvider<Self>;
            type AuthorityId = NimbusId;
            type WeightInfo = 
                pallet_cc_authorities_noting::weights::SubstrateWeight<Runtime>;
        }
    ```

    Observe que essa configuraÃ§Ã£o Ã© agnÃ³stica do caso de uso

3. Declare os mÃ³dulos como parte do runtime. No mesmo arquivo `lib.rs`, localizado na pasta `*/runtime/src`, adicione os mÃ³dulos Ã  construÃ§Ã£o do runtime:

    ```rust
            construct_runtime!(
            pub enum Runtime where
                Block = Block,
                NodeBlock = opaque::Block,
                UncheckedExtrinsic = UncheckedExtrinsic,
            {
                ...
                // Tanssi network
                AuthoritiesNoting: pallet_cc_authorities_noting = 50,
                AuthorInherent: pallet_author_inherent = 51,
                ...
            }
            );
    ```

4. Certifique-se de que seu cabeÃ§alho estÃ¡ configurado da seguinte forma:

    ```rust
    type Header = generic::Header<BlockNumber, BlakeTwo256>;
    /// An index to a block.
    pub type BlockNumber = u32; 
    ```

5. Adicione o executor do bloco, para permitir que os operators na rede Tanssi validem que os autores sÃ£o os Sequencers atribuÃ­dos pela Tanssi (e nÃ£o um ator mal-intencionado)

  ```rust
    cumulus_pallet_parachain_system::register_validate_block! {
        Runtime = Runtime,
        BlockExecutor = pallet_author_inherent::BlockExecutor::<Runtime, Executive>
        CheckInherents = CheckInherents,
    }
```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/templates/evm/
--- BEGIN CONTENT ---
---
title: Template EVM Base
description: O repositÃ³rio Tanssi inclui um Template EVM que fornece todas as configuraÃ§Ãµes necessÃ¡rias para lanÃ§ar uma rede totalmente compatÃ­vel com o Ethereum.
icon: material-ethereum
categories: EVM-Template
---

# Template EVM Base {: #baseline-evm-template }

## IntroduÃ§Ã£o {: #introduction }

O Template de rede EVM (Ethereum Virtual Machine) da Tanssi foi projetado para equipes que desenvolvem suas aplicaÃ§Ãµes em cima de contratos inteligentes EVM. Ele inclui todos os componentes essenciais necessÃ¡rios para uma rede totalmente compatÃ­vel com o Ethereum:

- **EVM** - adiciona uma camada de execuÃ§Ã£o da Ethereum Virtual Machine para aplicaÃ§Ãµes de contratos inteligentes baseados em EVM
- **Suporte Etherum JSON RPC** - as redes EVM da Tanssi sÃ£o totalmente compatÃ­veis com [Ethereum JSON RPC](https://ethereum.org/developers/docs/apis/json-rpc/){target=\_blank}. Consequentemente, todas as ferramentas baseadas em Ethereum como [MetaMask](https://metamask.io){target=\_blank}, [Ethers.js](https://docs.ethers.org/v6/){target=\_blank}, [Viem](https://viem.sh){target=\_blank}, [Hardhat](https://hardhat.org){target=\_blank}, [Foundry](https://getfoundry.sh/){target=\_blank} e muito mais, funcionam perfeitamente
- **Contas Unificadas** - permite que as redes EVM da Tanssi apresentem contas ECDSA no estilo Ethereum

## EVM Network Template {: #evm-network-template }

O Template jÃ¡ inclui a configuraÃ§Ã£o necessÃ¡ria para integraÃ§Ã£o perfeita com o protocolo Tanssi e o provedor de seguranÃ§a escolhido, por exemplo, [Symbiotic](https://symbiotic.fi/){target=\_blank} no Ethereum. Portanto, este Template nÃ£o requer alteraÃ§Ãµes adicionais no Runtime se o aplicativo for construÃ­do em cima do EVM.

Isso significa que este Template estÃ¡ pronto para ser implantado como estÃ¡ atravÃ©s da Tanssi, desbloqueando muitos recursos, como:

- Utilizar a [produÃ§Ã£o de blocos como serviÃ§o](/pt/learn/tanssi/network-services/block-production/){target=\_blank} da Tanssi
- Obter finalidade de transaÃ§Ã£o determinÃ­stica em segundos
- Escolher o provedor de seguranÃ§a que melhor se adapta Ã s suas necessidades. Por exemplo, aproveitar a seguranÃ§a de nÃ­vel Ethereum do [Symbiotic](https://symbiotic.fi/){target=\_blank}
- Construir dApps interagindo com sua rede atravÃ©s de uma [API](/pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/){target=\_blank}
- Conectar qualquer carteira Ethereum, como [Metamask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} e Ledger
- Usar bibliotecas Ethereum bem conhecidas como [Ethers.js](/pt/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}, [Web3.js](pt/builders/toolkit/ethereum-api/libraries/web3js/){target=\_blank}, [Web3.py](/pt/builders/toolkit/ethereum-api/libraries/web3py/){target=\_blank}, e mais
- Implantar contratos inteligentes EVM com ferramentas como [Remix](https://remix.ethereum.org){target=\_blank}, [Hardhat](https://hardhat.org){target=\_blank}, [Foundry](https://github.com/foundry-rs/foundry){target=\_blank}, e mais

## MÃ³dulos IncluÃ­dos {: #included-modules }

Alem dos mÃ³dulos e configuraÃ§Ãµes que tornam o Template de rede Tanssi EVM compatÃ­vel com o protocolo Tanssi, ele tambÃ©m inclui [muitos mÃ³dulos](/pt/builders/build/templates/overview/#included-modules){target=\_blank} para fornecer funcionalidades bÃ¡sicas.

Para atingir a compatibilidade total com o Ethereum, esses mÃ³dulos especÃ­ficos tambÃ©m estÃ£o incluÃ­dos:

- **[EVM](https://docs.rs/pallet-evm/latest/pallet_evm){target=\_blank}** - adiciona suporte para execuÃ§Ã£o de bytecode EVM nÃ£o modificado em uma rede powered by Tanssi. Ele usa o [SputnikVM](https://github.com/rust-ethereum/evm){target=\_blank} baseado em Rust como o mecanismo EVM subjacente
- **[Ethereum](https://docs.rs/pallet-ethereum/latest/pallet_ethereum){target=\_blank}** - funciona em conjunto com o mÃ³dulo EVM para fornecer emulaÃ§Ã£o completa para o processamento de blocos Ethereum. Entre muitas outras tarefas, Ã© responsÃ¡vel por criar blocos Ethereum emulados para componentes especÃ­ficos do Ethereum, como logs EVM

Ambos os mÃ³dulos fazem parte do projeto [Frontier](https://github.com/polkadot-evm/frontier){target=\_blank}, que Ã© a espinha dorsal das redes powered by Tanssi compatÃ­veis com Ethereum.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/templates/
--- BEGIN CONTENT ---
---
title: Templates para Desenvolvimento de Rede
description: Saiba mais sobre os templates bÃ¡sicos de rede que jÃ¡ vÃªm prontos para uso com a Tanssi e ajudam vocÃª a dar inÃ­cio ao desenvolvimento da sua rede.so
icon: octicons-copy-24
template: index-page.html
---

# Templates de Rede

Comece o desenvolvimento de sua rede com nossos Templates abrangentes. Projetados para implantaÃ§Ã£o rÃ¡pida, esses Templates fornecem uma base sÃ³lida para soluÃ§Ãµes EVM e nÃ£o-EVM, acelerando a sua jornada de produÃ§Ã£o.

## Escolha um Template

A Tanssi oferece dois Templates para dar inÃ­cio ao processo de desenvolvimento:

- **Template de rede Tanssi BÃ¡sico** - um Template que fornece a plataforma bÃ¡sica para comeÃ§ar a adicionar lÃ³gica personalizada
    <br>

    [:octicons-arrow-right-24: Saiba mais sobre o que este Template fornece](/pt/learn/decentralized-networks/included-templates#baseline-network-template)

    [:octicons-arrow-right-24: Comece a construir com este Template](/pt/builders/build/templates/substrate/)

- **Template de Rede EVM (MÃ¡quina Virtual Ethereum) Tanssi BÃ¡sico** - um Template que fornece compatibilidade total com o Ethereum
    <br>

    [:octicons-arrow-right-24: Saiba mais sobre o que este Template fornece](/pt/learn/decentralized-networks/included-templates/#baseline-evm-template)

    [:octicons-arrow-right-24: Comece a construir com este Template](/pt/builders/build/templates/evm/)

Para saber mais sobre os requisitos mÃ­nimos para que sua cadeia funcione na Tanssi e quais mÃ³dulos sÃ£o incluÃ­dos automaticamente, consulte a pÃ¡gina [VisÃ£o geral do Template](/pt/builders/build/templates/overview/).

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/templates/overview/
--- BEGIN CONTENT ---
---
title: Requisitos e Recursos de Templates
description: Explore the foundational setup and key features included in each Tanssi template, designed to streamline the building and deployment of Tanssi networks.
icon: octicons-home-24
categories: NoÃ§Ãµes bÃ¡sicas, Appchain
---

# VisÃ£o Geral dos Templates {: #templates-overview }

## IntroduÃ§Ã£o {: #introduction }

As redes implantadas atravÃ©s da Tanssi sÃ£o blockchains totalmente personalizÃ¡veis, beneficiando-se de um conjunto compartilhado de Sequencers e da seguranÃ§a de um provedor de sua escolha. Os Templates apresentados neste artigo implementam as funcionalidades e configuraÃ§Ãµes necessÃ¡rias para suportar o protocolo Tanssi, tornando o desenvolvimento mais fÃ¡cil.

## ConfiguraÃ§Ã£o Base para Suportar o Protocolo Tanssi {: #base-setup-supporting-tanssi }
As redes Tanssi devem implementar os seguintes mÃ³dulos para suportar o protocolo e se beneficiar com seguranÃ§a da produÃ§Ã£o de blocos da Tanssi como um serviÃ§o:

- **Author Noting** - registra o conjunto de Sequencers atribuÃ­dos Ã  rede pela Tanssi
- **Author Inherent** - permite que o Sequencer que estÃ¡ criando o bloco inclua sua identidade para ser validado e recompensado

Se vocÃª nÃ£o incluir esses mÃ³dulos no Runtime da rede Tanssi, nÃ£o haverÃ¡ um mÃ©todo para confirmar que os blocos estÃ£o sendo gerados por Sequencers confiÃ¡veis designados pelo orquestrador Tanssi. Isso poderia criar uma vulnerabilidade para que atores mal-intencionados explorem e comprometam a rede. Para obter mais informaÃ§Ãµes sobre a produÃ§Ã£o de blocos da Tanssi como um serviÃ§o, consulte o artigo [ServiÃ§os de ProduÃ§Ã£o de Blocos](/pt/learn/tanssi/network-services/block-production/){target=\_blank}.

AlÃ©m da produÃ§Ã£o de blocos, hÃ¡ outros aspectos essenciais para qualquer rede coberta nos Templates, como:

- **Consenso** - as redes tÃªm a funcionalidade necessÃ¡ria para permitir que os Sequencers produzam blocos, fofoquem e validem-nos e coordenem com o provedor de seguranÃ§a para serem notificados sobre a finalidade do bloco
- **Interoperabilidade de Redes** - lida com a ingestÃ£o e envio de mensagens descendentes e laterais de entrada, permitindo que uma rede Tanssi se comunique e interaja com as outras cadeias dentro do ecossistema
- **AtualizaÃ§Ãµes de Runtime** - uma atualizaÃ§Ã£o de Runtime em uma rede Tanssi deve ser informada aos operators do provedor de seguranÃ§a para permitir que eles verifiquem os blocos produzidos pelos Sequencers das redes Tanssi

## MÃ³dulos IncluÃ­dos {: #included-modules  }

AlÃ©m dos mÃ³dulos necessÃ¡rios para suportar a operaÃ§Ã£o de uma rede Tanssi, muitos outros mÃ³dulos fornecem comportamento funcional com o qual os usuÃ¡rios podem interagir.

Estes sÃ£o alguns dos mÃ³dulos funcionais que expÃµem um comportamento aos usuÃ¡rios que estÃ£o incluÃ­dos nos Templates e prontos para uso:

- **[Balances](https://paritytech.github.io/substrate/master/pallet_balances/index.html){target=\_blank}** - o mÃ³dulo Balances fornece funÃ§Ãµes para lidar com contas e saldos para a moeda nativa da rede Tanssi
- **[Utility](https://paritytech.github.io/polkadot-sdk/master/pallet_utility/index.html){target=\_blank}** - o mÃ³dulo Utility fornece funÃ§Ãµes para executar vÃ¡rias chamadas em um Ãºnico despacho. AlÃ©m dos lotes de transaÃ§Ãµes, este mÃ³dulo tambÃ©m permite a execuÃ§Ã£o de uma chamada de uma origem alternativa assinada
- **[Proxy](https://paritytech.github.io/polkadot-sdk/master/pallet_proxy/index.html){target=\_blank}** - o mÃ³dulo Proxy fornece funÃ§Ãµes para delegar a outras contas (proxies) a permissÃ£o para despachar chamadas de uma origem proxy
- **[Modo de ManutenÃ§Ã£o](https://github.com/moondance-labs/moonkit/blob/tanssi-polkadot-v1.3.0/pallets/maintenance-mode/src/lib.rs){target=\_blank}** - o mÃ³dulo Modo de ManutenÃ§Ã£o permite que a rede Tanssi seja definida para um modo em que nÃ£o executa transferÃªncias de saldo/ativos ou outras transaÃ§Ãµes. Isso pode ser Ãºtil ao atualizar o Runtime em uma emergÃªncia, ao executar grandes migraÃ§Ãµes de armazenamento ou quando uma vulnerabilidade de seguranÃ§a Ã© descoberta
- **[Tx Pause](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/tx-pause/src/lib.rs){target=\_blank}** - o mÃ³dulo Tx Pause permite que uma origem vÃ¡lida (normalmente Root) pause (e cancele a pausa) um mÃ³dulo inteiro ou uma Ãºnica transaÃ§Ã£o. Uma transaÃ§Ã£o em pausa (ou todas as transaÃ§Ãµes incluÃ­das em um mÃ³dulo em pausa) falharÃ¡ quando chamada atÃ© que seja despausada. Este mÃ³dulo fornece um grau maior de granularidade em comparaÃ§Ã£o com o modo de manutenÃ§Ã£o, tornando-o particularmente Ãºtil quando uma transaÃ§Ã£o defeituosa ou vulnerÃ¡vel Ã© identificada no Runtime
- **[Multisig](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/multisig/src/lib.rs){target=\_blank}** - o mÃ³dulo Multisig permite despachos de transaÃ§Ãµes que exigem -tipicamente- mais de uma assinatura. Uma transaÃ§Ã£o multisig define um conjunto de contas autorizadas e um limite para sua aprovaÃ§Ã£o, exigindo consenso entre vÃ¡rias partes

## Comece a Construir {: #getting-started  }

Para comeÃ§ar a construir sobre os Templates fornecidos, seja o [Template de rede Tanssi base](/pt/builders/build/templates/substrate/){target=\_blank} ou o [Template EVM (Ethereum Virtual Machine) base](/pt/builders/build/templates/evm/){target=\_blank}, a abordagem recomendada Ã© bifurcar o [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi){target=\_blank} e comeÃ§ar a adicionar [mÃ³dulos integrados](/pt/builders/build/customize/adding-built-in-module/){target=\_blank} ou [mÃ³dulos personalizados](/pt/builders/build/customize/adding-custom-made-module/){target=\_blank} sobre a tag [versÃ£o mais recente](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank}.

Esta abordagem tem algumas vantagens, como:

- Construir sobre a versÃ£o mais recente e estÃ¡vel
- Obter o protocolo Tanssi jÃ¡ configurado e incluÃ­do no Runtime do Template
- Mantenha sua bifurcaÃ§Ã£o atualizada sincronizando com o repositÃ³rio upstream da Tanssi
- Execute os testes incluÃ­dos, garantindo que a produÃ§Ã£o de blocos em sua rede Tanssi funcione conforme o esperado
- Execute um ambiente local completo com a configuraÃ§Ã£o [Zombienet](https://paritytech.github.io/zombienet){target=\_blank} incluÃ­da

Se os Templates jÃ¡ cobrem as necessidades do seu caso de uso ou apÃ³s construir e testar sua cadeia, vocÃª pode continuar com o artigo [Implantar sua rede via o Tanssi DApp](/pt/builders/deploy/dapp/){target=\_blank} para saber como usar o Tanssi dApp para registrar e colocar sua cadeia em funcionamento.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/build/templates/substrate/
--- BEGIN CONTENT ---
---
title: Template de Rede de Base
description: O repositÃ³rio Tanssi inclui um Template bÃ¡sico que fornece a configuraÃ§Ã£o necessÃ¡ria para suportar o protocolo e iniciar o desenvolvimento de uma rede.
icon: simple-paritysubstrate
categories: Substrate-Template
---

# Template de Rede de Base {: #baseline-network-template }

## IntroduÃ§Ã£o {: #introduction }

O repositÃ³rio Tanssi inclui um Template mÃ­nimo que fornece a configuraÃ§Ã£o necessÃ¡ria para suportar o protocolo Tanssi e alguns mÃ³dulos essenciais, como o que permite lidar com a moeda da rede Tanssi.

Esta seÃ§Ã£o aborda este Template bÃ¡sico, o que ele inclui e alguns aspectos a serem considerados ao adicionar dependÃªncias externas.

## Template de Rede de Base {:#baseline-network-template }

Desenvolver um Runtime de rede normalmente envolve duas etapas principais:

1. [Incorporar mÃ³dulos internos prÃ©-existentes](/pt/builders/build/customize/adding-built-in-module/){target=\_blank} no Runtime
2. [Criar mÃ³dulos personalizados](/pt/builders/build/customize/adding-custom-made-module/){target=\_blank} adaptados Ã s necessidades especÃ­ficas do seu aplicativo

Como o Template fornecido jÃ¡ inclui as configuraÃ§Ãµes essenciais para uma integraÃ§Ã£o perfeita com o protocolo Tanssi e o provedor de seguranÃ§a (por exemplo, [Symbiotic](https://symbiotic.fi/){target=\_blank} no Ethereum), as equipes interessadas em construir uma rede inovadora powered by Tanssi podem usar este Template como ponto de partida para adicionar sua lÃ³gica personalizada.

Aqui estÃ£o alguns dos recursos que vÃªm com este Template:

- Utilize da Tanssi [produÃ§Ã£o de blocos como serviÃ§o](/pt/learn/tanssi/network-services/block-production/){target=\_blank}
- Escolha o provedor de seguranÃ§a que melhor se adapta Ã s suas necessidades. Por exemplo, aproveite a seguranÃ§a de nÃ­vel Ethereum do [Symbiotic](https://symbiotic.fi/){target=\_blank}
- Obtenha a finalidade determinÃ­stica da transaÃ§Ã£o em segundos
- Crie dApps que interagem com sua rede por meio de uma [API](/pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/){target=\_blank}

Aproveitando esses recursos no Template, vocÃª pode iniciar o desenvolvimento da sua rede Tanssi e personalizÃ¡-la para atender aos seus requisitos e inovaÃ§Ãµes especÃ­ficos.

## Adicionando DependÃªncias Extras {: #adding-extra-dependencies}

O Template de rede Substrate inclui todos os mÃ³dulos e configuraÃ§Ãµes necessÃ¡rios que o tornam compatÃ­vel com o protocolo Tanssi e tambÃ©m [muitos outros mÃ³dulos](/pt/builders/build/templates/overview/#included-modules){target=\_blank} que fornecem funcionalidades bÃ¡sicas.

Este Template foi projetado para servir como base para construir, pois a maioria dos casos de uso requer capacidades expandidas, adicionando mÃ³dulos existentes ou personalizados. Para saber como adicionar novas funcionalidades ao seu Runtime, consulte a seÃ§Ã£o [personalizar Runtime](/pt/builders/build/customize/){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/deploy/dapp/
--- BEGIN CONTENT ---
---
title: Implemente sua appchain via o DApp
description: Aprenda como iniciar e implementar uma appchain na Tanssi usando o Tanssi dApp, uma soluÃ§Ã£o sem cÃ³digo para integrar e lanÃ§ar appchains descentralizadas em minutos.
icon: octicons-browser-24
categories: Appchain
---

# Implemente Sua Appchain AtravÃ©s da Tanssi DApp

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/W40oqavpZJ8' frameborder='0' allowfullscreen></iframe></div>
<style>.caption { font-family: Open Sans, sans-serif; font-size: 0.9em; color: rgba(170, 170, 170, 1); font-style: italic; letter-spacing: 0px; position: relative;}</style>

## IntroduÃ§Ã£o {: #introduction }

A Tanssi tem como objetivo reduzir a barreira de entrada para a construÃ§Ã£o de appchains descentralizadas, simplificando o processo de integraÃ§Ã£o e abstraindo os detalhes tÃ©cnicos do lanÃ§amento de uma appchain powered by Tanssi. O [Tanssi dApp](https://apps.tanssi.network){target=\_blank} permite que vocÃª inicie uma appchain em apenas alguns minutos. Este guia mostra as etapas necessÃ¡rias para lanÃ§ar uma appchain na Dancelight, a Tanssi TestNet, usando o Tanssi dApp.

## Testes RÃ¡pidos vs. Appchains Dedicadas {: #quick-trial-vs-dedicated-appchains  }

[O Tanssi dApp](https://apps.tanssi.network){target=\_blank} suporta a criaÃ§Ã£o de dois tipos de appchains:

- Teste rÃ¡pido: uma appchain temporÃ¡ria que se autodestrÃ³i apÃ³s 48 horas
- Dedicada: uma appchain de longa duraÃ§Ã£o para builders do ecossistema Tanssi

Ambos os tipos se comportam de forma idÃªntica; a diferenÃ§a Ã© a natureza temporÃ¡ria do teste rÃ¡pido. Em geral, o teste rÃ¡pido Ã© o melhor para quem quer experimentar uma appchain powered by Tanssi. Se precisar de um ambiente de teste de longa duraÃ§Ã£o, a equipe Tanssi pode ajudar a configurar uma appchain dedicada.

As capturas de tela e o conteÃºdo deste guia usam appchains de teste rÃ¡pido, mas o processo Ã© o mesmo para configurar uma appchain dedicada.

![Painel inicial do apps.tanssi.network](/images/builders/deploy/dapp/dapp-1.webp)

## PrÃ©-requisitos {: #prerequisites }

### Carteiras suportadas {: #supported-wallets }

Como a Tanssi Ã© construÃ­da com Substrate, vocÃª precisarÃ¡ de uma carteira compatÃ­vel com Substrate para implantar e gerenciar sua appchain Tanssi. Carteiras suportadas:

- [Talisman](https://talisman.xyz/){target=\_blank}
- [SubWallet](https://www.subwallet.app){target=\_blank}
- [Enkrypt](https://www.enkrypt.com){target=\_blank}
- [ExtensÃ£o Polkadot.js](https://polkadot.js.org/extension){target=\_blank}

Se vocÃª implantar uma appchain EVM powered by Tanssi, os usuÃ¡rios poderÃ£o usar carteiras Ethereum, como [MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}, sem precisar de carteira Substrate.

![Tela de conexÃ£o para vÃ¡rias carteiras Substrate](/images/builders/deploy/dapp/dapp-2.webp)

### Conecte Sua Carteira ao DApp {: #connect-wallet  }

Para conectar sua carteira Ã  Tanssi dApp, clique em **Connect Wallet** no canto superior direito e escolha o tipo de carteira. Depois:

1. Escolha sua conta no menu suspenso
2. Assine a mensagem solicitada para fazer login na Tanssi dApp

![BotÃ£o Connect Wallet na Tanssi dApp](/images/builders/deploy/dapp/dapp-3.webp)

ApÃ³s conectar, seu endereÃ§o aparecerÃ¡ no canto superior direito. Se tiver vÃ¡rias contas conectadas, clique no endereÃ§o para trocar.

## Configure Sua Appchain {: #configure-your-appchain }

Na [pÃ¡gina inicial](https://apps.tanssi.network/){target=\_blank} do dApp, clique em **Start Building** no bloco **Launch Network** para configurar sua appchain imediatamente. Escolha entre **Quick Trial** ou **Dedicated**. Veja as diferenÃ§as em [Testes rÃ¡pidos vs. appchains dedicadas](#quick-trial-vs-dedicated-appchains).

![SeÃ§Ã£o Launch Network do dApp](/images/builders/deploy/dapp/dapp-1.webp)

Em seguida, selecione o template que melhor atende ao seu caso de uso e configure as propriedades da appchain. VocÃª pode escolher o template EVM ou Substrate ou enviar um arquivo de especificaÃ§Ã£o bruta. Consulte [Templates](/pt/builders/build/templates/overview/){target=\_blank} para detalhes.

### Template EVM {: #evm-template }

O [template EVM](/pt/builders/build/templates/evm/){target=\_blank} adiciona a camada de compatibilidade Ethereum Ã  sua appchain Tanssi.

VocÃª precisarÃ¡ de um ID de cadeia EVM exclusivo ([EIP-155](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md){target=\_blank}). Verifique se o ID estÃ¡ livre em [Chainlist](https://chainid.network){target=\_blank}. Ao lanÃ§ar em produÃ§Ã£o, abra um PR para reservar o ID no repositÃ³rio [`ethereum-lists/chains`](https://github.com/ethereum-lists/chains){target=\_blank} assim que o endpoint RPC estiver ativo.

!!! note
    Um ID de cadeia EVM registrado Ã© necessÃ¡rio apenas na MainNet. Para testes na TestNet, use qualquer ID disponÃ­vel.

Para configurar:

1. Em **Network Details**, informe o nome do projeto, o ID de cadeia EVM e a categoria
2. Em **Gas Token**, informe o sÃ­mbolo do token nativo (18 casas decimais fixas)
3. Opcional: ajuste configuraÃ§Ãµes [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} em **Advanced** (base fee e variaÃ§Ã£o mÃ¡xima)
4. Em **Accounts**, forneÃ§a o endereÃ§o (estilo Ethereum) da conta sudo e o saldo inicial. SÃ³ existe uma conta sudo por vez; ela pode ser trocada depois e a rede pode migrar para um Template descentralizado
5. Opcional: em **Advanced**, clique em **Add** para adicionar contas e saldos de gÃªnese
6. Opcional: em **Genesis Smart Contracts**, clique em **Add** para incluir contratos gÃªnese (remova `0x` do bytecode)
7. Ao finalizar o template, clique em **Continue** e siga para [Checar saldos](#check-balances)

![Criar appchain EVM na Tanssi dApp](/images/builders/deploy/dapp/dapp-4.webp)

### Template Substrate {: #substrate-template }

O [template Substrate](/pt/builders/build/templates/overview/#baseline-network-template){target=\_blank} traz as configuraÃ§Ãµes bÃ¡sicas para integrar com a Tanssi e pode servir como base para uma appchain personalizada.

Para configurar:

1. Em **Network Details**, informe o nome do projeto e a categoria
2. Em **Gas Token**, informe decimais, sÃ­mbolo e [formato SS58](https://github.com/paritytech/ss58-registry/blob/main/ss58-registry.json){target=\_blank}
3. Em **Accounts**, informe o endereÃ§o (estilo Substrate) da conta sudo e o saldo inicial. SÃ³ existe uma conta sudo por vez; pode ser trocada depois e a rede pode migrar para governanÃ§a descentralizada
4. Opcional: em **Advanced**, clique em **Add** para adicionar contas e saldos de gÃªnese
5. Clique em **Continue** para seguir para [Checar saldos](#check-balances)

![Criar appchain Substrate na Tanssi dApp](/images/builders/deploy/dapp/dapp-5.webp)

### Personalizado {: #custom }

Se vocÃª jÃ¡ possui um runtime Substrate e vai enviar um arquivo de especificaÃ§Ã£o personalizado, garanta que ele possa evoluir para uma appchain Tanssi.

Seu runtime deve implementar o seguinte:

- Inclua o SDK Cumulus conforme [Base Setup to Connect to Polkadot](/pt/builders/build/templates/overview/#base-setup-to-polkadot){target=\_blank}
- Inclua os mÃ³dulos Tanssi de produÃ§Ã£o de blocos conforme [Base Setup to Support the Tanssi Protocol](/pt/builders/build/templates/overview/#base-setup-supporting-tanssi){target=\_blank}

Outras exigÃªncias no runtime:

- No mÃ³dulo `timestamp`, defina `OnTimestampSet` conforme o snippet:

    ```rust
    type OnTimestampSet = tp_consensus::OnTimestampSet<
        <Self as pallet_author_inherent::Config>::SlotBeacon,
        ConstU64<{ SLOT_DURATION }>,
    >;
    ```

- Remova mÃ³dulos de produÃ§Ã£o de blocos/consenso (Aura, Grandpa etc.), deixando a Tanssi assumir. Por exemplo, removendo:

    ```rust
    // Suporte a collators. A ordem destes 4 Ã© importante e nÃ£o deve mudar.
    #[runtime::pallet_index(20)]
    pub type Authorship = pallet_authorship;
    #[runtime::pallet_index(21)]
    pub type CollatorSelection = pallet_collator_selection;
    #[runtime::pallet_index(22)]
    pub type Session = pallet_session;
    #[runtime::pallet_index(23)]
    pub type Aura = pallet_aura;
    #[runtime::pallet_index(24)]
    pub type AuraExt = cumulus_pallet_aura_ext;
    ```

Por fim, [gere e edite](/pt/builders/build/customize/customizing-chain-specs/#editing-json-chain-specs){target=\_blank} a especificaÃ§Ã£o da cadeia, prestando atenÃ§Ã£o especial a:

- `para_id`: vocÃª precisa de um ID prÃ©-registrado; obtenha-o no passo **Reserve your Network ID** e retorne para prosseguir
- `is_ethereum`: defina como `true` se precisar expor RPCs compatÃ­veis com Ethereum

Ajuste tambÃ©m conforme o tipo de appchain:

=== "Quick Trial Appchain"

    ```json
    {
        ...
        "relay_chain": "rococo_flashbox_relay_testnet",
        "chainType": "Live",
        "genesis": {
            "runtime": {
                ...
                "authoritiesNoting": {
                    "orchestratorParaId": 1000
                },
                ...
            }
        }
        ...
    }
    ```

=== "Dedicated Appchain"

    ```json
    {
        ...
        "relay_chain": "rococo-local",
        "chainType": "Live",
        "genesis": {
            "runtime": {
                ...
                "authoritiesNoting": {
                    "orchestratorParaId": 0
                },
                ...
            }
        }
        ...
    }
    ```

Depois, selecione o template **Custom** e envie o arquivo JSON de especificaÃ§Ã£o bruta.

![Enviar especificaÃ§Ã£o customizada na Tanssi dApp](/images/builders/deploy/dapp/dapp-6.webp)

!!! note
    O arquivo de especificaÃ§Ã£o bruta nÃ£o deve exceder 2 MB.

## Checar Saldos {:  #check-balances}

Verifique se vocÃª tem saldo suficiente. Caso nÃ£o tenha, clique em **Request Tokens** e faÃ§a login com GitHub ou Google, responda Ã s perguntas rÃ¡pidas e solicite os tokens para a carteira conectada.

![Solicitar tokens](/images/builders/deploy/dapp/dapp-7.webp)

Para appchains dedicadas, preencha o [formulÃ¡rio de inscriÃ§Ã£o](https://www.tanssi.network/dedicated-chain-testnet-form){target=\_blank}; a equipe enviarÃ¡ os tokens em atÃ© um dia Ãºtil.

Saldos mÃ­nimos para lanÃ§ar:

=== "Quick Trial Appchain"
    |        Chain        | Balance Required |
    |:-------------------:|:----------------:|
    | Orchestration layer |     70 UNIT      |
    |   Tanssi TestNet    |     100 SNAP     |

=== "Dedicated Appchain"
    |       Chain        | Balance Required |
    |:------------------:|:----------------:|
    |   Tanssi TestNet   |     100 STAR     |

!!! note
    Appchains de teste rÃ¡pido usam uma camada adicional de orquestraÃ§Ã£o e, portanto, requerem SNAP e UNIT. Para appchains dedicadas, apenas STAR Ã© necessÃ¡rio.

## Reserve Seu ID de Appchain {: #reserve-appchain-id }

Se ainda nÃ£o fez isso, vocÃª precisa reservar o seu ID de appchain Tanssi, que identificarÃ¡ sua cadeia dentro do ecossistema Tanssi.

Para reservar o seu ID de appchain Tanssi, serÃ¡ necessÃ¡rio enviar uma transaÃ§Ã£o. Certifique-se de usar a conta com a qual pretende lanÃ§ar sua appchain Tanssi ao enviar a transaÃ§Ã£o.

1. Clique em **Reserve Network ID**
2. Assine a transaÃ§Ã£o na sua carteira

![Reservar ID da appchain na Tanssi dApp](/images/builders/deploy/dapp/dapp-8.webp)

ApÃ³s a transaÃ§Ã£o, o ID aparecerÃ¡ no dApp; clique em **Continue**. Parte dos tokens UNIT (ou STAR, para appchain dedicada) ficarÃ¡ reservada.

![ID reservado com sucesso](/images/builders/deploy/dapp/dapp-9.webp)

## Gere Seus Arquivos de Appchain {: #generate-appchain-files  }

Antes de implantar, gere trÃªs arquivos:

- [A especificaÃ§Ã£o da cadeia bruta](/pt/builders/build/customize/customizing-chain-specs/#generating-raw-specs-file){target=\_blank} - uma versÃ£o compacta do arquivo de especificaÃ§Ã£o JSON, que define as configuraÃ§Ãµes iniciais e o estado que todos os nÃ³s participantes da rede devem concordar para alcanÃ§ar consenso e produzir blocos
- [O cabeÃ§alho do estado gÃªnese](/pt/builders/build/customize/customizing-chain-specs/#genesis-state){target=\_blank} - define o estado inicial sobre o qual todas as transaÃ§Ãµes e transiÃ§Ãµes de estado sÃ£o executadas
- [O GÃªnesis Wasm](/pt/learn/framework/architecture/#runtime){target=\_blank} - um objeto WebAssembly (Wasm) que define a lÃ³gica de Runtime.
Eles sÃ£o gerados automaticamente com base no seu ID e configuraÃ§Ãµes. Clique em **Generate**.

![Gerar arquivos da appchain](/images/builders/deploy/dapp/dapp-10.webp)

Quando prontos, clique em **Continue** para o passo final.

## FaÃ§a o Deploy da Sua Appchain {: #deploy-your-appchain}

No caso de teste rÃ¡pido, sÃ£o duas transaÃ§Ãµes: registrar na camada de orquestraÃ§Ã£o e na Tanssi TestNet.

Para registrar na camada de orquestraÃ§Ã£o:

1. Clique em **Register** em **Register Network in Relay**
2. Confirme a transaÃ§Ã£o na carteira

![Registrar na camada de orquestraÃ§Ã£o](/images/builders/deploy/dapp/dapp-11.webp)

Quando a transaÃ§Ã£o for concluÃ­da com sucesso, o dApp serÃ¡ atualizado para mostrar que vocÃª registrou sua appchain Tanssi na seÃ§Ã£o Register Network in Relay.

Por fim, para registrar sua appchain na Tanssi, siga estas etapas:

1. Clique em **Register** em **Register Network in Tanssi**
2. Confirme a transaÃ§Ã£o

![Registrar na Tanssi](/images/builders/deploy/dapp/dapp-12.webp)

Quando a transaÃ§Ã£o for concluÃ­da, o dApp exibirÃ¡ o registro da appchain. No painel, vocÃª poderÃ¡ acompanhar o status, blocos, endpoints RPC/WS e outras informaÃ§Ãµes.

![Dashboard da appchain na Tanssi dApp](/images/builders/deploy/dapp/dapp-13.webp)

E pronto! VocÃª registrou sua appchain Tanssi. O processo de lanÃ§amento iniciarÃ¡ automaticamente apÃ³s a verificaÃ§Ã£o da equipe Tanssi. Depois de ativa, volte ao **Dashboard** para ver o RPC e demais dados da rede.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/deploy/
--- BEGIN CONTENT ---
---
title: Implante Sua Appchain 
description: Aprenda como implantar sua appchain na Tanssi como um teste rÃ¡pido para testes de curto prazo ou como uma dedicada para testes de longo prazo usando o Tanssi dApp.
template: index-page.html
icon: octicons-rocket-24
---

# Implante Sua Appchain em Minutos

Com o Tanssi, lanÃ§ar sua appchain Ã© simples e eficiente. A plataforma simplifica o processo, para que vocÃª possa se concentrar na construÃ§Ã£o de seu aplicativo.

## VisÃ£o Geral RÃ¡pida da ImplantaÃ§Ã£o via Tanssi DApp

A implantaÃ§Ã£o de uma appchain powered by Tanssi via [Tanssi dApp](https://apps.tanssi.network){target=\_blank} Ã© realizada como um fluxo Ãºnico e simplificado, consistindo em cinco etapas distintas:

1. Selecione um [template](/pt/builders/build/templates/overview/){target=\_blank} e configure-o
2. Atender aos saldos mÃ­nimos exigidos de tokens
3. Reserve seu Tanssi appchain ID
4. Gere seus arquivos de appchain personalizados
5. Registre sua appchain na Tanssi

![Um diagrama mostrando as etapas para implantar uma appchain Tanssi com o Tanssi dApp.](/images/builders/deploy/deploy-1.webp)

!!! note
    Para implantaÃ§Ãµes de _appchains de Teste RÃ¡pido_ e _appchains Dedicadas_ na TestNet da Tanssi, a verificaÃ§Ã£o Ã© realizada manualmente pela equipe da Tanssi. ApÃ³s a aprovaÃ§Ã£o, uma appchain de teste rÃ¡pido fica pronta em cerca de 10 minutos, enquanto uma appchain dedicada leva aproximadamente 2 horas. Na MainNet da Tanssi, todo o processo serÃ¡ totalmente descentralizado e permissionless, garantindo autonomia e escalabilidade desde o primeiro diaâ€

Para comeÃ§ar, visite [Usando o Tanssi DApp](/pt/builders/deploy/dapp/).

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/
--- BEGIN CONTENT ---
---
title: Guias para o Desenvolvimento de Redes com Tanssi
description: Comece a construir a sua rede, configure o seu ambiente de desenvolvimento, teste e implemente o seu runtime e escolha as integraÃ§Ãµes que se adequam ao seu caso de uso.
template: root-index-page.html
---

# Builders

Explore tudo o que precisa para construir, implementar e gerir redes dentro do ecossistema Tanssi. De ferramentas de desenvolvimento Ã  gestÃ£o de contas e conectividade de rede, o conteÃºdo desta secÃ§Ã£o permite que avance com confianÃ§a do conceito Ã  implementaÃ§Ã£o.

## Construir uma Rede com Tanssi

<div class="grid cards" markdown>

- <h2 class="title">Por Onde ComeÃ§ar?</h2>
  [:octicons-arrow-right-24: Construir uma rede do zero usando um Template](/pt/builders/build/templates/)

    [:octicons-arrow-right-24: Configurar um runtime existente baseado em Substrate para ser compatÃ­vel com Tanssi](/pt/builders/build/templates/custom-runtime/)

- <h2 class="title">Personalizar a Sua Rede</h2>
  [:octicons-arrow-right-24: Utilizar mÃ³dulos prÃ©-existentes para adicionar funcionalidades](/pt/builders/build/customize/adding-built-in-module/)

    [:octicons-arrow-right-24: Criar o seu prÃ³prio mÃ³dulo personalizado](/pt/builders/build/customize/adding-custom-made-module/)

    [:octicons-arrow-right-24: Integrar mÃ³dulos externos de outros fornecedores](/pt/builders/build/customize/adding-external-module/)
</div>

## Implementar e Gerir uma Rede com Tanssi

<div class="grid cards" markdown>

- <h2 class="title">Pronto para Implementar?</h2>
  [:octicons-arrow-right-24: Implementar a sua rede com a Tanssi dApp](/pt/builders/deploy/dapp/)

- <h2 class="title">AÃ§Ãµes PÃ³s-ImplementaÃ§Ã£o</h2>
  [:octicons-arrow-right-24: Pagar pelos serviÃ§os de produÃ§Ã£o de blocos](/pt/builders/manage/dapp/services-payment/)

    [:octicons-arrow-right-24: Cunhar tokens para a economia da sua rede](/pt/builders/manage/dapp/manage-tokens/)

    [:octicons-arrow-right-24: Gerir a conta Sudo para controlo administrativo](/pt/builders/manage/developer-portal/sudo/)

</div>

## Interagir com uma Rede com Tanssi

<div class="grid cards" markdown>

- <h2 class="title">ReferÃªncias de Rede Tanssi</h2>
  [:octicons-arrow-right-24: Aceder aos endpoints da rede](/pt/builders/tanssi-network/endpoints/)

- <h2 class="title">Ferramentas para Desenvolvimento de Rede Tanssi</h2>
  [:octicons-arrow-right-24: Explorar ferramentas para integraÃ§Ã£o de API Ethereum](/pt/builders/toolkit/ethereum-api/)

    [:octicons-arrow-right-24: Utilizar ferramentas Substrate para controlo avanÃ§ado da rede](/pt/builders/toolkit/substrate-api/)

    [:octicons-arrow-right-24: Melhorar a funcionalidade da sua aplicaÃ§Ã£o com integraÃ§Ãµes](/builders/toolkit/integrations/)

</div>

## Explore Esta SecÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/interoperability/built-in-bridge/
--- BEGIN CONTENT ---
---
title: Usando a Bridge Tanssi Integrada
description: Saiba como usar a bridge Tanssi integrada que conecta Tanssi e Ethereum para converter tokens TANSSI entre sua forma nativa e ERC-20, e vice-versa.
icon: octicons-arrow-switch-24
categories: Basics
---

# Usando a Bridge Tanssi Integrada

## IntroduÃ§Ã£o {: #introduction }

O protocolo Tanssi orquestra componentes de infraestrutura, permitindo que os desenvolvedores lancem seus appchains personalizados em minutos e fornecendo a eles seguranÃ§a econÃ´mica de nÃ­vel Ethereum pronta para uso. Para facilitar todo o processo para os desenvolvedores, uma [arquitetura de primeira classe](/pt/learn/tanssi/overview/#tanssi-architecture){target=\_blank} foi projetada e implementada.

O [token TANSSI](/pt/builders/tanssi-network/tanssi-token/){target=\_blank} Ã© o motor que permite a integraÃ§Ã£o de diferentes componentes de infraestrutura com [provedores de seguranÃ§a externos](/pt/learn/tanssi/external-security-providers/symbiotic/){target=\_blank} e alinha incentivos entre vÃ¡rios atores, incluindo detentores de tokens, node operators e builders de appchain. Para atender a diferentes casos de uso, o token tem duas versÃµes: a moeda nativa da rede Tanssi, TANSSI (Substrate), e sua versÃ£o ERC-20, no Ethereum.

Os usuÃ¡rios podem converter de uma versÃ£o para outra do token usando uma [bridge sem confianÃ§a integrada da Tanssi](/pt/learn/tanssi/tanssi-ethereum-bridge/){target=\_blank}.

Neste guia, vocÃª aprenderÃ¡ como mover seus ativos de Tanssi para Ethereum e vice-versa por meio de uma interface web segura e fÃ¡cil de usar disponÃ­vel no [Tanssi dApp](https://apps.tanssi.network/bridge){target=\_blank}, tornando as transferÃªncias entre cadeias acessÃ­veis a todos.

## PrÃ©-requisitos {: #prerequisites }

Antes de usar a bridge Tanssi, certifique-se de ter:

Para fazer a bridge de Tanssi para Ethereum:

- Uma [carteira compatÃ­vel com Substrate](/pt/builders/toolkit/substrate-api/wallets/){target=\_blank}, como [Talisman](/pt/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank}.
- Saldo TANSSI (Substrate) para transferir e pagar as taxas de bridge.
- A conta de destino do tipo Ethereum.

Para fazer a bridge de Ethereum para Tanssi:

- Uma [carteira compatÃ­vel com Ethereum](/pt/builders/toolkit/ethereum-api/wallets/){target=\_blank}, como [MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.
- Saldo TANSSI (ERC-20) para transferir.
- Saldo ETH para pagar as taxas de bridge.
- A conta de destino do tipo Substrate.

## Fazendo a Bridge de Tokens TANSSI para Ethereum {: #bridge-to-ethereum}

Se vocÃª deseja converter seus tokens TANSSI (Substrate) para TANSSI (ERC-20) no Ethereum, acesse o Tanssi dApp, abra a [seÃ§Ã£o da bridge](https://apps.tanssi.network/bridge){target=\_blank} e siga estas etapas:

1. Selecione **Mainnet** no menu suspenso **From**.
2. Clique em **Connect Wallet**. Uma janela pop-up aparecerÃ¡, permitindo que vocÃª selecione sua carteira Substrate preferida e escolha a conta correspondente.

![Selecione a rede Tanssi e conecte a carteira](/images/builders/interoperability/built-in-bridge/built-in-bridge-1.webp)

Agora, com sua carteira conectada:

1. Selecione a conta de destino no menu suspenso **Select recipient address** ou escolha o item **Enter a custom address** e insira manualmente a conta para onde deseja receber os tokens ERC-20.
2. Insira o valor a ser transferido no campo **Balance**. As taxas estimadas de bridge e transaÃ§Ã£o serÃ£o exibidas junto com o valor que a conta de destino receberÃ¡.
3. Clique em **Send** e assine a transaÃ§Ã£o.

![Executar a TransaÃ§Ã£o](/images/builders/interoperability/built-in-bridge/built-in-bridge-2.webp)

E Ã© isso! Seus tokens serÃ£o transferidos quando a prÃ³xima sessÃ£o comeÃ§ar. VocÃª pode ver quanto tempo resta na sessÃ£o atual na barra de progresso.

!!! note
    - VocÃª pode adicionar facilmente o endereÃ§o do contrato TANSSI ERC-20 Ã  sua carteira clicando no Ã­cone **+** mostrado ao lado do seu saldo.
    - As taxas para converter seus tokens TANSSI (Substrate) para TANSSI (ERC-20) podem flutuar ao longo do tempo e devem ser pagas usando TANSSI.

## Fazendo a Bridge de ERC-20 TANSSI para a Rede Tanssi {: #bridge-to-tanssi }

Se vocÃª deseja converter seus tokens TANSSI (ERC-20) para TANSSI (Substrate) nativo na rede Tanssi, acesse o Tanssi dApp, abra a [seÃ§Ã£o da bridge](https://apps.tanssi.network/bridge){target=\_blank} e siga estas etapas:

1. Selecione **Ethereum** no menu suspenso **From**.
2. Clique em **Connect Wallet**, selecione sua carteira Ethereum preferida e escolha a conta.

![Selecione Ethereum e conecte a carteira](/images/builders/interoperability/built-in-bridge/built-in-bridge-3.webp)

Agora, com sua carteira conectada:

1. Insira a conta de destino Substrate no campo **Recipient**.
2. Insira o valor a ser transferido no campo **Balance**. As taxas estimadas de bridge e transaÃ§Ã£o serÃ£o exibidas junto com o valor que a conta de destino receberÃ¡.
3. Clique em **Send** e assine a transaÃ§Ã£o.

![Executar a TransaÃ§Ã£o](/images/builders/interoperability/built-in-bridge/built-in-bridge-4.webp)

E Ã© isso! Seus tokens serÃ£o transferidos quando a prÃ³xima sessÃ£o comeÃ§ar. VocÃª pode ver quanto tempo resta na sessÃ£o atual na barra de progresso.

!!! note
    As taxas para converter seus tokens TANSSI (ERC-20) para TANSSI (Substrate) nativo na rede Tanssi podem flutuar ao longo do tempo e devem ser pagas usando ETH.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/interoperability/
--- BEGIN CONTENT ---
---
title: Interoperabilidade
description: Explore as soluÃ§Ãµes cross-chain integradas disponÃ­veis no ecossistema Tanssi, permitindo transferÃªncias de ativos e comunicaÃ§Ã£o entre Tanssi e Ethereum.
icon: octicons-link-24
template: index-page.html
---

# Interoperabilidade

Explore as soluÃ§Ãµes cross-chain integradas disponÃ­veis no ecossistema Tanssi, permitindo transferÃªncias de ativos e comunicaÃ§Ã£o entre Tanssi e Ethereum.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/dapp/
--- BEGIN CONTENT ---
---
title: Usando o DApp Tanssi para Gerenciar Sua Rede
description: Aprenda a usar o DApp Tanssi para gerenciar sua rede, incluindo o pagamento por serviÃ§os de produÃ§Ã£o de blocos, gerenciamento de tokens, abertura de canais XCM e muito mais.
icon: octicons-browser-24
template: index-page.html
---

# Usando o DApp Tanssi para Gerenciar Sua Rede

O [Tanssi dApp](https://apps.tanssi.network){target=\_blank} Ã© a sua plataforma de referÃªncia para lidar com os aspectos operacionais da sua rede dentro do ecossistema Tanssi. Projetado para facilitar o uso, o dApp permite que os desenvolvedores agilizem tarefas diÃ¡rias como gerenciar tokens, pagar por serviÃ§os de produÃ§Ã£o de blocos e supervisionar as operaÃ§Ãµes essenciais da rede sem precisar de conhecimento tÃ©cnico profundo ou configuraÃ§Ãµes avanÃ§adas.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/dapp/manage-tokens/
--- BEGIN CONTENT ---
---
title: Gerenciar Tokens
description: Aprenda como o governador da rede pode gerenciar o token de uma rede Powered by Tanssi usando o dApp para cunhÃ¡-lo, configurar o mercado de taxas EIP-1559 e muito mais.
icon: octicons-database-24
categories: Appchain
---

# Gerenciar Tokens

## IntroduÃ§Ã£o {: #introduction }

Qualquer rede implantada atravÃ©s da Tanssi Ã© soberana e livre para definir o Template de governanÃ§a que melhor se adapta ao seu caso de uso. O governador da rede tem superpoderes sobre a administraÃ§Ã£o da cadeia. Consequentemente, eles podem chamar funÃ§Ãµes privilegiadas, como atualizar o Runtime e gerenciar operaÃ§Ãµes relacionadas a tokens nativos, entre outras aÃ§Ãµes.

Existem algumas aÃ§Ãµes relacionadas ao gerenciamento de tokens nativos que estÃ£o disponÃ­veis para o governador da rede na Tanssi dApp:

- **Mint tokens** - cunha novos tokens, aumentando a oferta total
- **Update balances** - aumenta ou diminui o saldo de uma conta, afetando a oferta total
- **Transfer tokens** - executa uma transferÃªncia forÃ§ada de tokens de uma conta para outra
- **Configure gas dynamic** - disponÃ­vel apenas em redes compatÃ­veis com EVM, esta aÃ§Ã£o altera a configuraÃ§Ã£o [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md){target=\_blank}, afetando o mecanismo de precificaÃ§Ã£o da transaÃ§Ã£o

Neste guia, vocÃª aprenderÃ¡ como executar as aÃ§Ãµes listadas anteriormente usando o [Tanssi dApp](https://apps.tanssi.network){target=\_blank}.

## Verificando PrÃ©-requisitos {: #checking-prerequisites  }

Para os exemplos neste guia, vocÃª precisarÃ¡ ter o seguinte:

- Uma rede powered by Tanssi (Teste RÃ¡pido ou Dedicado)
- A conta que vocÃª usou ao registrar a rede, importada em qualquer uma das [carteiras suportadas](/builders/deploy/dapp/#supported-wallets){target=\_blank}
- A conta Sudo da sua rede, tambÃ©m importada em qualquer uma das [carteiras suportadas](/builders/deploy/dapp/#supported-wallets){target=\_blank}

!!! note
    A conta de registro da rede Ã© sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compatÃ­vel com EVM, a conta Sudo serÃ¡ do tipo Ethereum; caso contrÃ¡rio, serÃ¡ do tipo Substrate.

### Recuperando a conta de registro {: #retrieving-registration-account }

Se vocÃª nÃ£o souber qual Ã© a sua conta de registro, pode consultÃ¡â€‘la diretamente na cadeia orquestradora do Tanssi, que mantÃ©m os registros de todas as redes cadastradas. Para isso, acesse a seÃ§Ã£o **Chain state** no Polkadot.js Apps conectado Ã  cadeia orquestradora para [redes de teste rÃ¡pidas](https://polkadot.js.org/apps/?rpc=wss://fraa-flashbox-rpc.a.stagenet.tanssi.network#/chainstate){target=\_blank} ou [redes dedicadas](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\_blank} e siga estes passos:

1. Selecione o mÃ³dulo de armazenamento **registrar**
2. Selecione **registrarDeposit**
3. Insira o ID da sua rede
4. Clique no Ã­cone **+**

A conta de registro aparecerÃ¡ na parte inferior.

![Localizando sua conta de registro](/images/builders/manage/dapp/locate-registration-account.webp)

!!! note
    O dApp exibirÃ¡ sua rede no painel somente se a conta de registro estiver configurada corretamente.

### Recuperando a conta Sudo {: #retrieving-sudo-account }

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## Acessando o Painel de Gerenciamento de Tokens {: #accesing-token-management-panel }

O Tanssi dApp implementa uma interface suave, permitindo que o governador da rede acesse e execute funÃ§Ãµes privilegiadas. Para fazer isso, vÃ¡ para o [Tanssi dApp](https://apps.tanssi.network/){target=\_blank} e, em seguida:

1. Clique no botÃ£o **Manage**
2. Clique no botÃ£o **Token Management**.

![Acessando o painel de gerenciamento de tokens](/images/builders/manage/dapp/token-management/token-management-1.webp)

Agora vocÃª tem acesso direto Ã s aÃ§Ãµes apresentadas na introduÃ§Ã£o:

1. **Mint Tokens**
2. **Update Balances**
3. **Transfer Tokens**
4. Configurar **Gas Dynamics**

![O painel de gerenciamento de tokens](/images/builders/manage/dapp/token-management/token-management-2.webp)

!!! note
    Se vocÃª nÃ£o vir os detalhes da sua rede no painel, certifique-se de cumprir os [prÃ©-requisitos](#checking-prerequisites).

### Minting Tokens {: #minting-tokens }

O governador da rede pode cunhar novos tokens, aumentando sua oferta total. Para fazer isso, no painel **Token Management**, clique no botÃ£o **Mint tokens** e, em seguida:

1. Insira o endereÃ§o que conterÃ¡ os tokens recÃ©m-cunhados

    !!! note
        O endereÃ§o de destino deve ser do tipo Ethereum se a cadeia for compatÃ­vel com EVM e do tipo Substrate caso contrÃ¡rio.

2. Insira a quantidade de tokens a serem cunhados
3. Clique em **Mint**

![Minting tokens](/images/builders/manage/dapp/token-management/token-management-3.webp)

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o com a conta do governador da rede. Depois que a transaÃ§Ã£o for concluÃ­da, o saldo da conta de destino terÃ¡ sido aumentado pela quantia desejada.

### Updating Balances {: #updating-balances }

O governador da rede pode aumentar ou diminuir o saldo de qualquer conta, afetando, assim, a oferta total. Para fazer isso, no painel **Token Management**, clique no botÃ£o **Update Balances** e, em seguida:

1. Insira o endereÃ§o que conterÃ¡ os tokens recÃ©m-cunhados. Depois de inserir o endereÃ§o, seu saldo atual serÃ¡ exibido

    !!! note
        O endereÃ§o de destino deve ser do tipo Ethereum se a cadeia for compatÃ­vel com EVM e do tipo Substrate caso contrÃ¡rio.

2. Insira o novo saldo que o endereÃ§o conterÃ¡
3. Clique em **Update**

![Updating Balance](/images/builders/manage/dapp/token-management/token-management-4.webp)

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o com a conta do governador da rede. Depois que a transaÃ§Ã£o for concluÃ­da, o saldo da conta de destino refletirÃ¡ exatamente a quantia desejada, independentemente das participaÃ§Ãµes anteriores.

### Executando TransferÃªncias ForÃ§adas {: #forced-transfers }

O governador da rede pode reatribuir saldos, forÃ§ando uma transferÃªncia de tokens de uma conta para outra. Para fazer isso, no painel **Token Management**, clique no botÃ£o **Transfer Tokens** e, em seguida:

1. Insira o endereÃ§o de origem que transferirÃ¡ seus tokens
2. Insira o endereÃ§o de destino que receberÃ¡ os tokens

    !!! note
        Os endereÃ§os de origem e destino devem ser do tipo Ethereum se a cadeia for compatÃ­vel com EVM e do tipo Substrate caso contrÃ¡rio.

3. Insira a quantidade de tokens a serem transferidos
4. Clique em **Transfer**

![Transferir tokens](/images/builders/manage/dapp/token-management/token-management-5.webp)

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o com a conta do governador da rede. Depois que a transaÃ§Ã£o for concluÃ­da, a conta de destino terÃ¡ recebido o nÃºmero de tokens do endereÃ§o de origem.

### Definindo a Gas Dynamics{: #setting-gas }

!!! note
    Esta opÃ§Ã£o se aplica apenas a redes compatÃ­veis com EVM.

O governador de uma rede compatÃ­vel com EVM powered by Tanssi pode alterar sua configuraÃ§Ã£o [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md){target=\_blank}, afetando o mecanismo de precificaÃ§Ã£o da transaÃ§Ã£o. Para fazer isso, no painel **Token Management**, clique no botÃ£o **Gas Dynamics** e, em seguida:

1. Insira a nova taxa base, expressa em unidades Wei (10<sup>-18</sup>)
2. Insira o valor da elasticidade
3. Clique em **Update Dynamics**

![Configurar a Gas Dynamics](/images/builders/manage/dapp/token-management/token-management-6.webp)

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o com a conta do governador da rede. Depois que a transaÃ§Ã£o for concluÃ­da, o mecanismo de taxas da rede serÃ¡ executado com os novos parÃ¢metros de precificaÃ§Ã£o da transaÃ§Ã£o.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/dapp/register-external-assets/
--- BEGIN CONTENT ---
---
title: Registrar Ativos Externos
description: As redes Tanssi se beneficiam da comunicaÃ§Ã£o cross-chain nativa, permitindo transferÃªncias de tokens suaves e rÃ¡pidas entre a cadeia nativa do token e outras cadeias.
categories: Appchain
---

# Registrar Ativos Externos

## IntroduÃ§Ã£o {: #introduction  }

A transferÃªncia de ativos entre cadeias Ã© crucial porque permite a movimentaÃ§Ã£o contÃ­nua de ativos digitais em diferentes redes, aprimorando a interoperabilidade, a liquidez e a experiÃªncia do usuÃ¡rio. Para permitir transferÃªncias de ativos de e para duas redes, primeiro, um canal bidirecional deve ser aberto entre elas. GraÃ§as ao dApp Tanssi, abrir um canal Ã© uma tarefa fÃ¡cil e rÃ¡pida. Consulte o artigo [Gerenciar Canais de ComunicaÃ§Ã£o Cross-Chain](/pt/builders/manage/dapp/xcm-channels/){target=\_blank} para saber como fazer isso.

!!! note
  Abrir um canal de comunicaÃ§Ã£o bidirecional requer aprovaÃ§Ã£o dos governadores de ambas as redes.

Depois que os canais de comunicaÃ§Ã£o da sua rede forem estabelecidos, vocÃª pode registrar os ativos de outras cadeias (ativos externos) para comeÃ§ar a operar. Este guia irÃ¡ guiÃ¡-lo pelo processo de registro de ativos externos usando o [Tanssi dApp](https://apps.tanssi.network){target=\_blank}.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia, vocÃª precisarÃ¡ ter o seguinte:

- Uma rede powered by Tanssi (Dedicada) executando [runtime 500](https://github.com/moondance-labs/tanssi/releases/tag/runtime-500){target=\_blank} ou superior
  - A conta que vocÃª usou ao registrar a rede, importada em qualquer uma das [carteiras suportadas](/builders/deploy/dapp/#supported-wallets){target=\_blank}
- A conta Sudo da sua rede, tambÃ©m importada em qualquer uma das [carteiras suportadas](/builders/deploy/dapp/#supported-wallets){target=\_blank}

!!! note
    A conta de registro da rede Ã© sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compatÃ­vel com EVM, a conta Sudo serÃ¡ do tipo Ethereum; caso contrÃ¡rio, serÃ¡ do tipo Substrate.

### Recuperando a conta de registro {: #retrieving-registration-account }

Se vocÃª nÃ£o souber qual Ã© a sua conta de registro, pode consultÃ¡â€‘la diretamente na cadeia orquestradora do Tanssi, que mantÃ©m os registros de todas as redes cadastradas. Para isso, acesse a seÃ§Ã£o **Chain state** no Polkadot.js Apps conectado Ã  cadeia orquestradora para [redes de teste rÃ¡pidas](https://polkadot.js.org/apps/?rpc=wss://fraa-flashbox-rpc.a.stagenet.tanssi.network#/chainstate){target=\_blank} ou [redes dedicadas](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\_blank} e siga estes passos:

1. Selecione o mÃ³dulo de armazenamento **registrar**
2. Selecione **registrarDeposit**
3. Insira o ID da sua rede
4. Clique no Ã­cone **+**

A conta de registro aparecerÃ¡ na parte inferior.

![Localizando sua conta de registro](/images/builders/manage/dapp/locate-registration-account.webp)

!!! note
    O dApp exibirÃ¡ sua rede no painel somente se a conta de registro estiver configurada corretamente.

### Recuperando a conta Sudo {: #retrieving-sudo-account }

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## Acessando o Painel de Registro de Ativos Externos {: #accesing-external-assets-management-panel }

O dApp do Tanssi facilita para o responsÃ¡vel pela rede gerenciar as configuraÃ§Ãµes de comunicaÃ§Ã£o entre cadeias. Ele permite solicitar novos canais, aceitar pedidos de abertura, encerrar canais existentes, gerenciar ativos externos e muito mais. Para acessar o painel de gestÃ£o de crossâ€‘chain, acesse o [Tanssi dApp](https://apps.tanssi.network/){target=\_blank} e:

1. Clique em **Manage**
2. Clique em **XCM**

![Acessando o painel de gestÃ£o de cross-chain](/images/builders/manage/dapp/access-xcm-management-panel.webp)

!!! note
    Se os detalhes da sua rede nÃ£o aparecerem no dashboard, verifique se vocÃª cumpriu os [prÃ©-requisitos](#checking-prerequisites).

O painel mostrarÃ¡ a configuraÃ§Ã£o cross-chain da sua rede, juntamente com vÃ¡rias aÃ§Ãµes disponÃ­veis. Em relaÃ§Ã£o aos ativos externos, os elementos relevantes que sÃ£o apresentados a vocÃª sÃ£o:

1. **Registered Assets panel** - esta seÃ§Ã£o irÃ¡ agrupar e apresentar a vocÃª todos os ativos registrados que sua rede jÃ¡ tem disponÃ­veis
2. **Registered Assets List** - os ativos externos jÃ¡ registrados serÃ£o exibidos nesta seÃ§Ã£o, juntamente com suas informaÃ§Ãµes associadas, como nome do ativo, sÃ­mbolo, ID, oferta total e ID da rede onde Ã© nativo
3. **Asset Registration** - esta opÃ§Ã£o permite que vocÃª selecione outros ativos externos disponÃ­veis e registre-os. A [seÃ§Ã£o a seguir](#register-external-asset) explica como fazÃª-lo

![O painel de gerenciamento cross-chain](/images/builders/manage/dapp/register-external-assets/register-external-assets-1.webp)

## Registrar um Ativo Externo {: #register-external-asset}

Desde que sua rede jÃ¡ tenha estabelecido canais de comunicaÃ§Ã£o bidirecionais com outra rede, o governador da rede pode registrar ativos externos.

Para fazer isso, clique em **Asset Registration** e depois:

1. Selecione pelo menos um dos ativos disponÃ­veis na lista
2. Clique em **Register**

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o e, assim que ela for concluÃ­da, o ativo externo estarÃ¡ disponÃ­vel localmente.

![Registro de ativos](/images/builders/manage/dapp/register-external-assets/register-external-assets-2.webp)

!!! note
  O dApp apresenta apenas ativos conhecidos de redes conhecidas do ecossistema. Se o ativo que vocÃª precisa registrar nÃ£o estiver listado, vocÃª terÃ¡ que fazÃª-lo usando o portal do desenvolvedor.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/dapp/services-payment/
--- BEGIN CONTENT ---
---
title: Pagamento dos ServiÃ§os de ProduÃ§Ã£o de Blocos
description: As redes implantadas atravÃ©s da Tanssi beneficiam dos serviÃ§os de produÃ§Ã£o de blocos fornecidos por um conjunto de node operators, que sÃ£o compensados com tokens Tanssi.
icon: octicons-server-24
categories: Appchain
---

# Pagamento dos ServiÃ§os de ProduÃ§Ã£o de Blocos

## IntroduÃ§Ã£o {: #introduction }

Como apresentado no artigo [ProduÃ§Ã£o de Blocos como ServiÃ§o](/pt/learn/tanssi/network-services/block-production/#block-production-fees){target=\_blank}, existem dois custos principais associados que o governador da rede deve cobrir:

- **Sequencers assignment** - para a atribuiÃ§Ã£o de Sequencers pelo protocolo Tanssi, que acontece uma vez por sessÃ£o
- **Block production** - para cada bloco que Ã© produzido em nome da rede

Neste guia, vocÃª aprenderÃ¡ como usar o [Tanssi dApp](https://apps.tanssi.network){target=\_blank} para recarregar sua conta e manter a atividade da sua rede.

## Verificando os PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos neste guia, vocÃª precisarÃ¡ do seguinte:

- Uma rede powered by Tanssi (Teste RÃ¡pido ou Dedicado)
- A conta que vocÃª usou ao registrar a rede, importada em qualquer uma das [carteiras suportadas](/pt/builders/deploy/dapp/#supported-wallets){target=\_blank}

Se vocÃª nÃ£o souber qual Ã© a sua conta de registro, pode consultÃ¡â€‘la diretamente na cadeia orquestradora do Tanssi, que mantÃ©m os registros de todas as redes cadastradas. Para isso, acesse a seÃ§Ã£o **Chain state** no Polkadot.js Apps conectado Ã  cadeia orquestradora para [redes de teste rÃ¡pidas](https://polkadot.js.org/apps/?rpc=wss://fraa-flashbox-rpc.a.stagenet.tanssi.network#/chainstate){target=\_blank} ou [redes dedicadas](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\_blank} e siga estes passos:

1. Selecione o mÃ³dulo de armazenamento **registrar**
2. Selecione **registrarDeposit**
3. Insira o ID da sua rede
4. Clique no Ã­cone **+**

A conta de registro aparecerÃ¡ na parte inferior.

![Localizando sua conta de registro](/images/builders/manage/dapp/locate-registration-account.webp)

!!! note
    O dApp exibirÃ¡ sua rede no painel somente se a conta de registro estiver configurada corretamente.

## Topping-Up os CrÃ©ditos da Sua Rede {: #topping-up }

Seguindo um Template de pagamento conforme o uso, as redes devem ter fundos alocados para pagar pelos serviÃ§os, que, ao longo do tempo, serÃ£o deduzidos e queimados pelo protocolo Tanssi a cada mudanÃ§a de sessÃ£o para o custo da atribuiÃ§Ã£o do Sequencer e para cada bloco pelo custo de produÃ§Ã£o do bloco.

VocÃª pode verificar o saldo atual da sua rede e recarregÃ¡-lo usando o Tanssi dApp. Para fazer isso, acesse o [Tanssi dApp](https://apps.tanssi.network/){target=\_blank} e conecte a conta de registro da rede ao dApp. O site exibirÃ¡ um cartÃ£o mostrando o status da sua rede. Este cartÃ£o inclui a previsÃ£o de atividade projetada abaixo da seÃ§Ã£o **Block Production** e o botÃ£o **Top Up**.

![BotÃ£o de aÃ§Ã£o de recarga no dApp](/images/builders/manage/dapp/services-payment/services-payment-1.webp)

Clicar no botÃ£o **Top Up** exibe uma barra lateral onde as seguintes informaÃ§Ãµes podem ser vistas:

- **Current balance** - o saldo atual alocado para o serviÃ§o de produÃ§Ã£o de blocos da rede
- **Available balance** - o saldo disponÃ­vel na conta de registro da rede, que estÃ¡ conectada ao dApp
- **Current cost** - custo atual por atribuiÃ§Ã£o de Sequencer e custo por bloco
- **Projected forecast** - o dia estimado em que a rede ficarÃ¡ sem fundos e deixarÃ¡ de ser atendida

Para estender o horizonte projetado da rede, execute as seguintes aÃ§Ãµes:

1. Insira a quantidade de tokens para comprar serviÃ§os de produÃ§Ã£o de blocos
2. Clique em **Top Up**

![Barra lateral de recarga](/images/builders/manage/dapp/services-payment/services-payment-2.webp)

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o e, depois que ela for concluÃ­da, sua rede se beneficiarÃ¡ de um horizonte de atividade estendida.

!!! warning
    Se sua rede nÃ£o tiver fundos suficientes para cobrir a atribuiÃ§Ã£o do Sequencer e o valor de blocos de uma sessÃ£o, ela travarÃ¡.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/dapp/xcm-channels/
--- BEGIN CONTENT ---
---
title: Gerenciar Canais de ComunicaÃ§Ã£o Cross-Chain
description: As redes Tanssi se beneficiam da comunicaÃ§Ã£o cross-chain nativa, que permite pontes rÃ¡pidas e seguras aproveitando a arquitetura em que sÃ£o construÃ­das.
categories: Appchain
---

# Gerenciar Canais de ComunicaÃ§Ã£o Cross-Chain

## IntroduÃ§Ã£o {: #introduction}

Conforme apresentado no artigo [ComunicaÃ§Ã£o Cross-Chain Nativa](/pt/learn/framework/xcm/){target=\_blank} da seÃ§Ã£o Aprenda, todas as redes Tanssi tÃªm uma capacidade inerente de se comunicar e interoperar com qualquer outra rede no ecossistema. Esse recurso de comunicaÃ§Ã£o cross-chain nativo Ã© possÃ­vel graÃ§as Ã  infraestrutura Ãºnica em que as redes sÃ£o construÃ­das, aproveitando o formato Cross-Consensus Message (XCM para abreviar), que facilita a comunicaÃ§Ã£o entre diferentes sistemas de consenso.

A primeira etapa para habilitar a comunicaÃ§Ã£o entre as redes Ã© [abrir um canal](/pt/learn/framework/xcm/#channel-registration){target=\_blank}. O processo de abertura de um canal comeÃ§a enviando uma solicitaÃ§Ã£o para a rede com a qual vocÃª deseja estabelecer comunicaÃ§Ãµes. Depois que a solicitaÃ§Ã£o for aceita pelo governador da cadeia de destino, um canal serÃ¡ aberto.

Neste guia, vocÃª aprenderÃ¡ como usar o [Tanssi dApp](https://apps.tanssi.network){target=\_blank} para gerenciar os canais de comunicaÃ§Ã£o cross-chain da sua rede.

## Verificando PrÃ©-requisitos {: #checking-prerequisites}

Para os exemplos deste guia, vocÃª precisarÃ¡ ter o seguinte:

- Uma rede Tanssi (Dedicada) executando o [runtime 500](https://github.com/moondance-labs/tanssi/releases/tag/runtime-500){target=\_blank} ou superior
  - A conta que vocÃª usou ao registrar a rede, importada em qualquer uma das [carteiras suportadas](/builders/deploy/dapp/#supported-wallets){target=\_blank}
- A conta Sudo da sua rede, tambÃ©m importada em qualquer uma das [carteiras suportadas](/builders/deploy/dapp/#supported-wallets){target=\_blank}

!!! note
    A conta de registro da rede Ã© sempre Substrate, enquanto a conta Sudo depende do tipo de cadeia. Se a cadeia for compatÃ­vel com EVM, a conta Sudo serÃ¡ do tipo Ethereum; caso contrÃ¡rio, serÃ¡ do tipo Substrate.

### Recuperando a conta de registro {: #retrieving-registration-account }

Se vocÃª nÃ£o souber qual Ã© a sua conta de registro, pode consultÃ¡â€‘la diretamente na cadeia orquestradora do Tanssi, que mantÃ©m os registros de todas as redes cadastradas. Para isso, acesse a seÃ§Ã£o **Chain state** no Polkadot.js Apps conectado Ã  cadeia orquestradora para [redes de teste rÃ¡pidas](https://polkadot.js.org/apps/?rpc=wss://fraa-flashbox-rpc.a.stagenet.tanssi.network#/chainstate){target=\_blank} ou [redes dedicadas](https://polkadot.js.org/apps/?rpc=wss://services.tanssi-testnet.network/dancelight#/chainstate){target=\_blank} e siga estes passos:

1. Selecione o mÃ³dulo de armazenamento **registrar**
2. Selecione **registrarDeposit**
3. Insira o ID da sua rede
4. Clique no Ã­cone **+**

A conta de registro aparecerÃ¡ na parte inferior.

![Localizando sua conta de registro](/images/builders/manage/dapp/locate-registration-account.webp)

!!! note
    O dApp exibirÃ¡ sua rede no painel somente se a conta de registro estiver configurada corretamente.

### Recuperando a conta Sudo {: #retrieving-sudo-account }

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## Acessando o Painel de Gerenciamento de Canais {: #accesing-channel-management-panel }

O dApp do Tanssi facilita para o responsÃ¡vel pela rede gerenciar as configuraÃ§Ãµes de comunicaÃ§Ã£o entre cadeias. Ele permite solicitar novos canais, aceitar pedidos de abertura, encerrar canais existentes, gerenciar ativos externos e muito mais. Para acessar o painel de gestÃ£o de crossâ€‘chain, acesse o [Tanssi dApp](https://apps.tanssi.network/){target=\_blank} e:

1. Clique em **Manage**
2. Clique em **XCM**

![Acessando o painel de gestÃ£o de cross-chain](/images/builders/manage/dapp/access-xcm-management-panel.webp)

!!! note
    Se os detalhes da sua rede nÃ£o aparecerem no dashboard, verifique se vocÃª cumpriu os [prÃ©-requisitos](#checking-prerequisites).

O painel mostrarÃ¡ o status dos canais de comunicaÃ§Ã£o da sua rede, juntamente com vÃ¡rias aÃ§Ãµes disponÃ­veis. Os elementos que vocÃª recebe sÃ£o:

1. **Sovereign account** - Ã© uma conta sem chave que pertence Ã  rede em um sistema de consenso diferente, a cadeia de retransmissÃ£o neste caso. Ela sÃ³ pode ser usada pelo governador da rede.

   Antes de abrir um novo canal, a conta soberana da rede na cadeia de retransmissÃ£o deve ser financiada com tokens suficientes para serem bloqueados como um depÃ³sito de canal.

   Nesta seÃ§Ã£o, vocÃª pode ver o saldo da conta soberana da sua rede, copiar seu endereÃ§o e depositar tokens

2. **Incoming/Outgoing channel requests** - toda solicitaÃ§Ã£o de canal precisa ser aceita pela contraparte antes que qualquer mensagem possa ser enviada.

   Nesta seÃ§Ã£o, vocÃª pode ver a lista de solicitaÃ§Ãµes de saÃ­da pendentes e cancelÃ¡-las. VocÃª tambÃ©m pode ver quaisquer solicitaÃ§Ãµes de canal de entrada que sua rede possa ter recebido e aceitar o canal

3. **Established channels** - Depois que o governador da cadeia de destino aceitar a solicitaÃ§Ã£o do canal, o canal se torna aberto e disponÃ­vel para transmissÃ£o de mensagens.

   Nesta seÃ§Ã£o, vocÃª pode ver a lista de canais aceitos que sua rede possui, a direÃ§Ã£o em que as mensagens fluem pelo canal e cancelar o canal

4. **Request to open new channels** - esta opÃ§Ã£o permite que vocÃª selecione uma rede existente no ecossistema e solicite a abertura de um canal. A [prÃ³xima seÃ§Ã£o](#request-new-channel) explica como fazer isso

![O painel de gerenciamento de canais](/images/builders/manage/dapp/xcm-channels/xcm-channels-1.webp)

## SolicitaÃ§Ã£o para Abrir Novo Canal {: #request-new-channel }

Desde que sua rede tenha fundos suficientes para o depÃ³sito na conta soberana da cadeia de retransmissÃ£o, o governador da rede pode solicitar a abertura de um novo canal com qualquer outra rede.

Para fazer isso, clique em **HRMP Channels** e, em seguida:

1. Selecione a rede com a qual vocÃª deseja estabelecer um canal
2. Clique em **Request Channel**

VocÃª serÃ¡ solicitado a assinar a transaÃ§Ã£o e, assim que ela for concluÃ­da, a cadeia de destino receberÃ¡ a solicitaÃ§Ã£o.

![SolicitaÃ§Ã£o de abertura de canal](/images/builders/manage/dapp/xcm-channels/xcm-channels-2.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/developer-portal/impersonate/
--- BEGIN CONTENT ---
---
title: Fazer-se passar por outras contas com Sudo
description: Aprenda a usar a chave Sudo para despachar chamadas assinando uma transaÃ§Ã£o como se ela viesse de uma conta diferente.
icon: octicons-person-add-24
categories: Appchain
---

# Usando Sudo para Personificar Outras Contas

## IntroduÃ§Ã£o {: #introduction }

[Sudo](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\_blank} Ã© um mÃ³dulo que permite que chamadas de Runtime privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo Ã©, por vezes, referido coloquialmente como um superutilizador ou conta semelhante a um deus. Isto permite-lhe executar aÃ§Ãµes privilegiadas ao gerir a sua rede, como personificar outras contas.

Neste guia, aprenderÃ¡ como usar Sudo para personificar outras contas. Por exemplo, este guia usarÃ¡ a conta Sudo para se apresentar como uma conta arbitrÃ¡ria e transferir fundos dessa conta.

!!! warning
    A transferÃªncia de saldo demonstrada neste guia Ã© duvidosa e Ã© mostrada apenas como um exemplo de uso do Sudo.

## VerificaÃ§Ã£o de PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos neste guia, precisarÃ¡ do seguinte:

- Uma rede powered by Tanssi (Quick Trial ou Dedicated)
- A conta Sudo da sua rede conectada aos Polkadot.js Apps da sua rede. Pode consultar o [Guia de Gerenciamento do Sudo](/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} para obter instruÃ§Ãµes sobre como injetar a sua conta Sudo nos Polkadot.js Apps

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## Usando Sudo e o Dispatch como UtilitÃ¡rio {: #using-sudo-and-the-dispatch-as-utility }

Como sabe, a conta Sudo pode executar funÃ§Ãµes privilegiadas, incluindo a personificaÃ§Ã£o de outras contas. Ao enviar uma chamada atravÃ©s de `sudoAs`, o Runtime primeiro autenticarÃ¡ a chave Sudo e, em seguida, despacharÃ¡ a chamada de funÃ§Ã£o desejada com a origem `Signed` de uma determinada conta. No exemplo a seguir, o mÃ©todo `sudoAs` orquestrarÃ¡ o envio de alguns tokens para outra conta. Embora o resultado seja semelhante ao uso do Sudo com uma chamada `forceBalanceTransfer`, o exemplo a seguir usa uma chamada de transferÃªncia de saldo regular, onde a origem Ã© a conta do remetente e nÃ£o a conta Sudo.

Para fazer uma chamada `sudoAs` para personificar outra conta, navegue para o separador **Developer** (Desenvolvedor) dos Polkadot.js Apps para a sua rede powered by Tanssi e clique em **Sudo**. Se nÃ£o vir **Sudo** neste menu, nÃ£o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que a sua conta Sudo estÃ¡ injetada pela sua carteira e conectada aos Polkadot.js Apps. Em seguida, siga os seguintes passos:

1. Selecione a paleta **Sudo**
2. Selecione o mÃ©todo **sudoAs**
3. Selecione ou cole a conta desejada para personificar
4. Selecione a paleta desejada para a chamada a enviar. Neste caso, Ã© a paleta **balances** (saldos)
5. Selecione o mÃ©todo **transferAllowDeath**
6. Especifique a conta de destino para a transferÃªncia de saldo
7. Especifique o nÃºmero de tokens a enviar
8. Pressione **SubmitSudo** e confirme o pop-up resultante

![Fazer uma chamada Sudo as](/images/builders/manage/developer-portal/impersonate/impersonate-2.webp)

A outra conta tinha um saldo inicial de `1.000` tokens antes da chamada e, subsequentemente, caiu para `995`, como esperado.

![Verificar saldos no Polkadot.js Apps](/images/builders/manage/developer-portal/impersonate/impersonate-3.webp)

## Usando Sudo e o Dispatch como UtilitÃ¡rio {: #using-sudo-and-the-dispatch-as-utility }

A secÃ§Ã£o a seguir demonstrarÃ¡ o uso do Sudo para despachar chamadas de uma origem arbitrÃ¡ria. Ao enviar uma chamada desta forma, o Runtime primeiro autenticarÃ¡ a chave Sudo e, em seguida, despacharÃ¡ a chamada usando a paleta `utility` e a funÃ§Ã£o `dispatchAs`, permitindo que a origem da transaÃ§Ã£o seja exatamente o que deseja.

Para fazer isso, navegue para o separador **Developer** (Desenvolvedor) dos Polkadot.js Apps para a sua rede powered by Tanssi e clique em **Sudo**. Se nÃ£o vir **Sudo** neste menu, nÃ£o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que a sua [conta Sudo estÃ¡ injetada pela sua carteira e conectada aos Polkadot.js Apps](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Em seguida, siga os seguintes passos:

1. Selecione a paleta **Sudo**
2. Selecione o mÃ©todo **Sudo**
3. Selecione a paleta desejada para a chamada a enviar. Neste caso, Ã© a paleta **utility** (utilidade)
4. Selecione o mÃ©todo **dispatchAs**
5. Selecione **system** (sistema) no menu pendente
6. Selecione a origem **signed** (assinada), que define a origem da transaÃ§Ã£o para ser a conta especificada em vez de root (raiz)
7. Selecione a paleta desejada para a chamada a enviar. Neste caso, Ã© a paleta **balances** (saldos)
8. Selecione o mÃ©todo **transferAllowDeath**
9. Especifique a conta de destino para a transferÃªncia de saldo
10. Especifique o nÃºmero de tokens a enviar
11. Pressione **SubmitSudo** e confirme o pop-up resultante
![Usar Sudo Dispatch As no Polkadot.js Apps](/images/builders/manage/developer-portal/impersonate/impersonate-4.webp)

A outra conta tinha um saldo inicial de `995` tokens antes da chamada e caiu para `990`, como esperado.

![Verificar saldos no Polkadot.js Apps](/images/builders/manage/developer-portal/impersonate/impersonate-5.webp)

E Ã© isso! A secÃ§Ã£o [Developer Portal](/pt/builders/manage/developer-portal/) tem muitos mais guias sobre como gerir a sua rede Tanssi.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/developer-portal/
--- BEGIN CONTENT ---
---
title: Usando o Portal do Desenvolvedor para Gerenciar Sua Rede
description: Aprenda como usar o portal do desenvolvedor para administrar e gerenciar sua rede, incluindo a atualizaÃ§Ã£o do runtime da sua chain, a rotaÃ§Ã£o das chaves Sudo e muito mais.
icon: octicons-key-24
template: index-page.html
---

# Usando o Portal do Desenvolvedor

O portal do desenvolvedor permite que vocÃª gerencie com eficiÃªncia suas operaÃ§Ãµes de rede, seguranÃ§a e personalizaÃ§Ã£o Powered by Tanssi. Com ferramentas intuitivas Ã  sua disposiÃ§Ã£o, vocÃª pode garantir um gerenciamento tranquilo e adaptar sua rede para atender aos requisitos exclusivos do seu projeto.

## Como Conectar ao Portal do Desenvolvedor

Antes de comeÃ§ar, vocÃª precisa recuperar a WS URL da sua rede. Esta informaÃ§Ã£o estÃ¡ disponÃ­vel no **Dashboard** da sua rede no dApp Tanssi, na seÃ§Ã£o **Properties**.

![Recupere sua URL WS do painel Tanssi](/images/builders/manage/developer-portal/index-1.webp)

Agora vocÃª estÃ¡ pronto para conectar sua rede Powered by Tanssi ao portal do desenvolvedor. Navegue atÃ© [Polkadot.js Apps](https://polkadot.js.org/apps/){target=\_blank} e clique nas informaÃ§Ãµes da chain no canto superior esquerdo para mudar para a sua rede.

![Recupere sua URL WS do painel Tanssi](/images/builders/manage/developer-portal/index-2.webp)

Para configurar sua rede, siga estes passos:

1. Role para baixo no menu do lado esquerdo atÃ© ver **Development** (Desenvolvimento). Clique nisso para expandir as opÃ§Ãµes
2. Clique em **Local Node** (NÃ³ Local)
3. Insira sua URL RPC no campo de entrada do **custom endpoint** (ponto de extremidade personalizado)
4. Clique no botÃ£o salvar. O portal serÃ¡ recarregado e vocÃª deverÃ¡ estar conectado Ã  sua rede

![](/images/builders/manage/developer-portal/index-3.webp)

Agora que vocÃª tem sua rede carregada no portal do desenvolvedor, vocÃª pode mergulhar nos seguintes guias para comeÃ§ar a gerenciar sua rede.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/developer-portal/maintenance/
--- BEGIN CONTENT ---
---
title: Habilitando o Modo de ManutenÃ§Ã£o
description: Aprenda a usar o Sudo para ativar e desativar o modo de manutenÃ§Ã£o, que pausa sua rede enquanto ainda produz blocos e permite chamadas selecionadas.
icon: octicons-stop-24
categories: Appchain
---

# Habilitando o Modo de ManutenÃ§Ã£o

## IntroduÃ§Ã£o {: #introduction}

A [paleta de ManutenÃ§Ã£o](https://moonbeam.network/news/what-is-maintenance-mode/){target=\_blank} Ã© um mÃ³dulo projetado para uso apenas em emergÃªncias que representam ameaÃ§as existenciais Ã  rede. Habilitar o modo de manutenÃ§Ã£o em sua rede suspenderÃ¡ o processamento de todas as transaÃ§Ãµes regulares, incluindo interaÃ§Ãµes com a EVM. A produÃ§Ã£o de blocos continua em uma cadÃªncia regular e permite que as funÃ§Ãµes de governanÃ§a e staking continuem.

O modo de manutenÃ§Ã£o filtra (ignora) todas as chamadas fora da governanÃ§a e staking. Uma vez que o modo de manutenÃ§Ã£o Ã© encerrado, sua cadeia processarÃ¡ quaisquer transaÃ§Ãµes pendentes que foram enfileiradas enquanto sua cadeia estava no modo de manutenÃ§Ã£o. O modo de manutenÃ§Ã£o destina-se a ser usado apenas como uma medida temporÃ¡ria de emergÃªncia.

Por exemplo, imagine descobrir uma exploraÃ§Ã£o crÃ­tica em sua rede que poderia resultar em perdas financeiras significativas se atores mal-intencionados a explorassem. Embora vocÃª possa resolver o problema implementando uma atualizaÃ§Ã£o de Runtime, o processo leva tempo - tempo precioso durante o qual sua rede permanece vulnerÃ¡vel a ataques. Uma soluÃ§Ã£o potencial Ã© ativar o modo de manutenÃ§Ã£o em sua rede, concluir a atualizaÃ§Ã£o do Runtime e sair do modo de manutenÃ§Ã£o assim que a correÃ§Ã£o for verificada.

!!! warning
    Habilitar o modo de manutenÃ§Ã£o em uma rede de produÃ§Ã£o pode impactar significativamente os contratos em sua cadeia. Enquanto o modo de manutenÃ§Ã£o estiver ativado, nenhuma transaÃ§Ã£o de contrato inteligente Ã© processada, por isso Ã© fundamental considerar as possÃ­veis ramificaÃ§Ãµes antes de ativÃ¡-lo.

## Verificando os PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia, vocÃª precisarÃ¡ ter o seguinte:

- Uma rede powered by Tanssi (Teste RÃ¡pido ou Dedicado)
- A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. VocÃª pode consultar o [guia de Gerenciamento do Sudo](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} para obter instruÃ§Ãµes sobre como injetar sua conta Sudo nos Polkadot.js Apps

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## Habilitando o Modo de ManutenÃ§Ã£o {: #enabling-maintenance-mode }

Ainda, a conta Sudo pode realizar funÃ§Ãµes privilegiadas, como habilitar e desabilitar o modo de manutenÃ§Ã£o. Para entrar no modo de manutenÃ§Ã£o e interromper o processamento regular de transaÃ§Ãµes, navegue atÃ© a guia **Developer** do Polkadot.js Apps para sua rede powered by Tanssi e clique em **Sudo**. Se vocÃª nÃ£o vir **Sudo** neste menu, vocÃª nÃ£o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua [conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. EntÃ£o, siga os seguintes passos:

1. Selecione a paleta **maintenanceMode**
2. Selecione o mÃ©todo **enterMaintenanceMode**
3. Pressione **Submit Sudo** e confirme a transaÃ§Ã£o no pop-up resultante

![Habilitar o modo de manutenÃ§Ã£o](/images/builders/manage/developer-portal/maintenance/maintenance-2.webp)

Para verificar se o modo de manutenÃ§Ã£o foi habilitado, vocÃª pode verificar a seÃ§Ã£o **Explorer** na guia **Rede** e revisar os eventos recentes.

![Verificar se o modo de manutenÃ§Ã£o estÃ¡ habilitado](/images/builders/manage/developer-portal/maintenance/maintenance-3.webp)

## SaÃ­da do Modo de ManutenÃ§Ã£o {: #exiting-maintenance-mode }

Para sair do modo de manutenÃ§Ã£o e retornar sua rede Ã  operaÃ§Ã£o normal, navegue atÃ© a guia **Developer** do Polkadot.js Apps para sua rede powered by Tanssi e clique em **Sudo**. Se vocÃª nÃ£o vir **Sudo** neste menu, vocÃª nÃ£o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua [conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Siga os seguintes passos:

1. Selecione a paleta **maintenanceMode**
2. Selecione o mÃ©todo **resumeNormalOperation**
3. Pressione **Submit Sudo** e confirme a transaÃ§Ã£o no pop-up resultante
![Sair do modo de manutenÃ§Ã£o](/images/builders/manage/developer-portal/maintenance/maintenance-4.webp)

Para verificar se o modo de manutenÃ§Ã£o foi desabilitado, vocÃª pode verificar na seÃ§Ã£o **Explorer** na guia **Network** e revisar os eventos recentes.

![Verificar se o modo de manutenÃ§Ã£o estÃ¡ desabilitado](/images/builders/manage/developer-portal/maintenance/maintenance-5.webp)

Lembre-se que o uso do modo de manutenÃ§Ã£o Ã© uma aÃ§Ã£o de emergÃªncia que sÃ³ deve ser ativada quando sua cadeia estiver em risco extremo. Pode valer a pena estabelecer uma polÃ­tica para sua rede que defina gatilhos especÃ­ficos de disjuntor para determinar quando o modo de manutenÃ§Ã£o serÃ¡ habilitado. O estabelecimento de uma polÃ­tica com antecedÃªncia tambÃ©m simplificarÃ¡ a tomada de decisÃµes durante uma potencial emergÃªncia.

E Ã© isso! A seÃ§Ã£o [Portal do Desenvolvedor](/pt/builders/manage/developer-portal/) tem muitos mais guias sobre como gerenciar sua rede powered by Tanssi.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/developer-portal/minting/
--- BEGIN CONTENT ---
---
title: Cunhagem de Tokens Nativos com Sudo
description: Aprenda a usar a chave Sudo para gerenciar sua rede Powered by Tanssi e executar a aÃ§Ã£o privilegiada de cunhar tokens nativos, alterando a emissÃ£o total.
icon: material-creation-outline
categories: Appchain
---

# Usando Sudo para Cunhar Tokens Nativos

## IntroduÃ§Ã£o {: #introduction }

[Sudo](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\_blank} Ã© um mÃ³dulo que permite que chamadas de Runtime privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo Ã©, por vezes, referido coloquialmente como um superusuÃ¡rio ou uma conta semelhante a um deus. Isso permite que vocÃª realize aÃ§Ãµes privilegiadas no curso do gerenciamento de sua rede, como cunhar novos tokens nativos.

Neste guia, vocÃª aprenderÃ¡ como usar Sudo para cunhar corretamente novos tokens nativos. Este guia abrangente mostra como verificar o saldo de uma conta existente antes de atribuir a ela um novo saldo com acesso Sudo.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia, vocÃª precisarÃ¡ do seguinte:

- Uma rede powered by Tanssi (Quick Trial ou Dedicated)
- A conta Sudo da sua rede conectada aos seus Polkadot.js Apps. VocÃª pode consultar o [guia de gerenciamento do Sudo](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} para obter instruÃ§Ãµes sobre como injetar sua conta Sudo nos Polkadot.js Apps

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## Cunhagem de Tokens {: #minting-tokens }

Como vocÃª sabe, a conta Sudo tem a capacidade de realizar funÃ§Ãµes privilegiadas, incluindo a cunhagem de tokens adicionais. Ao configurar sua rede no [Tanssi dApp](https://apps.tanssi.network){target=\_blank}, vocÃª pode especificar os saldos da conta genesis. Em outras palavras, vocÃª tem a capacidade de dotar as contas com saldos iniciais ao iniciar sua rede Tanssi. No entanto, vocÃª tambÃ©m pode cunhar novos tokens apÃ³s o lanÃ§amento com a ajuda da conta Sudo.

!!! note
    Este tutorial demonstra a atribuiÃ§Ã£o de saldos de tokens arbitrÃ¡rios em uma rede TestNet que nÃ£o tem valor. VocÃª deve considerar cuidadosamente as ramificaÃ§Ãµes de criar tokens adicionais em sua prÃ³pria rede powered by Tanssi.

### Verificando o Saldo da Conta Existente {: #checking-existing-account-balance }

A prÃ³xima seÃ§Ã£o demonstrarÃ¡ como atribuir saldos de tokens arbitrÃ¡rios a contas usando a conta Sudo. Este processo substituirÃ¡ o saldo existente da conta especificada, portanto, verificar se a conta estÃ¡ vazia Ã© uma boa prÃ¡tica antes de continuar. Para verificar o saldo de uma conta, siga estas etapas:

1. Navegue atÃ© a guia **Desenvolvedor** do [Polkadot.js Apps](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} e clique em **Chain State** (Estado da Cadeia)
2. Selecione o pallet **system** para consultar
3. Selecione **account** (conta)
4. Cole o endereÃ§o da conta ou selecione-o no menu suspenso
5. Pressione o Ã­cone **+**
6. VocÃª verÃ¡ as informaÃ§Ãµes do saldo retornadas na parte inferior, incluindo saldos livres, reservados e congelados
![Verificar saldos no Polkadot.js Apps](/images/builders/manage/developer-portal/minting/minting-2.webp)

### Atribuindo Saldos com Sudo {: #assigning-balances-with-sudo }

Para atribuir um saldo de conta a uma conta, certifique-se de ter sua conta Sudo acessÃ­vel no [Polkadot.js Apps](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Em seguida, siga estas etapas:

1. Navegue atÃ© a guia **Developer** dos Polkadot.js Apps para sua rede Tanssi
1. Clique em **Sudo**. Se vocÃª nÃ£o vir **Sudo** neste menu, vocÃª nÃ£o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps
1. Selecione o pallet **balances**
1. Selecione o mÃ©todo **forceSetBalance**
1. Cole o endereÃ§o da conta para dotar com tokens ou selecione-o no menu suspenso
1. Insira a quantidade de tokens para dotar a conta. Neste exemplo, especificamos `9000000000000000000` para nove tokens nativos. Lembre-se que as redes EVM powered by Tanssi tÃªm 18 decimais, enquanto as redes Substrate ou personalizadas configuram os decimais ao lanÃ§ar a cadeia. Se vocÃª nÃ£o tiver certeza de quantos decimais sua rede tem, navegue atÃ© a guia **Settings** e clique em **Metadata**
1. Pressione **Submit Sudo** (Enviar Sudo) e confirme a transaÃ§Ã£o em sua carteira

![ForÃ§ar a atribuiÃ§Ã£o de saldos no Polkadot.js Apps](/images/builders/manage/developer-portal/minting/minting-3.webp)

E Ã© isso! A seÃ§Ã£o [Portal do Desenvolvedor](/pt/builders/manage/developer-portal/) tem muitos mais guias sobre como gerenciar sua rede Tanssi.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/developer-portal/pause-transactions/
--- BEGIN CONTENT ---
---
title: Pausando TransaÃ§Ãµes
description: Aprenda a usar o Sudo para pausar temporariamente transaÃ§Ãµes selecionadas, impedindo sua execuÃ§Ã£o, enquanto todas as outras transaÃ§Ãµes prosseguem normalmente.
icon: octicons-stopwatch-24
categories: Appchain
---

# Pausando TransaÃ§Ãµes

## IntroduÃ§Ã£o {: #introduction }

O [mÃ³dulo de Pausa de TransaÃ§Ã£o](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/tx-pause/src/lib.rs){target=\_blank} Ã© um dos [mÃ³dulos embutidos](/pt/learn/framework/modules/#built-in-modules){target=\_blank} incluÃ­dos no Polkadot SDK, e estÃ¡ disponÃ­vel em qualquer rede Powered by Tanssi baseada nos [Templates oficiais](/pt/builders/build/templates/overview/){target=\_blank} versÃ£o [400](https://github.com/moondance-labs/tanssi/releases/tag/runtime-400-templates){target=\_blank} ou superior.

Este mÃ³dulo permite que um governador de rede evite temporariamente a execuÃ§Ã£o de um conjunto de transaÃ§Ãµes selecionadas, enquanto o restante das transaÃ§Ãµes continua normalmente. Esse recurso Ã© Ãºtil em vÃ¡rios cenÃ¡rios, como desabilitar uma funcionalidade em que uma ameaÃ§a Ã  seguranÃ§a foi descoberta, habilitar uma funcionalidade sazonal somente quando necessÃ¡rio e habilitar um conjunto de transaÃ§Ãµes exatamente na data de lanÃ§amento.

Em um cenÃ¡rio de emergÃªncia, quando um exploit crÃ­tico Ã© descoberto, este mÃ³dulo permite que a rede isole e pare apenas a funcionalidade afetada, minimizando efetivamente o impacto geral.

!!! warning
    No momento em que este artigo foi escrito, este mÃ³dulo ainda nÃ£o foi auditado; portanto, nÃ£o Ã© recomendado para uso em produÃ§Ã£o.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia, vocÃª precisarÃ¡ ter o seguinte:

- Uma rede Powered by Tanssi (Quick Trial ou Dedicada) com o mÃ³dulo Pausa de TransaÃ§Ã£o. Qualquer nova implantaÃ§Ã£o de rede baseada em um dos Templates servirÃ¡; caso contrÃ¡rio, certifique-se de [incluir o mÃ³dulo](/pt/builders/build/customize/adding-built-in-module/){target=\_blank} em seu runtime de rede personalizado
- A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. VocÃª pode consultar o guia [Managing Sudo](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} para obter instruÃ§Ãµes sobre como injetar sua conta Sudo no Polkadot.js Apps

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## Nomes de MÃ³dulo e TransaÃ§Ã£o {: #modules-transaction-names }

O [mÃ³dulo Pausa de TransaÃ§Ã£o](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/tx-pause/src/lib.rs){target=\_blank} funciona filtrando a execuÃ§Ã£o de transaÃ§Ãµes especÃ­ficas contidas nos mÃ³dulos incluÃ­dos no Runtime da rede. Para fazer isso, ele mantÃ©m uma lista interna das transaÃ§Ãµes banidas, identificadas por nome de mÃ³dulo e transaÃ§Ã£o. Esta lista diferencia maiÃºsculas de minÃºsculas e sÃ³ funciona quando hÃ¡ uma correspondÃªncia exata entre um item na lista de transaÃ§Ãµes pausadas e a transaÃ§Ã£o que estÃ¡ sendo processada. Portanto, o uso dos nomes exatos dos mÃ³dulos e das transaÃ§Ãµes Ã© crucial.

Para descobrir os nomes dos mÃ³dulos disponÃ­veis em seu Runtime, vocÃª precisa ler a seÃ§Ã£o `construct_runtime!()` no arquivo `lib.rs` do seu Runtime de rede no repositÃ³rio do seu projeto. Se sua rede for baseada em um dos Templates oficiais, vocÃª encontrarÃ¡ o arquivo no [repositÃ³rio Tanssi](https://github.com/moondance-labs/tanssi){target=\_blank}:

- Para redes baseadas no Template EVM: [o arquivo lib.rs](https://github.com/moondance-labs/tanssi/blob/master/chains/container-chains/runtime-templates/frontier/src/lib.rs){target=\_blank}
- Para redes baseadas no Template Substrate: [o arquivo lib.rs](https://github.com/moondance-labs/tanssi/blob/master/chains/container-chains/runtime-templates/simple/src/lib.rs){target=\_blank}

O snippet a seguir Ã© um exemplo de como a seÃ§Ã£o `construct_runtime!()` se parece. Os nomes dos mÃ³dulos sÃ£o os localizados Ã  esquerda dos dois pontos.

```rust
    pub enum Runtime
    {
        ...
        Migrations: pallet_migrations = 7,
        MaintenanceMode: pallet_maintenance_mode = 8,
        TxPause: pallet_tx_pause = 9,
        Balances: pallet_balances = 10,
        Multisig: pallet_multisig = 16,      
        ...
   }
```

Para identificar os nomes das transaÃ§Ãµes incluÃ­das em um mÃ³dulo, vocÃª precisa consultar seu cÃ³digo-fonte. Os mÃ³dulos integrados no [Substrate](/pt/learn/framework/overview/#substrate-framework){target=\_blank} identificam suas transaÃ§Ãµes usando uma macro `#[pallet::call_index(INDEX)]`, onde `INDEX` Ã© um nÃºmero. No caso de um [mÃ³dulo embutido](/pt/builders/build/customize/adding-built-in-module/){target=\_blank}, o cÃ³digo estÃ¡ localizado na [pasta FRAME](https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame){target=\_blank} do repositÃ³rio Polkadot-SDK. Por exemplo, se vocÃª quiser saber sobre os nomes das transaÃ§Ãµes no mÃ³dulo `Balances`, consulte seu arquivo [lib.rs](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/balances/src/lib.rs){target=\_blank} e procure os nomes das funÃ§Ãµes abaixo das macros `#[pallet::call_index(INDEX)]`. O snippet a seguir Ã© a transaÃ§Ã£o `transfer_allow_death` do mÃ³dulo `Balances`, que Ã© o usado como exemplo neste guia:

```rust
pub fn transfer_allow_death(
    origin: OriginFor<T>,
    dest: AccountIdLookupOf<T>,
    #[pallet::compact] value: T::Balance,
) -> DispatchResult {
    // Code
    Ok(())
}
```

### Alguns MÃ³dulos e TransaÃ§Ãµes Usados com FrequÃªncia {: #frequently-used-modules-transactions }

Ao usar qualquer um dos mÃ³dulos Substrate embutidos, o nome com o qual ele Ã© referenciado no Runtime Ã© totalmente de responsabilidade do desenvolvedor, mas os nomes das transaÃ§Ãµes nÃ£o sÃ£o personalizÃ¡veis. Aqui estÃ¡ uma lista de alguns dos mÃ³dulos mais comumente usados com as transaÃ§Ãµes mais comumente usadas que eles contÃªm. Esses sÃ£o os nomes das transaÃ§Ãµes a serem usados neste mÃ³dulo Pausa de TransaÃ§Ã£o.

???+ function "[**pallet-ethereum**](https://github.com/polkadot-evm/frontier/blob/master/frame/ethereum/src/lib.rs){target=\_blank} â€” Este mÃ³dulo, junto com o mÃ³dulo EVM, fornece compatibilidade total com o Ethereum para a rede"

    | Nome da TransaÃ§Ã£o |        DescriÃ§Ã£o        |
    |:----------------:|:-------------------------:|
    |    `transact`    | Executa uma chamada Ethereum |

??? function "[**pallet_balances**](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/balances/src/lib.rs){target=\_blank} â€” Este mÃ³dulo fornece funcionalidade para lidar com contas e saldos para a moeda nativa da rede"

    |    Nome da TransaÃ§Ã£o    |                                                                 DescriÃ§Ã£o                                                                  |
    |:----------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------:|
    | `transfer_allow_death` |      Executa uma transferÃªncia de saldo, excluindo a conta do remetente quando seu saldo final fica abaixo do requisito mÃ­nimo de existÃªncia      |
    | `transfer_keep_alive`  | Executa uma transferÃªncia de saldo, mantendo a conta do remetente ativa mesmo quando seu saldo final fica abaixo do requisito mÃ­nimo de existÃªncia |
    |     `transfer_all`     |                                              Transfere todos os saldos nÃ£o bloqueados para um destino                                               |
    |         `burn`         |                                     Queima o saldo da conta de origem, reduzindo a emissÃ£o total                                     |

??? function "[**pallet_assets**](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/assets/src/lib.rs){target=\_blank} â€” Este mÃ³dulo fornece funcionalidade para lidar com tokens fungÃ­veis"

    |   Nome da TransaÃ§Ã£o    |                                                                DescriÃ§Ã£o                                                                 |
    |:---------------------:|:------------------------------------------------------------------------------------------------------------------------------------------:|
    |       `create`        |                                                   Emite uma nova classe de ativos fungÃ­veis                                                    |
    |    `start_destroy`    |                                          Inicia o processo de destruiÃ§Ã£o de uma classe de ativos fungÃ­veis                                           |
    |  `destroy_accounts`   |                       DestrÃ³i todas as contas associadas a um determinado ativo para as quais o processo de destruiÃ§Ã£o foi iniciado                        |
    |  `destroy_approvals`  |                       DestrÃ³i todas as aprovaÃ§Ãµes associadas a um determinado ativo para o qual o processo de destruiÃ§Ã£o foi iniciado                       |
    |   `finish_destroy`    |                          Conclui o processo de destruiÃ§Ã£o de um determinado ativo para o qual o processo de destruiÃ§Ã£o foi iniciado                          |
    |        `mint`         |                                                                Cria ativos                                                                |
    |        `burn`         |                                                                Queima ativos                                                                |
    |      `transfer`       |      Executa uma transferÃªncia de ativos excluindo a conta do remetente quando seu saldo final fica abaixo do requisito mÃ­nimo de existÃªncia      |
    | `transfer_keep_alive` | Executa uma transferÃªncia de ativos mantendo a conta do remetente ativa mesmo quando seu saldo final fica abaixo do requisito mÃ­nimo de existÃªncia |
    |       `freeze`        |                                          NÃ£o permite transferÃªncias de um ativo de uma conta especÃ­fica                                           |
    |        `thaw`         |                                         Permite novamente transferÃªncias de um ativo de uma conta especÃ­fica                                         |
    |    `freeze_asset`     |                                                      NÃ£o permite transferÃªncias de um ativo                                                       |
    |     `thaw_asset`      |                                                     Permite novamente transferÃªncias de um ativo                                                     |
    |    `set_metadata`     |                                                       Define os metadados para um ativo                                                       |
    |   `clear_metadata`    |                                                      Limpa os metadados para um ativo                                                      |

??? function "[**pallet_nfts**](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/nfts/src/lib.rs){target=\_blank} â€” Este mÃ³dulo fornece funÃ§Ãµes para lidar com tokens nÃ£o fungÃ­veis"

    |      Nome da TransaÃ§Ã£o       |                        DescriÃ§Ã£o                         |
    |:---------------------------:|:----------------------------------------------------------:|
    |          `create`           |       Emite uma nova coleÃ§Ã£o de itens nÃ£o fungÃ­veis        |
    |          `destroy`          |        DestrÃ³i uma coleÃ§Ã£o de itens nÃ£o fungÃ­veis         |
    |           `mint`            |            Cria um item em uma coleÃ§Ã£o NFT              |
    |           `burn`            |          DestrÃ³i um item de uma coleÃ§Ã£o NFT           |
    |         `transfer`          |                      Transfere um NFT                      |
    |    `lock_item_transfer`     |              NÃ£o permite a transferÃªncia de um item              |
    |   `unlock_item_transfer`    |         Permite novamente a transferÃªncia de um item bloqueado         |
    |       `set_attribute`       |     Define um atributo para uma coleÃ§Ã£o NFT ou um item     |
    |      `clear_attribute`      |    Limpa um atributo para uma coleÃ§Ã£o NFT ou um item    |
    |       `set_metadata`        |               Define os metadados para um item                |
    |      `clear_metadata`       |              Limpa os metadados para um item               |
    |  `set_collection_metadata`  |  Define os metadados para uma coleÃ§Ã£o de itens nÃ£o fungÃ­veis  |
    | `clear_collection_metadata` | Limpa os metadados para uma coleÃ§Ã£o de itens nÃ£o fungÃ­veis |
    |         `set_price`         |                 Define o preÃ§o de um item                 |
    |         `buy_item`          |        Compre um item, desde que esteja Ã  venda         |

??? function "[**pallet_multisig**](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/multisig/src/lib.rs){target=\_blank} â€” Este mÃ³dulo fornece funÃ§Ãµes para lidar com esquemas de mÃºltiplas assinaturas"

    |    Nome da TransaÃ§Ã£o    |                                                                 DescriÃ§Ã£o                                                                  |
    |:----------------------:|:--------------------------------------------------------------------------------------------------------------------------------------------:|
    | `as_multi_threshold_1` |                                           Registra uma chamada de mÃºltiplas assinaturas com uma Ãºnica aprovaÃ§Ã£o                                            |
    |       `as_multi`       | Registra uma chamada de mÃºltiplas assinaturas a ser feita de uma conta composta, se aprovada pelo limite mÃ­nimo especificado dos outros signatÃ¡rios |
    |   `approve_as_multi`   |              Registra a aprovaÃ§Ã£o de uma chamada de mÃºltiplas assinaturas e despacha a chamada quando o limite de signatÃ¡rios Ã© atingido              |
    |   `cancel_as_multi`    |                                         Cancela uma transaÃ§Ã£o de mÃºltiplas assinaturas prÃ©-existente e em andamento                                          |

## Pausando TransaÃ§Ãµes {: #pausing-transactions }

Como vocÃª sabe, a conta Sudo [pode executar aÃ§Ãµes privilegiadas](/pt/builders/manage/developer-portal/sudo/){target=\_blank}, como atualizaÃ§Ãµes de rede, criaÃ§Ã£o de novos tokens e, neste caso, pausar e despausar transaÃ§Ãµes.

Para pausar uma transaÃ§Ã£o, navegue atÃ© a guia **Desenvolvedor** do Polkadot.js Apps para sua rede Powered by Tanssi e clique em **Sudo**. Se vocÃª nÃ£o vir **Sudo** neste menu, nÃ£o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua [conta Sudo seja injetada por sua carteira e conectada aos Polkadot.js Apps](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Em seguida, siga as seguintes etapas:

1. Selecione o mÃ³dulo **txPause**
2. Selecione o mÃ©todo **pause**
3. Insira o nome do **mÃ³dulo** que contÃ©m a transaÃ§Ã£o que serÃ¡ pausada
4. Insira o nome da **transaÃ§Ã£o** que serÃ¡ pausada
5. Pressione **Submit Sudo** e confirme a transaÃ§Ã£o no pop-up resultante

Neste exemplo, a transaÃ§Ã£o pausada Ã© `transfer_allow_death` do mÃ³dulo `Balances`:

![Pausar transaÃ§Ã£o](/images/builders/manage/developer-portal/pause-transactions/pause-transactions-2.webp)

Para verificar se a transaÃ§Ã£o foi efetivamente pausada, tente executÃ¡-la. VocÃª deve obter um erro.

![Verificar que a transaÃ§Ã£o estÃ¡ pausada](/images/builders/manage/developer-portal/pause-transactions/pause-transactions-3.webp)

!!! warning
    A transaÃ§Ã£o `pause` nÃ£o verifica os nomes dos mÃ³dulos ou transaÃ§Ãµes e diferencia maiÃºsculas de minÃºsculas, portanto, qualquer erro de digitaÃ§Ã£o passarÃ¡ despercebido e a transaÃ§Ã£o serÃ¡ executada com sucesso. VocÃª sempre deve verificar se a transaÃ§Ã£o foi efetivamente pausada.

## Despausando TransaÃ§Ãµes {: #unpausing-transactions }

Para despausar uma transaÃ§Ã£o e retornÃ¡-la Ã  operaÃ§Ã£o normal, navegue atÃ© a guia **Desenvolvedor** do Polkadot.js Apps para sua rede Powered by Tanssi e clique em **Sudo**. Se vocÃª nÃ£o vir **Sudo** neste menu, vocÃª nÃ£o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua [conta Sudo seja injetada por sua carteira e conectada aos Polkadot.js Apps](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}. Em seguida, siga as seguintes etapas:

1. Selecione o mÃ³dulo **txPause**
2. Selecione o mÃ©todo **unpause**
3. Insira o nome do **mÃ³dulo** que contÃ©m a transaÃ§Ã£o que serÃ¡ despausada
4. Insira o nome da **transaÃ§Ã£o** que serÃ¡ despausada
5. Pressione **Submit Sudo** e confirme a transaÃ§Ã£o no pop-up resultante

Neste exemplo, a transaÃ§Ã£o a ser despausada Ã© `transfer_allow_death` do mÃ³dulo `Balances`:

![Retomar transaÃ§Ã£o](/images/builders/manage/developer-portal/pause-transactions/pause-transactions-4.webp)

A transaÃ§Ã£o `unpause` Ã© executada com sucesso somente se os parÃ¢metros do mÃ³dulo e da transaÃ§Ã£o tiverem sido pausados â€‹â€‹anteriormente; caso contrÃ¡rio, ela falha. ApÃ³s o despausamento bem-sucedido, a transaÃ§Ã£o pode ser chamada e executada novamente.

E Ã© isso! A seÃ§Ã£o [Portal do Desenvolvedor](/pt/builders/manage/developer-portal/) tem muitos mais guias sobre como gerenciar sua rede Tanssi.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/developer-portal/smart-contracts-creation-filter/
--- BEGIN CONTENT ---
---
title: Smart EVM - ImplantaÃ§Ãµes de Contratos Whitelistados
description: Aprenda como usar o Sudo para whitelistar implantadores de contratos inteligentes para sua rede Smart EVM powered by Tanssi, aumentando a seguranÃ§a geral.
icon: octicons-file-binary-24
categories: Appchain, EVM-Template
---

# Smart EVM - ImplantaÃ§Ãµes de Contratos Whitelistados

## IntroduÃ§Ã£o {: #introduction }

Redes powered by Tanssi compatÃ­veis com EVM se beneficiam de um recurso exclusivo: o governador da rede pode definir quais contas estÃ£o autorizadas a implantar contratos inteligentes, proibindo a aÃ§Ã£o para qualquer outra conta nÃ£o whitelistada.

Este recurso traz vÃ¡rios benefÃ­cios importantes que podem ser uma Ã³tima opÃ§Ã£o para diferentes casos de uso ou contextos. Alguns desses benefÃ­cios sÃ£o:

- **SeguranÃ§a aprimorada** - ao restringir a implantaÃ§Ã£o a contas confiÃ¡veis, o risco de implantar contratos inteligentes maliciosos ou vulnerÃ¡veis Ã© reduzido
- **Garantia de qualidade** - contas conhecidas e verificadas podem ser obrigadas a seguir padrÃµes de codificaÃ§Ã£o especÃ­ficos e passar por testes completos antes da implantaÃ§Ã£o
- **Conformidade regulatÃ³ria** - os casos de uso que sÃ£o altamente regulamentados podem limitar a implantaÃ§Ã£o para garantir que os contratos inteligentes atendam aos requisitos legais e de conformidade
- **PrevenÃ§Ã£o de spam e abuso** - impedir que maus atores implantem um grande nÃºmero de contratos desnecessÃ¡rios ou prejudiciais

Neste guia, vocÃª aprenderÃ¡ como usar a conta Sudo para gerenciar as contas whitelistadas que podem implantar contratos inteligentes em sua rede.

## Verificando os PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia, vocÃª precisarÃ¡ ter o seguinte:

- Uma rede powered by Tanssi compatÃ­vel com EVM (Teste RÃ¡pido ou Dedicado) executando o [runtime 700](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank} ou superior. Qualquer nova implantaÃ§Ã£o de rede baseada no [Template EVM](/pt/builders/build/templates/evm/){target=\_blank} servirÃ¡
- A conta Sudo da sua rede conectada aos seus Polkadot.js Apps da rede. VocÃª pode consultar o [Guia de Gerenciamento de Sudo](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} para obter instruÃ§Ãµes sobre como injetar sua conta Sudo nos Polkadot.js Apps

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## ComeÃ§ando {: #getting-started }

Para seguir as prÃ³ximas seÃ§Ãµes deste guia, acesse os Polkadot.js Apps para sua rede Tanssi. O link para os Polkadot.js Apps para sua rede Tanssi pode ser encontrado em seu [Painel Tanssi](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Tooling**.

![Localizando seu Link de Polkadot.js Apps em apps.tanssi.network](/images/builders/manage/developer-portal/smart-contracts-creation-filter/smart-contracts-creation-filter-1.webp)

Depois de acessar os Polkadot.js Apps, navegue atÃ© a guia **Developer** e clique em **Sudo**.

!!! note
    Se vocÃª nÃ£o vir **Sudo** neste menu, nÃ£o associou a conta Sudo aos Polkadot.js Apps. Certifique-se de que sua [conta Sudo seja injetada pela sua carteira e conectada aos Polkadot.js Apps](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}.

## Contas Whitelistadas {: #whitelist-accounts }

Para definir as contas que terÃ£o autorizaÃ§Ã£o para implantar contratos inteligentes, [comece a usar seus Polkadot.js Apps](#getting-started) e siga as etapas a seguir:

1. Selecione a paleta **parameters**. **setParameter** serÃ¡ selecionado automaticamente no seletor de funÃ§Ãµes e **ContractDeployFilter** no parÃ¢metro **keyValue**
2. Duas opÃ§Ãµes estarÃ£o disponÃ­veis no seletor **ContractDeployFilter**: **AllowedAddressesToCreate** e **AllowedAddressesToCreateInner**. Selecione a opÃ§Ã£o **AllowedAddressesToCreate** se quiser whitelistar as contas para implantaÃ§Ãµes de contratos inteligentes e a Ãºltima para whitelistar as contas para implantaÃ§Ãµes indiretas (por meio de uma chamada de contrato inteligente)
3. Alterne a chave **Include option**
4. Selecione a opÃ§Ã£o **Whitelisted**
5. Insira a conta whitelistada
6. Se vocÃª precisar inserir mais de uma conta, clique em **Add item**
7. Pressione **Submit Sudo** e confirme a transaÃ§Ã£o em sua carteira

![Contas Whitelistadas](/images/builders/manage/developer-portal/smart-contracts-creation-filter/smart-contracts-creation-filter-2.webp)

Essas mesmas etapas podem ser repetidas a qualquer momento para remover uma conta da whitelist ou para adicionar novas.

## Restaurando PermissÃµes para Implantar Contratos Inteligentes {: #restoring-permission}

Se vocÃª autorizou anteriormente algumas contas a implantar contratos inteligentes e deseja permitir que qualquer conta implante contratos inteligentes (desde que possam cobrir taxas de transaÃ§Ã£o regulares), [comece a usar seus Polkadot.js Apps](#getting-started) e siga as etapas a seguir:

1. Selecione a paleta **parameters**. **setParameter** serÃ¡ selecionado automaticamente no seletor de funÃ§Ãµes e **ContractDeployFilter** no parÃ¢metro **keyValue**
2. Duas opÃ§Ãµes estarÃ£o disponÃ­veis no seletor **ContractDeployFilter**: **AllowedAddressesToCreate** e **AllowedAddressesToCreateInner**. Selecione a opÃ§Ã£o **AllowedAddressesToCreate** se quiser limpar a whitelist para implantaÃ§Ãµes de contratos inteligentes e a Ãºltima para limpar a whitelist para implantaÃ§Ãµes indiretas (por meio de uma chamada de contrato inteligente)
3. Alterne a chave **Include option**
4. Selecione a opÃ§Ã£o **All**
5. Pressione **Submit Sudo** e confirme a transaÃ§Ã£o em sua carteira

![Limpando as Contas Whitelistadas](/images/builders/manage/developer-portal/smart-contracts-creation-filter/smart-contracts-creation-filter-3.webp)

## Consultando as Contas Whitelistadas {: #query-whitelisted-accounts }

Para obter a configuraÃ§Ã£o atual contendo as contas whitelistadas que podem implantar contratos inteligentes, acesse os Polkadot.js Apps (conforme explicado na seÃ§Ã£o [ComeÃ§ando](#getting-started)), navegue atÃ© a guia **Developer**, clique em **Chain state** e siga as etapas a seguir:

1. Selecione o armazenamento **parameters**
2. Selecione a opÃ§Ã£o **parameters(ContainerChainTemplateFrontierRuntimeParametersKey)**
3. Certifique-se de que a chave **Include option** estÃ¡ ligada
4. Certifique-se de que a opÃ§Ã£o **ContractDeployFilter** estÃ¡ selecionada
5. Duas opÃ§Ãµes estarÃ£o disponÃ­veis no seletor **ContractDeployFilter**: **AllowedAddressesToCreate** e **AllowedAddressesToCreateInner**. Selecione a opÃ§Ã£o **AllowedAddressesToCreate** se quiser consultar a whitelist para implantaÃ§Ãµes de contratos inteligentes e a Ãºltima para consultar a whitelist para implantaÃ§Ãµes indiretas (por meio de uma chamada de contrato inteligente)
6. Clique no botÃ£o **+**
7. A configuraÃ§Ã£o atual serÃ¡ exibida

![Consultando as Whitelists](/images/builders/manage/developer-portal/smart-contracts-creation-filter/smart-contracts-creation-filter-4.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/developer-portal/sudo/
--- BEGIN CONTENT ---
---
title: Gerenciando a Conta Sudo
description: Aprenda como gerenciar a conta Sudo da sua rede, incluindo como visualizar e importar a chave Sudo no Polkadot.js Apps e alterar a chave Sudo atual.
icon: octicons-key-24
categories: Appchain
---

# Gerenciando a Conta Sudo da Sua Rede

## IntroduÃ§Ã£o {: #introduction }

[Sudo](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\_blank} Ã© um mÃ³dulo que permite que chamadas de Runtime privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo Ã©, por vezes, coloquialmente referido como um superusuÃ¡rio ou uma conta semelhante a um deus. SÃ³ pode haver uma Ãºnica conta Sudo de cada vez. No entanto, as chaves Sudo podem ser rodadas para dar privilÃ©gios Sudo a uma nova conta.

Todas as redes powered by Tanssi vÃªm com a paleta Sudo por padrÃ£o, e vocÃª Ã© obrigado a designar uma conta como o endereÃ§o Sudo ao lanÃ§ar sua rede. Isso permite que vocÃª execute aÃ§Ãµes privilegiadas para gerenciar sua cadeia, como atualizar seu Runtime ou cunhar novos tokens nativos. Embora a paleta Sudo seja necessÃ¡ria para lanÃ§ar sua rede Tanssi no TestNet, vocÃª pode desativar a paleta Sudo e fazer a transiÃ§Ã£o para a governanÃ§a descentralizada apÃ³s o lanÃ§amento do MainNet.

No guia a seguir, vocÃª aprenderÃ¡ como visualizar a conta Sudo atual da sua rede e como alterÃ¡-la, alÃ©m de importÃ¡-la para o Polkadot.js Apps. Existem guias semelhantes nesta seÃ§Ã£o explicando como usar a conta Sudo para realizar aÃ§Ãµes privilegiadas, como [atualizar seu Runtime](/pt/builders/manage/developer-portal/upgrade/){target=\_blank} e [cunhar tokens nativos](/pt/builders/manage/developer-portal/minting/){target=\_blank}.

## Verificando os PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia, vocÃª precisarÃ¡ ter o seguinte:

- Uma rede powered by Tanssi (Quick Trial ou Dedicated)
- A conta Sudo da sua rede conectada ao Polkadot.js Apps da sua rede

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

### Configurando o Polkadot.js Apps { : #configuring-polkadotjs-apps }

Depois de navegar para o Polkadot.js Apps da sua rede, vocÃª precisarÃ¡ adicionar sua conta Sudo. Injetar sua conta Sudo no Polkadot.js Apps a partir de uma extensÃ£o do navegador Ã© considerado mais seguro do que armazenar contas diretamente no navegador. No entanto, vocÃª ainda pode importar sua conta Sudo diretamente para o cache do navegador. Esse mÃ©todo nÃ£o requer o uso de nenhuma extensÃ£o. Para importar uma conta para o Polkadot.js dessa maneira, siga as etapas:

1. Clique em **ConfiguraÃ§Ãµes**
2. Em **criaÃ§Ã£o de conta no navegador**, selecione **Permitir a criaÃ§Ã£o de conta local no navegador**
3. Pressione **Salvar**

![Permitir a criaÃ§Ã£o de armazenamento no navegador](/images/builders/manage/developer-portal/sudo/sudo-2.webp)

Em seguida, volte para a guia contas e pressione **Conta**. VocÃª poderÃ¡ substituir a chave privada prÃ©-gerada pela da sua conta Sudo.

![Adicionando conta no Polkadot.js Apps](/images/builders/manage/developer-portal/sudo/sudo-3.webp)

!!! warning
    O armazenamento de chaves no navegador nÃ£o Ã© adequado para ambientes de produÃ§Ã£o. Este exemplo Ã© fornecido apenas para fins de demonstraÃ§Ã£o em um ambiente TestNet.

## Alterando a Conta Sudo {: #changing-the-sudo-account }

A alteraÃ§Ã£o da conta Sudo da sua rede powered by Tanssi Ã© um processo simples. TambÃ©m conhecido como rotaÃ§Ã£o de suas chaves Sudo, esse processo removerÃ¡ o acesso Sudo da conta Sudo existente e concederÃ¡ Ã  nova conta. SÃ³ pode haver uma conta Sudo a qualquer momento. No entanto, vocÃª Ã© livre para alterar a conta Sudo quantas vezes quiser.

Antes de comeÃ§ar, certifique-se de ter sua conta Sudo existente acessÃ­vel no [Polkadot.js Apps](#configuring-polkadotjs-apps). Em seguida, siga as etapas:

1. Navegue atÃ© a guia **Desenvolvedor** do Polkadot.js Apps da sua rede
2. Clique em **Sudo**. Se vocÃª nÃ£o vir **Sudo** neste menu, nÃ£o associou a conta Sudo ao Polkadot.js Apps. Certifique-se de que sua conta Sudo seja injetada pela sua carteira e conectada ao Polkadot.js Apps
3. Selecione o tÃ­tulo **Definir chave Sudo**
4. Selecione a nova conta para a qual vocÃª transferirÃ¡ os privilÃ©gios Sudo
5. Pressione **Reatribuir** e confirme a transaÃ§Ã£o em sua carteira

![Alterar a conta Sudo no Polkadot.js Apps](/images/builders/manage/developer-portal/sudo/sudo-4.webp)

!!! note
    Certifique-se de ter acesso Ã  nova conta Sudo. Assim que o Sudo for transferido, ele nÃ£o poderÃ¡ ser desfeito sem acesso Ã  chave Sudo atual.

E Ã© isso! A seÃ§Ã£o [Portal do Desenvolvedor](/pt/builders/manage/developer-portal/) tem muitos mais guias sobre como gerenciar sua rede Tanssi.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/developer-portal/upgrade/
--- BEGIN CONTENT ---
---
title: Atualize o Runtime da Sua Appchain
description: Aprenda como usar a conta Sudo para realizar a aÃ§Ã£o privilegiada de atualizaÃ§Ã£o do runtime da sua appchain powered by Tanssi atravÃ©s do portal do desenvolvedor.
icon: octicons-arrow-up-24
categories: Appchain
---

# Atualizando o Runtime da Sua Appchain com Sudo

## IntroduÃ§Ã£o {: #introduction }

[Sudo](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\_blank} Ã© um mÃ³dulo que permite que chamadas de Runtime privilegiadas sejam despachadas quando chamadas da conta Sudo. Sudo Ã© por vezes coloquialmente referido como um superusuÃ¡rio ou uma conta semelhante a um deus. Isso permite que vocÃª realize aÃ§Ãµes privilegiadas no curso do gerenciamento da sua appchain, como a atualizaÃ§Ã£o do Runtime da sua appchain powered by Tanssi.

Neste guia, vocÃª aprenderÃ¡ como usar o Sudo para atualizar o runtime da sua appchain. Com acesso Sudo, atualizar sua cadeia Ã© um processo rÃ¡pido e fÃ¡cil. Observe que as equipas de appchain em produÃ§Ã£o terÃ£o a opÃ§Ã£o de eliminar gradualmente o acesso Sudo e confiar na governanÃ§a para processar as atualizaÃ§Ãµes de Runtime.

## Verificando os PrÃ©-Requisitos {: #checking-prerequisites }

Para o exemplo neste guia, vocÃª precisarÃ¡ ter o seguinte:

- Uma appchain powered by Tanssi (Quick Trial, Dedicated ou MainNet).
- A conta Sudo da sua appchain conectada ao portal do desenvolvedor da sua appchain. VocÃª pode consultar o [guia de Gerenciamento do Sudo](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank} para obter instruÃ§Ãµes sobre como injetar a sua conta Sudo no portal do desenvolvedor.
- O novo ficheiro binÃ¡rio de [runtime Wasm](/pt/learn/framework/architecture/#runtime){target=\_blank}, compilado com uma versÃ£o superior Ã  atual.

Se vocÃª nÃ£o souber qual Ã© a conta Sudo da sua rede Tanssi, Ã© possÃ­vel encontrÃ¡â€‘la no [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Properties**.

![Localizando seu endereÃ§o Sudo em apps.tanssi.network](/images/builders/manage/locate-sudo-account.webp)

!!! warning
    Ã‰ fundamental proteger a chave da sua conta Sudo com o mÃ¡ximo de cuidado, pois ela concede acesso privilegiado Ã  sua rede Tanssi.

## Obtendo o Runtime Wasm {: #obtaining-wasm-runtime }

Se a sua cadeia for baseada em um dos Templates oficiais, vocÃª pode baixar o arquivo binÃ¡rio oficial de runtime Wasm na tabela abaixo. Os lanÃ§amentos oficiais sÃ£o publicados na [seÃ§Ã£o de lanÃ§amentos](https://github.com/moondance-labs/tanssi/releases){target_blank} no repositÃ³rio Tanssi.

|                                               VersÃ£o                                                |                                                                             Template EVM                                                                              |                                                                            Template Substrate                                                                             |
|:----------------------------------------------------------------------------------------------------:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| [1400](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1400-templates){target=\_blank} | [Download EVM V1400 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1400-templates/frontier-template-runtime-1400.wasm){target=\_blank} | [Download Substrate V1400 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1400-templates/simple-template-runtime-1400.wasm){target=\_blank} |
| [1300](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1300-templates){target=\_blank} | [Download EVM V1300 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1300-templates/frontier-template-runtime-1300.wasm){target=\_blank} | [Download Substrate V1300 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1300-templates/simple-template-runtime-1300.wasm){target=\_blank} |
| [1201](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1201-templates){target=\_blank} | [Download EVM V1201 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1201-templates/frontier-template-runtime-1201.wasm){target=\_blank} | [Download Substrate V1201 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1201-templates/simple-template-runtime-1201.wasm){target=\_blank} |
| [1100](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1100-templates){target=\_blank} | [Download EVM V1100 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1100-templates/frontier-template-runtime-1100.wasm){target=\_blank} | [Download Substrate V1100 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1100-templates/simple-template-runtime-1100.wasm){target=\_blank} |
| [1000](https://github.com/moondance-labs/tanssi/releases/tag/runtime-1000-templates){target=\_blank} | [Download EVM V1000 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1000-templates/frontier-template-runtime-1000.wasm){target=\_blank} | [Download Substrate V1000 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-1000-templates/simple-template-runtime-1000.wasm){target=\_blank} |
|  [900](https://github.com/moondance-labs/tanssi/releases/tag/runtime-900-templates){target=\_blank}  |  [Download EVM V900 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-900-templates/frontier-template-runtime-900.wasm){target=\_blank}   |  [Download Substrate V900 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-900-templates/simple-template-runtime-900.wasm){target=\_blank}   |
|       [800](https://github.com/moondance-labs/tanssi/releases/tag/runtime-800){target=\_blank}       |       [Download EVM V800 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-800/frontier-template-runtime-800.wasm){target=\_blank}        |       [Download Substrate V800 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-800/simple-template-runtime-800.wasm){target=\_blank}        |
|       [700](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank}       |       [Download EVM V700 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-700/frontier-template-runtime-700.wasm){target=\_blank}        |       [Download Substrate V700 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-700/simple-template-runtime-700.wasm){target=\_blank}        |
|       [600](https://github.com/moondance-labs/tanssi/releases/tag/runtime-600){target=\_blank}       |       [Download EVM V600 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-600/frontier-template-runtime-600.wasm){target=\_blank}        |       [Download Substrate V600 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-600/simple-template-runtime-600.wasm){target=\_blank}        |
|       [500](https://github.com/moondance-labs/tanssi/releases/tag/runtime-500){target=\_blank}       |       [Download EVM V500 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-500/frontier-template-runtime-500.wasm){target=\_blank}        |       [Download Substrate V500 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-500/simple-template-runtime-500.wasm){target=\_blank}        |
|  [400](https://github.com/moondance-labs/tanssi/releases/tag/runtime-400-templates){target=\_blank}  |  [Download EVM V400 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-400-templates/frontier-template-runtime-400.wasm){target=\_blank}   |  [Download Substrate V400 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-400-templates/simple-template-runtime-400.wasm){target=\_blank}   |
|  [300](https://github.com/moondance-labs/tanssi/releases/tag/templates-runtime-300){target=\_blank}  |  [Download EVM V300 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/templates-runtime-300/frontier-template-runtime-300.wasm){target=\_blank}   |  [Download Substrate V300 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/templates-runtime-300/simple-template-runtime-300.wasm){target=\_blank}   |
|       [200](https://github.com/moondance-labs/tanssi/releases/tag/runtime-200){target=\_blank}       |       [Download EVM V200 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-200/frontier-template-runtime-200.wasm){target=\_blank}        |       [Download Substrate V200 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-200/simple-template-runtime-200.wasm){target=\_blank}        |
|  [101](https://github.com/moondance-labs/tanssi/releases/tag/runtime-101-templates){target=\_blank}  |  [Download EVM V101 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-101-templates/frontier-template-runtime-101.wasm){target=\_blank}   |  [Download Substrate V101 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-101-templates/simple-template-runtime-101.wasm){target=\_blank}   |
|  [100](https://github.com/moondance-labs/tanssi/releases/tag/runtime-100-templates){target=\_blank}  |  [Download EVM V100 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-100-templates/frontier-template-runtime-100.wasm){target=\_blank}   |  [Download Substrate V100 Wasm file](https://github.com/moondance-labs/tanssi/releases/download/runtime-100-templates/simple-template-runtime-100.wasm){target=\_blank}   |

VocÃª deve sempre atualizar o Runtime seguindo as versÃµes de forma ordenada, aplicando uma versÃ£o apÃ³s a outra sem pular nenhuma delas. Para isso, vocÃª precisa saber a versÃ£o atual do Runtime da sua appchain, que vocÃª encontrarÃ¡ no seu [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Propriedades**. Por exemplo, se a versÃ£o do seu Runtime for `1000`, vocÃª deverÃ¡ atualizar primeiro para `1100`, depois para `1201`, depois para `1300` e assim por diante atÃ© a versÃ£o mais recente disponÃ­vel.

!!! warning
    Aplicar as atualizaÃ§Ãµes em ordem garante que as alteraÃ§Ãµes (migraÃ§Ãµes) nas estruturas de dados internas sejam aplicadas, preservando a consistÃªncia dos dados. Caso contrÃ¡rio, pode **paralisar** sua appchain.

!!! note
    Se estiver compilando o Runtime manualmente, certifique-se de usar a versÃ£o Wasm `compact` e `compressed`, que Ã© otimizada e mais leve.

## Atualizando Seu Runtime {: #upgrading-your-runtime }

Para comeÃ§ar, acesse o portal do desenvolvedor da sua appchain Tanssi, que pode ser encontrado no seu [Tanssi Dashboard](https://apps.tanssi.network){target=\_blank} na seÃ§Ã£o **Ferramentas**.

![Localizar seu Link do Portal do Desenvolvedor em apps.tanssi.network](/images/builders/manage/developer-portal/upgrade/upgrade-1.webp)

!!! warning
    Se a sua appchain foi implantada usando um Template oficial e a atualizaÃ§Ã£o pretendida Ã© um runtime personalizado, certifique-se de ter alterado o nome padrÃ£o da especificaÃ§Ã£o (*frontier-template* ou *container-chain-template*) para um diferente antes de construir o arquivo Wasm. VocÃª tambÃ©m precisarÃ¡ executar a extrÃ­nseca `setCodeWithoutChecks` em vez de `setCode`.

Com o seu [Runtime Wasm](/learn/framework/architecture/#runtime){target=\_blank} pronto para ser carregado e a sua [conta Sudo acessÃ­vel no portal do desenvolvedor](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}, siga as seguintes etapas:

1. Navegue atÃ© a aba **Desenvolvedor** do portal do desenvolvedor da sua appchain Tanssi.
2. Clique em **Sudo**. Se vocÃª nÃ£o vir **Sudo** neste menu, Ã© porque vocÃª nÃ£o associou a conta Sudo ao portal do desenvolvedor. Certifique-se de que a sua [conta Sudo estÃ¡ injetada pela sua carteira e conectada ao portal do desenvolvedor](/pt/builders/manage/developer-portal/sudo/#configuring-polkadotjs-apps){target=\_blank}.
3. Selecione o pallet **system**.
4. Selecione **setCode**.
5. Alterne a chave **fileUpload** para habilitar o upload do seu arquivo de runtime Wasm.
6. FaÃ§a o upload do seu runtime Wasm.
7. Pressione **Enviar Sudo** e confirme a transaÃ§Ã£o na sua carteira.
![Atualizando seu Runtime no Portal do Desenvolvedor](/images/builders/manage/developer-portal/upgrade/upgrade-2.webp)

VocÃª pode verificar se a atualizaÃ§Ã£o do seu runtime foi bem-sucedida verificando a versÃ£o do runtime no canto superior esquerdo. Nesse caso, vocÃª pode ver que o runtime da appchain powered by Tanssi foi atualizado com sucesso para a versÃ£o `400`.

![Verificar a versÃ£o do Runtime no Polkadot.js Apps](/images/builders/manage/developer-portal/upgrade/upgrade-3.webp)

E Ã© isso! A seÃ§Ã£o [portal do desenvolvedor](/pt/builders/manage/developer-portal/) tem muitos outros guias sobre como gerenciar sua appchain Tanssi.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/manage/
--- BEGIN CONTENT ---
---
title: Gerencie sua Rede
description: Saiba como usar o portal do desenvolvedor e o Tanssi dApp para gerenciar sua rede, incluindo a cunhagem de tokens, o pagamento por serviÃ§os de produÃ§Ã£o de blocos e muito mais.
icon: octicons-gear-24
template: index-page.html
---

# Gerenciando sua Rede powered by Tanssi

A Tanssi dApp e o portal do desenvolvedor servem a propÃ³sitos diferentes ao gerenciar sua rede, oferecendo benefÃ­cios exclusivos adaptados Ã s suas necessidades:

- **[Tanssi dApp](https://apps.tanssi.network){target=\_blank}** - simplifica todo o ciclo de vida da rede, desde a implantaÃ§Ã£o atÃ© o gerenciamento bÃ¡sico. Ao remover as complexidades tÃ©cnicas, ela permite uma experiÃªncia mais rÃ¡pida e simplificada para criar e gerenciar redes. Algumas aÃ§Ãµes que podem ser executadas via dApp incluem:

  - [Pagamento por serviÃ§os de produÃ§Ã£o de blocos](/pt/builders/manage/dapp/services-payment/)
  - [Gerenciamento de tokens](/pt/builders/manage/dapp/manage-tokens/) (cunhagem e transferÃªncia de tokens, atualizaÃ§Ã£o de saldos e muito mais)

- **Developer portal** - construÃ­do sobre Polkadot.js Apps, o portal do desenvolvedor fornece ferramentas avanÃ§adas para gerenciamento de rede, sendo ideal para tarefas que exigem controle e personalizaÃ§Ã£o. Algumas aÃ§Ãµes que podem ser executadas atravÃ©s do portal do desenvolvedor incluem:

  - [Gerenciamento da conta Sudo](/pt/builders/manage/developer-portal/sudo/)
  - [Envio de atualizaÃ§Ãµes de runtime](/pt/builders/manage/developer-portal/upgrade/)
  - [Cunhagem de tokens](/pt/builders/manage/developer-portal/minting/)
  - [Pausar transaÃ§Ãµes](/pt/builders/manage/developer-portal/pause-transactions/) ou [habilitar modo de manutenÃ§Ã£o](/pt/builders/manage/developer-portal/maintenance/) em emergÃªncias

Passe para as seÃ§Ãµes abaixo para explorar como cada ferramenta ajuda vocÃª a gerenciar sua rede powered by Tanssi de forma eficiente.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/tanssi-network/endpoints/
--- BEGIN CONTENT ---
---
title: Endpoints da Rede
description: As redes Tanssi tÃªm dois endpoints disponÃ­veis para os usuÃ¡rios se conectarem, um para HTTPS e outro para WSS. Esta pÃ¡gina traz os endpoints RPC de que vocÃª precisa para comeÃ§ar.
icon: octicons-share-android-24
categories: Reference
---

## Pontos Finais da Rede

As redes Tanssi tÃªm dois pontos finais disponÃ­veis para os utilizadores se conectarem: um para HTTPS e outro para WSS.

## MainNet Tanssi 

Os pontos finais HTTPS e WSS da Tanssi Network MainNet sÃ£o os seguintes:

=== "HTTPS"

    ```text
    https://{{ networks.mainnet.dns_name }}
    ```

=== "WSS"

    ```text
    wss://{{ networks.mainnet.dns_name }}
    ```


## Dancelight

Os pontos finais HTTPS e WSS da Tanssi TestNet sÃ£o os seguintes:

=== "HTTPS"

    ```text
    https://{{ networks.dancelight.dns_name }}
    ```

=== "WSS"

    ```text
    wss://{{ networks.dancelight.dns_name }}
    ```

### Rede Demo EVM

Os pontos finais HTTPS e WSS da rede Demo EVM sÃ£o os seguintes:

=== "HTTPS"

    ```text
    {{ networks.dancelight.demo_evm_rpc_url }}
    ```

=== "WSS"

    ```text
    {{ networks.dancelight.demo_evm_rpc_wss_url }}
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/tanssi-network/
--- BEGIN CONTENT ---
---
title: Fundamentos da Rede
description: Descubra tudo o que vocÃª precisa saber sobre o ecossistema Tanssi, suas diferentes redes e seus principais aspectos para comeÃ§ar a desenvolver e interagir com ele.
icon: octicons-star-24
template: index-page.html
---

# Fundamentos da Rede

ConheÃ§a a rede Tanssi, as TestNets disponÃ­veis e as principais funcionalidades e aspectos essenciais para comeÃ§ar a desenvolver e interagir com o ecossistema.

## VisÃ£o Geral da Rede

- **Token TANSSI**: o token utilitÃ¡rio nativo das redes Tanssi e sua representaÃ§Ã£o ERC-20.
- **Dancelight**: a TestNet oficial da Tanssi para implantaÃ§Ã£o e experimentaÃ§Ã£o rÃ¡pidas de rede.
- **Redes powered by Tanssi**: redes construÃ­das na plataforma Tanssi, alavancando seus recursos para criar blockchains personalizadas.
- **Rede Demo EVM**: uma rede compatÃ­vel com Ethereum que exemplifica uma rede totalmente operacional impulsionada pela Tanssi.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::

## Recursos Adicionais

<div class="subsection-wrapper">
  <div class="card">
    <a href="/builders/toolkit/">
      <div class="card-header">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M7.875 2.292a.114.114 0 0 0-.032.018A7.239 7.239 0 0 0 4.75 8.25a7.248 7.248 0 0 0 3.654 6.297c.57.327.982.955.941 1.682v.002l-.317 6.058a.75.75 0 1 1-1.498-.078l.317-6.062v-.004c.006-.09-.047-.215-.188-.296A8.749 8.749 0 0 1 3.25 8.25a8.738 8.738 0 0 1 3.732-7.169 1.547 1.547 0 0 1 1.709-.064c.484.292.809.835.809 1.46v4.714a.25.25 0 0 0 .119.213l2.25 1.385c.08.05.182.05.262 0l2.25-1.385a.25.25 0 0 0 .119-.213V2.478c0-.626.325-1.169.81-1.461a1.547 1.547 0 0 1 1.708.064 8.741 8.741 0 0 1 3.732 7.17 8.747 8.747 0 0 1-4.41 7.598c-.14.081-.193.206-.188.296v.004l.318 6.062a.75.75 0 1 1-1.498.078l-.317-6.058v-.002c-.041-.727.37-1.355.94-1.682A7.247 7.247 0 0 0 19.25 8.25a7.239 7.239 0 0 0-3.093-5.94.114.114 0 0 0-.032-.018l-.01-.001c-.003 0-.014 0-.031.01-.036.022-.084.079-.084.177V7.19c0 .608-.315 1.172-.833 1.49l-2.25 1.385a1.75 1.75 0 0 1-1.834 0l-2.25-1.384A1.752 1.752 0 0 1 8 7.192V2.477c0-.098-.048-.155-.084-.176a.068.068 0 0 0-.031-.011l-.01.001Z"></path></svg>
        <h2 class="title">Network Toolkit</h2>
      </div>
      <p class="description">Mergulhe em ferramentas e recursos projetados para simplificar o processo de desenvolvimento ao construir dApps nas redes Tanssi e powered by Tanssi.</p>
    </a>
  </div>
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/tanssi-network/mainnet/
--- BEGIN CONTENT ---
---
title: Comece com a Tanssi MainNet
description: A Tanssi Network MainNet estÃ¡ ativa, permitindo que os desenvolvedores aproveitem o protocolo descentralizado para lanÃ§ar appchains com seguranÃ§a de nÃ­vel Ethereum em minutos.
icon: octicons-star-24
---

# Comece a Usar a Tanssi Network MainNet

## IntroduÃ§Ã£o {: #introduction }

A Tanssi Network MainNet estÃ¡ ativa, permitindo que os desenvolvedores embarquem e lancem rapidamente suas appchains em questÃ£o de minutos.

Esta pÃ¡gina de referÃªncia rÃ¡pida oferece todos os elementos essenciais que vocÃª precisa para comeÃ§ar na Rede Tanssi.

## TANSSI Token {: #tanssi-token }

Os tokens {{ networks.mainnet.token_symbol }} servem como a moeda nativa dentro da Tanssi Network. Para iniciar a implantaÃ§Ã£o de uma rede na Tanssi, vocÃª precisarÃ¡ obter tokens {{ networks.mainnet.token_symbol }}.

## Endpoints de Rede {: #tanssi-network-endpoints }

A Tanssi MainNet possui dois tipos de endpoints disponÃ­veis para os usuÃ¡rios se conectarem: um para HTTPS e outro para WSS.

=== "HTTPS"

    ```text
    https://{{ networks.mainnet.dns_name }}/
    ```

=== "WSS"

    ```text
    wss://{{ networks.mainnet.dns_name }}
    ```

## Exploradores de Blocos {: #tanssi-block-explorers }

Para a Tanssi MainNet, vocÃª pode usar o seguinte block explorer:

- [Tanssi Network Subscan]({{ networks.mainnet.subscan_url }}){target=\_blank}
- [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/explorer){target=\_blank}

O suporte para exploradores de blocos adicionais estÃ¡ em andamento e, Ã  medida que mais exploradores suportarem a Tanssi MainNet, esta seÃ§Ã£o serÃ¡ atualizada de acordo.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/tanssi-network/tanssi-token/
--- BEGIN CONTENT ---
---
title: Token TANSSI
description: ConheÃ§a as duas versÃµes do token Tanssi â€” o token nativo do Substrate e a representaÃ§Ã£o ERC-20 no Ethereum â€” e suas utilidades e casos de uso.
icon: octicons-ruby-24
categories: Basics
---

# Token TANSSI {: #tanssi-token }

## IntroduÃ§Ã£o {: #introduction }

O token da rede Tanssi Ã© o token de utilidade que alimenta o protocolo Tanssi. Considerando a [arquitetura da Tanssi](/pt/learn/tanssi/overview/#tanssi-architecture){target=\_blank}, o token existe em duas representaÃ§Ãµes distintas, mas interconectadas: Substrate nativo e ERC-20 Ethereum. As duas versÃµes podem ser interligadas atravÃ©s da [bridge Tanssi-Ethereum](/pt/learn/tanssi/tanssi-ethereum-bridge/){target=\_blank}.

Neste guia, a utilidade do token e as diferenÃ§as entre suas duas representaÃ§Ãµes sÃ£o abordadas, o que Ã© crucial para operators de rede, stakers, gerentes de appchain e usuÃ¡rios em geral que desejam participar do ecossistema Tanssi.

## Utilidade do Token {: #token-utility }

A Tanssi Ã© um protocolo de infraestrutura descentralizado que facilita a implantaÃ§Ã£o de appchains com lÃ³gica personalizada. Ele permite que os desenvolvedores se concentrem no caso de uso, em vez de desviar tempo e energia para gerenciar [os vÃ¡rios componentes necessÃ¡rios](/pt/learn/tanssi/overview/#what-tanssi-provides){target=\_blank} para que uma rede funcione sem problemas.

A execuÃ§Ã£o de um protocolo descentralizado saudÃ¡vel nÃ£o sÃ³ requer um mecanismo de governanÃ§a robusto para garantir que as decisÃµes sejam tomadas de forma transparente, mas tambÃ©m o alinhamento de incentivos e coordenaÃ§Ã£o entre vÃ¡rios atores do ecossistema, incluindo desenvolvedores de appchain, node operators, operators de Sequencers, disponibilidade de dados e provedores de RPC, bem como usuÃ¡rios em geral. O token Tanssi serve como a espinha dorsal, fornecendo os mecanismos econÃ´micos necessÃ¡rios para coordenar, incentivar o comportamento adequado e proteger todo o ecossistema. Ele permite uma evoluÃ§Ã£o de protocolo verificÃ¡vel e imposta por cÃ³digo por meio de um processo de tomada de decisÃ£o totalmente na cadeia.

O token tem vÃ¡rias utilidades:

- **GovernanÃ§a on-chain**: os detentores de tokens podem usar o token para propor e votar em decisÃµes de governanÃ§a, como atualizaÃ§Ãµes de software, como gastar fundos do tesouro, alterar regras de protocolo e muito mais.
- **ImplantaÃ§Ã£o de Appchain**: use o token para registrar e lanÃ§ar seu appchain em minutos.
- **Pagamento do serviÃ§o de sequenciamento**: use o token para manter seu appchain ativo.
- **Recompensa de serviÃ§os de sequenciamento e operator**: obtenha tokens como recompensas pelos serviÃ§os de seus nÃ³s.
- **Staking em Sequencers**: os detentores de tokens podem apostar em Sequencers, recebendo recompensas sem risco de corte.
- **Staking em operators**: os detentores de tokens podem apostar em operators, recebendo recompensas por seus serviÃ§os de validaÃ§Ã£o.
- **Pagamento de taxas**: use o token para pagar as taxas de interaÃ§Ã£o com a rede Tanssi.

!!! note
    Todas as taxas de transaÃ§Ã£o na Tanssi sÃ£o pagas usando o token, com o valor total indo diretamente para financiar a conta do tesouro do protocolo. Esses fundos sÃ³ podem ser gastos via governanÃ§a.

## RepresentaÃ§Ãµes de Token {: #token-representations }

A rede Tanssi Ã© construÃ­da usando a estrutura Substrate, aproveitando sua arquitetura modular e alto desempenho. Portanto, o token nativo Ã© do tipo Substrate. Os mecanismos de cunhagem e queima do protocolo acontecem na rede Tanssi, ou, em outras palavras, acontecem na representaÃ§Ã£o do token Substrate.

AlÃ©m disso, o protocolo Tanssi conta com [provedores de seguranÃ§a externos](/pt/learn/tanssi/external-security-providers/){target=\_blank}, como o [Symbiotic](/pt/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}, para proteger o ecossistema por meio de ativos reapostados. Esse mecanismo de reaposta Ã© implementado no Ethereum; portanto, uma versÃ£o ERC-20 do token tambÃ©m existe para cobrir casos de uso no lado Ethereum.

Aproveitando os [recursos de bridging integrados Ã ](/pt/learn/tanssi/tanssi-ethereum-bridge/){target=\_blank} Tanssi, o token pode ser convertido para (e de) a representaÃ§Ã£o ERC-20 no Ethereum. Quando o token Ã© ponteado para Ethereum, os tokens sÃ£o travados na conta soberana da bridge, e uma mensagem Ã© enviada ao contrato Ethereum para cunhar a quantia equivalente em ERC-20. Esse mecanismo de travamento e cunhagem garante que a versÃ£o ERC-20 seja criada por meio de um mecanismo de bridging sem confianÃ§a, mantendo um relacionamento 1:1 com o token nativo.

```mermaid
flowchart LR
    subgraph Tanssi_Network ["Rede Tanssi"]
        Tanssi_Substrate["$TANSSI (Substrate)"]
        Tanssi_Substrate_Utility["âœ“ GovernanÃ§a on-chain
        âœ“ ImplantaÃ§Ã£o de Appchain
        âœ“ Recompensas de Sequencers
        âœ“ Staking em Sequencers
        âœ“ Pagamento de taxas
        "]
        Tanssi_Substrate --> Tanssi_Substrate_Utility
    end

    subgraph Ethereum_Network ["Ethereum"]
        Tanssi_ERC20["$TANSSI (ERC-20)"]
        Tanssi_ERC20_Utility["âœ“ Recompensa de serviÃ§os de operator
        âœ“ Staking em operators
        <pre> </pre>
        "]
        Tanssi_ERC20 --> Tanssi_ERC20_Utility
    end

    Bridge["Trustless Bridge"]

    Tanssi_Network <--> Bridge <--> Ethereum_Network

    %% Apply custom style to utility nodes
    classDef utility_style fill: transparent, stroke: transparent, text-align: start;
    class Tanssi_Substrate_Utility,Tanssi_ERC20_Utility utility_style;
    %% Make utility arrows transparent
    linkStyle 0 stroke:transparent,fill:transparent;
    linkStyle 1 stroke:transparent,fill:transparent;
```

### Tanssi (Substrate) - Token Nativo {: #tanssi-substrate }

O token Tanssi nativo existe na rede Tanssi como um ativo baseado em Substrate e Ã© a forma original do token que alimenta as operaÃ§Ãµes principais do protocolo.

Este token usa como [conta do tipo Substrate Sr25519](/pt/learn/tanssi/account-types/#key-types-in-tanssi-protocol){target=\_blank}, entÃ£o requer uma carteira como a [Talisman](/pt/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank} ou qualquer outra [carteira compatÃ­vel com Substrate](/pt/builders/toolkit/substrate-api/wallets/){target=\_blank}.

!!! note
    O token nativo Tanssi (Substrate) tem doze (12) casas decimais.

### Tanssi (ERC-20) - RepresentaÃ§Ã£o Ethereum {: #tanssi-erc-20 }

A versÃ£o ERC-20 da Tanssi Ã© um token Ethereum padrÃ£o que representa o token nativo na rede Ethereum. Essa versÃ£o Ã© criada por meio do mecanismo de bridge sem confianÃ§a, utilizando uma estratÃ©gia de bloqueio e cunhagem, mantendo assim um relacionamento 1:1 com o token nativo.

Este token, como qualquer outro ativo Ethereum, usa uma [conta ECDSA](/pt/learn/tanssi/account-types/#key-types-in-tanssi-protocol){target=\_blank}, entÃ£o requer uma carteira como [Metamask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} ou qualquer outra [carteira compatÃ­vel com Ethereum](/pt/builders/toolkit/ethereum-api/wallets/){target=\_blank}.

!!! note
    O Tanssi (ERC-20) tem doze (12) casas decimais.

### ComparaÃ§Ã£o Tanssi (Substrate) e Tanssi (ERC-20) {: #substrate-erc-20-comparison }

Para entender melhor as diferenÃ§as entre as duas representaÃ§Ãµes de token, a tabela a seguir fornece um resumo de seus principais recursos:

| **Recurso**            | **Tanssi (Substrate)**                                                                                                                                                                                                  | **Tanssi (ERC-20)**                                                                                                                                                                               |
|------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Rede**            | Rede Tanssi                                                                                                                                                                                                          | Ethereum MainNet                                                                                                                                                                                  |
| **PadrÃ£o de Token**     | Ativo Substrate nativo                                                                                                                                                                                                  | Token padrÃ£o ERC-20                                                                                                                                                                             |
| **Casas Decimais**     | Doze (12) decimais                                                                                                                                                                                                    | Doze (12) decimais                                                                                                                                                                              |
| **Tipo de Conta**       | [Sr25519](https://wiki.polkadot.com/learn/learn-cryptography/#keypairs-and-signing){target=\_blank}                                                                                                                  | [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm){target=\_blank}                                                                                                  |
| **Carteiras CompatÃ­veis** | [Talisman](/pt/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank}, [SubWallet](/pt/builders/toolkit/substrate-api/wallets/subwallet/){target=\_blank} e outros                                              | [MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}, [Talisman](/pt/builders/toolkit/ethereum-api/wallets/talisman/){target=\_blank} e outras carteiras compatÃ­veis com Ethereum |
| **Principais Utilidades**  | - ParticipaÃ§Ã£o na governanÃ§a on-chain<br/>- Registro e implantaÃ§Ã£o de Appchain<br/>- Pagamento de serviÃ§os de sequenciamento<br/>- Taxas de transaÃ§Ã£o na rede Tanssi<br/>- Staking em Sequencers<br/>- Recompensas de operaÃ§Ã£o do Sequencer | - Recompensas de validaÃ§Ã£o do operator<br/>- Staking em operators                                                                                                                                          |
| **OpÃ§Ãµes de Staking**    | Staking de Sequencer (para manter a atividade da appchain)                                                                                                                                        | Staking de operator (para validar/proteger todo o ecossistema Tanssi)                                                                                                                            |
| **ConversÃ£o de Bridge**  | Pode ser ponteado para ERC-20, pagando taxas em $TANSSI (Substrate)                                                                                                                                                            | Pode ser ponteado para Substrate, pagando taxas em $ETH                                                                                                                                                  |
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/tanssi-network/testnet/dancelight/
--- BEGIN CONTENT ---
---
title: ComeÃ§ar a Usar a Dancelight
description: Dancelight Ã© a Tanssi TestNet, e Ã© a maneira mais fÃ¡cil de comeÃ§ar a usar a Tanssi Network para implementar sua appchain compatÃ­vel com Substrate ou EVM.
icon: octicons-star-24
---

# ComeÃ§ar a Usar a Dancelight

## IntroduÃ§Ã£o {: #introduction }

Dancelight Ã© a primeira Tanssi TestNet pÃºblica e foi projetada para otimizar a implantaÃ§Ã£o de redes descentralizadas. Ela permite que as equipes embarquem e lancem rapidamente suas appchains em questÃ£o de minutos, fornecendo um ambiente robusto para testes e desenvolvimento.

Esta pÃ¡gina de referÃªncia rÃ¡pida oferece todos os elementos essenciais que vocÃª precisa para comeÃ§ar a usar a Dancelight.

## Tokens da TestNet {: #testnet-tokens }

Os tokens {{ networks.dancelight.token_symbol }} servem como a moeda nativa dentro da Tanssi Network. Para iniciar a implantaÃ§Ã£o de uma rede na Dancelight, vocÃª precisarÃ¡ obter tokens {{ networks.dancelight.token_symbol }}. Siga estas etapas:

1. Visite o site [Tanssi Network](https://www.tanssi.network/claim-dance-tokens){target=\_blank}.
2. Preencha o formulÃ¡rio, fornecendo informaÃ§Ãµes bÃ¡sicas e seu endereÃ§o baseado em Substrate.
3. Em atÃ© um dia Ãºtil apÃ³s o envio do formulÃ¡rio, vocÃª receberÃ¡ tokens {{ networks.dancelight.token_symbol }} para testes.

!!! note
    Os tokens {{ networks.dancelight.token_symbol }} nÃ£o tÃªm valor. Por favor, nÃ£o envie solicitaÃ§Ãµes desnecessÃ¡rias.

## Pontos de Extremidade da Rede {: #dancelight-network-endpoints }

Dancelight tem dois tipos de pontos de extremidade disponÃ­veis para os usuÃ¡rios se conectarem: um para HTTPS e outro para WSS.

=== "HTTPS"

    ```text
    https://{{ networks.dancelight.dns_name }}
    ```

=== "WSS"

    ```text
    wss://{{ networks.dancelight.dns_name }}
    ```

## Exploradores de Blocos {: #dancelight-block-explorers }

Para a Dancelight, vocÃª pode usar os seguintes exploradores de blocos:

- [Subscan]({{ networks.dancelight.subscan_url }}){target=\_blank}.
- [O portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/explorer){target=\_blank}.

O suporte para exploradores de blocos adicionais estÃ¡ em andamento e, Ã  medida que mais exploradores suportarem a Dancelight, esta seÃ§Ã£o serÃ¡ atualizada de acordo.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/tanssi-network/testnet/demo-evm-network/
--- BEGIN CONTENT ---
---
title: Rede de DemonstraÃ§Ã£o EVM Tanssi
description: Teste nossa rede de demonstraÃ§Ã£o EVM Tanssi para descobrir as capacidades de uma rede totalmente compatÃ­vel com Ethereum, implantada atravÃ©s da Tanssi em apenas alguns minutos.
icon: material-ethereum
categories: Appchain, EVM-Template
---

## IntroduÃ§Ã£o {: #introduction }

Explore as funcionalidades de uma rede totalmente compatÃ­vel com Ethereum, implantada atravÃ©s da Tanssi, interagindo com a rede EVM de demonstraÃ§Ã£o em [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.

Esta pÃ¡gina de referÃªncia rÃ¡pida oferece todos os elementos essenciais de que vocÃª precisa para interagir com esta rede de demonstraÃ§Ã£o.

## Faucet para Tokens TestNet {: #faucet }

VocÃª pode acessar tokens {{ networks.dancelight.demo_evm_token_symbol }}, a moeda nativa da rede de demonstraÃ§Ã£o EVM, na faucet no [Tanssi dApp](https://apps.tanssi.network/demo){target=\_blank}. VocÃª pode receber atÃ© 100 tokens {{ networks.dancelight.demo_evm_token_symbol }} a cada 12 horas.

Para solicitar tokens da faucet, acesse o [Tanssi dApp](https://apps.tanssi.network/demo){target=\_blank} e pressione **Adicionar ao MetaMask**.

![Adicionar ao MetaMask](/images/builders/tanssi-network/testnet/demo-evm-network/demo-1.webp)

Em seguida, siga estas etapas:

1. Pressione **Solicitar Tokens**
2. Selecione a conta que vocÃª gostaria de receber tokens {{ networks.dancelight.demo_evm_token_symbol }} e pressione **AvanÃ§ar**
3. Pressione **Conectar**

![Solicitar tokens](/images/builders/tanssi-network/testnet/demo-evm-network/demo-2.webp)

!!! note
    Tokens {{ networks.dancelight.demo_evm_token_symbol }} nÃ£o tÃªm valor. Por favor, nÃ£o envie spam para a faucet com solicitaÃ§Ãµes desnecessÃ¡rias.

Seus tokens serÃ£o distribuÃ­dos em breve, e vocÃª pode verificar seu saldo de tokens {{ networks.dancelight.demo_evm_token_symbol }} pesquisando seu endereÃ§o no \[explorador\]({{ networks.dancelight.demo_evm_blockscout_url }}){target=\_blank}.

## Endpoints de Rede {: #network-endpoints }

Os endpoints HTTPS e WSS da rede EVM de demonstraÃ§Ã£o sÃ£o os seguintes:

=== "HTTPS"

    ```text
    {{ networks.dancelight.demo_evm_rpc_url }}
    ```

=== "WSS"

    ```text
    {{ networks.dancelight.demo_evm_rpc_wss_url }}
    ```

## Exploradores de Blocos {: #block-explorers }

Para a rede EVM de demonstraÃ§Ã£o, vocÃª pode usar qualquer um dos seguintes exploradores:

- [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc={{ networks.dancelight.demo_evm_rpc_wss_url }}){target=\_blank} (API Substrate)
- [Blockscout]({{ networks.dancelight.demo_evm_blockscout_url }}){target=\_blank} (API Ethereum)
- [Expedition](https://evmexplorer.tanssi-chains.network/?rpcUrl={{ networks.dancelight.demo_evm_rpc_url }}){target=\_blank} (API Ethereum)

## ID da Cadeia {: #chain-id }

A rede EVM de demonstraÃ§Ã£o tem um [ID de cadeia](https://chainlist.org/chain/{{ networks.dancelight.demo_evm_chain_id }}){target=\_blank} de: `{{ networks.dancelight.demo_evm_chain_id }}`, que Ã© `{{ networks.dancelight.demo_evm_chain_hex_id }}` em hexadecimal.

## InÃ­cio RÃ¡pido {: #quick-start }

VocÃª pode interagir com uma rede EVM Powered by Tanssi usando bibliotecas Ethereum padrÃ£o, como [Ethers.js](/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}, [Web3.js](/builders/toolkit/ethereum-api/libraries/web3js/){target=\_blank} e [Web3.py](/builders/toolkit/ethereum-api/libraries/web3py/){target=\_blank}. Para comeÃ§ar rapidamente, vocÃª precisarÃ¡ criar um provedor conectado a uma rede EVM Tanssi:
// Insira sua URL RPC aqui

=== "Ethers.js"

    ```js
    import { ethers } from "ethers";

    const providerRPC = {
      evmNetwork: {
        name: 'dancelight-evm-network',
        // Insira sua URL RPC aqui
        rpc: '{{ networks.dancelight.demo_evm_rpc_url }}', 
        chainId: {{ networks.dancelight.demo_evm_chain_id }}, // {{ networks.dancelight.demo_evm_chain_hex_id }} em hexadecimal,
      },
    };
    const provider = new ethers.JsonRpcProvider(
      providerRPC.evmNetwork.rpc, 
      {
        chainId: providerRPC.evmNetwork.chainId,
        name: providerRPC.evmNetwork.name,
      }
    );
    ```

=== "Web3.js"

    ```js
    const Web3 = require('web3');

    const web3 = new Web3(
      '{{ networks.dancelight.demo_evm_rpc_url }}'
    );
    ```

=== "Web3.py"

    ```python
    from web3 import Web3

    web3 = Web3(Web3.HTTPProvider('{{ networks.dancelight.demo_evm_rpc_url }}')) 
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/tanssi-network/testnet/
--- BEGIN CONTENT ---
---
title: Redes de Teste
description: ConheÃ§a a Dancelight, a TestNet da Tanssi, e a rede EVM de demonstraÃ§Ã£o executada sobre a Dancelight, alÃ©m de como comeÃ§ar a desenvolver e interagir com cada uma dessas redes.
icon: octicons-telescope-24
template: index-page.html
---

# TestNet

Dancelight, a TestNet oficial da Tanssi, permite que os desenvolvedores experimentem aplicaÃ§Ãµes blockchain em um ambiente controlado antes de entrar em operaÃ§Ã£o. Ela fornece as ferramentas para configurar redes, interagir com versÃµes de teste de protocolos e solucionar problemas para garantir uma transiÃ§Ã£o mais suave para a produÃ§Ã£o.

Quando estiver pronto para ver como seu projeto pode prosperar em um ambiente do mundo real, experimente o ambiente EVM de demonstraÃ§Ã£o. Totalmente compatÃ­vel com o Ethereum, esta configuraÃ§Ã£o powered by Tanssi apresenta os principais recursos e oferece uma experiÃªncia imersiva, dando-lhe um vislumbre do potencial total da sua soluÃ§Ã£o personalizada.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/dev-env/foundry/
--- BEGIN CONTENT ---
---
title: Implante Contratos com Foundry
description: Aprenda a usar o Foundry, um ambiente de desenvolvimento Ethereum, para compilar, implantar e interagir com contratos inteligentes Solidity na sua rede EVM da Tanssi.
icon: octicons-code-square-24
categories: EVM-Template
---

# Usando Foundry para Implantar na Sua Rede EVM

## IntroduÃ§Ã£o {: #introduction }

[Foundry](https://github.com/foundry-rs/foundry){target=\_blank} Ã© um ambiente de desenvolvimento Ethereum escrito em Rust que ajuda a gerenciar dependÃªncias, compilar projetos, executar testes, implantar contratos e interagir com blockchains pela linha de comando. O Foundry pode interagir diretamente com a API Ethereum de redes EVM powered by Tanssi, portanto pode ser usado para implantar e interagir com contratos inteligentes na sua rede Tanssi.

Quatro ferramentas compÃµem o Foundry:

- **[Forge](https://getfoundry.sh/forge/overview/){target=\_blank}** â€“ compila, testa e implanta contratos
- **[Cast](https://getfoundry.sh/cast/overview/){target=\_blank}** â€“ interface de linha de comando para interagir com contratos
- **[Anvil](https://getfoundry.sh/anvil/overview/){target=\_blank}** â€“ nÃ³ local de TestNet para desenvolvimento que pode bifurcar redes existentes
- **[Chisel](https://getfoundry.sh/chisel/overview/){target=\_blank}** â€“ REPL Solidity para testar rapidamente trechos de cÃ³digo

Este guia mostra como usar o Foundry para compilar, implantar e depurar contratos Ethereum na rede EVM de demonstraÃ§Ã£o. VocÃª pode seguir os mesmos passos na sua rede EVM da Tanssi trocando a URL RPC e o Chain ID dos exemplos.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para comeÃ§ar, vocÃª precisarÃ¡ de:

 - Uma conta com fundos
 - [Foundry instalado](https://getfoundry.sh/introduction/installation/){target=\_blank}

## Criando um Projeto Foundry {: #creating-a-foundry-project }

VocÃª precisa criar um projeto Foundry se ainda nÃ£o tiver um. Siga os passos:

1. Instale o Foundry com os comandos abaixo. No Windows, Ã© necessÃ¡rio instalar o Rust e compilar o Foundry a partir do cÃ³digo-fonte:

    === "Ubuntu"

        ```bash
        curl -L https://foundry.paradigm.xyz | bash foundryup
        ```

    === "MacOS"

        ```bash
        curl -L https://foundry.paradigm.xyz | bash foundryup
        ```

    === "Windows"

        ```bash
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs/ | sh
        cargo install --git https://github.com/foundry-rs/foundry foundry-cli anvil --bins --locked
        ```

    ApÃ³s instalar, talvez seja necessÃ¡rio reiniciar o terminal ou adicionar `foundryup` ao PATH.

2. Crie o projeto (serÃ¡ criada uma pasta com trÃªs subpastas):

    ```bash
    forge init foundry
    ```

VocÃª pode receber um erro como `The target directory is a part of or on its own an already initialized git repository, and it requires clean working and staging areas, including no untracked files.` Para resolver, adicione arquivos e faÃ§a um commit se estiver mantendo o projeto em um repositÃ³rio GitHub. Caso contrÃ¡rio, faÃ§a um commit fictÃ­cio sem enviar. Se executar `forge init foundry` novamente, o erro nÃ£o aparecerÃ¡.

Com o projeto padrÃ£o criado, vocÃª verÃ¡ trÃªs pastas:

- `lib` â€“ dependÃªncias do projeto como submÃ³dulos git
- `src` â€“ onde colocar seus contratos inteligentes (com funcionalidade)
- `test` â€“ onde colocar os testes do Forge em Solidity

AlÃ©m dessas trÃªs pastas, um repositÃ³rio git serÃ¡ criado com um `.gitignore` prÃ©-preenchido ignorando tipos de arquivo e pastas relevantes.

## A Pasta `src` {: #the-src-folder }

O repositÃ³rio `foundry` prÃ©-configurado inclui `Counter.sol` em `src`, `Counter.s.sol` em `script` e `Counter.t.sol` em `test`. Exclua esses arquivos para evitar erros ao compilar e implantar `MyToken.sol`. VocÃª pode fazer isso com:

```bash
rm src/Counter.sol script/Counter.s.sol test/Counter.t.sol
```

Nas etapas seguintes, vocÃª implantarÃ¡ um contrato ERC-20. No diretÃ³rio `src`, crie o arquivo `MyToken.sol`:

```bash
cd src
touch MyToken.sol
```

Abra o arquivo e adicione o contrato:

```solidity
pragma solidity ^0.8.0;

// Import OpenZeppelin Contract
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";

// This ERC-20 contract mints the specified amount of tokens to the contract creator
contract MyToken is ERC20 {
  constructor(uint256 initialSupply) ERC20("MyToken", "MYTOK") {
    _mint(msg.sender, initialSupply);
  }
}
```

Antes de compilar, instale os contratos OpenZeppelin como dependÃªncia. VocÃª pode ter que fazer commit das mudanÃ§as anteriores antes. Por padrÃ£o, o Foundry usa submÃ³dulos git em vez de pacotes npm, entÃ£o o caminho e comando tradicionais do npm nÃ£o sÃ£o usados. Em vez disso, use o nome do repositÃ³rio do OpenZeppelin no GitHub:

```bash
forge install OpenZeppelin/openzeppelin-contracts
```

## Compilando Solidity {: #compiling-solidity }

Com todas as dependÃªncias instaladas, compile o contrato:

```bash
forge build
```

![Compilar contrato no Foundry](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-1.webp)

ApÃ³s a compilaÃ§Ã£o, duas pastas serÃ£o criadas: `out` e `cache`. A ABI e o bytecode dos contratos ficam em `out`. Essas duas pastas jÃ¡ estÃ£o ignoradas no `.gitignore` incluÃ­do na inicializaÃ§Ã£o padrÃ£o do projeto Foundry.

## Implantando o Contrato {: #deploying-the-contract }

Implantar o contrato com Forge exige apenas um comando, mas vocÃª precisa incluir um endpoint RPC, uma chave privada financiada e argumentos do builder. `MyToken.sol` pede uma oferta inicial de tokens em seu builder, portanto o comando inclui 100 como argumento do builder. VocÃª pode implantar o contrato `MyToken.sol` usando o comando abaixo (ajuste para a rede correta):

```bash
forge create --rpc-url {{ networks.dancelight.demo_evm_rpc_url }} \
--constructor-args 100 \
--private-key INSERT_YOUR_PRIVATE_KEY \
src/MyToken.sol:MyToken
```

Depois de alguns segundos, o contrato Ã© implantado e vocÃª verÃ¡ o endereÃ§o no terminal.

![ImplantaÃ§Ã£o de contrato no Foundry](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-2.webp)

ParabÃ©ns, seu contrato estÃ¡ ativo! Salve o endereÃ§o, pois o usarÃ¡ para interagir com esta instÃ¢ncia no prÃ³ximo passo.

## Interagindo com o Contrato {: #interacting-with-the-contract }

O Foundry inclui o [Cast](https://getfoundry.sh/cast/overview/){target=\_blank}, uma CLI para realizar chamadas RPC Ethereum.

Recupere o nome do token usando o Cast, onde `INSERT_YOUR_CONTRACT_ADDRESS` Ã© o endereÃ§o do contrato implantado na seÃ§Ã£o anterior:

```bash
cast call INSERT_YOUR_CONTRACT_ADDRESS "name()" --rpc-url {{ networks.dancelight.demo_evm_rpc_url }}
```

VocÃª deve obter os dados em hexadecimal:

```text
0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000
```

Isso nÃ£o Ã© legÃ­vel, mas vocÃª pode usar o Cast para converter para o formato desejado. Neste caso, o dado Ã© texto, entÃ£o converta para ASCII para ver "My Token":

![Visualizar contrato no Foundry](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-3.webp)

```bash
cast --to-ascii 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074d79546f6b656e00000000000000000000000000000000000000000000000000
```

VocÃª tambÃ©m pode alterar dados com o Cast. Tente queimar tokens enviando-os para o endereÃ§o zero.

```bash
cast send --private-key INSERT_YOUR_PRIVATE_KEY \
--rpc-url {{ networks.dancelight.demo_evm_rpc_url }} \
--chain {{ networks.dancelight.demo_evm_chain_id }} \
INSERT_YOUR_CONTRACT_ADDRESS \
"transfer(address,uint256)" 0x0000000000000000000000000000000000000001 1
```

A transaÃ§Ã£o serÃ¡ assinada pela sua conta EVM e transmitida Ã  rede. A saÃ­da deve se parecer com:

![InteraÃ§Ã£o de contrato no Foundry](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-4.webp)

ParabÃ©ns, vocÃª implantou e interagiu com um contrato usando Foundry!

## Bifurcando com Anvil {: #forking-with-anvil }

Como mencionado, o [Anvil](https://getfoundry.sh/anvil/overview/){target=\_blank} Ã© um nÃ³ local de TestNet para desenvolvimento que pode bifurcar redes existentes. Bifurcar a rede demo EVM permite interagir com contratos vivos implantados na rede.

Para bifurcar a rede demo EVM na linha de comando, execute o seguinte comando no diretÃ³rio do projeto Foundry. VocÃª tambÃ©m pode substituir a URL RPC pela URL RPC da sua rede EVM da Tanssi:

```bash
anvil --fork-url {{ networks.dancelight.demo_evm_rpc_url }}
```

A instÃ¢ncia bifurcada terÃ¡ 10 contas de desenvolvimento prÃ©-financiadas com 10.000 tokens de teste. A instÃ¢ncia fica disponÃ­vel em `http://127.0.0.1:8545/`. A saÃ­da no terminal deve ser semelhante a:

![Tela do terminal ao bifurcar](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-5.webp)

Para verificar se vocÃª bifurcou a rede, consulte o Ãºltimo nÃºmero do bloco e compare com o nÃºmero atual da [rede demo EVM]({{ networks.dancelight.demo_evm_blockscout_url }}){target=\_blank}.

```bash
curl --data '{"method":"eth_blockNumber","params":[],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST localhost:8545 
```

Se converter o `result` de [hex para decimal](https://www.rapidtables.com/convert/number/hex-to-decimal.html){target=\_blank}, vocÃª deve obter o nÃºmero mais recente do bloco do momento em que bifurcou.

A partir daqui, vocÃª pode implantar novos contratos na instÃ¢ncia bifurcada da rede demo EVM (ou qualquer outra rede EVM com Tanssi) ou interagir com contratos jÃ¡ implantados. Seguindo o exemplo anterior, vocÃª pode fazer uma chamada com o Cast para verificar o saldo de tokens MYTOK cunhados na conta que implantou o contrato:

```bash
cast call INSERT_CONTRACT_ADDRESS  "balanceOf(address)(uint256)" \
 INSERT_YOUR_ADDRESS --rpc-url http://localhost:8545
```

## Usando Chisel {: #using-chisel }

O [Chisel](https://getfoundry.sh/chisel/overview/){target=\_blank} Ã© um REPL ou shell Solidity. Ele permite escrever Solidity diretamente no console para testar trechos pequenos de cÃ³digo, permitindo pular a configuraÃ§Ã£o de projeto e implantaÃ§Ã£o de contrato para processos rÃ¡pidos.

Como o Chisel Ã© Ãºtil para testes rÃ¡pidos, ele pode ser usado fora de um projeto Foundry. Mas, se for executado dentro de um projeto Foundry, ele mantÃ©m as configuraÃ§Ãµes do `foundry.toml`.

Neste exemplo, vocÃª testarÃ¡ alguns recursos do `abi` em Solidity para demonstrar como o Chisel pode ser Ãºtil. Para comeÃ§ar a usar o Chisel, execute no terminal para iniciar o shell:

```bash
chisel
```

No shell, escreva cÃ³digo Solidity como se estivesse dentro de uma funÃ§Ã£o:

```solidity
bytes memory myData = abi.encode(100, true, "Build with Tanssi");
```

Suponha que vocÃª esteja interessado em como o `abi` codifica dados porque quer armazenar dados de forma mais eficiente no blockchain e economizar gÃ¡s. Para ver como `myData` Ã© armazenado em memÃ³ria, use o comando a seguir no shell do Chisel:

```bash
!memdump
```

`memdump` despejarÃ¡ todos os dados da sessÃ£o atual. VocÃª verÃ¡ algo como abaixo. Se nÃ£o souber ler hexadecimal ou nÃ£o souber como funciona a codificaÃ§Ã£o ABI, talvez nÃ£o consiga encontrar onde a variÃ¡vel `myData` foi armazenada.

![memdump no Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-6.webp)

Felizmente, o Chisel permite descobrir facilmente onde a informaÃ§Ã£o estÃ¡ armazenada. Usando o comando `!rawstack`, Ã© possÃ­vel encontrar a posiÃ§Ã£o na pilha onde o valor de uma variÃ¡vel estÃ¡:

```bash
!rawstack myData
```

Nesse caso, como `myData` tem mais de 32 bytes, o ponteiro de memÃ³ria Ã© exibido. Mas Ã© exatamente o que precisamos, jÃ¡ que vocÃª jÃ¡ conhece toda a pilha pelo comando `!memdump`.

![rawstack no Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-7.webp)

O comando `!rawstack` mostra que a variÃ¡vel `myData` estÃ¡ em `0x80`; comparando com o dump de memÃ³ria do `!memdump`, parece que `myData` estÃ¡ armazenado assim:

```text
[0x80:0xa0]: 0x00000000000000000000000000000000000000000000000000000000000000a0
[0xa0:0xc0]: 0x0000000000000000000000000000000000000000000000000000000000000064
[0xc0:0xe0]: 0x0000000000000000000000000000000000000000000000000000000000000001
[0xe0:0x100]: 0x0000000000000000000000000000000000000000000000000000000000000060
[0x100:0x120]: 0x0000000000000000000000000000000000000000000000000000000000000011
[0x120:0x140]: 0x4275696c6420776974682054616e737369000000000000000000000000000000
```

A princÃ­pio, isso faz sentido, pois `0xa0` tem valor `0x64` (igual a 100) e `0xc0` tem valor `0x01` (igual a true). Para saber mais sobre a codificaÃ§Ã£o ABI, veja a [documentaÃ§Ã£o de Solidity para ABI](https://docs.soliditylang.org/en/v0.8.18/abi-spec.html){target=\_blank}. Neste caso, hÃ¡ muitos zeros nesse tipo de empacotamento de dados, entÃ£o, como desenvolvedor de smart contracts, vocÃª pode tentar usar structs ou empacotar os dados de forma mais eficiente com cÃ³digo bitwise.

Quando terminar com esse cÃ³digo, limpe o estado do Chisel para nÃ£o interferir em qualquer lÃ³gica futura que queira testar (mantendo a mesma instÃ¢ncia do Chisel):

```bash
!clear
```

HÃ¡ um jeito ainda mais fÃ¡cil de testar com o Chisel. Quando vocÃª escreve cÃ³digo terminando com ponto e vÃ­rgula `;`, o Chisel executa como uma instruÃ§Ã£o, armazenando o valor no estado de runtime do Chisel. Mas, se vocÃª sÃ³ precisa ver como os dados ABI codificados aparecem, pode rodar o cÃ³digo como uma expressÃ£o. Para testar com o mesmo exemplo de `abi`, escreva no shell do Chisel:

```bash
abi.encode(100, true, "Build with Tanssi")
```

VocÃª verÃ¡ algo como:

![ExpressÃµes no Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-8.webp)

Embora nÃ£o exiba os dados do mesmo jeito, vocÃª ainda vÃª o conteÃºdo e ele quebra mais detalhes, como informar que o valor `0xa0` define o comprimento dos dados.

Por padrÃ£o, ao sair do shell do Chisel, nenhum dado persiste. Mas vocÃª pode instruir o Chisel a persistir. Por exemplo, siga estes passos para armazenar uma variÃ¡vel:

1. Armazene um `uint256` no Chisel

    ```bash
    uint256 myNumber = 101;
    ```

2. Armazene a sessÃ£o com `!save`. Neste exemplo, use o nÃºmero `1` como ID de salvamento

    ```bash
    !save 1
    ```

3. Saia da sessÃ£o  
    ```bash
    !quit
    ```

Para visualizar e interagir com os estados do Chisel salvos, siga estes passos:

1. Veja a lista de estados salvos do Chisel

    ```bash
    chisel list
    ```

2. Carregue seu estado salvo fornecendo o comando `chisel load` seguido do ID do estado

    ```bash
    chisel load 1
    ```

3. Visualize o `uint256` salvo no Chisel a partir do conjunto de passos anterior

    ```bash
    !rawstack myNumber
    ```  

![Salvar estado no Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-9.webp)

VocÃª pode atÃ© bifurcar redes enquanto usa o Chisel:

```bash
!fork {{ networks.dancelight.demo_evm_rpc_url }}
```

EntÃ£o, por exemplo, vocÃª pode consultar o saldo da conta Alice na rede demo EVM:

```text
0x44236223aB4291b93EEd10E4B511B37a398DEE55.balance
```

![Bifurcando no Chisel](/images/builders/toolkit/ethereum-api/dev-environments/foundry/foundry-10.webp)

Se quiser saber mais sobre o Chisel, baixe o Foundry e consulte a [pÃ¡gina de referÃªncia oficial](https://getfoundry.sh/chisel/reference/){target=\_blank}.

## Foundry com Hardhat {: #foundry-with-hardhat }  

Muitas vezes, um projeto que vocÃª quer integrar tem toda a configuraÃ§Ã£o em [Hardhat](/pt/builders/toolkit/ethereum-api/dev-env/hardhat/){target=\_blank}, tornando penosa a tarefa de converter tudo para Foundry. Esse trabalho extra Ã© evitÃ¡vel criando um projeto hÃ­brido que use recursos do Hardhat e do Foundry juntos, o que Ã© possÃ­vel com o plugin [hardhat-foundry](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-foundry){target=\_blank}.  

Para converter seu projeto Foundry prÃ©-existente em hÃ­brido, essencialmente vocÃª vai instalar um projeto Hardhat na mesma pasta:

```bash
npm init
npm install --save-dev hardhat @nomicfoundation/hardhat-foundry
npx hardhat init
```

Para mais informaÃ§Ãµes, consulte nossa documentaÃ§Ã£o sobre [Criando um Projeto Hardhat](/pt/builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project){target=\_blank}.

ApÃ³s inicializar o novo projeto Hardhat, algumas pastas e arquivos novos devem aparecer: `contracts`, `hardhat.config.js`, `scripts` e `test/Lock.js`. VocÃª precisarÃ¡ fazer algumas modificaÃ§Ãµes para criar o projeto hÃ­brido:

1. Edite o arquivo `hardhat.config.js` dentro do repositÃ³rio. Abra-o e, no topo, adicione:

    ```javascript
    require('@nomicfoundation/hardhat-foundry');
    ```

    ApÃ³s adicionar o plugin `hardhat-foundry`, as pastas `contracts` tÃ­picas do Hardhat nÃ£o funcionarÃ£o porque agora o Hardhat espera que todos os contratos inteligentes estejam na pasta `src` do Foundry

2. Mova todos os contratos da pasta `contracts` para a pasta `src` e entÃ£o apague a pasta `contracts`
3. Edite o arquivo `foundry.toml` para garantir que dependÃªncias instaladas via submÃ³dulos Git e npm possam ser compiladas pela ferramenta Forge. Edite o `profile.default` para garantir que a entrada `libs` contenha `lib` e `node_modules`:

    ```toml
    [profile.default]
    src = 'src'
    out = 'out'
    libs = ['lib', 'node_modules']
    solc = '0.8.20'
    evm_version = 'london'
    ```

Agora tanto `forge build` quanto `npx hardhat compile` devem funcionar independentemente das dependÃªncias.  

Tanto `forge test` quanto `npx hardhat test` conseguem acessar todos os contratos e dependÃªncias. O `forge test` testarÃ¡ apenas os testes em Solidity, enquanto `npx hardhat test` testarÃ¡ apenas os testes em JavaScript. Se quiser usÃ¡-los em conjunto, vocÃª pode criar um novo script no arquivo `package.json`:

```json
"scripts": {
    "test": "npx hardhat test && forge test"
}
```

VocÃª pode executar este comando com:

```bash
npm run test
```

Por fim, embora nÃ£o seja necessÃ¡rio, pode valer a pena mover todos os scripts JavaScript da pasta `scripts` para a pasta `script` do Foundry e apagar a pasta `scripts` para nÃ£o ter duas pastas com o mesmo propÃ³sito.

ParabÃ©ns, vocÃª implantou e interagiu com contratos inteligentes na sua rede EVM Tanssi usando Foundry! Para mais informaÃ§Ãµes, consulte o [Foundry Book](https://getfoundry.sh/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/dev-env/hardhat/
--- BEGIN CONTENT ---
---
title: Implantar Contratos com Hardhat
description: Aprenda a usar o Hardhat, um ambiente de desenvolvimento Ethereum, para compilar, implantar e interagir com contratos inteligentes Solidity na sua rede EVM da Tanssi.
icon: octicons-code-square-24
categories: EVM-Template
---

# Usando Hardhat para Implantar na Sua Rede EVM

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/1Kbs7dxkjJQ?si=n0ipTN2nbvqISLGu' frameborder='0' allowfullscreen></iframe></div>
<style>.caption { font-family: Open Sans, sans-serif; font-size: 0.9em; color: rgba(170, 170, 170, 1); font-style: italic; letter-spacing: 0px; position: relative;}</style>

## IntroduÃ§Ã£o {: #introduction }

[Hardhat](https://hardhat.org){target=_blank} Ã© um ambiente de desenvolvimento Ethereum que ajuda a gerenciar e automatizar as tarefas recorrentes inerentes Ã  criaÃ§Ã£o de contratos inteligentes e dApps. Ele funciona com qualquer rede EVM, incluindo as redes compatÃ­veis com a Tanssi, para compilar e implantar contratos de forma transparente.

Este guia mostra como compilar, implantar e interagir com contratos inteligentes Ethereum na rede EVM de demonstraÃ§Ã£o da Tanssi. VocÃª pode adaptar para sua prÃ³pria rede Tanssi adicionando a URL RPC dela Ã  sua carteira EVM e alternando para essa rede.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para este guia, vocÃª precisarÃ¡ do MetaMask instalado e configurado para funcionar com sua rede EVM da Tanssi. VocÃª pode seguir [este guia para configurar o MetaMask para a rede EVM de demonstraÃ§Ã£o](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=_blank}.

## Criando um Projeto Hardhat {: #creating-a-hardhat-project }
Se ainda nÃ£o tiver um projeto Hardhat, crie um seguindo os passos:

1. Crie um diretÃ³rio para o projeto

    ```sh
    mkdir hardhat && cd hardhat
    ```

2. Inicialize o projeto, o que criarÃ¡ um `package.json`

    ```sh
    npm init -y
    ```

3. Instale o Hardhat

    ```sh
    npm install hardhat
    ```

4. Crie o projeto

    ```sh
    npx hardhat init
    ```

    !!! note
        `npx` executa binÃ¡rios instalados localmente no projeto. Embora seja possÃ­vel instalar o Hardhat globalmente, Ã© recomendÃ¡vel instalÃ¡-lo localmente para controlar a versÃ£o por projeto.

5. Um menu aparecerÃ¡ permitindo criar um novo projeto ou usar um exemplo. Para este guia, escolha **Create an empty hardhat.config.js**

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>npx hardhat init</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;888</span>
  <span data-ty>8888888888&nbsp;&nbsp;8888b.&nbsp;&nbsp;888d888&nbsp;.d88888&nbsp;88888b.&nbsp;&nbsp;&nbsp;8888b.&nbsp;&nbsp;888888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"88b&nbsp;888P"&nbsp;&nbsp;d88"&nbsp;888&nbsp;888&nbsp;"88b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"88b&nbsp;888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;.d888888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;888&nbsp;.d888888&nbsp;888</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;Y88b&nbsp;888&nbsp;888&nbsp;&nbsp;888&nbsp;888&nbsp;&nbsp;888&nbsp;Y88b.</span>
  <span data-ty>888&nbsp;&nbsp;&nbsp;&nbsp;888&nbsp;"Y888888&nbsp;888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Y88888&nbsp;888&nbsp;&nbsp;888&nbsp;"Y888888&nbsp;&nbsp;"Y888</span>
    <br>
  <span data-ty>ðŸ‘· Welcome to Hardhat v2.22.2 ðŸ‘·â€</span>
    <br>
  <span data-ty="input" data-ty-prompt="?">&nbsp;What do you want to do? â€¦</span>
  <span data-ty>&nbsp;&nbsp;Create a JavaScript project </span>
  <span data-ty>&nbsp;&nbsp;Create a TypeScript project </span>
  <span data-ty>&nbsp;&nbsp;Create a TypeScript project (with Viem) </span>
  <span data-ty="input" data-ty-prompt="â¯ Create an empty hardhat.config.js"></span>
  <span data-ty>&nbsp;&nbsp;Quit </span>
</div>

Isso criarÃ¡ um arquivo de configuraÃ§Ã£o Hardhat (`hardhat.config.js`) no diretÃ³rio do projeto.

Quando o projeto estiver pronto, instale tambÃ©m o [plugin Ethers](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-ethers){target=_blank} para usar a biblioteca [Ethers.js](/pt/builders/toolkit/ethereum-api/libraries/ethersjs/){target=_blank} com a rede:

```sh
npm install @nomicfoundation/hardhat-ethers ethers
```

AlÃ©m disso, instale o plugin `hardhat-ignition-ethers` para implantar contratos com o Hardhat Ignition:

```sh
npm install --save-dev @nomicfoundation/hardhat-ignition-ethers
```

## O Arquivo do Contrato {: #the-contract-file }

Com o projeto vazio criado, crie o diretÃ³rio `contracts`:

```sh
mkdir contracts && cd contracts
```

O contrato de exemplo que serÃ¡ implantado se chama `Box` e armazena um valor recuperÃ¡vel depois. No diretÃ³rio `contracts`, crie o arquivo `Box.sol`:

```sh
touch Box.sol
```

Abra o arquivo e adicione o contrato:

```solidity
// contracts/Box.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

contract Box {
    uint256 private value;

    // Emitido quando o valor armazenado Ã© alterado
    event ValueChanged(uint256 newValue);

    // Armazena um novo valor no contrato
    function store(uint256 newValue) public {
        value = newValue;
        emit ValueChanged(newValue);
    }

    // LÃª o Ãºltimo valor armazenado
    function retrieve() public view returns (uint256) {
        return value;
    }
}
```

## O Arquivo de ConfiguraÃ§Ã£o do Hardhat {: #hardhat-configuration-file }

Antes de implantar na sua rede Tanssi, ajuste o `hardhat.config.js` e crie um arquivo seguro para armazenar sua chave privada.

Exemplo de configuraÃ§Ã£o para usar a rede EVM de demonstraÃ§Ã£o ou a sua rede Tanssi:

```js
// 1. Importe os plugins Ethers e Hardhat Ignition necessÃ¡rios para interagir com o contrato
require('@nomicfoundation/hardhat-ethers');
require('@nomicfoundation/hardhat-ignition-ethers');

// 2. Adicione sua chave privada com tokens da sua rede Tanssi
// Isto Ã© apenas para exemplo â€” **nunca armazene suas chaves privadas em um arquivo JavaScript**
const privateKey = 'INSERT_PRIVATE_KEY';

module.exports = {
  // 3. Especifique a versÃ£o do Solidity
  solidity: '0.8.1',
  networks: {
    // 4. Adicione a especificaÃ§Ã£o da sua rede EVM da Tanssi
    dancelight: {
      url: '{{ networks.dancelight.demo_evm_rpc_url }}',
      chainId: {{ networks.dancelight.demo_evm_chain_id }}, // Preencha o ChainID EVM da sua rede Tanssi
      accounts: [privateKey]
    }
  }
};
```

Pronto para implantar!

## Compilando Solidity {: #compiling-solidity }

Compile o contrato com:

```sh
npx hardhat compile
```

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>npx hardhat compile</span>
    <span data-ty>Compiled 8 Solidity files successfully (evm target: paris).</span>
    <span data-ty="input"><span class="file-path"></span></span>
</div>

ApÃ³s a compilaÃ§Ã£o, o diretÃ³rio `artifacts` Ã© criado com bytecode e metadados (`.json`). Considere adicionÃ¡-lo ao `.gitignore`.

## Implantando o Contrato {: #deploying-the-contract }

A implantaÃ§Ã£o usarÃ¡ o Hardhat Ignition, um framework declarativo para implantaÃ§Ãµes. Saiba mais na [documentaÃ§Ã£o do Ignition](https://hardhat.org/ignition/docs/getting-started#overview){target=_blank}.

Crie a estrutura para o mÃ³dulo Ignition:

```sh
mkdir ignition ignition/modules && touch ignition/modules/Box.js
```

Depois, escreva o mÃ³dulo do Ignition seguindo estes passos:

1. Importe `buildModule` do Hardhat Ignition
2. Exporte um mÃ³dulo usando `buildModule`
3. Use `getAccount` para selecionar a conta de deploy
4. Defina gas price e gas limit customizados, se necessÃ¡rio
5. FaÃ§a o deploy do contrato `Box`
6. Retorne um objeto com o contrato para usÃ¡-lo em testes e scripts

```js
// 1.  Import the `buildModule` function from the Hardhat Ignition module
const { buildModule } = require('@nomicfoundation/hardhat-ignition/modules');

// 2. Export a module using `buildModule`
module.exports = buildModule('BoxModule', (m) => {
  // 3. Use the `getAccount` method to select the deployer account
  const deployer = m.getAccount(0);

  // 4. Specify custom gas price and gas limit settings for the deployment
  const customGasPrice = 50000000000n;
  const customGasLimit = 1000000;

  // 5. Deploy the `Box` contract using the selected deployer account and custom gas settings
  const box = m.contract('Box', [], {
    from: deployer,
    gasPrice: customGasPrice,
    gasLimit: customGasLimit,
  });

  // 6. Return an object from the module including references to deployed contracts. This makes the deployed `Box` contract accessible for interaction in tests and scripts
  return { box };
});
```

Para executar o script e implantar o `Box.sol`, especifique o nome da rede conforme definido em `hardhat.config.js`. Sem rede, o Hardhat usa a rede local por padrÃ£o.

```sh
npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight
```

Confirme a rede quando solicitado. Em alguns segundos, o contrato serÃ¡ implantado e o endereÃ§o aparecerÃ¡ no terminal. Se for outra rede Tanssi, ajuste o nome da rede para combinar com o `hardhat.config.js`.

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span> npx hardhat ignition deploy ./ignition/modules/Box.js --network dancelight</span>
    <br>
    <span data-ty>âœ… Confirm deploy to network dancelight (5678)? â€¦ yes</span>
    <span data-ty>Hardhat Ignition ðŸš€</span>
    <br>
    <span data-ty>Deploying [ BoxModule ]</span>
    <br>
    <span data-ty>Batch #1</span>
    <span data-ty>Executed BoxModule#Box</span>
    <br>
    <span data-ty>[ BoxModule ] successfully deployed ðŸš€</span>
    <br>
    <span data-ty>Deployed Addresses</span>
    <br>
    <span data-ty>BoxModule#Box - 0xa84caB60db6541573a091e5C622fB79e175E17be</span>
    <span data-ty="input"><span class="file-path"></span></span>
</div>

ParabÃ©ns, o contrato estÃ¡ ativo! Guarde o endereÃ§o para interagir na prÃ³xima etapa.

## Interagindo com o contrato {: #interacting-with-the-contract }

Para interagir com o contrato implantado, abra o `console` do Hardhat:

```sh
npx hardhat console --network dancelight
```

Execute, linha a linha:

1. Crie uma instÃ¢ncia local de `Box.sol`

    ```js
    const Box = await ethers.getContractFactory('Box');
    ```

2. Conecte a instÃ¢ncia ao contrato implantado usando o endereÃ§o

    ```js
    const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be');
    ```

3. Interaja com o contrato; por exemplo, chame `store` e salve um valor simples

    ```js
    await box.store(5);
    ```

Sua conta EVM assinarÃ¡ a transaÃ§Ã£o e a transmitirÃ¡. A saÃ­da se parecerÃ¡ com:

<div id="termynal" data-termynal>
    <span data-ty="input">npx hardhat console --network dancelight</span>
    <br>
    <span data-ty>Welcome to Node.js v20.9.0.</span>
    <span data-ty>Type ".help" for more information.</span>
    <span data-ty="input" data-ty-prompt=">"> const Box = await ethers.getContractFactory('Box');</span>
    <span data-ty>undefined</span>
    <br>
    <span data-ty="input" data-ty-prompt=">"> const box = await Box.attach('0xa84caB60db6541573a091e5C622fB79e175E17be');</span>
    <span data-ty>undefined</span>
    <br>
    <span data-ty="input" data-ty-prompt=">"> await box.store(5);</span>
    <span data-ty>ContractTransactionResponse {<br>
    provider: HardhatEthersProvider { ... },<br>
    blockNumber: null,<br>
    blockHash: null,<br>
    index: undefined,<br>
    hash: '0x1c49a64a601fc5dd184f0a368a91130cb49203ec0f533c6fcf20445c68e20264',<br>
    type: 2,<br>
    to: '0xa84caB60db6541573a091e5C622fB79e175E17be',<br>
    from: '0x3B939FeaD1557C741Ff06492FD0127bd287A421e',<br>
    nonce: 87,<br>
    gasLimit: 45881n,<br>
    gasPrice: 1107421875n,<br>
    maxPriorityFeePerGas: 1n,<br>
    maxFeePerGas: 1107421875n,<br>
    data: '0x6057361d0000000000000000000000000000000000000000000000000000000000000005',<br>
    value: 0n,<br>
    chainId: 5678n,<br>
    signature: Signature { r: "0x9233b9cc4ae6879b7e08b9f1a4bfb175c8216eee0099966eca4a305c7f369ecc", s: "0x7663688633006b5a449d02cb08311569fadf2f9696bd7fe65417860a3b5fc57d", yParity: 0, networkV: null },<br>
    accessList: [],<br>
    blobVersionedHashes: null<br>
    }</span>
    <span data-ty="input" data-ty-prompt=">"> await box.retrieve();</span>
    <span data-ty>5n</span>
    <br>
</div>

Note seu endereÃ§o em `from`, o endereÃ§o do contrato e os dados enviados. Para recuperar o valor:

```js
await box.retrieve();
```

VocÃª deverÃ¡ ver `5` ou o valor armazenado.

!!! note
    Se executar o retrieve imediatamente apÃ³s armazenar, pode ver o valor antigo. Tente novamente apÃ³s alguns instantes.

ParabÃ©ns, vocÃª implantou e interagiu com um contrato usando o Hardhat!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/dev-env/
--- BEGIN CONTENT ---
---
title: Ambientes de Desenvolvimento
description: Aprenda a interagir com sua rede compatÃ­vel com EVM Tanssi atravÃ©s da API Ethereum com diferentes ferramentas Ethereum como Remix, Hardhat, Foundry e muito mais.
icon: octicons-code-square-24
template: index-page.html
---

# Ambientes de Desenvolvimento

Estabelecer um ambiente de desenvolvimento eficaz Ã© crucial para construir, testar e implantar contratos inteligentes de forma eficiente. Os ambientes de desenvolvimento simplificam o processo de construÃ§Ã£o de aplicaÃ§Ãµes blockchain, abstraindo muitas das complexidades subjacentes envolvidas na interaÃ§Ã£o com as redes blockchain. Eles fornecem as ferramentas e estruturas necessÃ¡rias para:

- Escrever, compilar, testar e implantar contratos inteligentes Solidity
- Simular interaÃ§Ãµes blockchain localmente para teste e depuraÃ§Ã£o
- Automatizar fluxos de trabalho para implantaÃ§Ãµes mais rÃ¡pidas

Cada ambiente de desenvolvimento ajuda vocÃª a alcanÃ§ar o mesmo objetivo, construir e implantar aplicaÃ§Ãµes blockchain, mas eles o fazem de maneiras Ãºnicas. Por exemplo, IDEs baseadas em navegador como [Remix](/pt/builders/toolkit/ethereum-api/dev-env/remix/) fornecem uma maneira rÃ¡pida e acessÃ­vel de comeÃ§ar a codificar, enquanto ferramentas como [Foundry](/pt/builders/toolkit/ethereum-api/dev-env/foundry/) e [Hardhat](/pt/builders/toolkit/ethereum-api/dev-env/hardhat/) atendem aos desenvolvedores que preferem fluxos de trabalho especÃ­ficos, como uma abordagem Solidity-first ou integrada ao JavaScript. Escolha aquele que melhor se alinha Ã s suas necessidades e estilo de desenvolvimento.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/dev-env/remix/
--- BEGIN CONTENT ---
---
title: Implante Contratos Inteligentes com Remix
description: Saiba como usar uma das IDEs Ethereum mais populares, o Remix, para interagir com sua rede EVM baseada na Tanssi.
icon: octicons-code-square-24
categories: EVM-Template
---

# Usando Remix para Implantar na sua Rede EVM da Tanssi

<style>.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }</style><div class='embed-container'><iframe src='https://www.youtube.com/embed/vSc80mg_L9E?si=qnIXJ6wL0iKU3mU1' frameborder='0' allowfullscreen></iframe></div>
<style>.caption { font-family: Open Sans, sans-serif; font-size: 0.9em; color: rgba(170, 170, 170, 1); font-style: italic; letter-spacing: 0px; position: relative;}</style>

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores de dApps em redes EVM baseadas na Tanssi podem usar o [Remix](https://remix.ethereum.org){target=_blank}, um dos ambientes de desenvolvimento Ethereum mais populares, para criar, compilar e implantar contratos inteligentes. O Remix funciona com qualquer rede EVM graÃ§as Ã  compatibilidade das redes EVM da Tanssi.

Este guia mostra como criar e implantar um contrato Solidity na rede EVM de demonstraÃ§Ã£o da Tanssi usando a IDE Remix. Para sua prÃ³pria rede Tanssi, basta adicionar a URL RPC dela Ã  sua carteira EVM e alternar para essa rede.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

VocÃª precisarÃ¡ do MetaMask instalado e configurado para funcionar com sua rede EVM da Tanssi. Siga [este guia para configurar o MetaMask para a rede EVM de demonstraÃ§Ã£o](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=_blank}.

## ComeÃ§ando com o Remix {: #getting-started-with-remix }

Acesse o [Remix](https://remix.ethereum.org){target=_blank} e vÃ¡ para a aba **File Explorer**.

![Explorador de arquivos no Remix](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-1.webp)

Crie um novo arquivo para o contrato Solidity:

1. Clique em **Create New File** no **File Explorer**
2. Nomeie, por exemplo, `MyToken.sol`

![Crie um novo arquivo para seu contrato Solidity](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-2.webp)

Cole o contrato abaixo no editor:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/audit/2023-03/contracts/token/ERC20/ERC20.sol';

// This ERC-20 contract mints the specified amount of tokens to the contract creator.
contract MyToken is ERC20 {
  constructor(uint256 initialSupply) ERC20("MyToken", "MYTOK") {
    _mint(msg.sender, initialSupply);
  }
}
```

![Cole o contrato no editor](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-3.webp)

Ã‰ um ERC-20 simples baseado no [Template atual do OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol){target=_blank}. Cria `MyToken` com sÃ­mbolo `MYTOK` e cunha todo o fornecimento inicial para o criador.

Para compilar:

1. Abra a aba **Solidity compiler**
2. Clique em **Compile MyToken.sol**

![Compile MyToken.sol no Remix](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-4.webp)

## Implantando um Contrato com Remix {: #deploying-a-contract-to-your-network-using-remix }

VÃ¡ para **Deployment**, mude **ENVIRONMENT** de **JavaScript VM** para **Injected Web3** para usar o provedor do MetaMask apontando para sua rede Tanssi.

![Altere o ambiente para Injected Web3](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-5.webp)

Permita que o Remix se conecte ao MetaMask:

1. Selecione a(s) conta(s)
2. Clique em **Next**
3. Clique em **Connect**

![Selecione as contas para conectar ao Remix](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-6.webp)

Para implantar o token:

1. Ao lado de **Deploy**, informe o fornecimento inicial `8000000000000000000000000` (8 milhÃµes com 18 decimais) e clique em **Deploy**
2. Confirme a transaÃ§Ã£o no MetaMask

![Insira um saldo de token e implante](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-7.webp)

ApÃ³s a confirmaÃ§Ã£o, o contrato aparece em **Deployed Contracts**. Copie o endereÃ§o se precisar.

![RÃ³tulo Confirmed em uma transaÃ§Ã£o](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-8.webp)

Para interagir:

1. Expanda o contrato em **Deployed Contracts**
2. Em **balanceOf**, cole seu endereÃ§o e clique **balanceOf** para ver o saldo
3. Veja **Decimals**, **Name**, **Symbol** e **Initial Supply**
4. Copie o endereÃ§o do contrato (botÃ£o ao lado do nome)

![Interaja com o contrato do Remix](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-9.webp)

## Interagindo com o ERC-20 no MetaMask {: #interacting-with-an-erc-20-on-your-network-from-metamask }

Abra o MetaMask na conta que implantou o contrato e adicione o token:

1. Aba **Tokens** â†’ **Import tokens**

![Adicione um token](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-10.webp)

2. Cole o endereÃ§o do contrato em **Token contract address** (sÃ­mbolo e decimais preenchem automaticamente) â†’ **Next**

![Cole o endereÃ§o do contrato copiado](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-11.webp)

Confirme em **Import**; vocÃª verÃ¡ 8 milhÃµes de MyTokens.

![Adicione os tokens Ã  sua conta MetaMask](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-12.webp)

Envie 500 MyTokens para outra conta (**Send**), escolha o destinatÃ¡rio e confirme.

![ConfirmaÃ§Ã£o da transferÃªncia de token](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-13.webp)

ApÃ³s a conclusÃ£o, o saldo Ã© reduzido.

![Verifique a reduÃ§Ã£o no saldo da conta](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-14.webp)

VocÃª pode verificar a transaÃ§Ã£o no [explorador da sua rede Tanssi](https://tanssi-evmexplorer.netlify.app){target=_blank}.

![Verifique o status da transaÃ§Ã£o no explorador](/images/builders/toolkit/ethereum-api/dev-environments/remix/remix-15.webp)

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/dev-env/thirdweb/
--- BEGIN CONTENT ---
---
title: Como usar o thirdweb
description: Este guia mostra recursos do thirdweb, incluindo criar, testar e implantar templates de smart contracts para lanÃ§ar dApps na Tanssi.
icon: octicons-code-square-24
categories: EVM-Template
---

# Usando thirdweb na Tanssi

## IntroduÃ§Ã£o {: #introduction }

[thirdweb](https://thirdweb.com){target=\_blank} Ã© um framework completo de desenvolvimento Web3 que fornece tudo o que vocÃª precisa para criar smart contracts, desenvolver dApps e muito mais.

Com o thirdweb, vocÃª acessa ferramentas para todas as fases do ciclo de desenvolvimento de dApps. Ã‰ possÃ­vel criar seus prÃ³prios contratos personalizados ou usar qualquer um dos contratos predefinidos do thirdweb para comeÃ§ar rapidamente. Em seguida, use a CLI do thirdweb para implantar seus smart contracts. Depois, interaja com eles criando uma aplicaÃ§Ã£o Web3 na linguagem de sua escolha, incluindo, entre outras, React e TypeScript.

Este guia mostra alguns recursos do thirdweb que vocÃª pode usar para desenvolver smart contracts e dApps em redes EVM da Tanssi. Para ver todos os recursos que o thirdweb oferece, consulte o [site de documentaÃ§Ã£o do thirdweb](https://portal.thirdweb.com){target=\_blank}.

## Criar Contrato {: #create-contract }

Para criar um novo smart contract usando a [CLI do thirdweb](https://portal.thirdweb.com/cli){target=\_blank}, siga estes passos:

1. No terminal, execute:

    ```bash
    npx thirdweb create contract
    ```

2. Informe suas preferÃªncias nos prompts da linha de comando:
    1. DÃª um nome ao projeto
    2. Escolha o framework: **Hardhat** ou **Foundry**
    3. Nomeie seu smart contract
    4. Escolha o tipo de contrato base: **Empty**, **ERC20**, **ERC721** ou **ERC1155**
    5. Adicione as [extensÃµes](https://portal.thirdweb.com/contracts/extensions){target=\_blank} desejadas
3. ApÃ³s criar, navegue atÃ© o diretÃ³rio do projeto e abra-o no editor de cÃ³digo de sua preferÃªncia
4. Ao abrir a pasta `contracts`, vocÃª encontrarÃ¡ seu smart contract escrito em Solidity

    O cÃ³digo a seguir Ã© de um contrato `ERC721Base` sem extensÃµes especificadas. Ele implementa toda a lÃ³gica contida no contrato [`ERC721Base.sol`](https://github.com/thirdweb-dev/contracts/blob/main/contracts/base/ERC721Base.sol){target=\_blank}, que por sua vez implementa o padrÃ£o [`ERC721A`](https://github.com/thirdweb-dev/contracts/blob/main/contracts/eip/ERC721A.sol){target=\_blank}.

    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    import '@thirdweb-dev/contracts/base/ERC721Base.sol';

    contract Contract is ERC721Base {
        constructor(
            string memory _name,
            string memory _symbol,
            address _royaltyRecipient,
            uint128 _royaltyBps
        ) ERC721Base(_name, _symbol, _royaltyRecipient, _royaltyBps) {}
    }
    ```

    Este contrato herda a funcionalidade de `ERC721Base` pelas etapas:

    - Importar o contrato `ERC721Base`
    - Declarar que seu contrato herda `ERC721Base`
    - Implementar os mÃ©todos necessÃ¡rios, como o builder

5. Depois de ajustar seu contrato com a lÃ³gica desejada, vocÃª pode implantÃ¡-lo em uma rede EVM da Tanssi usando o [Deploy](#deploy-contract). Isso Ã© coberto na prÃ³xima seÃ§Ã£o!

Como alternativa, Ã© possÃ­vel implantar um contrato predefinido para NFTs, tokens ou marketplace diretamente na pÃ¡gina Explore do thirdweb:

1. Acesse a [pÃ¡gina Explore do thirdweb](https://thirdweb.com/explore){target=\_blank}

    ![Explorar contratos no thirdweb](/images/builders/toolkit/ethereum-api/dev-environments/thirdweb/thirdweb-1.webp)

2. Escolha o tipo de contrato que deseja implantar entre as opÃ§Ãµes disponÃ­veis: NFTs, tokens, marketplace e mais
3. Siga os prompts na tela para configurar e implantar seu contrato

Para mais informaÃ§Ãµes sobre os diferentes contratos disponÃ­veis no Explore, consulte a [documentaÃ§Ã£o do thirdweb sobre contratos predefinidos](https://portal.thirdweb.com/contracts){target=\_blank}.

## Implantar Contrato {: #deploy-contract }

O Deploy Ã© a ferramenta do thirdweb que permite implantar um smart contract em qualquer rede compatÃ­vel com EVM sem configurar URLs RPC, expor chaves privadas, escrever scripts ou outras etapas adicionais como verificaÃ§Ã£o do contrato.

1. Para implantar seu smart contract usando o Deploy, navegue atÃ© o diretÃ³rio `contracts` do projeto e execute:

    ```bash
    npx thirdweb deploy
    ```

    Executar este comando aciona as seguintes aÃ§Ãµes:

    - Compila todos os contratos no diretÃ³rio atual
    - Oferece a opÃ§Ã£o de escolher quais contratos vocÃª deseja implantar
    - Envia o cÃ³digo-fonte (ABI) do seu contrato para o IPFS

2. Ao concluir, abrirÃ¡ um dashboard para preencher os parÃ¢metros:

    - `_name` - nome do contrato
    - `_symbol` - sÃ­mbolo ou â€œtickerâ€
    - `_royaltyRecipient` - endereÃ§o da carteira que receberÃ¡ royalties de vendas secundÃ¡rias
    - `_royaltyBps` - basis points (bps) que serÃ£o pagos ao beneficiÃ¡rio a cada venda secundÃ¡ria, ex.: 500 = 5%

3. Selecione a rede desejada, por exemplo, a rede EVM de demonstraÃ§Ã£o da Tanssi ou sua prÃ³pria rede
4. Gerencie configuraÃ§Ãµes adicionais no dashboard do contrato conforme necessÃ¡rio, como fazer upload de NFTs, configurar permissÃµes e mais

    ![Implantar com thirdweb deploy](/images/builders/toolkit/ethereum-api/dev-environments/thirdweb/thirdweb-2.webp)

Para informaÃ§Ãµes adicionais sobre o Deploy, consulte a [documentaÃ§Ã£o do thirdweb](https://portal.thirdweb.com/contracts/){target=\_blank}.

## Criar AplicaÃ§Ã£o {: #create-application }

O thirdweb oferece SDKs para vÃ¡rias linguagens, como React, React Native, TypeScript e Unity. VocÃª comeÃ§arÃ¡ criando uma aplicaÃ§Ã£o e depois poderÃ¡ escolher qual SDK usar:

1. No terminal, execute:

    ```bash
    npx thirdweb create --app
    ```

2. Informe suas preferÃªncias nos prompts:

    1. DÃª um nome ao projeto
    2. Escolha o framework: **Next.js**, **Vite** ou **React Native**. Para este exemplo, selecione **Vite**

3. Use o SDK de React ou TypeScript para interagir com as funÃ§Ãµes da sua aplicaÃ§Ã£o. Isso serÃ¡ abordado na prÃ³xima seÃ§Ã£o sobre interaÃ§Ã£o com contratos

### Especificar o Client ID {: #specify-client-id }

Antes de lanÃ§ar seu dApp (localmente ou em produÃ§Ã£o), vocÃª deve ter um Client ID do thirdweb associado ao projeto. O Client ID do thirdweb equivale a uma chave de API. VocÃª pode criar uma chave de API gratuita [fazendo login na sua conta do thirdweb, indo em **Settings** e clicando em **API Keys**](https://thirdweb.com/dashboard/settings/api-keys){target=\_blank}.

Clique em **Create API Key** e siga estes passos:

1. DÃª um nome para sua chave de API
2. Informe os domÃ­nios permitidos para receber requisiÃ§Ãµes. Ã‰ recomendado permitir apenas os domÃ­nios necessÃ¡rios; para desenvolvimento, pode selecionar **Allow all domains**
3. Clique em **Next** e confirme o prompt na pÃ¡gina seguinte

![Criar API key no thirdweb](/images/builders/toolkit/ethereum-api/dev-environments/thirdweb/thirdweb-3.webp)

!!! note
    O nome da variÃ¡vel do Client ID varia conforme o framework escolhido; por exemplo, no Vite serÃ¡ `VITE_TEMPLATE_CLIENT_ID`, no Next.js serÃ¡ `NEXT_PUBLIC_TEMPLATE_CLIENT_ID` e no React Native serÃ¡ `EXPO_PUBLIC_THIRDWEB_CLIENT_ID`.

Por fim, informe seu Client ID (API Key) no arquivo `.env`. O `.env` deve estar no diretÃ³rio raiz do projeto (por exemplo, nÃ£o na pasta `src`).

Se vocÃª gerou o app thirdweb com Vite, terÃ¡ um arquivo `client.ts` parecido com o abaixo. Se vocÃª criou o `.env` com a chave de API do thirdweb definida em `VITE_TEMPLATE_CLIENT_ID`, pode deixar o `client.ts` como estÃ¡ e seguir para a prÃ³xima seÃ§Ã£o.

```typescript title="client.ts"
import { createThirdwebClient } from 'thirdweb';

// Substitua pela sua string de client ID.
// Consulte https://portal.thirdweb.com/typescript/v5/client para obter um client ID
const clientId = import.meta.env.VITE_TEMPLATE_CLIENT_ID;

export const client = createThirdwebClient({
  clientId: clientId,
});
```

!!! note
    Se vocÃª nÃ£o criar um Client ID e nÃ£o o especificar corretamente no `.env`, verÃ¡ uma tela em branco ao tentar gerar o app. NÃ£o aparece mensagem de erro sem abrir o console, entÃ£o certifique-se de configurar o Client ID corretamente.

### Executar Localmente {: #run-locally }

Para executar seu dApp localmente para testes e depuraÃ§Ã£o, use:

```bash
yarn dev
```

O app serÃ¡ compilado e mostrarÃ¡ o host e a porta para acessar no navegador.

![Executar thirdweb localmente](/images/builders/toolkit/ethereum-api/dev-environments/thirdweb/thirdweb-4.webp)

### Configurar Rede {: #configure-chain }

O thirdweb oferece poucas redes em `@thirdweb/chains` e nÃ£o inclui as redes Tanssi, entÃ£o vocÃª precisa especificar os detalhes da rede, como Chain ID e URL RPC. Crie uma rede personalizada com [`defineChain`](https://portal.thirdweb.com/references/typescript/v5/defineChain){target=\_blank}:

```typescript title="chains.ts"
    import { defineChain } from 'thirdweb';
    const tanssi = defineChain({
      id: {{ networks.dancelight.demo_evm_chain_id }},
      rpc: '{{ networks.dancelight.demo_evm_rpc_url }}',
    });
```

## thirdweb SDK {: #thirdweb-sdk }

As seÃ§Ãµes a seguir dÃ£o uma visÃ£o geral de mÃ©todos fundamentais do SDK do thirdweb e como interagir com eles. Cada trecho de cÃ³digo mostra os imports relevantes e demonstra o uso em um cenÃ¡rio tÃ­pico. Este guia serve como referÃªncia rÃ¡pida para os mÃ©todos mais comuns do thirdweb usados por desenvolvedores de dApps. Para detalhes de todos os recursos do thirdweb, visite o [site de documentaÃ§Ã£o](https://portal.thirdweb.com/){target=\_blank}.

### Contas e Carteiras {: #accounts-and-wallets }

O thirdweb diferencia contas e carteiras no SDK. Para o SDK, uma conta sempre tem um endereÃ§o de blockchain e pode assinar mensagens, transaÃ§Ãµes e dados tipados, mas nÃ£o pode ser â€œconectadaâ€ ou â€œdesconectadaâ€. JÃ¡ uma carteira contÃ©m uma ou mais contas, pode ser conectada ou desconectada e delega a assinatura Ã s contas.

O snippet abaixo mostra como inicializar e conectar uma carteira MetaMask com o SDK do thirdweb, depois assinar e enviar uma transaÃ§Ã£o recuperando o hash. Esse processo se aplica a qualquer um dos mais de 300 conectores de carteira suportados pelo SDK.

???+ code "initialize.ts"
    ```typescript
    import { sendTransaction } from 'thirdweb';
// MetaMask wallet used for example, the pattern is the same for all wallets
import { createWallet } from 'thirdweb/wallets';

// Initialize the wallet. thirdweb supports 300+ wallet connectors
const wallet = createWallet('io.metamask');

// Connect the wallet. This returns a promise that resolves to the connected account
const account = await wallet.connect({
  // Pass the client you created with `createThirdwebClient()`
  client,
});

// Sign and send a transaction with the account. Returns the transaction hash
const { transactionHash } = await sendTransaction({
  // Assuming you have called `prepareTransaction()` or `prepareContractCall()` before, which returns the prepared transaction to send
  transaction,
  // Pass the account to sign the transaction with
  account,
});
    ```

### Obter contrato {: #get-contract }

Para conectar ao seu contrato, use o mÃ©todo [`getContract`](https://portal.thirdweb.com/references/typescript/v5/getContract){target=\_blank} do SDK. Por exemplo, vocÃª pode buscar dados de um [contrato incrementer na rede EVM de demonstraÃ§Ã£o da Tanssi]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D?tab=contract){target=\_blank}.

```typescript
import { getContract } from 'thirdweb';
import { client } from './client';

const myContract = getContract({
  client,
  chain: tanssi,
  address: 0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D, // EndereÃ§o do contrato Incrementer na demo EVM
  abi: '[{\"inputs\":[],\"name\":\"increment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]';
});
```

### Chamar funÃ§Ãµes do contrato {: #calling-contract-functions }

Para chamar um contrato na versÃ£o mais recente do SDK, use [`prepareContractCall`](https://portal.thirdweb.com/typescript/v5/transactions/prepare){target=\_blank}.

```typescript
import { prepareContractCall, toWei } from 'thirdweb';

const tx = prepareContractCall({
  contract,
  // Assine a funÃ§Ã£o que deseja chamar
  method: 'function mintTo(address to, uint256 amount)',
  // Passe os parÃ¢metros para o mÃ©todo.
  // Os tipos sÃ£o inferidos automaticamente pela assinatura
  params: ['0x123...', toWei('100')],
});
```

Voltando ao [contrato incrementer]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D?tab=contract){target=\_blank}, preparar uma chamada para incrementar o contrato fica assim:

```typescript
import { prepareContractCall } from 'thirdweb';

const tx = prepareContractCall({
  contract,
  // Assine a funÃ§Ã£o que deseja chamar
  method: 'function increment()',
  // Increment nÃ£o recebe parÃ¢metros, entÃ£o deixe um array vazio
  params: [],
});
```

### Preparar transaÃ§Ãµes brutas {: #preparing-raw-transactions }

VocÃª tambÃ©m pode preparar uma transaÃ§Ã£o diretamente com dados codificados. Para isso, use o mÃ©todo [`prepareTransaction`](https://portal.thirdweb.com/typescript/v5/transactions/prepare){target=\_blank} do thirdweb e especifique diretamente `to`, `value`, `chain` e `client`.

```typescript
import { prepareTransaction, toWei } from 'thirdweb';

const transaction = prepareTransaction({
  // Conta que receberÃ¡
  to: '0x456...',
  // Valor em ether a enviar na transaÃ§Ã£o
  value: toWei('1'),
  // Rede onde a transaÃ§Ã£o serÃ¡ executada. Assume que vocÃª jÃ¡ configurou
  // a rede EVM demo da Tanssi como chain personalizada, conforme mostrado na seÃ§Ã£o de configuraÃ§Ã£o
  chain: tanssi,
  // Seu client thirdweb
  client,
});
```

### Ler Estado do Contrato {: #read-contract-state }

Use a funÃ§Ã£o [`readContract`](https://portal.thirdweb.com/typescript/v5/transactions/read){target=\_blank} para chamar funÃ§Ãµes de leitura do contrato informando a assinatura do mÃ©todo Solidity e eventuais parÃ¢metros.

```typescript
import { readContract } from 'thirdweb';

const balance = await readContract({
  contract: contract,
  method: 'function balanceOf(address) view returns (uint256)',
  params: ['0x123...'],
});
```

Para uma funÃ§Ã£o sem parÃ¢metros, como `number`, que retorna o nÃºmero atual armazenado no [contrato incrementer]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D?tab=contract){target=\_blank}, basta informar o nome da funÃ§Ã£o:

```typescript
import { readContract } from 'thirdweb';

const number = await readContract({
  contract: contract,
  method: 'number',
  params: [],
});
```

VocÃª sabia? Com a [CLI do thirdweb](https://portal.thirdweb.com/cli){target=\_blank}, vocÃª gera facilmente funÃ§Ãµes para todas as chamadas possÃ­veis de um contrato. Para isso, execute:

```bash
npx thirdweb generate INSERT_CHAIN_ID/INSERT_CONTRACT_ADDRESS
```

Chain ID e endereÃ§o do contrato sÃ£o obrigatÃ³rios. Por exemplo, para gerar funÃ§Ãµes do [contrato incrementer na demo EVM da Tanssi]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D?tab=contract){target=\_blank}, use:

```bash
npx thirdweb generate {{ networks.dancelight.demo_evm_chain_id }}/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D
```

O arquivo gerado com todos os mÃ©todos correspondentes ficarÃ¡ em `thirdweb/CHAIN_ID/CONTRACT_ADDRESS`. No exemplo acima, o arquivo de saÃ­da fica em `thirdweb/{{ networks.dancelight.demo_evm_chain_id }}/0xC12f6fA2d1CA8f875bD25555e8883f1dDa40a93D.ts`. Para mais informaÃ§Ãµes, veja a [documentaÃ§Ã£o do thirdweb sobre a CLI](https://portal.thirdweb.com/cli/generate){target=\_blank}.

### Enviar uma TransaÃ§Ã£o {: #sending-a-transaction }

Toda transaÃ§Ã£o enviada com o SDK precisa ser preparada primeiro. Essa preparaÃ§Ã£o Ã© sÃ­ncrona e leve, sem requisiÃ§Ãµes de rede. AlÃ©m disso, fornece definiÃ§Ãµes type-safe para as chamadas de contrato.

VocÃª pode preparar uma transaÃ§Ã£o assim:

```typescript title="Prepare uma transaÃ§Ã£o"
import { prepareTransaction, toWei } from 'thirdweb';

const transaction = prepareTransaction({
  to: '0x1234567890123456789012345678901234567890',
  chain: tanssi,
  client: thirdwebClient,
  value: toWei('1.0'),
  gasPrice: 150n,
});
```

Depois de preparada, envie a transaÃ§Ã£o assim:

```typescript title="Enviar uma transaÃ§Ã£o"
import { sendTransaction } from 'thirdweb';

const { transactionHash } = await sendTransaction({
  account,
  transaction,
});
```

Opcionalmente, use `sendAndConfirmTransaction` para aguardar a mineraÃ§Ã£o. Isso Ã© Ãºtil se vocÃª quiser bloquear o usuÃ¡rio atÃ© a confirmaÃ§Ã£o.

```typescript title="Enviar e confirmar uma transaÃ§Ã£o"
import { sendAndConfirmTransaction } from 'thirdweb';
import { createWallet } from 'thirdweb/wallets';

const wallet = createWallet('io.metamask');
const account = await wallet.connect({ client });

const receipt = await sendAndConfirmTransaction({
  transaction,
  account,
});
```

### Utilidades de TransaÃ§Ã£o {: #transaction-utilites }

O thirdweb fornece diversos utilitÃ¡rios para preparar e enviar transaÃ§Ãµes.

VocÃª pode estimar o gas usado por uma transaÃ§Ã£o:

```typescript title="Estimando gas"
import { estimateGas } from 'thirdweb';

const gasEstimate = await estimateGas({ transaction });
console.log('gas estimado', gasEstimate);
```

TambÃ©m Ã© possÃ­vel estimar o custo em Ether e Wei:

```typescript title="Estimando custo de gas"
import { estimateGas } from 'thirdweb';

const gasCost = await estimateGasCost({ transaction });
console.log('custo em ether', gasCost.ether);
```

O thirdweb tambÃ©m oferece uma forma prÃ¡tica de simular transaÃ§Ãµes e verificar a integridade antes de submetÃª-las. VocÃª pode simular uma transaÃ§Ã£o assim:

```typescript title="Simular uma transaÃ§Ã£o"
import { simulateTransaction } from 'thirdweb';

const result = await simulateTransaction({ transaction });
console.log('resultado da simulaÃ§Ã£o', result);
```

VocÃª pode codificar dados da transaÃ§Ã£o para usar depois:

```typescript title="Codificar dados da transaÃ§Ã£o"
import { encode } from 'thirdweb';

const data = await encode(transaction);
console.log('dados codificados', data);
```

### ConnectButton {: #connect-button }

Provavelmente a primeira interaÃ§Ã£o do usuÃ¡rio com seu dApp serÃ¡ conectar a carteira. O thirdweb fornece uma maneira fÃ¡cil e altamente personalizÃ¡vel de habilitar isso. O [`ConnectButton`](https://portal.thirdweb.com/react/v5/components/ConnectButton){target=\_blank} pode ser adaptado Ã s carteiras desejadas. O `ConnectButton` aceita um parÃ¢metro opcional `wallets` com um array de carteiras. VocÃª pode adicionar ou remover carteiras do array para alterar as opÃ§Ãµes disponÃ­veis aos usuÃ¡rios. O thirdweb tambÃ©m oferece um [Playground do ConnectButton](https://thirdweb.com/dashboard/connect/playground){target=\_blank} para personalizar e ver as alteraÃ§Ãµes em tempo real, dada a alta flexibilidade do botÃ£o.

```typescript title="ConnectButton"
import { ConnectButton } from 'thirdweb/react';
import { createWallet, inAppWallet } from 'thirdweb/wallets';
 
const wallets = [
  inAppWallet(),
  createWallet('io.metamask'),
  createWallet('com.coinbase.wallet'),
  createWallet('me.rainbow'),
];
 
function Example() {
  return (
    <div>
      <ConnectButton client={client} wallets={wallets} />
    </div>
  );
}
```

## Implantar a AplicaÃ§Ã£o {: #deploy-application }

Relembrando, vocÃª pode compilar o projeto de exemplo localmente executando:

```bash
yarn dev
```

Para hospedar sua aplicaÃ§Ã£o web estÃ¡tica em armazenamento descentralizado, execute:

```bash
npx thirdweb deploy --app
```

Executar esse comando cria a build de produÃ§Ã£o e armazena usando o [Storage](https://portal.thirdweb.com/references/typescript/v5/functions#storage){target=\_blank}, a soluÃ§Ã£o descentralizada de arquivos do thirdweb. Ele envia a aplicaÃ§Ã£o construÃ­da para o IPFS, uma rede de armazenamento descentralizada, e gera uma URL Ãºnica que fornece um local persistente para hospedar sua aplicaÃ§Ã£o na web.

Se tiver dÃºvidas ou encontrar problemas durante o processo, contate o suporte do thirdweb em [support.thirdweb.com](http://support.thirdweb.com){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/
--- BEGIN CONTENT ---
---
title: API Ethereum
description: Aprenda a interagir com sua rede compatÃ­vel com EVM Tanssi por meio da API Ethereum com diferentes ambientes de desenvolvimento, bibliotecas e muito mais.
icon: material-ethereum
template: index-page.html
---

# Ferramentas Ethereum

Desenvolver em cadeias compatÃ­veis com EVM baseadas em Tanssi requer a compreensÃ£o de como interagir com o blockchain de forma eficaz. Seja vocÃª construindo aplicativos descentralizados (dApps), implantando contratos inteligentes ou consultando dados de blockchain, o uso das ferramentas e fluxos de trabalho corretos Ã© essencial.

Esta seÃ§Ã£o oferece uma visÃ£o geral das principais ferramentas e fluxos de trabalho que os desenvolvedores usam para interagir com essas redes, ajudando a aprimorar seu fluxo de trabalho de desenvolvimento.

Pronto para mergulhar? Confira algumas das seguintes ferramentas:

- **Ambientes de desenvolvimento** - [Remix](/pt/builders/toolkit/ethereum-api/dev-env/remix/), [Foundry](/pt/builders/toolkit/ethereum-api/dev-env/foundry/) e [Hardhat](/builders/toolkit/ethereum-api/dev-env/hardhat/)
- **Bibliotecas** - [Ethers.js](/pt/builders/toolkit/ethereum-api/libraries/ethersjs/), [viem](/pt/builders/toolkit/ethereum-api/libraries/viem/) e [Web3.js](/pt/builders/toolkit/ethereum-api/libraries/web3js/)
- **Carteiras** - [MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/), [SubWallet](/pt/builders/toolkit/ethereum-api/wallets/subwallet/) e [Talisman](/pt/builders/toolkit/ethereum-api/wallets/talisman/)

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/libraries/ethersjs/
--- BEGIN CONTENT ---
---
title: TransaÃ§Ãµes e Contratos EVM com Ethers.js
description: Aprenda a usar a biblioteca Ethers.js para enviar transaÃ§Ãµes e implantar contratos Solidity na sua rede compatÃ­vel com Ethereum Powered by Tanssi.
icon: octicons-code-24
categories: EVM-Template
---

# Biblioteca JavaScript Ethers.js

<style>.video-container{display:flex;justify-content:space-between;max-width:1000px;margin:0 auto;}.video-column{width:49%;}.embed-container{position:relative;padding-bottom:56.25%;height:0;overflow:hidden;max-width:100%;margin-bottom:10px;}.embed-container iframe,.embed-container object,.embed-container embed{position:absolute;top:0;left:0;width:100%;height:100%;}</style><div class="video-container"><div class="video-column"><div class='embed-container'><iframe src='https://www.youtube.com/embed/bXtknNifO78?si=Hjiah5yhKvBcsE7f' frameborder='0' allowfullscreen></iframe></div></div><div class="video-column"><div class='embed-container'><iframe src='https://www.youtube.com/embed/m9iVeCP7owI?si=krm6z9AsFCDrjlJh' frameborder='0' allowfullscreen></iframe></div></div></div>

## IntroduÃ§Ã£o {: #introduction }

A biblioteca [Ethers.js](https://docs.ethers.org/v6/){target=\_blank} fornece ferramentas para interagir com nÃ³s Ethereum usando JavaScript, semelhante Ã  [Web3.js](/pt/builders/toolkit/ethereum-api/libraries/web3js/){target=\_blank}. As redes EVM Powered by Tanssi oferecem uma API compatÃ­vel com Ethereum/JSON-RPC, entÃ£o vocÃª pode usar Ethers.js para interagir com uma rede EVM da Tanssi como faria no Ethereum. Para mais detalhes, consulte a [documentaÃ§Ã£o oficial](https://docs.ethers.org/v6){target=\_blank}.

Neste guia vocÃª aprenderÃ¡ a usar Ethers.js na sua rede EVM da Tanssi. Para demonstrar, enviaremos uma transaÃ§Ã£o e implantaremos um contrato em uma appchain EVM de demonstraÃ§Ã£o rodando no [Dancelight](/pt/builders/tanssi-network/testnet/dancelight/){target=\_blank}. Para sua prÃ³pria appchain Tanssi, basta trocar o endpoint.

Se preferir vÃ­deo, veja os tutoriais no topo desta pÃ¡gina sobre [Enviar transaÃ§Ãµes com Ethers.js](#send-a-transaction) e [Implantar contratos com Ethers.js](#deploy-a-contract).

!!! note
    Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessÃ¡rio.
    
    Verifique tambÃ©m se vocÃª tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a [documentaÃ§Ã£o oficial](https://nodejs.org/en/download){target=\blank}.
    
    AlÃ©m disso, certifique-se de ter inicializado um arquivo `package.json` para mÃ³dulos ES6. VocÃª pode criar um `package.json` padrÃ£o com npm executando `npm init --yes`.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia vocÃª precisarÃ¡:

 - De uma conta com fundos na rede EVM da Tanssi que estiver usando para testes

## Instalando Ethers.js {: #install-ethersjs }

Instale a biblioteca Ethers.js e o compilador Solidity:

=== "npm"

    ```bash
    npm install ethers solc@0.8.0
    ```

=== "yarn"

    ```bash
    yarn add ethers solc@0.8.0
    ```

## Configurando o Provedor Ethers {: #setting-up-the-ethers-provider }

Os scripts a seguir usam um [provedor Ethers](https://docs.ethers.org/v6/api/providers/){target=\_blank} para falar com a rede.

1. Importe `ethers`
2. Defina `providerRPC` com `name`, `rpc` e `chainId` da rede
3. Crie o `provider` com `ethers.JsonRpcProvider`

```js
// 1. Importe ethers
import { ethers } from "ethers";

// 2. Defina as configuraÃ§Ãµes da rede
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    // Insira aqui sua URL RPC
    rpc: '{{ networks.dancelight.demo_evm_rpc_url }}',
    chainId: {{ networks.dancelight.demo_evm_chain_id }}, // {{ networks.dancelight.demo_evm_chain_hex_id }} em hexadecimal,
  },
};
// 3. Crie o provider do ethers
const provider = new ethers.JsonRpcProvider(
  providerRPC.evmNetwork.rpc, 
  {
    chainId: providerRPC.evmNetwork.chainId,
    name: providerRPC.evmNetwork.name,
  }
);
```

Guarde este trecho; ele Ã© reutilizado nos scripts abaixo.

## Enviar uma TransaÃ§Ã£o {: #send-a-transaction }

Criaremos dois scripts: um para consultar saldos e outro para enviar a transaÃ§Ã£o.

### Script de Saldos {: #check-balances-script }

Crie o arquivo:

```bash
touch balances.js
```

Depois monte o script:

1. Inclua o provedor
2. Defina `addressFrom` e `addressTo`
3. Crie a funÃ§Ã£o `balances`
4. Use `provider.getBalance` e `ethers.formatEther` para exibir os saldos
5. Chame `balances()`

```js
// 1. Adicione aqui a lÃ³gica do provider do Ethers:
// {...}

// 2. Crie as variÃ¡veis de endereÃ§o
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// 3. Crie a funÃ§Ã£o de saldos
const balances = async () => {
  // 4. Busque os saldos
  const balanceFrom = ethers.formatEther(await provider.getBalance(addressFrom));
  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} {{ networks.dancelight.demo_evm_token_symbol }}`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} {{ networks.dancelight.demo_evm_token_symbol }}`);
};

// 5. Chamar a funÃ§Ã£o de saldos
balances();
```

??? code "Ver o script completo"

    ```js
    // Import ethers
import { ethers } from 'ethers';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};
// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Define addresses
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// Create balances function
const balances = async () => {
  // Fetch balances
  const balanceFrom = ethers.formatEther(
    await provider.getBalance(addressFrom)
  );
  const balanceTo = ethers.formatEther(await provider.getBalance(addressTo));

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);
};

// Call the balances function
balances();
    ```

Execute:

```bash
node balances.js
```

Saldos serÃ£o exibidos em {{ networks.dancelight.demo_evm_token_symbol }}.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node balances.js</span>
  <span data-ty>The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 20.0 TANGO
    <br> The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 1.0 TANGO
  </span>
</div>

### Script de Envio de TransaÃ§Ã£o {: #send-transaction-script }

Crie o arquivo:

```bash
touch transaction.js
```

Passos:

1. Inclua o provedor
2. Defina `privateKey` e `addressTo` (**nÃ£o armazene chaves reais em arquivos JS**)
3. Crie a wallet com `privateKey` e `provider`
4. Crie a funÃ§Ã£o `send`
5. Monte o objeto de transaÃ§Ã£o (`to`, `value` com `ethers.parseEther`)
6. Envie com `wallet.sendTransaction` e aguarde o recibo
7. Chame `send()`

```js
// 1. Adicione aqui a lÃ³gica do provider do Ethers:
// {...}

// 2. Crie as variÃ¡veis da conta
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const addressTo = 'INSERT_ADDRESS_TO';

// 3. Crie a wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// 4. Crie a funÃ§Ã£o de envio
const send = async () => {
  console.log(`Attempting to send transaction from ${wallet.address} to ${addressTo}`);

  // 5. Crie o objeto da tx
  const tx = {
    to: addressTo,
    value: ethers.parseEther('1'),
  };

  // 6. Assine e envie a tx â€” aguarde o recibo
  const createReceipt = await wallet.sendTransaction(tx);
  await createReceipt.wait();
  console.log(`Transaction successful with hash: ${createReceipt.hash}`);
};

// 7. Chame a funÃ§Ã£o de envio
send();
```

??? code "Ver o script completo"

    ```js
    // Import ethers
import { ethers } from 'ethers';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Define accounts and wallet
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const addressTo = 'INSERT_ADDRESS_TO';
const wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// Create send function
const send = async () => {
  console.log(
    `Attempting to send transaction from ${wallet.address} to ${addressTo}`
  );

  // Create transaction
  const tx = {
    to: addressTo,
    value: ethers.parseEther('1'),
  };

  // Send transaction and get hash
  const createReceipt = await wallet.sendTransaction(tx);
  await createReceipt.wait();
  console.log(`Transaction successful with hash: ${createReceipt.hash}`);
};

// Call the send function
send();
    ```

Rode com:

```bash
node transaction.js
```

O hash serÃ¡ exibido. Use `balances.js` antes/depois para confirmar a mudanÃ§a de saldo.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node transaction.js</span>
  <span data-ty>Attempting to send transaction from 0x44236223aB4291b93EEd10E4B511B37a398DEE55 to 0x8841701 Dba3639B254D9CEe712E49D188A1e941e
    <br> Transaction successful with hash: 0x29d87c00704b949cb4cc04fdc6c98d53b3c0ec4fb3ffe0c52864a73 b586f563c
  </span>
  <span data-ty="input"><span class="file-path"></span>node balances.js</span>
  <span data-ty>The balance of 0x44236223aB4291b93EEd10E4B511B37a398DEE55 is: 18.999958 TANGO
    <br> The balance of 0x8841701Dba3639B254D9CEe712E49D188A1e941e is: 2.0 TANGO
  </span>
</div>

## Implantar um Contrato {: #deploy-a-contract }

O contrato que vocÃª irÃ¡ compilar e implantar nas prÃ³ximas seÃ§Ãµes Ã© um simples incrementador, chamado `Incrementer.sol`. Comece criando o arquivo do contrato:

```
touch Incrementer.sol
```

Depois, adicione o cÃ³digo Solidity ao arquivo:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
```

A funÃ§Ã£o `constructor`, executada quando o contrato Ã© implantado, define o valor inicial da variÃ¡vel `number` armazenada on-chain (padrÃ£o Ã© 0). A funÃ§Ã£o `increment` soma o `_value` informado ao nÃºmero atual, mas exige uma transaÃ§Ã£o, pois modifica o dado armazenado. Por fim, a funÃ§Ã£o `reset` zera o valor armazenado.

!!! note
    Este contrato Ã© apenas um exemplo simples para fins ilustrativos.

### Script de CompilaÃ§Ã£o {: #compile-contract-script }

Nesta seÃ§Ã£o, vocÃª criarÃ¡ um script que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato `Incrementer.sol`. Para comeÃ§ar, crie o arquivo `compile.js` executando:

```
touch compile.js
```

Em seguida, escreva o script e conclua estas etapas:

1. Importe os pacotes `fs` e `solc`
2. Use `fs.readFileSync` para ler e salvar o conteÃºdo de `Incrementer.sol` em `source`
3. Monte o objeto `input` para o compilador Solidity especificando `language`, `sources` e `settings`
4. Compile o contrato usando `solc.compile` com o objeto `input`
5. Extraia o contrato compilado e exporte-o para ser usado no script de implantaÃ§Ã£o

```js
// 1. Import packages
import fs from 'fs';
import solc from 'solc';

// 2. Get path and load contract
const source = fs.readFileSync('Incrementer.sol', 'utf8');

// 3. Create input object
const input = {
  language: 'Solidity',
  sources: {
    'Incrementer.sol': {
      content: source,
    },
  },
  settings: {
    outputSelection: {
      '*': {
        '*': ['*'],
      },
    },
  },
};
// 4. Compile the contract
const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));
const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];

// 5. Export contract data
export default contractFile;
```

### Script de Deploy {: #deploy-contract-script }
Compile `Incrementer.sol` e depois crie `deploy.js`:

```bash
touch deploy.js
```

Passos:

1. Importe o contrato de `compile.js`
2. Inclua o provedor
3. Defina `privateKey` (**nÃ£o salve chaves reais em JS**)
4. Guarde `bytecode` e `abi`
5. Crie a wallet
6. Crie a `ContractFactory`
7. Crie a funÃ§Ã£o `deploy`
8. Use `incrementer.deploy(5)` e aguarde o recibo
9. Chame `deploy()`

```js
// 1. Importe o arquivo do contrato
import contractFile from './compile';

// 2. Adicione aqui a lÃ³gica do provider do Ethers:
// {...}

// 3. Crie as variÃ¡veis da conta
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};

// 4. Salve o bytecode e o ABI
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// 5. Crie a wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// 6. Crie a instÃ¢ncia do contrato com o assinante
const incrementer = new ethers.ContractFactory(abi, bytecode, wallet);

// 7. Crie a funÃ§Ã£o de deploy
const deploy = async () => {
  console.log(`Attempting to deploy from account: ${wallet.address}`);

  // 8. Envie a tx (valor inicial definido como 5) e aguarde o recibo
  const contract = await incrementer.deploy(5);
  const txReceipt = await contract.deploymentTransaction().wait();

  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);
};

// 9. Chame a funÃ§Ã£o de deploy
deploy();
```

??? code "Ver o script completo"

    ```js
    // Import ethers and compile
import { ethers } from 'ethers';
import contractFile from './compile.js';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Define accounts and wallet
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// Load contract info
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// Create contract instance with signer
const incrementer = new ethers.ContractFactory(abi, bytecode, wallet);

// Create deploy function
const deploy = async () => {
  console.log(`Attempting to deploy from account: ${wallet.address}`);

  // Send tx (initial value set to 5) and wait for receipt
  const contract = await incrementer.deploy(5);
  const txReceipt = await contract.deploymentTransaction().wait();

  console.log(`Contract deployed at address: ${txReceipt.contractAddress}`);
};

// Call the deploy function
deploy();
    ```

Execute:

```bash
node deploy.js
```

O endereÃ§o do contrato serÃ¡ exibido.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node deploy.js</span>
  <span data-ty>Attempting to deploy from account: 0x44236223aB4291b93EEd10E4B511B37a398DEE55
    <br> Contract deployed at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2
  </span>
</div>

### Ler Dados do Contrato (Calls) {: #read-contract-data }

Calls nÃ£o alteram estado; nenhuma transaÃ§Ã£o Ã© enviada. Crie `get.js`:

```bash
touch get.js
```

Passos:

1. Importe o `contractFile` de `compile.js`
2. Inclua o provedor
3. Defina `contractAddress`
4. Crie a instÃ¢ncia com `ethers.Contract`
5. Crie a funÃ§Ã£o `get`
6. Chame `incrementer.number()` e exiba o valor
7. Chame `get()`

```js
// 1. Importe o ABI do contrato
import contractFile from './compile';

// 2. Adicione aqui a lÃ³gica do provider do Ethers:
// {...}

// 3. VariÃ¡vel do endereÃ§o do contrato
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// 4. Crie a instÃ¢ncia do contrato
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  provider
);

// 5. Crie a funÃ§Ã£o get
const get = async () => {
  console.log(`Fazendo uma chamada para o contrato no endereÃ§o: ${contractAddress}`);

  // 6. Chame o contrato 
  const data = await incrementer.number();

  console.log(`The current number stored is: ${data}`);
};

// 7. Chame a funÃ§Ã£o get
get();
```

??? code "Ver o script completo"

    ```js
    // Import ethers and compile
import { ethers } from 'ethers';
import contractFile from './compile.js';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Contract address variable
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// Create contract instance
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  provider
);

// Create get function
const get = async () => {
  console.log(`Making a call to contract at address: ${contractAddress}`);

  // Call contract
  const data = await incrementer.number();

  console.log(`The current number stored is: ${data}`);
};

// Call get function
get();
    ```

Rode com:

```bash
node get.js
```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node get.js</span>
  <span data-ty>Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2
    <br> The current number stored is: 5
  </span>
</div>

### Interagir com o Contrato (Send) {: #interact-with-contract }

Sends alteram estado e exigem transaÃ§Ã£o. Crie `increment.js` e `reset.js`:

```bash
touch increment.js reset.js
```

`increment.js`:

1. Importe `contractFile`
2. Inclua o provedor
3. Defina `privateKey`, `contractAddress`, `_value` (**nÃ£o salve chaves reais em JS**)
4. Crie a wallet
5. Crie a instÃ¢ncia do contrato com signer
6. Crie a funÃ§Ã£o `increment`
7. Chame `incrementer.increment(_value)` e aguarde recibo
8. Chame `increment()`

```js
// 1. Importe o ABI do contrato
import contractFile from './compile';

// 2. Adicione aqui a lÃ³gica do provider do Ethers:
// {...}

// 3. Crie as variÃ¡veis
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const _value = 3;

// 4. Crie a wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// 5. Crie a instÃ¢ncia do contrato com o assinante
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  wallet
);

// 6. Crie a funÃ§Ã£o de incremento
const increment = async () => {
  console.log(
    `Chamando a funÃ§Ã£o de incremento por ${_value} no contrato no endereÃ§o: ${contractAddress}`
  );

  // 7. Assine e envie a tx e aguarde o recibo
  const createReceipt = await incrementer.increment(_value);
  await createReceipt.wait();

  console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

// 8. Chame a funÃ§Ã£o de incremento
increment();
```

??? code "Ver o script completo"

    ```js
    // Import ethers and compile
import { ethers } from 'ethers';
import contractFile from './compile.js';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const _value = 3;

// Create wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// Create contract instance with signer
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  wallet
);

// Create increment function
const increment = async () => {
  console.log(
    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
  );

  // Sign and send tx and wait for receipt
  const createReceipt = await incrementer.increment(_value);
  await createReceipt.wait();

  console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

// Call the increment function
increment();
    ```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node increment.js</span>
  <span data-ty>Calling the increment by 3 function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2
    <br> Tx successful with hash: 0x8aa7ccb4613ac92713bcc6ff064f1b0c978e24b3f6acb6d6bfa730a10af522bb
  </span>
  <span data-ty="input"><span class="file-path"></span>node get.js</span>
  <span data-ty>Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2
    <br> The current number stored is: 8
  </span>
</div>

`reset.js`:

1. Importe `contractFile`
2. Inclua o provedor
3. Defina `privateKey` e `contractAddress`
4. Crie a wallet
5. Crie a instÃ¢ncia do contrato com signer
6. Crie a funÃ§Ã£o `reset`
7. Chame `incrementer.reset()` e aguarde recibo
8. Chame `reset()`

```js
// 1. Importe o ABI do contrato
import contractFile from './compile';

// 2. Adicione aqui a lÃ³gica do provider do Ethers:
// {...}

// 3. Crie as variÃ¡veis
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// 4. Crie a wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// 5. Crie a instÃ¢ncia do contrato com o assinante
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  wallet
);

// 6. Crie a funÃ§Ã£o de reset
const reset = async () => {
  console.log(`Chamando a funÃ§Ã£o de reset no contrato no endereÃ§o: ${contractAddress}`);

  // 7. Assine e envie a tx e aguarde o recibo
  const createReceipt = await incrementer.reset();
  await createReceipt.wait();

  console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

// 8. Chame a funÃ§Ã£o de reset
reset();
```

??? code "Ver o script completo"

    ```js
    // Import ethers and compile
import { ethers } from 'ethers';
import contractFile from './compile.js';

// Define network configurations
const providerRPC = {
  evmNetwork: {
    name: 'dancelight-evm-network',
    rpc: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
    chainId: 5678, // 0x162E in hex,
  },
};

// Create ethers provider
const provider = new ethers.JsonRpcProvider(providerRPC.evmNetwork.rpc, {
  chainId: providerRPC.evmNetwork.chainId,
  name: providerRPC.evmNetwork.name,
});

// Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// Create wallet
let wallet = new ethers.Wallet(accountFrom.privateKey, provider);

// Create contract instance with signer
const incrementer = new ethers.Contract(
  contractAddress,
  contractFile.abi,
  wallet
);

// Create reset function
const reset = async () => {
  console.log(
    `Calling the reset function in contract at address: ${contractAddress}`
  );

  // Sign and send tx and wait for receipt
  const createReceipt = await incrementer.reset();
  await createReceipt.wait();

  console.log(`Tx successful with hash: ${createReceipt.hash}`);
};

// Call the reset function
reset();
    ```

Rode:

```bash
node increment.js
node reset.js
```

Use `get.js` junto para confirmar a mudanÃ§a de valor.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>node increment.js</span>
  <span data-ty>Calling the reset function in contract at address: 0x2EF0C649C08D55637dec9fCcebCFe D27F2F2a5F2
    <br> Tx successful with hash: 0xb689da50a43e98b5a83ff64757afbf100be12e2db6ff4d0504168f262cc08fb0
  </span>
  <span data-ty="input"><span class="file-path"></span>node get.js</span>
  <span data-ty>Making a call to contract at address: 0x2EF0C649C08D55637dec9fCcebCFeD27F2F2a5F2
    <br> The current number stored is: 0
  </span>
</div>

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/libraries/
--- BEGIN CONTENT ---
---
title: Bibliotecas Ethereum
description: Aprenda a usar bibliotecas Ethereum como Ethers.js, Web3.js ou Web3.py para enviar transaÃ§Ãµes ou implantar contratos em sua rede Tanssi EVM.
icon: octicons-code-24
template: index-page.html
---

# Bibliotecas

As bibliotecas sÃ£o ferramentas essenciais para interagir com redes blockchain. Elas fornecem funÃ§Ãµes e abstraÃ§Ãµes prÃ©-construÃ­das que simplificam tarefas como leitura e escrita de dados de cadeia. Essas bibliotecas eliminam a necessidade de lidar com solicitaÃ§Ãµes brutas da blockchain, tornando mais fÃ¡cil para os desenvolvedores construÃ­rem e implantarem aplicativos descentralizados, garantindo a compatibilidade com o Ethereum e outras redes compatÃ­veis com EVM.

Algumas das principais capacidades de trabalhar com bibliotecas incluem:

- **Gerenciamento de transaÃ§Ãµes** - criar, assinar e transmitir transaÃ§Ãµes
- **InteraÃ§Ãµes com contratos inteligentes** - simplificar a chamada de funÃ§Ãµes de contrato, decodificar respostas e lidar com eventos de contrato
- **IntegraÃ§Ã£o de carteira** - facilitar integraÃ§Ãµes de carteira seguras para transacionar com a rede
- **AnÃ¡lise de dados de blockchain** - decodificar e interpretar estruturas de dados complexas retornadas por contratos inteligentes
- **Monitoramento de eventos** - ouvir eventos emitidos por contratos e acionar aÃ§Ãµes especÃ­ficas do aplicativo

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/libraries/viem/
--- BEGIN CONTENT ---
---
title: Como usar a biblioteca viem Ethereum
description: Neste tutorial, use a interface TypeScript do viem para enviar transaÃ§Ãµes e implantar contratos Solidity na sua rede EVM powered by Tanssi.
icon: octicons-code-24
categories: EVM-Template
---

# Biblioteca viem TypeScript Ethereum

## IntroduÃ§Ã£o {: #introduction }

[viem](https://viem.sh){target=\_blank} Ã© uma biblioteca TypeScript modular que fornece abstraÃ§Ãµes sobre a API JSON-RPC, facilitando a interaÃ§Ã£o com nÃ³s Ethereum. Como as redes EVM da Tanssi expÃµem uma API compatÃ­vel com Ethereum/JSON-RPC, vocÃª pode usar viem para interagir com qualquer rede EVM Tanssi. Veja a [documentaÃ§Ã£o do viem](https://viem.sh/docs/getting-started){target=\_blank} para mais detalhes.

Neste guia, vocÃª verÃ¡ como usar viem para enviar uma transaÃ§Ã£o e implantar um contrato na rede EVM de demonstraÃ§Ã£o. O mesmo fluxo se aplica a qualquer rede EVM da Tanssi.

!!! note
    Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessÃ¡rio.
    
    Verifique tambÃ©m se vocÃª tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a [documentaÃ§Ã£o oficial](https://nodejs.org/en/download){target=\blank}.
    
    AlÃ©m disso, certifique-se de ter inicializado um arquivo `package.json` para mÃ³dulos ES6. VocÃª pode criar um `package.json` padrÃ£o com npm executando `npm init --yes`.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos, vocÃª precisarÃ¡ de:

 - Uma conta com fundos na rede EVM Tanssi que estiver usando

## Instalando viem {: #installing-viem }

Crie um projeto TypeScript bÃ¡sico e instale dependÃªncias:

```bash
mkdir viem-examples && cd viem-examples && npm init --y
```

Instale viem e o compilador Solidity:

=== "npm"

    ```bash
    npm install typescript ts-node viem solc@0.8.0
    ```

=== "yarn"

    ```bash
    yarn add typescript ts-node viem solc@0.8.0
    ```

Gere o `tsconfig`:

```bash
npx tsc --init
```

!!! note
    Tutorial criado usando Node.js v18.18.0.

## Configurar um Cliente viem (Provedor) {: #setting-up-a-viem-provider }

VocÃª pode criar:
- um cliente de leitura com `createPublicClient`, para saldos/dados; ou
- um cliente de escrita com `createWalletClient`, para enviar transaÃ§Ãµes.

Primeiro defina a cadeia com `defineChain`, informando todos os campos (incluindo `public` e `default` RPC).

### Para Ler Dados da Cadeia {: #for-reading-chain-data }

Passos:

1. Importe `createPublicClient`, `http` e `defineChain` de `viem`.
2. Defina os detalhes da cadeia (inclua URLs `public` e `default`).
3. Crie o `client` com `createPublicClient`, passando rede e RPC HTTP.

```ts
// 1. Import the necessary components from viem
import { createPublicClient, http, defineChain } from 'viem';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a public client for reading chain data
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});
```

### Para Gravar Dados da Cadeia {: #for-writing-chain-data }

Passos:

1. Importe `createWalletClient`, `http`, `defineChain` de `viem` e `privateKeyToAccount` de `viem/accounts`.
2. Defina os detalhes da cadeia (inclua URLs `public` e `default`).
3. Crie a conta com `privateKeyToAccount`.
4. Crie o `client` com `createWalletClient`, passando conta, rede e RPC HTTP.

!!! remember
    DemonstraÃ§Ã£o apenas. Nunca salve chave privada em arquivo TypeScript.

```ts
// 1. Import the necessary components from viem and viem/accounts
import { createWalletClient, http, defineChain } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create your account using the privateKeyToAccount function
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';

//4. Create a wallet client for writing chain data
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});
```

!!! note
    Para carteiras de navegador, veja este exemplo (onde `demo` Ã© a rede definida em `defineChain`):
    ```ts
    const [account] = await window.ethereum.request({
  method: 'eth_requestAccounts',
});
const walletClient = createWalletClient({
  account,
  chain: demo,
  transport: custom(window.ethereum),
});
    ```

## Enviar uma TransaÃ§Ã£o {: #send-transaction }

Criaremos dois scripts: um para saldos e outro para enviar a transaÃ§Ã£o.

### Script de Saldos {: #check-balances-script }
Crie o arquivo:

```bash
touch balances.ts
```

Passos:

1. Importe `createPublicClient`, `http`, `formatEther`, `defineChain`.
2. Defina a cadeia (inclua URLs `public`/`default`).
3. Configure o cliente pÃºblico.
4. Defina `addressFrom` e `addressTo`.
5. Crie a funÃ§Ã£o `balances` usando `publicClient.getBalance`.
6. Formate com `formatEther` e exiba.
7. Chame `balances()`.

???+ code "Ver balances.ts"

    ```ts
    // 1. Import the necessary components from viem
import { createPublicClient, http, formatEther, defineChain } from 'viem';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'UNIT',
    symbol: 'UNIT',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a public client for reading chain data
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create address variables
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// 5. Create balances function
const balances = async () => {
  // 6. Fetch balances
  const balanceFrom = formatEther(
    await publicClient.getBalance({ address: addressFrom })
  );
  const balanceTo = formatEther(
    await publicClient.getBalance({ address: addressTo })
  );

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);
};

// 7. Call the balances function
balances();
    ```

Execute:

```bash
npx ts-node balances.ts
```

Saldos em {{ networks.dancelight.demo_evm_token_symbol }} serÃ£o exibidos.

![Resultado do script balances](/images/builders/toolkit/ethereum-api/libraries/viem/viem-1.webp)

### Script de Envio {: #send-transaction-script }

Crie o arquivo:

```bash
touch transaction.ts
```

Passos:

1. Importe `createPublicClient`, `createWalletClient`, `http`, `parseEther`, `defineChain` e `privateKeyToAccount`.
2. Defina a cadeia (inclua URLs `public`/`default`).
3. Configure o cliente de carteira (escrita) com sua chave (**nÃ£o salve chaves reais em TS**).
4. Configure o cliente pÃºblico (leitura) para aguardar recibo.
5. Defina `addressTo`.
6. Crie `send()` com o objeto da transaÃ§Ã£o.
7. Envie com `walletClient.sendTransaction` e aguarde o hash.
8. Aguarde o recibo com `publicClient.waitForTransactionReceipt`.
9. Chame `send()`.

???+ code "Ver transaction.ts"

    ```ts
    // 1. Import the necessary components from viem and viem/accounts
import {
  createPublicClient,
  createWalletClient,
  http,
  parseEther,
  defineChain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a wallet client for writing chain data
// The private key must be prepended with `0x` to avoid errors
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create a public client for reading chain data
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 5. Create to address variable
const addressTo = 'INSERT_ADDRESS_TO';

// 6. Create send function
const send = async () => {
  console.log(
    `Attempting to send transaction from ${account.address} to ${addressTo}`
  );

  // 7. Sign and send transaction
  const hash = await walletClient.sendTransaction({
    to: addressTo,
    value: parseEther('1'),
  });

  // 8. Wait for the transaction receipt
  await publicClient.waitForTransactionReceipt({
    hash,
  });

  console.log(`Transaction successful with hash: ${hash}`);
};

// 9. Call the send function
send();
    ```

Execute:

```bash
npx ts-node transaction.ts
```

VocÃª verÃ¡ o hash; use `balances.ts` antes/depois para confirmar saldos.

![Resultado dos scripts transaction e balances](/images/builders/toolkit/ethereum-api/libraries/viem/viem-2.webp)

## Implantar um Contrato {: #deploy-contract }

O contrato que vocÃª irÃ¡ compilar e implantar nas prÃ³ximas seÃ§Ãµes Ã© um simples incrementador, chamado `Incrementer.sol`. Comece criando o arquivo do contrato:

```
touch Incrementer.sol
```

Depois, adicione o cÃ³digo Solidity ao arquivo:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
```

A funÃ§Ã£o `constructor`, executada quando o contrato Ã© implantado, define o valor inicial da variÃ¡vel `number` armazenada on-chain (padrÃ£o Ã© 0). A funÃ§Ã£o `increment` soma o `_value` informado ao nÃºmero atual, mas exige uma transaÃ§Ã£o, pois modifica o dado armazenado. Por fim, a funÃ§Ã£o `reset` zera o valor armazenado.

!!! note
    Este contrato Ã© apenas um exemplo simples para fins ilustrativos.

### Script de CompilaÃ§Ã£o {: #compile-contract-script }

Nesta seÃ§Ã£o, vocÃª criarÃ¡ um script em TypeScript que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato `Incrementer.sol`. Para comeÃ§ar, crie o arquivo `compile.ts` executando:

```bash
touch compile.ts
```

Depois, escreva o script seguindo estas etapas:

1. Importe os pacotes `fs` e `solc`
2. Use `fs.readFileSync` para ler e salvar o conteÃºdo de `Incrementer.sol` em `source`
3. Monte o objeto `input` para o compilador Solidity especificando `language`, `sources` e `settings`
4. Compile o contrato com `solc.compile` usando o objeto `input`
5. Extraia o contrato compilado e exporte-o para ser usado no script de implantaÃ§Ã£o

```ts
// 1. Import packages
const fs = require('fs');
const solc = require('solc');

// 2. Get path and load contract
const source = fs.readFileSync('Incrementer.sol', 'utf8');

// 3. Create input object
const input = {
  language: 'Solidity',
  sources: {
    'Incrementer.sol': {
      content: source,
    },
  },
  settings: {
    outputSelection: {
      '*': {
        '*': ['*'],
      },
    },
  },
};
// 4. Compile the contract
const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));
const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];

// 5. Export contract data
export default contractFile;
```

### Script de Deploy {: #deploy-contract-script }

Compile `Incrementer.sol` e crie `deploy.ts`:

```bash
touch deploy.ts
```

Passos:

1. Importe `createPublicClient`, `createWalletClient`, `http`, `defineChain`, `privateKeyToAccount` e o `contractFile` de `compile.ts`.
2. Defina a cadeia (inclua URLs `public`/`default`).
3. Configure o cliente de carteira (escrita) para implantar (**nÃ£o salve chaves reais em TS**).
4. Configure o cliente pÃºblico (leitura) para obter recibo.
5. Carregue `bytecode` e `abi`.
6. Crie a funÃ§Ã£o `deploy`.
7. Use `walletClient.deployContract` com ABI, bytecode, conta e valor inicial.
8. Aguarde recibo/leitura conforme necessÃ¡rio.
9. Chame `deploy()`.

???+ code "Ver deploy.ts"

    ```ts
    // 1. Update import
import {
  createPublicClient,
  createWalletClient,
  http,
  defineChain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import contractFile from './compile';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a wallet client for writing chain data
// The private key must be prepended with `0x` to avoid errors
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create a public client for reading chain data
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 5. Load contract information
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;
const _initialNumber = 5;

// 6. Create deploy function
const deploy = async () => {
  console.log(`Attempting to deploy from account: ${account.address}`);

  // 7. Send transaction (initial value set to 5)
  const contract = await walletClient.deployContract({
    abi,
    account,
    bytecode,
    args: [_initialNumber],
  });

  // 8. Get the transaction receipt for the deployment
  const transaction = await publicClient.waitForTransactionReceipt({
    hash: contract,
  });

  console.log(`Contract deployed at address: ${transaction.contractAddress}`);
};

// 9. Call the deploy function
deploy();
    ```

Execute:

```bash
npx ts-node deploy.ts
```

O endereÃ§o do contrato serÃ¡ exibido.

![Resultado do script deploy](/images/builders/toolkit/ethereum-api/libraries/viem/viem-3.webp)

### Ler Dados do Contrato (Calls) {: #read-contract-data }

Calls nÃ£o alteram estado; nÃ£o precisam de transaÃ§Ã£o. Crie `get.ts`:

```bash
touch get.ts
```

Passos:

1. Importe `createPublicClient`, `http`, `defineChain` e `contractFile` de `compile.ts`.
2. Defina a cadeia (inclua URLs `public`/`default`).
3. Configure o cliente pÃºblico.
4. Defina `contractAddress` e `abi`.
5. Crie a funÃ§Ã£o `get`.
6. Chame `publicClient.readContract` (funÃ§Ã£o `number`) e exiba o valor.
7. Chame `get()`.

???+ code "Ver get.ts"

    ```ts
    // 1. Update import
import { createPublicClient, http, defineChain } from 'viem';
import contractFile from './compile';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a public client for reading chain data
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});
// 4. Create contract variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const abi = contractFile.abi;

// 5. Create get function
const get = async () => {
  console.log(`Making a call to contract at address: ${contractAddress}`);

  // 6. Call contract
  const data = await publicClient.readContract({
    abi,
    functionName: 'number',
    address: contractAddress,
    args: [],
  });

  console.log(`The current number stored is: ${data}`);
};

// 7. Call get function
get();
    ```

Execute:

```bash
npx ts-node get.ts
```

![Resultado do script get](/images/builders/toolkit/ethereum-api/libraries/viem/viem-4.webp)

### Interagir com o Contrato (Sends) {: #interact-with-contract }

Sends alteram estado e exigem transaÃ§Ã£o. Crie `increment.ts` e `reset.ts`:

```bash
touch increment.ts reset.ts
```

`increment.ts`:

1. Importe `createPublicClient`, `createWalletClient`, `http`, `defineChain`, `privateKeyToAccount` e `contractFile`.
2. Defina a cadeia (inclua URLs `public`/`default`).
3. Configure o cliente de carteira (escrita) (**nÃ£o salve chaves reais em TS**).
4. Configure o cliente pÃºblico (leitura) para recibo.
5. Defina `contractAddress`, `abi`, `_value`.
6. Crie `increment()`.
7. Chame `walletClient.writeContract` com `_value` e aguarde hash.
8. Aguarde recibo com `publicClient.waitForTransactionReceipt`.
9. Chame `increment()`.

???+ code "Ver increment.ts"

    ```ts
    // 1. Update import
import {
  createPublicClient,
  createWalletClient,
  http,
  defineChain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import contractFile from './compile';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a wallet client for writing chain data
// The private key must be prepended with `0x` to avoid errors
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create a public client for reading chain data
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 5. Create contract variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const abi = contractFile.abi;
const _value = 3;

// 6. Create increment function
const increment = async () => {
  console.log(
    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
  );
  // 7. Call contract
  const hash = await walletClient.writeContract({
    abi,
    functionName: 'increment',
    address: contractAddress,
    args: [_value],
  });

  // 8. Wait for the transaction receipt
  await publicClient.waitForTransactionReceipt({
    hash,
  });

  console.log(`Transaction successful with hash: ${hash}`);
};

// 9. Call increment function
increment();
    ```

Execute:

```bash
npx ts-node increment.ts
```

![Resultado dos scripts increment e get](/images/builders/toolkit/ethereum-api/libraries/viem/viem-5.webp)

`reset.ts`:

1. Importe as mesmas dependÃªncias de `increment.ts`.
2. Defina a cadeia.
3. Configure clientes de carteira e pÃºblico.
4. Defina `contractAddress` e `abi`.
5. Crie `reset()`.
6. Chame `walletClient.writeContract` (funÃ§Ã£o `reset`) e aguarde hash.
7. Aguarde recibo com `publicClient.waitForTransactionReceipt`.
8. Chame `reset()`.

???+ code "Ver reset.ts"

    ```ts
    // 1. Update import
import {
  createPublicClient,
  createWalletClient,
  http,
  defineChain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import contractFile from './compile';

// 2. Specify the details of your EVM network
export const demoEVM = defineChain({
  id: 5678,
  name: 'demo',
  network: 'demo',
  nativeCurrency: {
    decimals: 18,
    name: 'TANGO',
    symbol: 'TANGO',
  },
  rpcUrls: {
    default: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
    public: {
      http: ['https://services.tanssi-testnet.network/dancelight-2001'],
      webSocket: ['wss://services.tanssi-testnet.network/dancelight-2001'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Explorer',
      url: 'https://dancelight-2001-blockscout.tanssi-chains.network/',
    },
  },
});

// 3. Create a wallet client for writing chain data
// The private key must be prepended with `0x` to avoid errors
const account = privateKeyToAccount('INSERT_PRIVATE_KEY');
const rpcUrl = 'https://services.tanssi-testnet.network/dancelight-2001';
const walletClient = createWalletClient({
  account,
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 4. Create a public client for reading chain data
const publicClient = createPublicClient({
  chain: demoEVM,
  transport: http(rpcUrl),
});

// 5. Create contract variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const abi = contractFile.abi;

// 6. Create reset function
const reset = async () => {
  console.log(
    `Calling the reset function in contract at address: ${contractAddress}`
  );

  // 7. Call contract
  const hash = await walletClient.writeContract({
    abi,
    functionName: 'reset',
    address: contractAddress,
    args: [],
  });

  // 8. Wait for the transaction receipt
  await publicClient.waitForTransactionReceipt({
    hash,
  });

  console.log(`Transaction successful with hash: ${hash}`);
};

// 9. Call reset function
reset();
    ```

Execute:

```bash
npx ts-node reset.ts
```

![Resultado dos scripts reset e get](/images/builders/toolkit/ethereum-api/libraries/viem/viem-6.webp)

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/libraries/web3js/
--- BEGIN CONTENT ---
---
title: TransaÃ§Ãµes e Contratos EVM com Web3.js
description: Aprenda a usar a biblioteca Ethereum Web3.js para enviar transaÃ§Ãµes e implantar contratos inteligentes Solidity na sua rede EVM compatÃ­vel e powered by Tanssi.
icon: octicons-code-24
categories: EVM-Template
---

# Biblioteca JavaScript Web3.js

## IntroduÃ§Ã£o {: #introduction }

[Web3.js](https://web3js.readthedocs.io){target=\_blank} Ã© um conjunto de bibliotecas que permite que desenvolvedores interajam com nÃ³s Ethereum usando os protocolos HTTP, IPC ou WebSocket em JavaScript. As redes EVM powered by Tanssi tÃªm uma API semelhante Ã  do Ethereum, totalmente compatÃ­vel com chamadas JSON RPC no estilo Ethereum. Portanto, os desenvolvedores podem aproveitar essa compatibilidade e usar a biblioteca Web3.js para interagir com um nÃ³ EVM da Tanssi como se estivessem no Ethereum. Para saber mais sobre Web3.js, consulte o [site de documentaÃ§Ã£o](https://web3js.readthedocs.io/en/v1.10.0){target=\_blank}.

Neste guia, vocÃª aprenderÃ¡ a configurar a biblioteca Web3.js para sua rede EVM da Tanssi. Em seguida, para mostrar a biblioteca em aÃ§Ã£o, vocÃª usarÃ¡ Web3.js para enviar uma transaÃ§Ã£o e implantar um contrato em uma rede EVM de demonstraÃ§Ã£o da Tanssi executando no [Dancelight](/pt/builders/tanssi-network/testnet/dancelight/){target=\_blank}. Este guia pode ser adaptado para sua prÃ³pria rede EVM da Tanssi simplesmente trocando o endpoint.

!!! note
    Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessÃ¡rio.
    
    Verifique tambÃ©m se vocÃª tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a [documentaÃ§Ã£o oficial](https://nodejs.org/en/download){target=\blank}.
    
    AlÃ©m disso, certifique-se de ter inicializado um arquivo `package.json` para mÃ³dulos ES6. VocÃª pode criar um `package.json` padrÃ£o com npm executando `npm init --yes`.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia, vocÃª precisarÃ¡ de:

- Uma conta com fundos na rede EVM da Tanssi que estiver usando nos testes

## Instalando Web3Js {: #installing-web3js }

Para este guia, instale a biblioteca Web3.js e o compilador Solidity. Para instalar ambos os pacotes NPM, execute:

=== "npm"

    ```bash
    npm install web3 solc@0.8.0
    ```

=== "yarn"

    ```bash
    yarn add web3 solc@0.8.0
    ```

## Configurando o Provedor Web3 {: #setting-up-the-web3-provider }

Ao longo deste guia, vocÃª criarÃ¡ vÃ¡rios scripts com funÃ§Ãµes diferentes, como enviar uma transaÃ§Ã£o, implantar um contrato e interagir com um contrato implantado. Na maioria desses scripts, vocÃª precisarÃ¡ criar um provedor Web3.js para interagir com a rede.

Para configurar um provedor Web3, siga estes passos:

1. Importe a biblioteca `Web3`.
2. Crie o provedor Web3 e defina a URL RPC. VocÃª pode configurar Web3.js para funcionar com a rede EVM de demonstraÃ§Ã£o da Tanssi executando na Dancelight ou com sua prÃ³pria rede EVM da Tanssi apenas alterando o endpoint.

```js
// 1. Importe o Web3
const Web3 = require('web3');

// 2. Crie o provider do Web3 e insira sua URL RPC
const web3 = new Web3(
  '{{ networks.dancelight.demo_evm_rpc_url }}'
);
```

Guarde este snippet, pois ele serÃ¡ necessÃ¡rio nos scripts usados nas seÃ§Ãµes a seguir.

## Enviar uma TransaÃ§Ã£o {: #send-a-transaction }

Nesta seÃ§Ã£o, vocÃª criarÃ¡ alguns scripts. O primeiro verificarÃ¡ os saldos de suas contas antes de tentar enviar uma transaÃ§Ã£o. O segundo script enviarÃ¡ a transaÃ§Ã£o.

VocÃª tambÃ©m pode usar o script de saldo para verificar os saldos apÃ³s a transaÃ§Ã£o ser enviada.

### Script para verificar saldos {: #check-balances-script }

Basta um arquivo para verificar os saldos dos dois endereÃ§os antes e depois da transaÃ§Ã£o. Para comeÃ§ar, crie o arquivo `balances.js` executando:

```bash
touch balances.js
```

Em seguida, crie o script deste arquivo seguindo estes passos:

1. [Configure o provedor Web3](#setting-up-the-web3-provider)
2. Defina as variÃ¡veis `addressFrom` e `addressTo`
3. Crie a funÃ§Ã£o assÃ­ncrona `balances`, que envolve o mÃ©todo `web3.eth.getBalance`
4. Use a funÃ§Ã£o `web3.eth.getBalance` para buscar os saldos dos endereÃ§os `addressFrom` e `addressTo`. VocÃª tambÃ©m pode usar `web3.utils.fromWei` para transformar o saldo em um nÃºmero mais legÃ­vel em `{{ networks.dancelight.demo_evm_token_symbol }}`
5. Por fim, execute a funÃ§Ã£o `balances`

```js
// 1. Adicione aqui a lÃ³gica do provider do Web3:
// {...}

// 2. Crie as variÃ¡veis de endereÃ§o
const addressFrom = 'INSERIR_ENDERECO_DE';
const addressTo = 'INSERIR_ENDERECO_PARA';

// 3. Crie a funÃ§Ã£o de saldos
const balances = async () => {
  // 4. Busque as informaÃ§Ãµes de saldo
  const balanceFrom = web3.utils.fromWei(
    await web3.eth.getBalance(addressFrom),
    'ether'
  );
  const balanceTo = web3.utils.fromWei(
    await web3.eth.getBalance(addressTo),
    'ether'
  );

  console.log(`O saldo de ${addressFrom} Ã©: ${balanceFrom} {{ networks.dancelight.demo_evm_token_symbol }}`);
  console.log(`O saldo de ${addressTo} Ã©: ${balanceTo} {{ networks.dancelight.demo_evm_token_symbol }}`);
};

// 5. Chamar a funÃ§Ã£o de saldos
balances();
```

??? code "Ver o script completo"

    ```js
    // Import Web3
const Web3 = require('web3');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create address variables
const addressFrom = 'INSERT_ADDRESS_FROM';
const addressTo = 'INSERT_ADDRESS_TO';

// Create balances function
const balances = async () => {
  // Fetch balance info
  const balanceFrom = web3.utils.fromWei(
    await web3.eth.getBalance(addressFrom),
    'ether'
  );
  const balanceTo = web3.utils.fromWei(
    await web3.eth.getBalance(addressTo),
    'ether'
  );

  console.log(`The balance of ${addressFrom} is: ${balanceFrom} TANGO`);
  console.log(`The balance of ${addressTo} is: ${balanceTo} TANGO`);
};

// Call balances function
balances();
    ```

Para executar o script e buscar os saldos das contas, rode:

```bash
node balances.js
```

Se funcionar, os saldos dos endereÃ§os de origem e destino serÃ£o exibidos no terminal em ETH.

![Verificar saldo no Web3.js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-1.webp)

### Script para Enviar TransaÃ§Ã£o {: #send-transaction-script }

VocÃª sÃ³ precisa de um arquivo para executar uma transaÃ§Ã£o entre contas. Neste exemplo, vocÃª transferirÃ¡ 1 token {{ networks.dancelight.demo_evm_token_symbol }} de um endereÃ§o de origem (do qual vocÃª possui a chave privada) para outro endereÃ§o. Para comeÃ§ar, crie o arquivo `transaction.js` executando:

```bash
touch transaction.js
```

Em seguida, crie o script deste arquivo seguindo estes passos:

1. [Configure o provedor Web3](#setting-up-the-web3-provider)
2. Defina `addressFrom`, incluindo a `privateKey`, e a variÃ¡vel `addressTo`. A chave privada Ã© necessÃ¡ria para criar uma instÃ¢ncia de carteira. **Nota: isto Ã© apenas para fins de exemplo. Nunca armazene suas chaves privadas em um arquivo JavaScript**
3. Crie a funÃ§Ã£o assÃ­ncrona `send`, que encapsula o objeto de transaÃ§Ã£o e as funÃ§Ãµes de assinar e enviar a transaÃ§Ã£o
4. Crie e assine a transaÃ§Ã£o usando a funÃ§Ã£o `web3.eth.accounts.signTransaction`. Informe o `gas`, o `addressTo` e o `value` da transaÃ§Ã£o, alÃ©m da `privateKey` do remetente
5. Envie a transaÃ§Ã£o assinada usando o mÃ©todo `web3.eth.sendSignedTransaction` e passe a transaÃ§Ã£o bruta. Em seguida, use `await` para aguardar o processamento e o retorno do recibo da transaÃ§Ã£o
6. Por fim, execute a funÃ§Ã£o `send`

```js
// 1. Adicione aqui a lÃ³gica do provider do Web3:
// {...}

// 2. Crie as variÃ¡veis de conta
const accountFrom = {
  privateKey: 'INSIRA_SUA_CHAVE_PRIVADA',
  address: 'INSIRA_O_ENDERECO_PUBLICO_DA_CHAVE',
};
const addressTo = 'INSERIR_ENDERECO_PARA'; // Alterar para o endereÃ§o desejado

// 3. Crie a funÃ§Ã£o send
const send = async () => {
  console.log(
    `Tentando enviar transaÃ§Ã£o de ${accountFrom.address} para ${addressTo}`
  );

  // 4. Assine a transaÃ§Ã£o com a chave privada
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      gas: 21000,
      to: addressTo,
      value: web3.utils.toWei('1', 'ether'),
    },
    accountFrom.privateKey
  );

  // 5. Envie a transaÃ§Ã£o e aguarde o recibo
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(
    `TransaÃ§Ã£o bem-sucedida com hash: ${createReceipt.transactionHash}`
  );
};

// 6. Chame a funÃ§Ã£o send
send();
```

??? code "Ver o script completo"

    ```js
    // Import Web3
const Web3 = require('web3');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create account variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',
};
const addressTo = 'INSERT_ADDRESS_TO';

// Create send function
const send = async () => {
  console.log(
    `Attempting to send transaction from ${accountFrom.address} to ${addressTo}`
  );

  // Sign tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      gas: 21000,
      to: addressTo,
      value: web3.utils.toWei('1', 'ether'),
    },
    accountFrom.privateKey
  );

  // Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(
    `Transaction successful with hash: ${createReceipt.transactionHash}`
  );
};

// Call send function
send();
    ```

Para executar o script, rode o seguinte comando no terminal:

```bash
node transaction.js
```

Se a transaÃ§Ã£o for bem-sucedida, o hash serÃ¡ exibido no terminal.

VocÃª tambÃ©m pode usar o script `balances.js` para verificar se os saldos das contas de origem e destino mudaram. O fluxo completo ficaria assim:

![Enviar transaÃ§Ã£o no Web3.js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-2.webp)

## Implantar um Contrato {: #deploy-a-contract }

O contrato que vocÃª irÃ¡ compilar e implantar nas prÃ³ximas seÃ§Ãµes Ã© um simples incrementador, chamado `Incrementer.sol`. Comece criando o arquivo do contrato:

```
touch Incrementer.sol
```

Depois, adicione o cÃ³digo Solidity ao arquivo:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
```

A funÃ§Ã£o `constructor`, executada quando o contrato Ã© implantado, define o valor inicial da variÃ¡vel `number` armazenada on-chain (padrÃ£o Ã© 0). A funÃ§Ã£o `increment` soma o `_value` informado ao nÃºmero atual, mas exige uma transaÃ§Ã£o, pois modifica o dado armazenado. Por fim, a funÃ§Ã£o `reset` zera o valor armazenado.

!!! note
    Este contrato Ã© apenas um exemplo simples para fins ilustrativos.

### Script para Compilar o Contrato {: #compile-contract-script }

Nesta seÃ§Ã£o, vocÃª criarÃ¡ um script que usa o compilador Solidity para gerar o bytecode e a interface (ABI) do contrato `Incrementer.sol`. Para comeÃ§ar, crie o arquivo `compile.js` executando:

```
touch compile.js
```

Em seguida, escreva o script e conclua estas etapas:

1. Importe os pacotes `fs` e `solc`
2. Use `fs.readFileSync` para ler e salvar o conteÃºdo de `Incrementer.sol` em `source`
3. Monte o objeto `input` para o compilador Solidity especificando `language`, `sources` e `settings`
4. Compile o contrato usando `solc.compile` com o objeto `input`
5. Extraia o contrato compilado e exporte-o para ser usado no script de implantaÃ§Ã£o

```js
// 1. Import packages
import fs from 'fs';
import solc from 'solc';

// 2. Get path and load contract
const source = fs.readFileSync('Incrementer.sol', 'utf8');

// 3. Create input object
const input = {
  language: 'Solidity',
  sources: {
    'Incrementer.sol': {
      content: source,
    },
  },
  settings: {
    outputSelection: {
      '*': {
        '*': ['*'],
      },
    },
  },
};
// 4. Compile the contract
const tempFile = JSON.parse(solc.compile(JSON.stringify(input)));
const contractFile = tempFile.contracts['Incrementer.sol']['Incrementer'];

// 5. Export contract data
export default contractFile;
```

### Script para Implantar o Contrato {: #deploy-contract-script }
Com o script para compilar o contrato `Incrementer.sol` pronto, vocÃª pode usar os resultados para enviar uma transaÃ§Ã£o assinada que o implanta. Para isso, crie um arquivo para o script de implantaÃ§Ã£o chamado `deploy.js`:

```bash
touch deploy.js
```

Em seguida, crie o script deste arquivo seguindo estes passos:

1. Importe o arquivo do contrato a partir de `compile.js`
2. [Configure o provedor Web3](#setting-up-the-web3-provider)
3. Defina as variÃ¡veis `addressFrom`, incluindo a `privateKey`, e `addressTo`. A chave privada Ã© necessÃ¡ria para criar uma instÃ¢ncia de carteira. **Nota: isto Ã© apenas para fins de exemplo. Nunca armazene suas chaves privadas em um arquivo JavaScript**
4. Salve o `bytecode` e o `abi` do contrato compilado
5. Crie a funÃ§Ã£o assÃ­ncrona `deploy` que serÃ¡ usada para implantar o contrato
6. Crie a instÃ¢ncia do contrato usando a funÃ§Ã£o `web3.eth.Contract`
7. Crie o builder e passe o `bytecode` e o valor inicial do incrementer. Neste exemplo, defina o valor inicial como `5`
8. Crie e assine a transaÃ§Ã£o usando a funÃ§Ã£o `web3.eth.accounts.signTransaction`. Informe o `data` e o `gas` da transaÃ§Ã£o, alÃ©m da `privateKey` do remetente
9. Envie a transaÃ§Ã£o assinada usando o mÃ©todo `web3.eth.sendSignedTransaction` e passe a transaÃ§Ã£o bruta. Em seguida, use `await` para aguardar o processamento e o retorno do recibo
10. Por fim, execute a funÃ§Ã£o `deploy`

```js
// 1. Importe o arquivo do contrato
const contractFile = require('./compile');

// 2. Adicione aqui a lÃ³gica do provider do Web3:
// {...}

// 3. Crie as variÃ¡veis de endereÃ§o
const accountFrom = {
  privateKey: 'INSERIR_CHAVE_PRIVADA',
  address: 'INSERIR_ENDERECO_PUBLICO_DA_CHAVE',
};

// 4. Obtenha o bytecode e o ABI
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// 5. Crie a funÃ§Ã£o deploy
const deploy = async () => {
  console.log(`Tentando implantar a partir da conta ${accountFrom.address}`);

  // 6. Crie a instÃ¢ncia do contrato
  const incrementer = new web3.eth.Contract(abi);

  // 7. Crie a transaÃ§Ã£o do builder
  const incrementerTx = incrementer.deploy({
    data: bytecode,
    arguments: [5],
  });

  // 8. Assine a transaÃ§Ã£o e envie
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      data: incrementerTx.encodeABI(),
      gas: await incrementerTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // 9. Envie a transaÃ§Ã£o e aguarde o recibo
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Contrato implantado no endereÃ§o: ${createReceipt.contractAddress}`);
};

// 10. Chame a funÃ§Ã£o deploy
deploy();
```

??? code "Ver o script completo"

    ```js
    // Import web3 and the contract file
const Web3 = require('web3');
const contractFile = require('./compile');

// Add the Web3 provider logic here
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create address variables
const accountFrom = {
  privateKey: 'INSERT_PRIVATE_KEY',
  address: 'INSERT_PUBLIC_ADDRESS_OF_PK',
};

// Get the bytecode and API
const bytecode = contractFile.evm.bytecode.object;
const abi = contractFile.abi;

// Create deploy function
const deploy = async () => {
  console.log(`Attempting to deploy from account ${accountFrom.address}`);

  // Create contract instance
  const incrementer = new web3.eth.Contract(abi);

  // Create constructor tx with initial value of 5
  const incrementerTx = incrementer.deploy({
    data: bytecode,
    arguments: [5],
  });

  // Sign transacation and send
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      data: incrementerTx.encodeABI(),
      gas: await incrementerTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Contract deployed at address: ${createReceipt.contractAddress}`);
};

// Call deploy function
deploy();
    ```

Para executar o script, digite o seguinte comando no terminal:

```bash
node deploy.js
```

Se der certo, o endereÃ§o do contrato serÃ¡ exibido no terminal.

![Implantar contrato com Web3.js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-3.webp)

### Ler Dados do Contrato (mÃ©todos de chamada) {: #read-contract-data }

MÃ©todos de chamada sÃ£o interaÃ§Ãµes que nÃ£o modificam o armazenamento do contrato (nÃ£o alteram variÃ¡veis), portanto nenhuma transaÃ§Ã£o precisa ser enviada. Eles simplesmente leem variÃ¡veis de armazenamento do contrato implantado.

Para comeÃ§ar, crie um arquivo chamado `get.js`:

```bash
touch get.js
```

Depois, siga estes passos para criar o script:

1. Importe o `abi` do arquivo `compile.js`
2. [Configure o provedor Web3](#setting-up-the-web3-provider)
3. Crie a variÃ¡vel `contractAddress` usando o endereÃ§o do contrato implantado
4. Crie uma instÃ¢ncia do contrato usando a funÃ§Ã£o `web3.eth.Contract` e passando o `abi` e o `contractAddress`
5. Crie a funÃ§Ã£o assÃ­ncrona `get`
6. Use a instÃ¢ncia do contrato para chamar um dos mÃ©todos do contrato e passe os inputs necessÃ¡rios. Neste exemplo, vocÃª chamarÃ¡ o mÃ©todo `number`, que nÃ£o requer entradas. Use `await`, que retornarÃ¡ o valor solicitado quando a promessa for resolvida
7. Por fim, chame a funÃ§Ã£o `get`

```js
// 1. Importe o abi do contrato
const { abi } = require('./compile');

// 2. Adicione aqui a lÃ³gica do provider do Web3:
// {...}

// 3. Crie as variÃ¡veis de endereÃ§o
const contractAddress = 'INSERIR_ENDERECO_DO_CONTRATO';

// 4. Crie a instÃ¢ncia do contrato
const incrementer = new web3.eth.Contract(abi, contractAddress);

// 5. Crie a funÃ§Ã£o get
const get = async () => {
  console.log(`Fazendo uma chamada ao contrato no endereÃ§o: ${contractAddress}`);

  // 6. Chame o contrato
  const data = await incrementer.methods.number().call();

  console.log(`O nÃºmero armazenado atualmente Ã©: ${data}`);
};

// 7. Chame a funÃ§Ã£o get
get();
```

??? code "Ver o script completo"

    ```js
    // Import web3 and the contract file
const Web3 = require('web3');
const { abi } = require('./compile');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create address variables
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// Create contract instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// Create get function
const get = async () => {
  console.log(`Making a call to contract at address: ${contractAddress}`);

  // Call contract
  const data = await incrementer.methods.number().call();

  console.log(`The current number stored is: ${data}`);
};

// Call get function
get();
    ```

Para executar o script, digite o seguinte comando no terminal:

```bash
node get.js
```

Se der certo, o valor serÃ¡ exibido no terminal.

![Ler valor do contrato no Web3.js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-4.webp)

### Interagir com o Contrato (mÃ©todos de envio) {: #interact-with-contract }

MÃ©todos de envio sÃ£o interaÃ§Ãµes que modificam o armazenamento do contrato (alteram variÃ¡veis), portanto uma transaÃ§Ã£o precisa ser assinada e enviada. Nesta seÃ§Ã£o, vocÃª criarÃ¡ dois scripts: um para incrementar e outro para resetar o incrementer. Para comeÃ§ar, crie um arquivo para cada script e nomeie-os `increment.js` e `reset.js`:

```bash
touch increment.js reset.js
```

Abra o arquivo `increment.js` e siga estes passos para criar o script:

1. Importe o `abi` do arquivo `compile.js`
2. [Configure o provedor Web3](#setting-up-the-web3-provider)
3. Defina a `privateKey` da conta de origem, o `contractAddress` do contrato implantado e o `_value` pelo qual incrementar. A chave privada Ã© necessÃ¡ria para criar uma instÃ¢ncia de carteira. **Nota: isto Ã© apenas para fins de exemplo. Nunca armazene suas chaves privadas em um arquivo JavaScript**
4. Crie uma instÃ¢ncia do contrato usando a funÃ§Ã£o `web3.eth.Contract` e passando o `abi` e o `contractAddress`
5. Use a instÃ¢ncia do contrato para construir a transaÃ§Ã£o de incremento usando a funÃ§Ã£o `methods.increment` e passando `_value` como entrada
6. Crie a funÃ§Ã£o assÃ­ncrona `increment`
7. Use a instÃ¢ncia do contrato e a transaÃ§Ã£o de incremento criada para assinar a transaÃ§Ã£o com a chave privada do remetente. Use a funÃ§Ã£o `web3.eth.accounts.signTransaction` e especifique o endereÃ§o `to`, o `data` e o `gas` da transaÃ§Ã£o
8. Envie a transaÃ§Ã£o assinada usando o mÃ©todo `web3.eth.sendSignedTransaction` e passe a transaÃ§Ã£o bruta. Em seguida, use `await` para aguardar o processamento e o retorno do recibo
9. Por fim, chame a funÃ§Ã£o `increment`

```js
// 1. Importe o abi do contrato
const { abi } = require('./compile');

// 2. Adicione aqui a lÃ³gica do provider do Web3:
// {...}

// 3. Crie as variÃ¡veis
const accountFrom = {
  privateKey: 'INSIRA_SUA_CHAVE_PRIVADA',
};
const contractAddress = 'INSERIR_ENDERECO_DO_CONTRATO';
const _value = 3;

// 4. Crie a instÃ¢ncia do contrato
const incrementer = new web3.eth.Contract(abi, contractAddress);

// 5. Monte a transaÃ§Ã£o de incremento
const incrementTx = incrementer.methods.increment(_value);

// 6. Crie a funÃ§Ã£o increment
const increment = async () => {
  console.log(
    `Chamando a funÃ§Ã£o increment de ${_value} no contrato no endereÃ§o: ${contractAddress}`
  );

  // 7. Assine a transaÃ§Ã£o com a chave privada
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data: incrementTx.encodeABI(),
      gas: await incrementTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // 8. Envie a transaÃ§Ã£o e aguarde o recibo
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`TransaÃ§Ã£o bem-sucedida com hash: ${createReceipt.transactionHash}`);
};

// 9. Chame a funÃ§Ã£o increment
increment();
```

??? code "Ver o script completo"

    ```js
    // Import Web3 and the contract abi
const Web3 = require('web3');
const { abi } = require('./compile');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';
const _value = 3;

// Create contract instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// Build increment tx
const incrementTx = incrementer.methods.increment(_value);

// Create increment function
const increment = async () => {
  console.log(
    `Calling the increment by ${_value} function in contract at address: ${contractAddress}`
  );

  // Sign Tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data: incrementTx.encodeABI(),
      gas: await incrementTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // Send Tx and Wait for Receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);
};

// Call increment function
increment();
    ```

Para executar o script, digite o seguinte comando no terminal:

```bash
node increment.js
```

Se der certo, o hash da transaÃ§Ã£o serÃ¡ exibido no terminal. VocÃª pode usar o script `get.js` junto com o `increment.js` para garantir que o valor esteja mudando como esperado.

![Incrementar e conferir valor no Web3.js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-5.webp)

Em seguida, abra o arquivo `reset.js` e siga estes passos para criar o script:

1. Importe o `abi` do arquivo `compile.js`
2. [Configure o provedor Web3](#setting-up-the-web3-provider)
3. Defina a `privateKey` da conta de origem e o `contractAddress` do contrato implantado. A chave privada Ã© necessÃ¡ria para criar uma instÃ¢ncia de carteira. **Nota: isto Ã© apenas para fins de exemplo. Nunca armazene suas chaves privadas em um arquivo JavaScript**
4. Crie uma instÃ¢ncia do contrato usando a funÃ§Ã£o `web3.eth.Contract` e passando o `abi` e o `contractAddress`
5. Use a instÃ¢ncia do contrato para montar a transaÃ§Ã£o de reset usando a funÃ§Ã£o `methods.reset`
6. Crie a funÃ§Ã£o assÃ­ncrona `reset`
7. Use a instÃ¢ncia do contrato e a transaÃ§Ã£o de reset criada para assinar a transaÃ§Ã£o com a chave privada do remetente. Use a funÃ§Ã£o `web3.eth.accounts.signTransaction` e especifique o endereÃ§o `to`, o `data` e o `gas` da transaÃ§Ã£o
8. Envie a transaÃ§Ã£o assinada usando o mÃ©todo `web3.eth.sendSignedTransaction` e passe a transaÃ§Ã£o bruta. Em seguida, use `await` para aguardar o processamento e o retorno do recibo
9. Por fim, chame a funÃ§Ã£o `reset`

```js
// 1. Importe o abi do contrato
const { abi } = require('./compile');

// 2. Adicione aqui a lÃ³gica do provider do Web3:
// {...}

// 3. Crie as variÃ¡veis
const accountFrom = {
  privateKey: 'INSIRA_SUA_CHAVE_PRIVADA',
};
const contractAddress = 'INSERIR_ENDERECO_DO_CONTRATO';

// 4. Crie a instÃ¢ncia do contrato
const incrementer = new web3.eth.Contract(abi, contractAddress);

// 5. Monte a transaÃ§Ã£o de reset
const resetTx = incrementer.methods.reset();

// 6. Crie a funÃ§Ã£o reset
const reset = async () => {
  console.log(
    `Chamando a funÃ§Ã£o reset no contrato no endereÃ§o: ${contractAddress}`
  );

  // 7. Assine a transaÃ§Ã£o com a chave privada
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data: resetTx.encodeABI(),
      gas: await resetTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // 8. Envie a transaÃ§Ã£o e aguarde o recibo
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`TransaÃ§Ã£o bem-sucedida com hash: ${createReceipt.transactionHash}`);
};

// 9. Chame a funÃ§Ã£o reset
reset();
```

??? code "Ver o script completo"

    ```js
    // Import Web3 and the contract abi
const Web3 = require('web3');
const { abi } = require('./compile');

// Add the Web3 provider logic here:
const providerRPC = {
  evmNetwork: 'https://services.tanssi-testnet.network/dancelight-2001', // Insert your RPC URL here
};
const web3 = new Web3(providerRPC.evmNetwork);

// Create variables
const accountFrom = {
  privateKey: 'INSERT_YOUR_PRIVATE_KEY',
};
const contractAddress = 'INSERT_CONTRACT_ADDRESS';

// Create Contract Instance
const incrementer = new web3.eth.Contract(abi, contractAddress);

// Build reset tx
const resetTx = incrementer.methods.reset();

// Create reset function
const reset = async () => {
  console.log(
    `Calling the reset function in contract at address: ${contractAddress}`
  );

  // Sign tx with PK
  const createTransaction = await web3.eth.accounts.signTransaction(
    {
      to: contractAddress,
      data: resetTx.encodeABI(),
      gas: await resetTx.estimateGas(),
    },
    accountFrom.privateKey
  );

  // Send tx and wait for receipt
  const createReceipt = await web3.eth.sendSignedTransaction(
    createTransaction.rawTransaction
  );
  console.log(`Tx successful with hash: ${createReceipt.transactionHash}`);
};

// Call reset function
reset();
    ```

Para executar o script, digite o seguinte comando no terminal:

```bash
node reset.js
```

Se der certo, o hash da transaÃ§Ã£o serÃ¡ exibido no terminal. VocÃª pode usar o script `get.js` junto com o `reset.js` para garantir que o valor esteja mudando como esperado.

![Resetar contrato no Web3.js](/images/builders/toolkit/ethereum-api/libraries/web3js/web3js-6.webp)

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/libraries/web3py/
--- BEGIN CONTENT ---
---
title: TransaÃ§Ãµes e Contratos EVM com Web3.py
description: Aprenda a usar a biblioteca Ethereum Web3.py para enviar transaÃ§Ãµes e implantar contratos Solidity na sua rede compatÃ­vel com Ethereum Powered by Tanssi.
icon: octicons-code-24
categories: EVM-Template
---

# Biblioteca Python Web3.py

## IntroduÃ§Ã£o {: #introduction }

[Web3.py](https://web3py.readthedocs.io/en/stable/){target=\_blank} Ã© um conjunto de bibliotecas que permite interagir com nÃ³s Ethereum via HTTP, IPC ou WebSocket em Python. As redes EVM da Tanssi expÃµem uma API compatÃ­vel com Ethereum/JSON-RPC, entÃ£o vocÃª pode usar Web3.py para falar com um nÃ³ EVM da Tanssi como se estivesse no Ethereum. Veja a [documentaÃ§Ã£o](https://web3py.readthedocs.io/en/stable/){target=\_blank} para mais detalhes.

Neste guia, vocÃª configurarÃ¡ o Web3.py para sua rede EVM da Tanssi e usarÃ¡ a biblioteca para enviar uma transaÃ§Ã£o e implantar um contrato em uma appchain de demonstraÃ§Ã£o executando no [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}. Para sua rede, basta trocar o endpoint.

!!! note
    Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessÃ¡rio.
    
    AlÃ©m disso, certifique-se de ter o Python 3 e um gerenciador de pacotes como o pip instalados.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

VocÃª precisarÃ¡:

 - De uma conta com fundos na rede EVM Tanssi usada nos testes

## Instalando Web3.py {: #install-web3py }

Instale Web3.py e o compilador Solidity:

```bash
pip3 install web3 py-solc-x
```

## Configurando o Provedor Web3.py {: #setting-up-the-web3py-provider }

Os scripts a seguir usam um [provedor Web3.py](https://web3py.readthedocs.io/en/stable/providers.html){target=\_blank} para se conectar Ã  rede.

1. Importe `web3`.
2. Crie o provedor HTTP com a URL RPC da rede.

```python
# 1. Importe web3.py
from web3 import Web3

# 2. Crie o provedor web3.py
# Insira sua URL RPC aqui
web3 = Web3(Web3.HTTPProvider('{{ networks.dancelight.demo_evm_rpc_url }}'))
```

Guarde este trecho; ele Ã© reutilizado nos scripts seguintes.

## Enviar uma TransaÃ§Ã£o {: #send-a-transaction }

Dois scripts: um para saldos e outro para enviar.

### Script de Saldos {: #check-balances-script }
Crie o arquivo:

```bash
touch balances.py
```

Passos:

1. Inclua o provedor Web3.
2. Defina `address_from` e `address_to`.
3. Use `web3.eth.get_balance` e `web3.from_wei` para exibir em {{ networks.dancelight.demo_evm_token_symbol }}.

```python
# 1. Import web3.py
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 2. Create address variables
address_from = "INSERT_ADDRESS_FROM"
address_to = "INSERT_ADDRESS_TO"

# 4. Fetch balance data
balance_from = web3.from_wei(
    web3.eth.get_balance(Web3.to_checksum_address(address_from)), "ether"
)
balance_to = web3.from_wei(
    web3.eth.get_balance(Web3.to_checksum_address(address_to)), "ether"
)

print(f"The balance of { address_from } is: { balance_from } TANGO")
print(f"The balance of { address_to } is: { balance_to } TANGO")
```

Execute:

```bash
python3 balances.py
```

![Verificar saldo Web3.py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-1.webp)

### Script de Envio {: #send-transaction-script }

Crie o arquivo:

```bash
touch transaction.py
```

Passos:

1. Importe Web3.py e `rpc_gas_price_strategy`.
2. Inclua o provedor.
3. Defina `account_from` (com `private_key`) e `address_to`. **NÃ£o armazene chaves reais em arquivos Python.**
4. Defina a estratÃ©gia de gas price com `rpc_gas_price_strategy`.
5. Monte e assine a transaÃ§Ã£o com `sign_transaction` (nonce, gas, gasPrice, to, value). Use `get_transaction_count` para nonce, `generate_gas_price` para gasPrice e `to_wei` para valor.
6. Envie com `send_raw_transaction` e aguarde recibo com `wait_for_transaction_receipt`.

```python
# 1. Add imports
from web3 import Web3
from web3.gas_strategies.rpc import rpc_gas_price_strategy

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create address variables
account_from = {
    "private_key": "INSERT_ YOUR_PRIVATE_KEY",
    "address": "INSERT_ PUBLIC_ADDRESS_OF_PK",
}
address_to = "INSERT_ ADDRESS_TO"

print(
    f'Attempting to send transaction from { account_from["address"] } to { address_to }'
)

# 4. Set the gas price strategy
web3.eth.set_gas_price_strategy(rpc_gas_price_strategy)

# 5. Sign tx with PK
tx_create = web3.eth.account.sign_transaction(
    {
        "nonce": web3.eth.get_transaction_count(
            Web3.to_checksum_address(account_from["address"])
        ),
        "gasPrice": web3.eth.generate_gas_price(),
        "gas": 21000,
        "to": Web3.to_checksum_address(address_to),
        "value": web3.to_wei("1", "ether"),
    },
    account_from["private_key"],
)

# 6. Send tx and wait for receipt
tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Transaction successful with hash: { tx_receipt.transactionHash.hex() }")
```

Execute:

```bash
python3 transaction.py
```

![Enviar Tx Web3.py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-2.webp)

## Implantar um Contrato {: #deploy-a-contract }

O contrato que vocÃª irÃ¡ compilar e implantar nas prÃ³ximas seÃ§Ãµes Ã© um simples incrementador, chamado `Incrementer.sol`. Comece criando o arquivo do contrato:

```
touch Incrementer.sol
```

Depois, adicione o cÃ³digo Solidity ao arquivo:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

contract Incrementer {
    uint256 public number;

    constructor(uint256 _initialNumber) {
        number = _initialNumber;
    }

    function increment(uint256 _value) public {
        number = number + _value;
    }

    function reset() public {
        number = 0;
    }
}
```

A funÃ§Ã£o `constructor`, executada quando o contrato Ã© implantado, define o valor inicial da variÃ¡vel `number` armazenada on-chain (padrÃ£o Ã© 0). A funÃ§Ã£o `increment` soma o `_value` informado ao nÃºmero atual, mas exige uma transaÃ§Ã£o, pois modifica o dado armazenado. Por fim, a funÃ§Ã£o `reset` zera o valor armazenado.

!!! note
    Este contrato Ã© apenas um exemplo simples para fins ilustrativos.

### Script de CompilaÃ§Ã£o {: #compile-contract-script }

Crie `compile.py`:

```bash
touch compile.py
```

Passos:

1. Importe `solcx`.
2. (Opcional) Instale o solc com `solcx.install_solc`.
3. Compile `Incrementer.sol` com `solcx.compile_files`.
4. Exporte ABI e bytecode.

```python
# 1. Import solcx
import solcx

# 2. If you haven't already installed the Solidity compiler, uncomment the following line
# solcx.install_solc()

# 3. Compile contract
temp_file = solcx.compile_files(
    "Incrementer.sol",
    output_values=["abi", "bin"],
    # solc_version='0.8.19'
)

# 4. Export contract data
abi = temp_file["Incrementer.sol:Incrementer"]["abi"]
bytecode = temp_file["Incrementer.sol:Incrementer"]["bin"]
```

!!! note
    Se aparecer erro de solc nÃ£o instalado, descomente a etapa 2 no snippet.

### Script de Deploy {: #deploy-contract-script }

Compile primeiro; depois crie `deploy.py`:

```bash
touch deploy.py
```

Passos:

1. Importe Web3.py, ABI e bytecode.
2. Inclua o provedor.
3. Defina `account_from`/`private_key` (**nÃ£o salve chaves reais em Python**).
4. Crie instÃ¢ncia do contrato com ABI/bytecode.
5. Construa a tx do builder (valor inicial 5) com `build_transaction`, incluindo `from` e `nonce`.
6. Assine com `sign_transaction`.
7. Envie com `send_raw_transaction` e aguarde recibo com `wait_for_transaction_receipt`.

```python
# 1. Add imports
from compile import abi, bytecode
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create address variable
account_from = {
    "private_key": "INSERT_YOUR_PRIVATE_KEY",
    "address": "INSERT_PUBLIC_ADDRESS_OF_PK",
}

print(f'Attempting to deploy from account: { account_from["address"] }')

# 4. Create contract instance
Incrementer = web3.eth.contract(abi=abi, bytecode=bytecode)

# 5. Build constructor tx
construct_txn = Incrementer.constructor(5).build_transaction(
    {
        "from": Web3.to_checksum_address(account_from["address"]),
        "nonce": web3.eth.get_transaction_count(
            Web3.to_checksum_address(account_from["address"])
        ),
    }
)

# 6. Sign tx with PK
tx_create = web3.eth.account.sign_transaction(
    construct_txn, account_from["private_key"]
)

# 7. Send tx and wait for receipt
tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Contract deployed at address: { tx_receipt.contractAddress }")
```

Execute:

```bash
python3 deploy.py
```

![Implantar Contrato Web3py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-3.webp)

### Ler Dados do Contrato (Calls) {: #read-contract-data }

Calls nÃ£o mudam estado; nÃ£o precisam de transaÃ§Ã£o. Crie `get.py`:

```bash
touch get.py
```

Passos:

1. Importe Web3.py e o ABI.
2. Inclua o provedor.
3. Defina `contract_address`.
4. Instancie o contrato com ABI/endereÃ§o.
5. Chame `number()` e exiba.

```python
# 1. Import the ABI
from compile import abi
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create address variable
contract_address = "INSERT_CONTRACT_ADDRESS"

print(f"Making a call to contract at address: { contract_address }")

# 4. Create contract instance
Incrementer = web3.eth.contract(address=contract_address, abi=abi)

# 5. Call Contract
number = Incrementer.functions.number().call()
print(f"The current number stored is: { number } ")
```

Execute:

```bash
python3 get.py
```

![Ler do Contrato Web3py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-4.webp)

### Interagir com o Contrato (Sends) {: #interact-with-contract }

Sends alteram estado; exigem transaÃ§Ã£o. Crie `increment.py` e `reset.py`:

```bash
touch increment.py reset.py
```

`increment.py`:

1. Importe Web3.py e ABI.
2. Inclua o provedor.
3. Defina `account_from`/`private_key`, `contract_address`, `value` (**nÃ£o salve chaves reais em Python**).
4. Instancie o contrato.
5. Construa a tx de incremento com `build_transaction` (from, nonce).
6. Assine com `sign_transaction`.
7. Envie com `send_raw_transaction` e aguarde recibo.

```python
# 1. Add imports
from compile import abi
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create variables
account_from = {
    "private_key": "INSERT_YOUR_PRIVATE_KEY",
    "address": "INSERT_PUBLIC_ADDRESS_OF_PK",
}
contract_address = "INSERT_CONTRACT_ADDRESS"
value = 3

print(
    f"Calling the increment by { value } function in contract at address: { contract_address }"
)

# 4. Create contract instance
Incrementer = web3.eth.contract(address=contract_address, abi=abi)

# 5. Build increment tx
increment_tx = Incrementer.functions.increment(value).build_transaction(
    {
        "from": Web3.to_checksum_address(account_from["address"]),
        "nonce": web3.eth.get_transaction_count(
            Web3.to_checksum_address(account_from["address"])
        ),
    }
)

# 6. Sign tx with PK
tx_create = web3.eth.account.sign_transaction(increment_tx, account_from["private_key"])

# 7. Send tx and wait for receipt
tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Tx successful with hash: { tx_receipt.transactionHash.hex() }")
```

Execute:

```bash
python3 increment.py
```

![Incrementar Contrato Web3py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-5.webp)

`reset.py` segue o mesmo padrÃ£o chamando `reset()` sem argumentos:

```python
# 1. Add imports
from compile import abi
from web3 import Web3

# 2. Create web3.py provider
provider_rpc = {
    # Insert your RPC URL here
    "evm_network": "https://services.tanssi-testnet.network/dancelight-2001",
}
web3 = Web3(Web3.HTTPProvider(provider_rpc["evm_network"]))

# 3. Create variables
account_from = {
    "private_key": "INSERT_YOUR_PRIVATE_KEY",
    "address": "INSERT_PUBLIC_ADDRESS_OF_PK",
}
contract_address = "INSERT_CONTRACT_ADDRESS"

print(f"Calling the reset function in contract at address: { contract_address }")

# 4. Create contract instance
Incrementer = web3.eth.contract(address=contract_address, abi=abi)

# 5. Build reset tx
reset_tx = Incrementer.functions.reset().build_transaction(
    {
        "from": Web3.to_checksum_address(account_from["address"]),
        "nonce": web3.eth.get_transaction_count(
            Web3.to_checksum_address(account_from["address"])
        ),
    }
)

# 6. Sign tx with PK
tx_create = web3.eth.account.sign_transaction(reset_tx, account_from["private_key"])

# 7. Send tx and wait for receipt
tx_hash = web3.eth.send_raw_transaction(tx_create.rawTransaction)
tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)

print(f"Tx successful with hash: { tx_receipt.transactionHash.hex() }")
```

Execute:

```bash
python3 reset.py
```

![Redefinir Contrato Web3py](/images/builders/toolkit/ethereum-api/libraries/web3py/web3py-6.webp)

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/precompiles/batch/
--- BEGIN CONTENT ---
---
title: PrÃ©-compilado Batch
description: Aprenda a combinar vÃ¡rias transferÃªncias e interaÃ§Ãµes de contrato por meio de uma interface Solidity usando o Batch Precompile na sua rede EVM powered by Tanssi.
keywords: solidity, ethereum, batch, transaÃ§Ã£o, tanssi, precompiled, contratos
icon: octicons-stack-24
categories: EVM-Template
---

# Interagindo com o Batch Precompile

## IntroduÃ§Ã£o {: #introduction }

O contrato Batch Precompile em redes EVM powered by Tanssi permite agrupar vÃ¡rias chamadas EVM em uma sÃ³.

Normalmente, fazer o usuÃ¡rio interagir com vÃ¡rios contratos exige vÃ¡rias confirmaÃ§Ãµes de transaÃ§Ã£o na carteira. Um exemplo seria aprovar o acesso de um contrato a um token e logo em seguida transferi-lo. Com o Batch Precompile, vocÃª melhora a experiÃªncia do usuÃ¡rio com transaÃ§Ãµes em lote, pois reduz o nÃºmero de confirmaÃ§Ãµes necessÃ¡rias. AlÃ©m disso, as taxas de gÃ¡s podem diminuir, jÃ¡ que o batching evita mÃºltiplas taxas base (as 21000 unidades iniciais de gÃ¡s de cada transaÃ§Ã£o).

O precompile interage diretamente com o [pallet EVM do Substrate](https://polkadot-evm.github.io/frontier){target=\_blank}. Quem chama a funÃ§Ã£o em lote tem seu endereÃ§o agindo como `msg.sender` para todas as subtransaÃ§Ãµes, mas, diferente de [delegate calls](https://docs.soliditylang.org/en/v0.8.15/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries){target=\_blank}, o contrato de destino ainda altera o prÃ³prio armazenamento. Ã‰ como se o usuÃ¡rio assinasse vÃ¡rias transaÃ§Ãµes, mas com apenas uma confirmaÃ§Ã£o.

O Batch Precompile estÃ¡ localizado neste endereÃ§o:

```text
{{ networks.demo_evm.precompiles.batch }}
```

!!! note
    O uso de precompiladas pode trazer consequÃªncias inesperadas. As precompiladas do Tanssi sÃ£o derivadas das do Moonbeam; portanto, familiarize-se com as [consideraÃ§Ãµes de seguranÃ§a das precompiladas do Moonbeam](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## A Interface Solidity em Lote {: #the-batch-interface }

[`Batch.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/Batch.sol){target=\_blank} Ã© uma interface Solidity que permite interagir com os trÃªs mÃ©todos do precompile.

??? code "Batch.sol"

    ```solidity
    // SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The Batch contract's address.
address constant BATCH_ADDRESS = 0x0000000000000000000000000000000000000801;

/// @dev The Batch contract's instance.
Batch constant BATCH_CONTRACT = Batch(BATCH_ADDRESS);

/// @author The Moonbeam Team
/// @title Batch precompile
/// @dev Allows to perform multiple calls throught one call to the precompile.
/// Can be used by EOA to do multiple calls in a single transaction.
/// @custom:address 0x0000000000000000000000000000000000000801
interface Batch {
    /// @dev Batch multiple calls into a single transaction.
    /// All calls are performed from the address calling this precompile.
    ///
    /// In case of one subcall reverting following subcalls will still be attempted.
    ///
    /// @param to List of addresses to call.
    /// @param value List of values for each subcall. If array is shorter than "to" then additional
    /// calls will be performed with a value of 0.
    /// @param callData Call data for each `to` address. If array is shorter than "to" then
    /// additional calls will be performed with an empty call data.
    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.
    /// If array is shorter than "to" then the remaining gas available will be used.
    /// @custom:selector 79df4b9c
    function batchSome(
        address[] memory to,
        uint256[] memory value,
        bytes[] memory callData,
        uint64[] memory gasLimit
    ) external;

    /// @dev Batch multiple calls into a single transaction.
    /// All calls are performed from the address calling this precompile.
    ///
    /// In case of one subcall reverting, no more subcalls will be executed but
    /// the batch transaction will succeed. Use batchAll to revert on any subcall revert.
    ///
    /// @param to List of addresses to call.
    /// @param value List of values for each subcall. If array is shorter than "to" then additional
    /// calls will be performed with a value of 0.
    /// @param callData Call data for each `to` address. If array is shorter than "to" then
    /// additional calls will be performed with an empty call data.
    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.
    /// If array is shorter than "to" then the remaining gas available will be used.
    /// @custom:selector cf0491c7
    function batchSomeUntilFailure(
        address[] memory to,
        uint256[] memory value,
        bytes[] memory callData,
        uint64[] memory gasLimit
    ) external;

    /// @dev Batch multiple calls into a single transaction.
    /// All calls are performed from the address calling this precompile.
    ///
    /// In case of one subcall reverting, the entire batch will revert.
    ///
    /// @param to List of addresses to call.
    /// @param value List of values for each subcall. If array is shorter than "to" then additional
    /// calls will be performed with a value of 0.
    /// @param callData Call data for each `to` address. If array is shorter than "to" then
    /// additional calls will be performed with an empty call data.
    /// @param gasLimit Gas limit for each `to` address. Use 0 to forward all the remaining gas.
    /// If array is shorter than "to" then the remaining gas available will be used.
    /// @custom:selector 96e292b8
    function batchAll(
        address[] memory to,
        uint256[] memory value,
        bytes[] memory callData,
        uint64[] memory gasLimit
    ) external;

    /// Emitted when a subcall succeeds.
    event SubcallSucceeded(uint256 index);

    /// Emitted when a subcall fails.
    event SubcallFailed(uint256 index);
}
    ```

A interface inclui as seguintes funÃ§Ãµes:

???+ function "**batchSome**(*address[]* to, *uint256[]* value, *bytes[]* callData, *uint64[]* gasLimit) â€” executa vÃ¡rias chamadas, combinando os mesmos Ã­ndices dos arrays para formar cada subchamada. Se uma subchamada reverter, as seguintes ainda serÃ£o tentadas"

    === "ParÃ¢metros"

        - `to` - array de endereÃ§os para direcionar as subtransaÃ§Ãµes, em que cada entrada Ã© uma subtransaÃ§Ã£o
        - `value` - array de valores em moeda nativa para enviar nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes terÃ£o valor 0
        - `callData` - array de dados de chamada para incluir nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes nÃ£o terÃ£o dados de chamada
        - `gasLimit` - array de limites de gÃ¡s nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Valores 0 sÃ£o interpretados como ilimitados e encaminham todo o gÃ¡s restante da transaÃ§Ã£o em lote. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes encaminharÃ£o todo o gÃ¡s restante

??? function "**batchSomeUntilFailure**(*address[]* to, *uint256[]* value, *bytes[]* callData, *uint64[]* gasLimit) â€” executa vÃ¡rias chamadas, combinando os mesmos Ã­ndices dos arrays para formar cada subchamada. Se uma subchamada reverter, nenhuma subchamada seguinte serÃ¡ executada"

    === "ParÃ¢metros"

        - `to` - array de endereÃ§os para direcionar as subtransaÃ§Ãµes, em que cada entrada Ã© uma subtransaÃ§Ã£o
        - `value` - array de valores em moeda nativa para enviar nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes terÃ£o valor 0
        - `callData` - array de dados de chamada para incluir nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes nÃ£o terÃ£o dados de chamada
        - `gasLimit` - array de limites de gÃ¡s nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Valores 0 sÃ£o interpretados como ilimitados e encaminham todo o gÃ¡s restante da transaÃ§Ã£o em lote. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes encaminharÃ£o todo o gÃ¡s restante

??? function "**batchAll**(*address[]* to, *uint256[]* value, *bytes[]* callData, *uint64[]* gasLimit) â€” executa vÃ¡rias chamadas de forma atÃ´mica, combinando os mesmos Ã­ndices dos arrays para formar cada subchamada. Se uma subchamada reverter, todas as subchamadas irÃ£o reverter"

    === "ParÃ¢metros"

        - `to` - array de endereÃ§os para direcionar as subtransaÃ§Ãµes, em que cada entrada Ã© uma subtransaÃ§Ã£o
        - `value` - array de valores em moeda nativa para enviar nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes terÃ£o valor 0
        - `callData` - array de dados de chamada para incluir nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes nÃ£o terÃ£o dados de chamada
        - `gasLimit` - array de limites de gÃ¡s nas subtransaÃ§Ãµes, em que o Ã­ndice corresponde Ã  subtransaÃ§Ã£o no mesmo Ã­ndice em *to*. Valores 0 sÃ£o interpretados como ilimitados e encaminham todo o gÃ¡s restante da transaÃ§Ã£o em lote. Se este array for menor que o array *to*, todas as subtransaÃ§Ãµes seguintes encaminharÃ£o todo o gÃ¡s restante

A interface tambÃ©m inclui os seguintes eventos:

- **SubcallSucceeded**(*uint256* index) - emitido quando uma subchamada do Ã­ndice informado Ã© bem-sucedida
- **SubcallFailed**(*uint256* index) - emitido quando uma subchamada do Ã­ndice informado falha

## Interaja com a Interface Solidity {: #interact-with-the-solidity-interface }

### Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para acompanhar este tutorial, vocÃª precisa ter a carteira configurada para sua rede EVM e uma conta com tokens nativos. VocÃª pode adicionar sua rede EVM Ã  MetaMask com um clique no [Tanssi dApp](https://apps.tanssi.network){target=\_blank}. Ou [configurar a MetaMask para a Tanssi com a rede EVM de demonstraÃ§Ã£o](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

### Contrato de Exemplo {: #example-contract}

O contrato `SimpleContract.sol` serÃ¡ usado como exemplo de interaÃ§Ã£o em lote, mas, na prÃ¡tica, qualquer contrato pode ser usado.

```solidity
// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.0;

contract SimpleContract {
    mapping(uint256 => string) public messages;

    function setMessage(uint256 id, string calldata message) external {
        messages[id] = message;
    }
}
```

### ConfiguraÃ§Ã£o do Remix {: #remix-set-up }

VocÃª pode interagir com o Batch Precompile usando o [Remix](https://remix.ethereum.org){target=\_blank}. Tenha uma cÃ³pia de [`Batch.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/Batch.sol){target=\_blank} e de `SimpleContract.sol`. Para adicionar o precompile no Remix e seguir o tutorial:

1. Clique na aba **File explorer**
2. Cole o contrato `Batch.sol` em um arquivo do Remix chamado **Batch.sol**
3. Cole o contrato `SimpleContract.sol` em um arquivo do Remix chamado **SimpleContract.sol**

### Compile o Contrato {: #compile-the-contract }

Em seguida, compile os dois arquivos no Remix:

1. Certifique-se de que o arquivo **Batch.sol** estÃ¡ aberto
2. Clique na aba **Compile**, a segunda de cima
3. Para compilar, clique em **Compile Batch.sol**

![Compiling Batch.sol](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-1.webp)

Se a interface foi compilada com sucesso, vocÃª verÃ¡ um check verde ao lado da aba **Compile**.

### Acesse o Precompile {: #access-the-precompile }

Em vez de implantar o Batch Precompile, acesse a interface informando o endereÃ§o do contrato prÃ©-compilado:

1. Clique na aba **Deploy and Run** logo abaixo da aba **Compile** no Remix. Observe que o contrato prÃ©-compilado jÃ¡ estÃ¡ implantado
2. Certifique-se de que **Injected Provider - MetaMask** estÃ¡ selecionado no menu **ENVIRONMENT**. Ao selecionar, a MetaMask pode solicitar que vocÃª conecte sua conta ao Remix
3. Confirme que a conta correta aparece em **ACCOUNT**
4. Garanta que **Batch.sol** estÃ¡ selecionado no menu **CONTRACT**. Como Ã© um contrato prÃ©-compilado, nÃ£o Ã© necessÃ¡rio implantar cÃ³digo. Vamos apenas fornecer o endereÃ§o do precompile no campo **At Address**
5. Informe o endereÃ§o do Batch Precompile: `{{networks.demo_evm.precompiles.batch}}` e clique em **At Address**

![Access the address](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-2.webp)

O precompile **BATCH** aparecerÃ¡ na lista de **Deployed Contracts**.

### Implemente o Contrato de Exemplo {: #deploy-example-contract }

Por outro lado, `SimpleContract.sol` serÃ¡ implantado como um novo contrato. Antes de comeÃ§ar esta seÃ§Ã£o, repita a [etapa de compilaÃ§Ã£o](#compile-the-contract) com o arquivo `SimpleContract.sol`.

1. Clique na aba **Deploy and Run** logo abaixo da aba **Compile** no Remix
2. Certifique-se de que **Injected Provider - MetaMask** estÃ¡ selecionado em **ENVIRONMENT**. Ao selecionar, a MetaMask pode solicitar que vocÃª conecte sua conta ao Remix
3. Confirme que a conta correta aparece em **ACCOUNT**
4. Garanta que **SimpleContract** estÃ¡ selecionado no menu **CONTRACT**
5. Clique em **Deploy**
6. Confirme a transaÃ§Ã£o que aparecerÃ¡ na MetaMask clicando em **Confirm**

![Deploy SimpleContract](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-3.webp)

O contrato **SIMPLECONTRACT** aparecerÃ¡ na lista de **Deployed Contracts**.

### Envie moeda nativa via precompile {: #send-native-currency-via-precompile }

Enviar moeda nativa com o Batch Precompile exige mais do que alguns cliques no Remix ou na MetaMask. Neste exemplo, vocÃª usarÃ¡ a funÃ§Ã£o **batchAll** para enviar moeda nativa de forma atÃ´mica.

TransaÃ§Ãµes tÃªm um campo `value` para indicar o valor de moeda nativa a enviar. No Remix, isso Ã© definido pelo input **VALUE** na aba **DEPLOY & RUN TRANSACTIONS**. PorÃ©m, para o Batch Precompile, esses valores sÃ£o fornecidos no array **value** das funÃ§Ãµes em lote.

Tente transferir o token nativo da sua rede para duas carteiras usando o Batch Precompile:

1. Expanda o contrato do batch em **Deployed Contracts**
2. Expanda a funÃ§Ã£o **batchAll**
3. No campo **to**, insira os endereÃ§os neste formato: `["INSERIR_ENDERECO_1", "INSERIR_ENDERECO_2"]`, onde o primeiro endereÃ§o corresponde Ã  primeira carteira e o segundo Ã  segunda carteira
4. No campo **value**, insira o valor que deseja transferir em Wei para cada endereÃ§o. Por exemplo, `["1000000000000000000", "2000000000000000000"]` transferirÃ¡ 1 token nativo para o primeiro endereÃ§o e 2 tokens para o segundo
5. Para **callData**, insira `[]`. NÃ£o hÃ¡ dados de chamada para uma simples transferÃªncia de token nativo
6. Para **gasLimit**, insira `[]`
7. Clique em **transact**
8. Clique em **Confirm** na MetaMask para confirmar a transaÃ§Ã£o

![Send Batch Transfer](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-4.webp)

Quando a transaÃ§Ã£o for concluÃ­da, vocÃª pode conferir os saldos das duas contas na MetaMask ou no explorador da sua rede (link no [Tanssi dApp](https://apps.tanssi.network){target=\_blank}). ParabÃ©ns! VocÃª enviou uma transferÃªncia em lote via Batch Precompile.

!!! note
     Normalmente, para enviar moeda nativa para ou atravÃ©s de um contrato, seria preciso definir o `value` no objeto geral da transaÃ§Ã£o e interagir com uma funÃ§Ã£o payable. Contudo, como o Batch Precompile interage diretamente com o cÃ³digo Substrate, esta nÃ£o Ã© uma transaÃ§Ã£o Ethereum tÃ­pica, entÃ£o isso nÃ£o Ã© necessÃ¡rio.

### Descubra o call data de uma interaÃ§Ã£o de contrato {: #find-a-contract-interactions-call-data }

Interfaces visuais como o [Remix](/pt/builders/toolkit/ethereum-api/dev-env/remix/){target=\_blank} e bibliotecas como [Ethers.js](/pt/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank} ocultam como transaÃ§Ãµes Ethereum interagem com contratos Solidity. O nome e os tipos de entrada de uma funÃ§Ã£o sÃ£o transformados em um [seletor de funÃ§Ã£o](https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector-and-argument-encoding){target=\_blank} e os dados de entrada sÃ£o codificados. Esses dois elementos sÃ£o combinados e enviados como o call data da transaÃ§Ã£o. Para enviar uma subtransaÃ§Ã£o dentro de uma transaÃ§Ã£o em lote, o remetente precisa conhecer previamente esse call data.

Tente encontrar o call data de uma transaÃ§Ã£o usando o Remix:

1. Expanda o contrato `SimpleContract.sol` em **Deployed Contracts**
2. Expanda a funÃ§Ã£o **setMessage**
3. Insira o **id** desejado, como `1`
4. Insira a **message** desejada, como `"tanssi"`
5. Em vez de enviar a transaÃ§Ã£o, clique no botÃ£o de copiar ao lado de **transact** para copiar o call data

![Transaction Call Data](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-5.webp)

Agora vocÃª tem o call data da transaÃ§Ã£o! Considerando os valores de exemplo `1` e `"tanssi"`, podemos observar seus valores codificados no call data:

```text
0x648345c8                                                        // function selector
0000000000000000000000000000000000000000000000000000000000000001  // 1 id
0000000000000000000000000000000000000000000000000000000000000040  // 32 byte offset
000000000000000000000000000000000000000000000000000000000000000   // 32 byte length
674616e7373690000000000000000000000000000000000000000000000000000 // "tanssi" em bytes
```

O call data pode ser dividido em cinco linhas em que:

 - A primeira linha Ã© o seletor de funÃ§Ã£o
 - A segunda linha Ã© igual a 1, que Ã© o **id** fornecido
 - O restante envolve o input **message**. Essas trÃªs Ãºltimas linhas sÃ£o mais complexas, pois strings sÃ£o um [tipo dinÃ¢mico](https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#use-of-dynamic-types){target=\_blank} com tamanho variÃ¡vel. A terceira linha se refere ao offset que define onde os dados da string comeÃ§am. A quarta linha se refere ao comprimento da mensagem na linha seguinte, que Ã© de 32 bytes no total â€” a mensagem "tanssi" mais o preenchimento
 
VocÃª pode repetir as etapas acima para capturar o call data para os valores `2` e `"hello"` e enviar vÃ¡rias subchamadas de forma atÃ´mica com o Batch Precompile na prÃ³xima seÃ§Ã£o.

### InteraÃ§Ã£o de FunÃ§Ã£o via Precompile {: #function-interaction-via-precompile }

O exemplo desta seÃ§Ã£o usarÃ¡ a funÃ§Ã£o **batchAll**, que garante a resoluÃ§Ã£o atÃ´mica das transaÃ§Ãµes. Lembre-se de que hÃ¡ outras duas funÃ§Ãµes em lote que podem continuar subtransaÃ§Ãµes apesar de erros ou parar subtransaÃ§Ãµes seguintes sem reverter as anteriores.

Interagir com uma funÃ§Ã£o Ã© muito semelhante a [enviar moeda nativa](#send-native-currency-via-precompile), jÃ¡ que ambas sÃ£o transaÃ§Ãµes. Entretanto, Ã© necessÃ¡rio call data para fornecer entradas Ã s funÃ§Ãµes corretamente, e o remetente pode querer limitar o gÃ¡s gasto em cada subtransaÃ§Ã£o.

Os campos `callData` e `gasLimit` sÃ£o mais relevantes para subtransaÃ§Ãµes que interagem com contratos. Para cada funÃ§Ã£o da interface em lote, `callData` Ã© um array em que cada Ã­ndice corresponde ao call data de cada destinatÃ¡rio da subtransaÃ§Ã£o, ou seja, cada entrada em `to`. Se o tamanho do array `callData` for menor que o array `to`, as subtransaÃ§Ãµes restantes nÃ£o terÃ£o call data (funÃ§Ãµes sem entradas). O `gasLimit` Ã© um array que define quanto gÃ¡s cada subtransaÃ§Ã£o pode gastar. Se o valor em um Ã­ndice for 0 ou o Ã­ndice estiver fora do tamanho do array (mas ainda menor que o tamanho de `to`), todo o gÃ¡s restante da transaÃ§Ã£o anterior Ã© encaminhado.

Para usar o precompile e enviar uma transaÃ§Ã£o em lote atÃ´mica combinando duas interaÃ§Ãµes de contrato, faÃ§a o seguinte:

1. Copie o endereÃ§o do contrato `SimpleContract.sol` com o botÃ£o de copiar Ã  direita do cabeÃ§alho. Tenha tambÃ©m o [call data da seÃ§Ã£o anterior](#find-a-contract-interactions-call-data)
2. Expanda o contrato do batch em **Deployed Contracts**
3. Expanda a funÃ§Ã£o **batchAll**
4. Para o campo **to**, cole o endereÃ§o de `SimpleContract.sol` assim: `["INSERIR_ENDERECO_SIMPLE_CONTRACT","INSERIR_ENDERECO_SIMPLE_CONTRACT"]`. Observe que Ã© preciso repetir o endereÃ§o para cada transaÃ§Ã£o em lote, mesmo que o contrato seja o mesmo
5. Para o campo **value**, como `SimpleContract.sol` nÃ£o requer moeda nativa, insira `[0,0]` para 0 Wei
6. Para o campo **callData**, insira os call data da seÃ§Ã£o anterior neste formato: `["INSERIR_PRIMEIRO_CALL_DATA","INSERIR_SEGUNDO_CALL_DATA"]`
7. Para o campo **gasLimit**, insira `[]`. VocÃª pode definir um valor de gÃ¡s para cada subchamada ou deixar como array vazio
8. Clique em **transact**
9. Clique em **Confirm** na MetaMask para confirmar a transaÃ§Ã£o

![Batch Function Interaction](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-6.webp)

Se vocÃª usou o mesmo call data do tutorial, pode verificar se a transaÃ§Ã£o deu certo assim:

1. Expanda o contrato `SimpleContract.sol` em **Deployed Contracts**
2. Ã€ direita do botÃ£o **messages**, insira `1`
3. Clique no botÃ£o azul **messages**

![SimpleContract Confirmation](/images/builders/toolkit/ethereum-api/precompiles/batch/batch-7.webp)

A frase **"tanssi"** deve aparecer embaixo. VocÃª pode repetir com o id "2" e verÃ¡ **"hello"**. ParabÃ©ns! VocÃª interagiu com uma funÃ§Ã£o usando o Batch Precompile.

### Combinando SubtransaÃ§Ãµes {: combining-subtransactions }

AtÃ© aqui, transferir moeda nativa e interagir com funÃ§Ãµes foram aÃ§Ãµes separadas, mas elas podem ser combinadas.

As quatro strings a seguir podem ser usadas como inputs de uma transaÃ§Ã£o em lote. Elas enviam 1 token nativo para a conta pÃºblica Gerald (`0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b`) e interagem com um contrato `SimpleContract.sol` prÃ©-implantado duas vezes. Eis o detalhamento:

HÃ¡ trÃªs subtransaÃ§Ãµes que correspondem a trÃªs endereÃ§os no array `to`. O primeiro Ã© a conta pÃºblica Gerald e os dois seguintes sÃ£o um contrato `SimpleContract.sol`. VocÃª pode substituir os dois Ãºltimos pelo seu prÃ³prio contrato `SimpleContract.sol` se quiser. Ou substituir apenas um: Ã© possÃ­vel interagir com mÃºltiplos contratos em uma Ãºnica mensagem.

```text
[
  "0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b",
  "0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39", 
  "0xd14b70a55F6cBAc06d4FA49b99be0370D0e1BD39"
]
```

TambÃ©m haverÃ¡ trÃªs valores para o array `value`. O primeiro endereÃ§o em `to` indica `1000000000000000000` wei ou `1` UNIT do token nativo. Lembre que os tokens nativos de redes EVM powered by Tanssi tÃªm [18 casas decimais, assim como no Ethereum](https://eth-converter.com){target=\_blank}. Os dois valores seguintes sÃ£o `0` porque a funÃ§Ã£o com que suas subtransaÃ§Ãµes interagem nÃ£o aceita nem exige moeda nativa.  

```text
["1000000000000000000", "0", "0"]
```

VocÃª precisarÃ¡ de trÃªs valores para o array `callData`. Como transferir moeda nativa nÃ£o requer call data, a string fica vazia. O segundo e o terceiro valores correspondem a chamadas de **setMessage** que definem mensagens para os IDs 5 e 6.

```text
[
  "0x", 
  "0x648345c8000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000009796f752061726520610000000000000000000000000000000000000000000000", 
  "0x648345c800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000e61206d6f6f6e6265616d2070726f000000000000000000000000000000000000"
]
```

O input final Ã© para `gas_input`. Este array ficarÃ¡ vazio para encaminhar todo o gÃ¡s restante a cada subtransaÃ§Ã£o.

```text
[]
```

Tente enviar uma transaÃ§Ã£o em lote com esses inputs no Remix da mesma forma que [vocÃª agrupou uma chamada de funÃ§Ã£o](#function-interaction-via-precompile).

E Ã© isso! VocÃª interagiu com o precompile de batching usando MetaMask e Remix!

## Bibliotecas de Desenvolvimento Ethereum {: #ethereum-development-libraries }

Se vocÃª seguiu o [tutorial de Ethers.js](/pt/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}, pode ser difÃ­cil encontrar o call data de uma funÃ§Ã£o. A resposta estÃ¡ escondida no objeto `Interface` do Ethers, onde a funÃ§Ã£o [encodeFunctionData](https://docs.ethers.org/v6/api/abi/#Interface-encodeFunctionData){target=\_blank} permite informar o nome da funÃ§Ã£o e os inputs para obter o call data resultante. O [Web3.js](/pt/builders/toolkit/ethereum-api/libraries/web3js/){target=\_blank} tem funÃ§Ã£o semelhante, [encodeFunctionCall](https://web3js.readthedocs.io/en/v1.2.11/web3-eth-abi.html#encodefunctioncall){target=\_blank}.

!!! note
    Os trechos de cÃ³digo a seguir nÃ£o sÃ£o destinados a ambientes de produÃ§Ã£o. Adapte-os conforme cada caso de uso.

=== "Ethers.js"

     ```js
     // Import the contract ABI
const { abi } = require('./INSERT_ABI_PATH');

// Use ABI to create an interface
const yourContractInterface = new ethers.Interface(abi);

// Find call data for the setMessage function
const callData = yourContractInterface.encodeFunctionData(
  'INSERT_FUNCTION_NAME',
  [
    'INSERT_INPUT_1',
    'INSERT_INPUT_2',
    // ...
  ]
);
     ```

=== "Web3.js"

     ```js
     // Import the contract ABI
const { abi } = require('./INSERT_ABI_PATH');

// Find call data for the setMessage function
const callData = web3.eth.abi.encodeFunctionCall(abi, [
  'INSERT_INPUT_1',
  'INSERT_INPUT_2',
  // ...
]);
     ```

=== "Web3.py"

     ```py
     # Import the ABI and bytecode
from compile import abi, bytecode

# Create contract instance
your_contract = web3.eth.contract(abi=abi, bytecode=bytecode)

# Encode the contract call
call_data = your_contract.encodeABI(
    fn_name="INSERT_FUNCTION_NAME", args=["INSERT_INPUT_1", "INSERT_INPUT_2", ...]
)
     ```

Depois disso, vocÃª estarÃ¡ pronto para interagir com o Batch Precompile como faria normalmente com um contrato no [Ethers](/pt/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/precompiles/call-permit/
--- BEGIN CONTENT ---
---
title: O Call Permit Precompile 
description: Aprenda a usar o Call Permit Precompile em redes EVM powered by Tanssi para assinar um permit para qualquer chamada EVM que possa ser despachada por qualquer pessoa ou contrato inteligente.
keywords: solidity, ethereum, call permit, permit, gasless transaction, moonbeam, precompiled, contracts, tanssi
icon: octicons-arrow-up-right-24
categories: EVM-Template
---

# Interagindo com o Call Permit Precompile

## IntroduÃ§Ã£o {: #introduction }

O Call Permit Precompile em redes EVM powered by Tanssi permite que um usuÃ¡rio assine um permit, uma mensagem assinada [EIP-712](https://eips.ethereum.org/EIPS/eip-712){target=\_blank}, para qualquer chamada EVM, podendo ser despachada por qualquer pessoa ou contrato inteligente. Ã‰ semelhante ao Permit Signing das aprovaÃ§Ãµes ERC-20 introduzidas no [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612){target=\_blank}, exceto que se aplica a qualquer chamada EVM em vez de apenas aprovaÃ§Ãµes.

Quando o call permit Ã© despachado, isso Ã© feito em nome do usuÃ¡rio que assinou o permit e o usuÃ¡rio ou contrato que despacha o permit Ã© responsÃ¡vel por pagar as taxas de transaÃ§Ã£o. Assim, o precompile pode ser usado para realizar transaÃ§Ãµes sem gÃ¡s para o signatÃ¡rio.

Por exemplo, Alice assina um call permit e Bob o despacha, executando a chamada em nome de Alice. Bob paga as taxas de transaÃ§Ã£o; portanto, Alice nÃ£o precisa ter moeda nativa para pagar a transaÃ§Ã£o, a menos que a chamada inclua uma transferÃªncia.

O Call Permit Precompile estÃ¡ localizado no seguinte endereÃ§o:

```text
{{ networks.demo_evm.precompiles.call_permit }}
```

!!! note
    O uso de precompiladas pode trazer consequÃªncias inesperadas. As precompiladas do Tanssi sÃ£o derivadas das do Moonbeam; portanto, familiarize-se com as [consideraÃ§Ãµes de seguranÃ§a das precompiladas do Moonbeam](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## Interface Solidity do Call Permit {: #the-call-permit-interface }

[`CallPermit.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/CallPermit.sol){target=\_blank} Ã© uma interface Solidity que permite interagir com trÃªs mÃ©todos do precompile.

??? code "CallPermit.sol"

    ```solidity
    // SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The CallPermit contract's address.
address constant CALL_PERMIT_ADDRESS = 0x0000000000000000000000000000000000000802;

/// @dev The CallPermit contract's instance.
CallPermit constant CALL_PERMIT_CONTRACT = CallPermit(CALL_PERMIT_ADDRESS);

/// @author The Moonbeam Team
/// @title Call Permit Interface
/// @dev The interface aims to be a general-purpose tool to perform gas-less transactions. It uses the EIP-712 standard,
/// and signed messages can be dispatched by another network participant with a transaction
/// @custom:address 0x0000000000000000000000000000000000000802
interface CallPermit {
    /// @dev Dispatch a call on the behalf of an other user with a EIP712 permit.
    /// Will revert if the permit is not valid or if the dispatched call reverts or errors (such as
    /// out of gas).
    /// If successful the EIP712 nonce is increased to prevent this permit to be replayed.
    /// @param from Who made the permit and want its call to be dispatched on their behalf.
    /// @param to Which address the call is made to.
    /// @param value Value being transferred from the "from" account.
    /// @param data Call data
    /// @param gaslimit Gaslimit the dispatched call requires.
    ///     Providing it prevents the dispatcher to manipulate the gaslimit.
    /// @param deadline Deadline in UNIX seconds after which the permit will no longer be valid.
    /// @param v V part of the signature.
    /// @param r R part of the signature.
    /// @param s S part of the signature.
    /// @return output Output of the call.
    /// @custom:selector b5ea0966
    function dispatch(
        address from,
        address to,
        uint256 value,
        bytes memory data,
        uint64 gaslimit,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (bytes memory output);

    /// @dev Returns the current nonce for given owner.
    /// A permit must have this nonce to be consumed, which will
    /// increase the nonce by one.
    /// @custom:selector 7ecebe00
    function nonces(address owner) external view returns (uint256);

    /// @dev Returns the EIP712 domain separator. It is used to avoid replay
    /// attacks across assets or other similar EIP712 message structures.
    /// @custom:selector 3644e515
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}
    ```

A interface inclui as seguintes funÃ§Ãµes:

???+ function "**dispatch**(*address* from, *address* to, *uint256* value, *bytes* data, *uint64[]* gaslimit, *uint256* deadline, *uint8* v, *bytes32* r, *bytes32* s) â€” despacha uma chamada em nome de outro usuÃ¡rio com um permit EIP-712. Qualquer pessoa ou contrato pode chamar. A transaÃ§Ã£o reverte se o permit for invÃ¡lido ou se a chamada despachada reverter/errar (por exemplo, out of gas). Se for bem-sucedida, o nonce do signatÃ¡rio Ã© incrementado para evitar replay"

    === "ParÃ¢metros"

        - `from` - signatÃ¡rio do permit. A chamada serÃ¡ despachada em nome deste endereÃ§o
        - `to` - endereÃ§o para o qual a chamada Ã© feita
        - `value` - valor transferido da conta `from`
        - `data` - call data, ou aÃ§Ã£o a executar
        - `value` - valor transferido da conta `from`
        - `gasLimit` - limite de gÃ¡s exigido pela chamada despachada. Informar este parÃ¢metro evita que o despachante manipule o gas limit
        - `deadline` - tempo em segundos UNIX apÃ³s o qual o permit nÃ£o serÃ¡ mais vÃ¡lido. Em JavaScript, vocÃª pode obter o tempo UNIX atual executando `console.log(Date.now())` em um script ou no console do navegador
        - `v` - recovery ID da assinatura (1 byte final da assinatura concatenada)
        - `r` - primeiros 32 bytes da assinatura concatenada
        - `s` - segundos 32 bytes da assinatura concatenada

??? function "**nonces**(*address* owner) â€” retorna o nonce atual para o owner informado"

    === "ParÃ¢metros"

        - `owner` - endereÃ§o da conta a verificar

??? function "**DOMAIN_SEPARATOR**() â€” retorna o separador de domÃ­nio EIP-712 usado para evitar ataques de replay. Segue a implementaÃ§Ã£o do [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612#specification){target=\_blank}"

    === "ParÃ¢metros"

        Nenhum

    === "Retorno"
        O separador de domÃ­nio EIP-712 usado para evitar ataques de replay.

O separador de domÃ­nio Ã© definido no [padrÃ£o EIP-712](https://eips.ethereum.org/EIPS/eip-712){target=\_blank} e calculado como:

```text
keccak256(PERMIT_DOMAIN, name, version, chain_id, address)
```

Os parÃ¢metros do hash podem ser decompostos assim:

 - **PERMIT_DOMAIN** - Ã© o `keccak256` de `EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)`
 - **name** - Ã© o nome do domÃ­nio de assinatura e deve ser exatamente `'Call Permit Precompile'`
 - **version** - Ã© a versÃ£o do domÃ­nio de assinatura. Aqui, **version** Ã© `1`
 - **chainId** - Ã© o Chain ID da sua rede
 - **verifyingContract** - Ã© o endereÃ§o do contrato que verificarÃ¡ a assinatura. Neste caso, o endereÃ§o do Call Permit Precompile

Quando `dispatch` Ã© chamado, o permit precisa ser verificado antes de despachar a chamada. O primeiro passo Ã© [calcular o separador de domÃ­nio](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L138){target=\_blank}. O cÃ¡lculo pode ser visto na [implementaÃ§Ã£o do Moonbeam](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L112-L126){target=\_blank} ou em um exemplo prÃ¡tico no [contrato EIP712 do OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/cryptography/draft-EIP712.sol#L70-L84){target=\_blank}.

A partir daÃ­, um [hash da assinatura e dos argumentos](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L140-L151){target=\_blank} Ã© gerado, garantindo que a assinatura sÃ³ possa ser usada para o call permit. Ele usa um nonce para evitar replay. Ã‰ semelhante ao contrato [`ERC20Permit` do OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/token/ERC20/extensions/draft-ERC20Permit.sol#L52){target=\_blank}, exceto que o `PERMIT_TYPEHASH` Ã© para call permit e os argumentos correspondem aos da funÃ§Ã£o dispatch mais o nonce.

O separador de domÃ­nio e o hash struct podem ser usados para construir o [hash final](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L153-L157){target=\_blank} da mensagem totalmente codificada. Um exemplo prÃ¡tico estÃ¡ no [contrato EIP712 do OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/cryptography/draft-EIP712.sol#L101){target=\_blank}.

Com o hash final e os valores v, r e s, a assinatura pode ser [verificada e recuperada](https://github.com/moonbeam-foundation/moonbeam/blob/ae705bb2e9652204ace66c598a00dcd92445eb81/precompiles/call-permit/src/lib.rs#L211-L223){target=\_blank}. Se verificada com sucesso, o nonce Ã© incrementado em um e a chamada Ã© despachada.

## Preparar os contratos {: #setup-the-example-contract }

Neste exemplo, vocÃª aprenderÃ¡ a assinar um call permit que atualiza uma mensagem em um contrato simples, [`SetMessage.sol`](#example-contract). Antes de gerar a assinatura do call permit, Ã© preciso implantar o contrato e definir os argumentos da funÃ§Ã£o `dispatch` para o permit.

Depois de configurar o contrato de exemplo, vocÃª poderÃ¡ configurar o contrato do Call Permit Precompile.

### Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para acompanhar este tutorial, configure sua carteira para sua rede EVM e tenha uma conta com tokens nativos. VocÃª pode adicionar sua rede EVM Ã  MetaMask com um clique no [Tanssi dApp](https://apps.tanssi.network/){target=\_blank}. Ou [configurar a MetaMask para a Tanssi com a rede EVM de demonstraÃ§Ã£o](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

### Contrato de Exemplo {: #example-contract }

O contrato `SetMessage.sol` Ã© perfeito para demonstrar o uso do Call Permit Precompile.

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.7;

contract SetMessage {
    string storedMessage;

    function set(string calldata x) public {
        storedMessage = x;
    }

    function get() public view returns (string memory) {
        return storedMessage;
    }
}
```

### ConfiguraÃ§Ã£o do Remix {: #remix-set-up }

VocÃª pode usar o [Remix](https://remix.ethereum.org/){target=\_blank} para compilar e implantar o contrato de exemplo. Tenha uma cÃ³pia de [`SetMessage.sol`](#example-contract){target=\_blank} e de [`CallPermit.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/CallPermit.sol){target=\_blank}. Para adicionÃ¡-los ao Remix:

1. Clique na aba **File explorer** 
2. Cole o contrato `CallPermit.sol` em um arquivo do Remix chamado `CallPermit.sol`
3. Cole o contrato `SetMessage.sol` em um arquivo do Remix chamado `SetMessage.sol`

![Copiando e colando o contrato de exemplo no Remix](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-1.webp)

### Compile e implante o contrato de exemplo {: #compile-deploy-example-contract }

Primeiro, compile o contrato de exemplo:

1. Clique na aba **Compile**
2. Para compilar a interface, clique em **Compile SetMessage.sol**

![Compiling SetMessage.sol](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-2.webp)

Em seguida, implante-o:

1. Clique na aba **Deploy and Run**, logo abaixo da aba **Compile** no Remix. ObservaÃ§Ã£o: aqui vocÃª estÃ¡ implantando um contrato
2. Certifique-se de que **Injected Provider - Metamask** estÃ¡ selecionado no menu **ENVIRONMENT**
3. Garanta que **SetMessage.sol** esteja selecionado no menu **CONTRACT**
4. Clique em **Deploy**
5. A MetaMask aparecerÃ¡ e vocÃª deverÃ¡ **Confirmar** a transaÃ§Ã£o

![Provide the address](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-3.webp)

O contrato aparecerÃ¡ na lista de **Deployed Contracts** no painel Ã  esquerda. Copie o endereÃ§o do contrato, pois vocÃª precisarÃ¡ dele para gerar a assinatura do call permit na prÃ³xima seÃ§Ã£o.

### Compile e acesse o Call Permit Precompile {: #compile-access-call-permit }

Primeiro, compile o contrato Call Permit Precompile:

1. Clique na aba **Compile**
2. Para compilar a interface, clique em **Compile CallPermit.sol**

![Compiling SetMessage.sol](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-4.webp)

Depois, em vez de implantar o contrato, basta acessÃ¡-lo informando o endereÃ§o do precompile:

1. Clique na aba **Deploy and Run**, logo abaixo da aba **Compile** no Remix. ObservaÃ§Ã£o: aqui vocÃª nÃ£o implanta um contrato; apenas acessa um contrato prÃ©-compilado jÃ¡ implantado
2. Certifique-se de que **Injected Provider - Metamask** estÃ¡ selecionado no menu **ENVIRONMENT**
3. Garanta que **CallPermit.sol** esteja selecionado no menu **CONTRACT**. Como Ã© um contrato prÃ©-compilado, nÃ£o hÃ¡ etapa de deployment. ForneÃ§a o endereÃ§o do precompile no campo **At Address**
4. ForneÃ§a o endereÃ§o do Call Permit Precompile para redes EVM powered by Tanssi: `{{networks.demo_evm.precompiles.call_permit}}` e clique em **At Address**
5. O Call Permit Precompile aparecerÃ¡ na lista de **Deployed Contracts**

![Provide the address](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-5.webp)

## Gerar a Assinatura do Call Permit {: #generate-call-permit-signature}

Para interagir com o Call Permit Precompile, vocÃª precisa ter ou gerar uma assinatura para despachar o call permit. HÃ¡ vÃ¡rias formas de gerar a assinatura. Este guia mostra como fazÃª-lo usando o [Ethers.js](https://docs.ethers.org/v6/){target=\_blank}.

Veja um resumo dos passos para obter a assinatura:

1. Criar a `message`, incluindo parte dos dados necessÃ¡rios para o call permit: os argumentos da funÃ§Ã£o `dispatch` e o nonce do signatÃ¡rio
2. Montar a estrutura JSON dos dados a serem assinados, incluindo todos os tipos dos argumentos de `dispatch` e o nonce. Isso gera o tipo `CallPermit`, salvo como `primaryType`
3. Criar o domain separator usando exatamente `"Call Permit Precompile"` para o nome, a versÃ£o do seu dApp ou plataforma, o Chain ID da rede em que a assinatura serÃ¡ usada e o endereÃ§o do contrato que verificarÃ¡ a assinatura. VocÃª deve especificar o Chain ID da sua rede no script para gerar a assinatura correta
4. Assinar todos os dados montados usando Ethers.js
5. A assinatura serÃ¡ retornada; use o [`Signature.from`](https://docs.ethers.org/v6/api/crypto/#Signature_from){target=\_blank} do Ethers.js para obter os valores `v`, `r` e `s`

### Argumentos do Call Permit {: #call-permit-arguments }

Como visto na seÃ§Ã£o [Interface do Call Permit](#the-call-permit-interface), a funÃ§Ã£o `dispatch` recebe os parÃ¢metros: `from`, `to`, `value`, `data`, `gasLimit`, `deadline`, `v`, `r` e `s`.

Para obter os argumentos da assinatura (`v`, `r` e `s`), vocÃª deve assinar uma mensagem contendo os argumentos para os demais parÃ¢metros acima, alÃ©m do nonce do signatÃ¡rio.

- `from` - endereÃ§o da conta com a qual vocÃª assinarÃ¡ o call permit
- `to` - endereÃ§o do contrato `SetMessage.sol`
- `value` - pode ser `0` neste exemplo, jÃ¡ que apenas definiremos uma mensagem (sem transferir fundos)
- `data` - vocÃª pode enviar qualquer mensagem; precisa da representaÃ§Ã£o hex da mensagem a definir no contrato `SetMessage.sol`. Ela inclui o function selector da funÃ§Ã£o `set` e a string da mensagem. Para este exemplo, use `hello world` com a seguinte representaÃ§Ã£o hex:
     ```text
     0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000
     ```
- `gasLimit` - `100000` Ã© suficiente para enviar a chamada despachada
- `deadline` - obtenha o horÃ¡rio UNIX atual executando `console.log(Date.now())` em um script JavaScript ou no console do navegador. Depois, adicione segundos extras para definir quando o call permit expira

O nonce do signatÃ¡rio tambÃ©m Ã© necessÃ¡rio. Se for a primeira vez que assina um call permit, o nonce serÃ¡ `0`. VocÃª tambÃ©m pode verificar o nonce no Remix:

1. Expanda o contrato do call permit
2. Ao lado da funÃ§Ã£o **nonces**, insira o endereÃ§o do signatÃ¡rio e clique em **nonces**
3. O resultado aparecerÃ¡ logo abaixo da funÃ§Ã£o

![Get the nonce](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-6.webp)

### Use Ethers para Criar a Assinatura {: #use-ethers-to-create-the-signature }

Para gerar a assinatura do call permit usando JavaScript e Ethers, primeiro crie um projeto local:

```bash
mkdir call-permit-example && cd call-permit-example && touch getSignature.js
npm init -y
```

Agora vocÃª tem um arquivo para o script e um `package.json`. Abra o `package.json` e abaixo de `"dependencies"` adicione:

```json
"type": "module"
```

Em seguida, instale o [Ethers.js](https://docs.ethers.org/v6/){target=\_blank}:

```bash
npm i ethers
```

!!! remember
    Nunca revele suas chaves privadas, pois elas dÃ£o acesso direto aos fundos. Os passos a seguir sÃ£o apenas demonstrativos.

No arquivo `getSignature.js`, copie e edite o trecho a seguir. AlÃ©m dos campos discutidos na seÃ§Ã£o [Argumentos do Call Permit](#call-permit-arguments), vocÃª deve inserir o Chain ID da sua rede no Domain Separator para gerar a assinatura corretamente. Se usar um Chain ID incorreto, a assinatura serÃ¡ invÃ¡lida e nenhuma transaÃ§Ã£o poderÃ¡ ser despachada.

???+ code "getSignature.js"

    ```js
    import { ethers } from 'ethers';

const from = 'INSERT_FROM_ADDRESS';
const to = 'INSERT_TO_ADDRESS';
const value = 0;
const data =
  '0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000';
const gaslimit = 100000;
const nonce = 'INSERT_SIGNERS_NONCE';
const deadline = 'INSERT_DEADLINE';

const createPermitMessageData = () => {
  const message = {
    from: from,
    to: to,
    value: value,
    data: data,
    gaslimit: gaslimit,
    nonce: nonce,
    deadline: deadline,
  };

  const typedData = {
    types: {
      CallPermit: [
        { name: 'from', type: 'address' },
        { name: 'to', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'data', type: 'bytes' },
        { name: 'gaslimit', type: 'uint64' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
      ],
    },
    primaryType: 'CallPermit',
    domain: {
      name: 'Call Permit Precompile',
      version: '1',
      chainId: INSERT-CHAIN-ID,
      verifyingContract: '0x0000000000000000000000000000000000000802',
    },
    message: message,
  };

  return {
    typedData,
    message,
  };
};

const messageData = createPermitMessageData();

// For demo purposes only. Never store your private key in a JavaScript/TypeScript file
const privateKey = 'INSERT_PRIVATE_KEY';
const wallet = new ethers.Wallet(privateKey);

const signature = await wallet.signTypedData(messageData.typedData.domain, messageData.typedData.types, messageData.message);

console.log(`Transaction successful with hash: ${signature}`);

const ethersSignature = ethers.Signature.from(signature);
const formattedSignature = {
  r: ethersSignature.r,
  s: ethersSignature.s,
  v: ethersSignature.v,
};

console.log(formattedSignature);
    ```

Para executar o script:

```bash
node getSignature.js
```

No console, vocÃª verÃ¡ a assinatura concatenada e os valores `v`, `r` e `s`. Copie-os, pois serÃ£o usados ao interagir com o Call Permit Precompile nas prÃ³ximas seÃ§Ãµes.

![Signature values in the console](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-7.webp)

!!! note
    Tome cuidado ao copiar os valores `v`, `r` e `s` para o mÃ©todo `dispatch` do precompile. A ordem no precompile pode nÃ£o coincidir com a ordem de saÃ­da do script.

## Interaja com a Interface Solidity {: #interact-with-the-solidity-interface }

Agora que vocÃª gerou a assinatura do call permit, poderÃ¡ testar a chamada da funÃ§Ã£o `dispatch` do Call Permit Precompile.

### Despachar uma Chamada {: #dispatch-a-call }

Ao enviar a funÃ§Ã£o `dispatch`, use os mesmos argumentos que serviram para assinar o call permit. Para comeÃ§ar, volte Ã  aba **Deploy and Run** no Remix e, em **Deployed Contracts**, expanda o contrato do call permit. Certifique-se de estar conectado Ã  conta que consumirÃ¡ o call permit e pagarÃ¡ as taxas. Em seguida:

1. No campo **from**, informe o endereÃ§o da conta usada para assinar o call permit
2. Copie e cole o endereÃ§o do contrato `SetMessage.sol`
3. Informe `0` no campo **value**
4. Insira a representaÃ§Ã£o hex do function selector da funÃ§Ã£o `set` e a string que deseja definir como mensagem no contrato `SetMessage.sol`. Para este exemplo, use `hello world`:
     ```text
     0x4ed3885e0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000
     ```
5. Informe `100000` no campo **gasLimit**
6. Informe o `deadline` usado ao assinar o call permit
7. Copie o valor `v` obtido ao gerar a assinatura do call permit e cole em **v**
8. Copie o valor `r` obtido ao gerar a assinatura do call permit e cole em **r**
9. Copie o valor `s` obtido ao gerar a assinatura do call permit e cole em **s**
10. Clique em **transact** para enviar a transaÃ§Ã£o
11. A MetaMask aparecerÃ¡ para confirmar; clique em **Confirm**

![Dispatch the call permit](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-8.webp)

Quando a transaÃ§Ã£o for concluÃ­da, vocÃª poderÃ¡ verificar se a mensagem foi atualizada para `hello world`. Para isso:

1. Expanda o contrato `SetMessage.sol`
2. Clique em **get**
3. O resultado aparecerÃ¡ abaixo da funÃ§Ã£o e deve exibir `hello world`

![Verify the dispatch was executed as intended](/images/builders/toolkit/ethereum-api/precompiles/call-permit/call-9.webp)

ParabÃ©ns! VocÃª gerou uma assinatura de call permit e a usou para despachar uma chamada em nome do signatÃ¡rio.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/precompiles/cross-chain-transfers/
--- BEGIN CONTENT ---
---
title: TransferÃªncias Nativas de Tokens Entre Cadeias
description: Aprenda a usar o precompile da interface XCM para transferir tokens de qualquer rede EVM powered by Tanssi, aproveitando as capacidades nativas de interoperabilidade.
categories: EVM-Template
---

# TransferÃªncias Nativas de Tokens Entre Cadeias

## IntroduÃ§Ã£o {: #introduction }

Como apresentado no artigo sobre [ComunicaÃ§Ã£o Nativa Entre Cadeias](/pt/learn/framework/xcm/){target=\_blank} na seÃ§Ã£o Learn, redes powered by Tanssi contam com a capacidade nativa de se comunicar e interoperar com qualquer outra rede do ecossistema. Essa comunicaÃ§Ã£o entre cadeias permite transferÃªncias de tokens seguras e rÃ¡pidas usando o formato Cross-Consensus Message (XCM), que facilita a comunicaÃ§Ã£o entre diferentes sistemas de consenso.

O protocolo de comunicaÃ§Ã£o que possibilita as transferÃªncias Ã© construÃ­do sobre o [Substrate](/pt/learn/framework/overview/#substrate-framework){target=\_blank} e opera em um nÃ­vel mais baixo que o EVM, o que dificulta o acesso direto para desenvolvedores EVM.

Ainda assim, redes EVM contam com um precompile XCM que preenche a lacuna entre as camadas de execuÃ§Ã£o, expondo uma interface de smart contract que abstrai as complexidades subjacentes e torna a execuÃ§Ã£o de transferÃªncias cross-chain tÃ£o simples quanto qualquer chamada de contrato.

Este guia mostra como interagir com o precompile [XCM Interface](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\_blank} para executar transferÃªncias de tokens entre cadeias via Ethereum API.

O precompile XCM estÃ¡ localizado no seguinte endereÃ§o:

```text
{{networks.demo_evm.precompiles.xcm_interface }}
```

!!! note
    O uso de precompiladas pode trazer consequÃªncias inesperadas. As precompiladas do Tanssi sÃ£o derivadas das do Moonbeam; portanto, familiarize-se com as [consideraÃ§Ãµes de seguranÃ§a das precompiladas do Moonbeam](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## A Interface Solidity XCM {: #the-xcm-solidity-interface }

A interface [`XCMInterface.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\_blank} nas redes EVM da Tanssi Ã© uma interface Solidity que permite aos desenvolvedores interagir com as funÃ§Ãµes do precompile.

??? code "XCMInterface.sol"

    ```solidity
    // SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The XCM contract's address.
address constant XCM_CONTRACT_ADDRESS = 0x0000000000000000000000000000000000000804;

/// @dev The XCM contract's instance.
XCM constant XCM_CONTRACT = XCM(XCM_CONTRACT_ADDRESS);

/// @author The Moonbeam Team
/// @title XCM precompile Interface
/// @dev The interface that Solidity contracts use to interact with the substrate pallet-xcm.
interface XCM {
    // A location is defined by its number of parents and the encoded junctions (interior)
    struct Location {
        uint8 parents;
        bytes[] interior;
    }

    // Support for Weights V2
    struct Weight {
        uint64 refTime;
        uint64 proofSize;
    }

    // A way to represent fungible assets in XCM using Location format
    struct AssetLocationInfo {
        Location location;
        uint256 amount;
    }

    // A way to represent fungible assets in XCM using address format
    struct AssetAddressInfo {
        address asset;
        uint256 amount;
    }

    /// @dev Function to send assets via XCM using transfer_assets() pallet-xcm extrinsic.
    /// @custom:selector 59df8416
    /// @param dest The destination chain.
    /// @param beneficiary The actual account that will receive the tokens on dest.
    /// @param assets The combination (array) of assets to send.
    /// @param feeAssetItem The index of the asset that will be used to pay for fees.
    /// @param weight The weight to be used for the whole XCM operation.
    /// (uint64::MAX in refTime means Unlimited weight) 
    function transferAssetsLocation(
        Location memory dest,
        Location memory beneficiary,
        AssetLocationInfo[] memory assets,
        uint32 feeAssetItem,
        Weight memory weight
    ) external;

    /// @dev Function to send assets via XCM to a 20 byte-like parachain 
    /// using transfer_assets() pallet-xcm extrinsic.
    /// @custom:selector b489262e
    /// @param paraId The para-id of the destination chain.
    /// @param beneficiary The actual account that will receive the tokens on paraId destination.
    /// @param assets The combination (array) of assets to send.
    /// @param feeAssetItem The index of the asset that will be used to pay for fees.
    /// @param weight The weight to be used for the whole XCM operation.
    /// (uint64::MAX in refTime means Unlimited weight)
    function transferAssetsToPara20(
        uint32 paraId,
        address beneficiary,
        AssetAddressInfo[] memory assets,
        uint32 feeAssetItem,
        Weight memory weight
    ) external;

    /// @dev Function to send assets via XCM to a 32 byte-like parachain 
    /// using transfer_assets() pallet-xcm extrinsic.
    /// @custom:selector 4461e6f5
    /// @param paraId The para-id of the destination chain.
    /// @param beneficiary The actual account that will receive the tokens on paraId destination.
    /// @param assets The combination (array) of assets to send.
    /// @param feeAssetItem The index of the asset that will be used to pay for fees.
    /// @param weight The weight to be used for the whole XCM operation.
    /// (uint64::MAX in refTime means Unlimited weight)
    function transferAssetsToPara32(
        uint32 paraId,
        bytes32 beneficiary,
        AssetAddressInfo[] memory assets,
        uint32 feeAssetItem,
        Weight memory weight
    ) external;

    /// @dev Function to send assets via XCM to the relay chain 
    /// using transfer_assets() pallet-xcm extrinsic.
    /// @custom:selector d7c89659
    /// @param beneficiary The actual account that will receive the tokens on the relay chain.
    /// @param assets The combination (array) of assets to send.
    /// @param feeAssetItem The index of the asset that will be used to pay for fees.
    /// @param weight The weight to be used for the whole XCM operation.
    /// (uint64::MAX in refTime means Unlimited weight)
    function transferAssetsToRelay(
        bytes32 beneficiary,
        AssetAddressInfo[] memory assets,
        uint32 feeAssetItem,
        Weight memory weight
    ) external;
}
    ```

A interface inclui as estruturas de dados necessÃ¡rias e as funÃ§Ãµes a seguir:

???+ function "**transferAssetsToPara20**(_paraId, beneficiary, assets, feeAssetItem, weight_) â€” envia assets para outra rede compatÃ­vel com EVM usando a transaÃ§Ã£o `transfer_assets()` do pallet XCM"

    === "ParÃ¢metros"

        - `paraId` ++"uint32"++ - ID da rede de destino
        - `beneficiary` ++"address"++ - conta do tipo ECDSA na cadeia de destino que receberÃ¡ os tokens
        - `assets` ++"AssetAddressInfo[] memory"++ - array de assets a enviar
        - `feeAssetItem` ++"uint32"++ - Ã­ndice do asset que pagarÃ¡ as taxas
        - `weight` ++"Weight memory"++ - gÃ¡s mÃ¡ximo de toda a operaÃ§Ã£o. Definir `uint64::MAX` em `refTime` equivale na prÃ¡tica a *weight ilimitado*

    === "Exemplo"

        - `paraId` - 888
        - `beneficiary` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217
        - `assets` - [["0x0000000000000000000000000000000000000800", 1000000000000000000]]
        - `feeAssetItem` - 0
        - `weight` - [9223372036854775807, 9223372036854775807]

??? function "**transferAssetsToPara32**(_paraId, beneficiary, assets,feeAssetItem, weight_) â€” envia assets para uma rede Substrate usando a transaÃ§Ã£o `transfer_assets()` do pallet XCM"

    === "ParÃ¢metros"

        - `paraId` ++"uint32"++ - ID da rede de destino
        - `beneficiary` ++"bytes32"++ - conta do tipo SR25519 na cadeia de destino que receberÃ¡ os tokens
        - `assets` ++"AssetAddressInfo[] memory"++ - array de assets a enviar
        - `feeAssetItem` ++"uint32"++ - Ã­ndice do asset que pagarÃ¡ as taxas
        - `weight` ++"Weight memory"++ - gÃ¡s mÃ¡ximo de toda a operaÃ§Ã£o. Definir `uint64::MAX` em `refTime` equivale na prÃ¡tica a *weight ilimitado*

    === "Exemplo"

        - `paraId` - 888
        - `beneficiary` - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06
        - `assets` - [["0x0000000000000000000000000000000000000800", 1000000000000000000]]
        - `feeAssetItem` - 0
        - `weight` - [9223372036854775807, 9223372036854775807]

??? function "**transferAssetsToRelay**(_beneficiary, assets, feeAssetItem, weight_) â€” envia assets para a relay chain usando a transaÃ§Ã£o `transfer_assets()` do pallet XCM"

    === "ParÃ¢metros"

        - `beneficiary` ++"bytes32"++ - conta do tipo sr25519 na relay chain que receberÃ¡ os tokens
        - `assets` ++"AssetAddressInfo[] memory"++ - array de assets a enviar
        - `feeAssetItem` ++"uint32"++ - Ã­ndice do asset que pagarÃ¡ as taxas
        - `weight` ++"Weight memory"++ - gÃ¡s mÃ¡ximo de toda a operaÃ§Ã£o. Definir `uint64::MAX` em `refTime` equivale na prÃ¡tica a *weight ilimitado*

    === "Exemplo"

        - `beneficiary` - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06
        - `assets` - [["0x0000000000000000000000000000000000000800", 1000000000000000000]]
        - `feeAssetItem` - 0
        - `weight` - [9223372036854775807, 9223372036854775807]

??? function "**transferAssetsLocation**(_dest, beneficiary, assets, feeAssetItem, weight_) â€” envia assets usando a transaÃ§Ã£o `transfer_assets()` do pallet XCM"

    === "ParÃ¢metros"
        - `dest` ++"Location memory"++ - cadeia de destino
        - `beneficiary` ++"Location memory"++ - conta na cadeia de destino que receberÃ¡ os tokens
        - `assets` ++"AssetLocationInfo[] memory"++ - array de assets a enviar
        - `feeAssetItem` ++"uint32"++ - Ã­ndice do asset que pagarÃ¡ as taxas
        - `weight` ++"Weight memory"++ - gÃ¡s mÃ¡ximo de toda a operaÃ§Ã£o. Definir `uint64::MAX` em `refTime` equivale na prÃ¡tica a *weight ilimitado*

    === "Exemplo"
        - `dest` - ["1",[]]
        - `beneficiary` - [0, ["0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600"]]
        - `assets` - [[[1, ["0x010000000000000000000000000000000000000800"]], 1000000000000000000]]
        - `feeAssetItem` - 0
        - `weight` - [9223372036854775807, 9223372036854775807]
    
## Interaja com a Interface Solidity {: #interact-with-the-solidity-interface }

### Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para acompanhar este tutorial, configure sua carteira para sua rede EVM e tenha uma conta com tokens nativos. VocÃª pode adicionar sua rede EVM Ã  MetaMask com um clique no [Tanssi dApp](https://apps.tanssi.network){target=\_blank}. Ou [configurar a MetaMask para a Tanssi com a rede EVM de demonstraÃ§Ã£o](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

!!! note
    Ã‰ necessÃ¡rio ter canais de comunicaÃ§Ã£o estabelecidos com a cadeia de destino antes de usar a funcionalidade deste precompile. Para isso, consulte o guia [Gerenciar Canais de ComunicaÃ§Ã£o Entre Cadeias](/pt/builders/manage/dapp/xcm-channels/){target=\_blank}. AlÃ©m disso, se o token transferido for nativo da sua rede, a cadeia de destino deve ter registrado o asset estrangeiro.

### ConfiguraÃ§Ã£o do Remix {: #remix-set-up }

VocÃª pode interagir com o precompile XCM Interface usando o [Remix](https://remix.ethereum.org){target=\_blank}. Para adicionÃ¡-lo ao Remix, siga:

1. Obtenha uma cÃ³pia de [`XCMInterface.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\_blank}
2. Cole o conteÃºdo em um arquivo do Remix chamado `XcmInterface.sol`

### Compile o Contrato {: #compile-the-contract }

Em seguida, compile a interface no Remix:

1. Clique na aba **Compile** (segunda de cima)
2. Clique em **Compile XCMInterface.sol** para compilar

![Compiling XcmInterface.sol](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-1.webp)

Quando a compilaÃ§Ã£o concluir, um check verde aparecerÃ¡ ao lado da aba **Compile**.

### Acesse o Contrato {: #access-the-contract }

Em vez de implantar o precompile, acesse a interface informando o endereÃ§o do contrato prÃ©-compilado:

1. Clique na aba **Deploy and Run** logo abaixo de **Compile** no Remix. Os contratos prÃ©-compilados jÃ¡ estÃ£o acessÃ­veis em seus endereÃ§os, portanto nÃ£o hÃ¡ etapa de deployment
2. Certifique-se de que **Injected Provider - Metamask** estÃ¡ selecionado em **ENVIRONMENT**. Ao selecionar, a MetaMask pode solicitar conexÃ£o com o Remix
3. Garanta que a conta correta apareÃ§a em **ACCOUNT**
4. Selecione **XCM - XCMInterface.sol** em **CONTRACT**. Como Ã© um contrato prÃ©-compilado, nÃ£o hÃ¡ deployment; apenas informe o endereÃ§o do precompile no campo **At Address**
5. Informe o endereÃ§o do precompile: `{{networks.demo_evm.precompiles.xcm_interface}}` e clique em **At Address**

![Access the address](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-2.webp)

O precompile **XCM Interface** aparecerÃ¡ em **Deployed Contracts**.

### Envie tokens para outra rede compatÃ­vel com EVM {: #transfer-to-evm-chains }

Para enviar tokens a uma conta em outra rede compatÃ­vel com EVM, siga:

1. Expanda a funÃ§Ã£o **transferAssetsToPara20**
2. Informe o ID da rede (`paraId`)
3. Informe a conta de destino (20 bytes, estilo Ethereum)
4. Especifique os tokens a transferir. Este parÃ¢metro Ã© um array com pelo menos um asset; cada asset Ã© definido por seu endereÃ§o e montante

    !!! note
    Os tokens sÃ£o especificados pelo endereÃ§o ERC-20. Se o token que vocÃª deseja transferir for o nativo da rede, a [precompilada ERC-20 do token nativo](/builders/toolkit/ethereum-api/precompiles/erc20/){target=\_blank} ajuda a referenciÃ¡-lo por meio de uma interface ERC-20.

5. Informe o Ã­ndice do asset que pagarÃ¡ as taxas (baseado em zero)
6. Informe o gÃ¡s mÃ¡ximo da transaÃ§Ã£o, derivado de `refTime` e `proofSize`. Na prÃ¡tica, definir `refTime` como `uint64::MAX` equivale a *weight ilimitado*
7. Clique em **transact**
8. A MetaMask aparecerÃ¡ para revisÃ£o; clique em **Confirm** para enviar

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-3.webp)

ApÃ³s a confirmaÃ§Ã£o, aguarde alguns blocos para o saldo aparecer na cadeia de destino.

### Envie Tokens para uma Rede Substrate {: #transfer-to-substrate-chains }

Para enviar tokens a uma conta em uma rede Substrate, siga:

1. Expanda a funÃ§Ã£o **transferAssetsToPara32**
2. Informe o ID da rede (`paraId`)
3. Informe a conta de destino do tipo sr25519
4. Especifique os tokens a transferir. Este parÃ¢metro Ã© um array com pelo menos um asset; cada asset Ã© definido por seu endereÃ§o e montante
    
    !!! note
    Os tokens sÃ£o especificados pelo endereÃ§o ERC-20. Se o token que vocÃª deseja transferir for o nativo da rede, a [precompilada ERC-20 do token nativo](/builders/toolkit/ethereum-api/precompiles/erc20/){target=\_blank} ajuda a referenciÃ¡-lo por meio de uma interface ERC-20.

5. Informe o Ã­ndice do asset que pagarÃ¡ as taxas (baseado em zero)
6. Informe o gÃ¡s mÃ¡ximo da transaÃ§Ã£o, derivado de `refTime` e `proofSize`. Na prÃ¡tica, definir `refTime` como `uint64::MAX` equivale a *weight ilimitado*
7. Clique em **transact**
8. A MetaMask aparecerÃ¡ para revisÃ£o; clique em **Confirm** para enviar

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-4.webp)

ApÃ³s a confirmaÃ§Ã£o, aguarde alguns blocos para o saldo aparecer na cadeia de destino.

### Envie Tokens para a Relay Chain {: #transfer-to-relay-chain }

Para enviar tokens a uma conta na relay chain, siga:

1. Expanda a funÃ§Ã£o **transferAssetsToRelay**
2. Informe a conta de destino do tipo sr25519
3. Especifique os tokens a transferir. Este parÃ¢metro Ã© um array com pelo menos um asset; cada asset Ã© definido por seu endereÃ§o e montante
    
    !!! note
    Os tokens sÃ£o especificados pelo endereÃ§o ERC-20. Se o token que vocÃª deseja transferir for o nativo da rede, a [precompilada ERC-20 do token nativo](/builders/toolkit/ethereum-api/precompiles/erc20/){target=\_blank} ajuda a referenciÃ¡-lo por meio de uma interface ERC-20.

4. Informe o Ã­ndice do asset que pagarÃ¡ as taxas (baseado em zero)
5. Informe o gÃ¡s mÃ¡ximo da transaÃ§Ã£o, derivado de `refTime` e `proofSize`. Na prÃ¡tica, definir `refTime` como `uint64::MAX` equivale a *weight ilimitado*
6. Clique em **transact**
7. A MetaMask aparecerÃ¡ para revisÃ£o; clique em **Confirm** para enviar

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-5.webp)

ApÃ³s a confirmaÃ§Ã£o, aguarde alguns blocos para o saldo aparecer na cadeia de destino.

### Envie Tokens para Locais EspecÃ­ficos {: #transfer-locations }

Esta funÃ§Ã£o Ã© mais genÃ©rica e permite especificar cadeia de destino, conta e assets usando [XCM Multilocations](/pt/learn/framework/xcm/#message-destinations){target=\_blank}. Para enviar tokens para locais especÃ­ficos:

1. Expanda a funÃ§Ã£o **transferAssetsLocation**
2. Informe a multilocation que especifica a cadeia de destino. Qualquer cadeia pode ser informada, independentemente de tipo ou configuraÃ§Ã£o
3. Informe a multilocation que especifica a conta de destino. Qualquer conta pode ser informada, independentemente do tipo (ECDSA, sr25519 ou outro)
4. Especifique os tokens a transferir. Este parÃ¢metro Ã© um array com pelo menos um asset; cada asset Ã© definido por sua multilocation e montante
    
    !!! note
    Os tokens sÃ£o especificados pelo endereÃ§o ERC-20. Se o token que vocÃª deseja transferir for o nativo da rede, a [precompilada ERC-20 do token nativo](/builders/toolkit/ethereum-api/precompiles/erc20/){target=\_blank} ajuda a referenciÃ¡-lo por meio de uma interface ERC-20.

5. Informe o Ã­ndice do asset que pagarÃ¡ as taxas (baseado em zero)
6. Informe o gÃ¡s mÃ¡ximo da transaÃ§Ã£o, derivado de `refTime` e `proofSize`. Na prÃ¡tica, definir `refTime` como `uint64::MAX` equivale a *weight ilimitado*
7. Clique em **transact**
8. A MetaMask aparecerÃ¡ para revisÃ£o; clique em **Confirm** para enviar

![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-6.webp)

ApÃ³s a confirmaÃ§Ã£o, aguarde alguns blocos para o saldo aparecer na cadeia de destino.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/precompiles/erc20/
--- BEGIN CONTENT ---
---
title:  PrÃ©-compilado ERC-20 do Token Nativo
description: Saiba como acessar e interagir com a representaÃ§Ã£o ERC-20 do token nativo em redes EVM powered by Tanssi por meio da Interface ERC-20 prÃ©-compilada.
keywords: solidity, ethereum, token nativo, erc20, tanssi, precompiled, contracts
icon: material-circle-outline
categories: EVM-Template
---

#  PrÃ©-compilado ERC-20 do Token Nativo

## IntroduÃ§Ã£o {: #introduction }

O contrato prÃ©-compilado ERC-20 do token nativo em redes EVM powered by Tanssi permite que desenvolvedores interajam com o token nativo do protocolo por meio de uma interface ERC-20. Embora o token nativo da sua rede nÃ£o seja um ERC-20, agora vocÃª pode interagir com ele como se fosse um ERC-20 padrÃ£o.

Um dos principais benefÃ­cios desse precompile Ã© eliminar a necessidade de ter uma representaÃ§Ã£o embrulhada do token do protocolo como um smart contract ERC-20, como o WETH no Ethereum. AlÃ©m disso, minimiza a necessidade de mÃºltiplas representaÃ§Ãµes embrulhadas do mesmo token do protocolo. Consequentemente, dApps que precisam interagir com o token do protocolo via uma interface ERC-20 podem fazÃª-lo sem precisar de um contrato separado.

Por baixo dos panos, a [precompilada ERC-20](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank} executa aÃ§Ãµes especÃ­ficas do Substrate relacionadas ao mÃ³dulo de saldos, escrito em Rust. O mÃ³dulo de saldos fornece funcionalidades para lidar com diversos tipos de saldos.

Este guia mostrarÃ¡ como interagir com tokens UNIT, o token nativo do protocolo para redes de teste rÃ¡pido no [Dancelight](/pt/builders/tanssi-network/testnet/dancelight/){target=\_blank}, por meio da precompilada ERC-20. VocÃª pode seguir e adaptar este guia para interagir com sua prÃ³pria rede.

A precompilada estÃ¡ localizada no seguinte endereÃ§o:

```text
{{networks.demo_evm.precompiles.erc20 }}
```

!!! note
    O uso de precompiladas pode trazer consequÃªncias inesperadas. As precompiladas do Tanssi sÃ£o derivadas das do Moonbeam; portanto, familiarize-se com as [consideraÃ§Ãµes de seguranÃ§a das precompiladas do Moonbeam](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## Interface Solidity do ERC-20 {: #the-erc20-interface }

A interface [`ERC20.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank} nas redes EVM da Tanssi segue o [PadrÃ£o de Token EIP-20](https://eips.ethereum.org/EIPS/eip-20){target=\_blank}, que Ã© a interface padrÃ£o de API para tokens em smart contracts. O padrÃ£o define as funÃ§Ãµes e eventos exigidos para que um contrato de token seja interoperÃ¡vel com diferentes aplicaÃ§Ãµes.

??? code "ERC20.sol"

    ```solidity
    / SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The IERC20 contract's address.
address constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;

/// @dev The IERC20 contract's instance.
IERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);

/// @title ERC20 interface
/// @dev see https://github.com/ethereum/EIPs/issues/20
/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts
/// @custom:address 0x0000000000000000000000000000000000000800
interface IERC20 {
    /// @dev Returns the name of the token.
    /// @custom:selector 06fdde03
    function name() external view returns (string memory);

    /// @dev Returns the symbol of the token.
    /// @custom:selector 95d89b41
    function symbol() external view returns (string memory);

    /// @dev Returns the decimals places of the token.
    /// @custom:selector 313ce567
    function decimals() external view returns (uint8);

    /// @dev Total number of tokens in existence
    /// @custom:selector 18160ddd
    function totalSupply() external view returns (uint256);

    /// @dev Gets the balance of the specified address.
    /// @custom:selector 70a08231
    /// @param owner The address to query the balance of.
    /// @return An uint256 representing the amount owned by the passed address.
    function balanceOf(address owner) external view returns (uint256);

    /// @dev Function to check the amount of tokens that an owner allowed to a spender.
    /// @custom:selector dd62ed3e
    /// @param owner address The address which owns the funds.
    /// @param spender address The address which will spend the funds.
    /// @return A uint256 specifying the amount of tokens still available for the spender.
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /// @dev Transfer token for a specified address
    /// @custom:selector a9059cbb
    /// @param to The address to transfer to.
    /// @param value The amount to be transferred.
    /// @return true if the transfer was succesful, revert otherwise.
    function transfer(address to, uint256 value) external returns (bool);

    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    /// Beware that changing an allowance with this method brings the risk that someone may use both the old
    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    /// @custom:selector 095ea7b3
    /// @param spender The address which will spend the funds.
    /// @param value The amount of tokens to be spent.
    /// @return true, this cannot fail
    function approve(address spender, uint256 value) external returns (bool);

    /// @dev Transfer tokens from one address to another
    /// @custom:selector 23b872dd
    /// @param from address The address which you want to send tokens from
    /// @param to address The address which you want to transfer to
    /// @param value uint256 the amount of tokens to be transferred
    /// @return true if the transfer was succesful, revert otherwise.
    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    /// @dev Event emited when a transfer has been performed.
    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
    /// @param from address The address sending the tokens
    /// @param to address The address receiving the tokens.
    /// @param value uint256 The amount of tokens transfered.
    event Transfer(address indexed from, address indexed to, uint256 value);

    /// @dev Event emited when an approval has been registered.
    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
    /// @param owner address Owner of the tokens.
    /// @param spender address Allowed spender.
    /// @param value uint256 Amount of tokens approved.
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

/// @title Native currency wrapper interface.
/// @dev Allow compatibility with dApps expecting this precompile to be
/// a WETH-like contract.
interface WrappedNativeCurrency {
    /// @dev Provide compatibility for contracts that expect wETH design.
    /// Returns funds to sender as this precompile tokens and the native tokens are the same.
    /// @custom:selector d0e30db0
    function deposit() external payable;

    /// @dev Provide compatibility for contracts that expect wETH design.
    /// Does nothing.
    /// @custom:selector 2e1a7d4d
    /// @param value uint256 The amount to withdraw/unwrap.
    function withdraw(uint256 value) external;

    /// @dev Event emited when deposit() has been called.
    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c
    /// @param owner address Owner of the tokens
    /// @param value uint256 The amount of tokens "wrapped".
    event Deposit(address indexed owner, uint256 value);

    /// @dev Event emited when withdraw(uint256) has been called.
    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65
    /// @param owner address Owner of the tokens
    /// @param value uint256 The amount of tokens "unwrapped".
    event Withdrawal(address indexed owner, uint256 value);
}
    ```

!!! note
    A precompilada ERC-20 nÃ£o inclui as funÃ§Ãµes `deposit` e `withdraw` nem os eventos associados esperados de um token embrulhado, como o WETH.

## Interagir com a Interface Solidity {: #interact-with-the-solidity-interface }

### Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para acompanhar este tutorial, vocÃª precisarÃ¡ ter sua carteira configurada para funcionar com sua rede EVM com Tanssi e uma conta com tokens nativos. VocÃª pode adicionar sua rede EVM ao MetaMask com um clique no [Tanssi dApp](https://apps.tanssi.network){target=\_blank}. Ou, se preferir, [configure o MetaMask para Tanssi com a rede EVM de demonstraÃ§Ã£o](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

### Adicionar token a uma carteira EVM {: #add-token-to-evm-wallet }

Se quiser interagir com o token nativo da rede como faria com um ERC-20, adicione um token personalizado Ã  sua carteira compatÃ­vel com EVM usando o endereÃ§o da precompilada. Esta seÃ§Ã£o mostra como adicionar um ativo externo ao [MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

Para comeÃ§ar, abra o MetaMask, conecte-se Ã  sua rede e:

1. Acesse a aba **Assets**
2. Clique em **Import tokens**

![Importar tokens na aba Assets do MetaMask](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-1.webp)

Agora, crie o token personalizado:

1. Informe o endereÃ§o da precompilada para o endereÃ§o do contrato do token: `{{networks.demo_evm.precompiles.erc20 }}`. Ao inserir o endereÃ§o, os campos **Token Symbol** e **Token Decimal** devem preencher automaticamente. Caso nÃ£o aconteÃ§a, use `UNIT` como sÃ­mbolo e `18` como casas decimais. Lembre que o padrÃ£o de casas decimais das redes EVM da Tanssi Ã© `18`, o mesmo do Ethereum
2. Clique em **Next**

![Adicionar token customizado](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-2.webp)

O MetaMask solicitarÃ¡ a confirmaÃ§Ã£o da importaÃ§Ã£o. Revise os detalhes e clique em **Import Tokens** para importar os tokens UNIT na carteira.

![Confirmar e importar tokens](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-3.webp)

Pronto! VocÃª adicionou o token UNIT como um ERC-20 personalizado na sua rede EVM da Tanssi.

### ConfiguraÃ§Ã£o do Remix {: #remix-set-up }

VocÃª pode interagir com a precompilada ERC-20 usando o [Remix](https://remix.ethereum.org){target=\_blank}. Para adicionÃ¡-la ao Remix, vocÃª precisarÃ¡:

1. Obter uma cÃ³pia de [`ERC20.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank}
2. Colar o conteÃºdo em um arquivo do Remix chamado `IERC20.sol`

### Compilar o Contrato {: #compile-the-contract }

Em seguida, compile a interface no Remix:

1. Clique na aba **Compile** (segunda de cima)
2. Compile a interface clicando em **Compile IERC20.sol**

![Compilando IERC20.sol](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-4.webp)

Quando a compilaÃ§Ã£o for concluÃ­da, um check verde aparecerÃ¡ ao lado da aba **Compile**.

### Acessar o Contrato {: #access-the-contract }

Em vez de implantar a precompilada ERC-20, vocÃª acessarÃ¡ a interface informando o endereÃ§o do contrato prÃ©-compilado:

1. Clique na aba **Deploy and Run** logo abaixo da aba **Compile** no Remix. Observe que contratos prÃ©-compilados jÃ¡ estÃ£o acessÃ­veis em seus respectivos endereÃ§os, portanto nÃ£o hÃ¡ etapa de implantaÃ§Ã£o
2. Certifique-se de que **Injected Web3** estÃ¡ selecionado em **ENVIRONMENT**. Ao selecionar **Injected Web3**, o MetaMask pode solicitar conexÃ£o ao Remix caso ainda nÃ£o esteja
3. Verifique se a conta correta aparece em **ACCOUNT**
4. Garanta que **IERC20 - IERC20.sol** esteja selecionado em **CONTRACT**. Por ser um contrato prÃ©-compilado, nÃ£o hÃ¡ implantaÃ§Ã£o; em vez disso, informe o endereÃ§o da precompilada no campo **At Address**
5. Informe o endereÃ§o da precompilada ERC-20: `{{networks.demo_evm.precompiles.erc20}}` e clique em **At Address**

![Acessar o endereÃ§o](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-5.webp)

A precompilada **IERC20** aparecerÃ¡ na lista de **Deployed Contracts**.

### Obter InformaÃ§Ãµes BÃ¡sicas do Token {: #get-basic-token-information }

A interface ERC-20 permite obter rapidamente informaÃ§Ãµes como oferta total, nome, sÃ­mbolo e casas decimais. Para recuperar essas informaÃ§Ãµes:

1. Expanda o contrato **IERC20** em **Deployed Contracts**
2. Clique em **decimals** para obter as casas decimais do token nativo
3. Clique em **name** para obter o nome do token
4. Clique em **symbol** para obter o sÃ­mbolo do token
5. Clique em **totalSupply** para obter a oferta total de tokens nativos na rede

![Oferta total (Total Supply)](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-6.webp)

Os resultados de cada chamada sÃ£o exibidos abaixo das respectivas funÃ§Ãµes.

### Consultar Saldo de uma Conta {: #get-account-balance }

VocÃª pode verificar o saldo de qualquer endereÃ§o na rede chamando `balanceOf` e fornecendo um endereÃ§o:

1. Expanda a funÃ§Ã£o **balanceOf**
2. Informe o endereÃ§o que deseja consultar no campo **owner**
3. Clique em **call**

![Obter saldo de uma conta](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-7.webp)

O saldo serÃ¡ exibido abaixo da funÃ§Ã£o `balanceOf`.

### Aprovar um Gasto {: #approve-a-spend }

Para aprovar uma permissÃ£o de gasto, forneÃ§a um endereÃ§o para o spender e o nÃºmero de tokens que ele pode gastar. O spender pode ser uma conta externa (EOA) ou um smart contract. Neste exemplo, vocÃª aprovarÃ¡ uma allowance de 1 token UNIT. Siga:

1. Expanda a funÃ§Ã£o **approve**
2. Informe o endereÃ§o do spender. VocÃª deve ter criado duas contas antes de comeÃ§ar; use a segunda conta como spender
3. Informe o valor de tokens que o spender pode gastar em **value**. Para este exemplo, permita 1 token UNIT em Wei (`1000000000000000000`)
4. Clique em **transact**
5. A MetaMask aparecerÃ¡; revise os detalhes e clique em **Confirm** para enviar

![Confirmar transaÃ§Ã£o de approve](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-8.webp)

ApÃ³s a confirmaÃ§Ã£o, o saldo da sua conta permanece o mesmo: vocÃª apenas aprovou a permissÃ£o e o spender ainda nÃ£o gastou os fundos. Na prÃ³xima seÃ§Ã£o, vocÃª usarÃ¡ `allowance` para verificar que o spender pode gastar 1 token UNIT em seu nome.

### Obter Allowance do Spender {: #get-allowance-of-spender }

Para conferir se o spender recebeu a allowance aprovada em [Aprovar um Gasto](#approve-a-spend):

1. Expanda a funÃ§Ã£o **allowance**
2. Informe seu endereÃ§o em **owner**
3. Informe o endereÃ§o do **spender** usado na seÃ§Ã£o anterior
4. Clique em **call**

![Obter allowance do spender](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-9.webp)

Quando a chamada finalizar, a allowance do spender serÃ¡ exibida e deve ser equivalente a 1 token UNIT (`1000000000000000000`).

### Enviar TransferÃªncia {: #send-transfer }

Para enviar tokens diretamente da sua conta para outra, chame `transfer`:

1. Expanda a funÃ§Ã£o **transfer**
2. Informe o endereÃ§o para o qual deseja enviar tokens UNIT
3. Informe a quantidade de tokens UNIT a enviar. Neste exemplo, envie 1 UNIT (`1000000000000000000`)
4. Clique em **transact**
5. A MetaMask aparecerÃ¡; revise os detalhes e clique em **Confirm** para enviar

![Enviar transferÃªncia padrÃ£o](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-10.webp)

ApÃ³s a transaÃ§Ã£o, vocÃª pode [checar seu saldo](#get-account-balance) usando `balanceOf` ou pelo MetaMask. VerÃ¡ que seu saldo diminuiu em 1 UNIT. Use `balanceOf` tambÃ©m para confirmar que o saldo do destinatÃ¡rio aumentou em 1 UNIT conforme esperado.

### Enviar TransferÃªncia de uma Conta EspecÃ­fica {: #send-transferfrom }

AtÃ© agora, vocÃª aprovou uma allowance de 1 UNIT para o spender e enviou 1 UNIT via `transfer`. A funÃ§Ã£o `transferFrom` difere da `transfer` padrÃ£o porque permite definir de qual endereÃ§o os tokens serÃ£o enviados. VocÃª pode informar um endereÃ§o com allowance ou seu prÃ³prio endereÃ§o (se houver saldo). Neste exemplo, use a conta do spender para iniciar a transferÃªncia dos fundos permitidos do owner para o prÃ³prio spender. O spender poderia enviar para qualquer conta, mas aqui enviaremos do owner para o spender.

Primeiro, mude para a conta do spender no MetaMask. Ao trocar, o endereÃ§o selecionado no Remix em **Accounts** passarÃ¡ a ser o do spender.

![Trocar contas no Remix](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-11.webp)

Agora, inicie e envie a transferÃªncia:

1. Expanda a funÃ§Ã£o **transferFrom**
2. Informe seu endereÃ§o (do owner) no campo **from**
3. Informe o endereÃ§o do destinatÃ¡rio, que deve ser o endereÃ§o do spender, no campo **to**
4. Informe a quantidade de tokens UNIT a enviar. O spender sÃ³ pode enviar 1 UNIT, entÃ£o insira `1000000000000000000`
5. Clique em **transact**

![Enviar transferÃªncia padrÃ£o](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-12.webp)

ApÃ³s a transaÃ§Ã£o, [verifique o saldo](#get-account-balance) do owner e do spender usando `balanceOf`. O saldo do spender deve ter aumentado em 1 UNIT, e a allowance deve ter sido consumida. Para confirmar que o spender nÃ£o tem mais allowance, chame `allowance` informando os endereÃ§os de owner e spender; o resultado deve ser 0.

![Zerar allowance](/images/builders/toolkit/ethereum-api/precompiles/erc20/erc-13.webp)

E Ã© isso! VocÃª interagiu com a precompilada ERC-20 usando MetaMask e Remix!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/
--- BEGIN CONTENT ---
---
title: Ativos Externos como ERC-20
description: Aprenda como acessar e interagir com uma representaÃ§Ã£o ERC-20 de quaisquer ativos externos em redes Tanssi EVM por meio da Interface ERC-20 prÃ©-compilada.
keywords: solidity, ethereum, native, token, moonbeam, precompiled, contracts, assets, erc20
categories: EVM-Template
---

# Ativos Externos como ERC-20

## IntroduÃ§Ã£o {: #introduction }

Como apresentado no artigo [ComunicaÃ§Ã£o Cross-Chain Nativa](/learn/framework/xcm/){target=\_blank}, as redes implantadas atravÃ©s da Tanssi podem se comunicar e interagir com qualquer outra rede no ecossistema. Este ambiente multi-chain leva a um mundo multi-ativo, onde a transferÃªncia perfeita de ativos, dados e valor entre diferentes redes amplia as possibilidades de construir casos de uso em diversos setores, como finanÃ§as (DeFi), ativos do mundo real (RWAs) e outros.

Ativos externos sÃ£o tokens nativos de outra blockchain, ou, em outras palavras, ativos cuja cadeia de reserva nÃ£o Ã© a cadeia com a qual vocÃª estÃ¡ interagindo. As redes Tanssi podem registrar ativos externos para permitir sua entrada. Para fazer isso, Ã© necessÃ¡rio [estabelecer um canal XCM](/learn/framework/xcm/#channel-registration){target=\_blank} com a outra cadeia e, em seguida, registrar um de seus ativos nativos como um ativo externo. Os ativos externos registrados se comportam, em certa medida, da mesma forma que os locais.

A [prÃ©-compilaÃ§Ã£o de ativos ERC-20](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20Instance.sol){target=\_blank} permite que as redes baseadas no [Template Tanssi EVM](/builders/build/templates/evm/){target=\_blank} acessem qualquer ativo externo registrado atravÃ©s da interface ERC-20 padrÃ£o. Consequentemente, contratos inteligentes implantados na rede podem interagir com esses ativos da mesma forma que fariam com qualquer outro ERC-20 regular.

O endereÃ§o que representa o contrato ERC-20 Ã© formado com as primeiras trinta e seis posiÃ§Ãµes (dezoito bytes) definidas para o valor mÃ¡ximo e as Ãºltimas quatro posiÃ§Ãµes (dois bytes) substituÃ­das pela representaÃ§Ã£o hexadecimal do identificador de ativo registrado:

```text
```

Por exemplo, para o ativo cujo ID Ã© `1`, as Ãºltimas quatro posiÃ§Ãµes devem ser substituÃ­das por `0001`, e para um ativo com um ID de `10`, essas quatro posiÃ§Ãµes devem ser substituÃ­das por `000A`.

!!! note
    O uso de precompiladas pode trazer consequÃªncias inesperadas. As precompiladas do Tanssi sÃ£o derivadas das do Moonbeam; portanto, familiarize-se com as [consideraÃ§Ãµes de seguranÃ§a das precompiladas do Moonbeam](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## PrÃ©-requisitos {: #prerequisites }

Para acompanhar o conteÃºdo deste guia, vocÃª precisarÃ¡:

- Acesso a uma rede Tanssi EVM executando [runtime 500](https://github.com/moondance-labs/tanssi/releases/tag/runtime-500){target=\_blank} ou superior
- Um canal XCM bidirecional estabelecido para outra cadeia. Para gerenciar os canais da sua rede, consulte o artigo [Gerenciar Canais de ComunicaÃ§Ã£o Cross-Chain](/builders/manage/dapp/xcm-channels/){target=\_blank}
- Um ativo externo registrado. Uma vez que os canais XCM estejam abertos, o registro de ativos pode ser facilmente feito usando o [dApp](https://apps.tanssi.network/){target=\_blank}, conforme explicado no guia [Registrar Ativos Externos](/builders/manage/dapp/register-external-assets/){target=\_blank}
- Finalmente, vocÃª precisarÃ¡ de uma [carteira compatÃ­vel com EVM](/builders/toolkit/ethereum-api/wallets/){target=\_blank} configurada para funcionar com sua rede. VocÃª tambÃ©m pode conectar sua carteira Ã  [rede demo EVM](https://apps.tanssi.network/demo){target=\_blank}.

Os exemplos neste guia sÃ£o baseados na rede demo Tanssi EVM, que jÃ¡ possui canais abertos para outras redes e ativos externos registrados, como mostra a imagem a seguir:

1. O ativo externo registrado (UNIT) que serÃ¡ usado nas seÃ§Ãµes a seguir
2. Outros ativos externos disponÃ­veis ainda nÃ£o registrados

![Ativos externos registrados na rede demo EVM da Tanssi](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-1.webp)

## A Interface Solidity ERC-20 {: #the-erc20-interface }

A interface [`ERC20.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank} nas redes Tanssi EVM segue o [EIP-20 Token Standard](https://eips.ethereum.org/EIPS/eip-20){target=\_blank}, que Ã© a interface API padrÃ£o para tokens dentro de contratos inteligentes. O padrÃ£o define as funÃ§Ãµes e eventos necessÃ¡rios que um contrato de token deve implementar para ser interoperÃ¡vel com diferentes aplicaÃ§Ãµes.

??? code "ERC20.sol"


    ```solidity

    / SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @dev The IERC20 contract's address.
address constant IERC20_ADDRESS = 0x0000000000000000000000000000000000000800;

/// @dev The IERC20 contract's instance.
IERC20 constant IERC20_CONTRACT = IERC20(IERC20_ADDRESS);

/// @title ERC20 interface
/// @dev see https://github.com/ethereum/EIPs/issues/20
/// @dev copied from https://github.com/OpenZeppelin/openzeppelin-contracts
/// @custom:address 0x0000000000000000000000000000000000000800
interface IERC20 {
    /// @dev Returns the name of the token.
    /// @custom:selector 06fdde03
    function name() external view returns (string memory);

    /// @dev Returns the symbol of the token.
    /// @custom:selector 95d89b41
    function symbol() external view returns (string memory);

    /// @dev Returns the decimals places of the token.
    /// @custom:selector 313ce567
    function decimals() external view returns (uint8);

    /// @dev Total number of tokens in existence
    /// @custom:selector 18160ddd
    function totalSupply() external view returns (uint256);

    /// @dev Gets the balance of the specified address.
    /// @custom:selector 70a08231
    /// @param owner The address to query the balance of.
    /// @return An uint256 representing the amount owned by the passed address.
    function balanceOf(address owner) external view returns (uint256);

    /// @dev Function to check the amount of tokens that an owner allowed to a spender.
    /// @custom:selector dd62ed3e
    /// @param owner address The address which owns the funds.
    /// @param spender address The address which will spend the funds.
    /// @return A uint256 specifying the amount of tokens still available for the spender.
    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    /// @dev Transfer token for a specified address
    /// @custom:selector a9059cbb
    /// @param to The address to transfer to.
    /// @param value The amount to be transferred.
    /// @return true if the transfer was succesful, revert otherwise.
    function transfer(address to, uint256 value) external returns (bool);

    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
    /// Beware that changing an allowance with this method brings the risk that someone may use both the old
    /// and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
    /// race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
    /// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    /// @custom:selector 095ea7b3
    /// @param spender The address which will spend the funds.
    /// @param value The amount of tokens to be spent.
    /// @return true, this cannot fail
    function approve(address spender, uint256 value) external returns (bool);

    /// @dev Transfer tokens from one address to another
    /// @custom:selector 23b872dd
    /// @param from address The address which you want to send tokens from
    /// @param to address The address which you want to transfer to
    /// @param value uint256 the amount of tokens to be transferred
    /// @return true if the transfer was succesful, revert otherwise.
    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    /// @dev Event emited when a transfer has been performed.
    /// @custom:selector ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
    /// @param from address The address sending the tokens
    /// @param to address The address receiving the tokens.
    /// @param value uint256 The amount of tokens transfered.
    event Transfer(address indexed from, address indexed to, uint256 value);

    /// @dev Event emited when an approval has been registered.
    /// @custom:selector 8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
    /// @param owner address Owner of the tokens.
    /// @param spender address Allowed spender.
    /// @param value uint256 Amount of tokens approved.
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}

/// @title Native currency wrapper interface.
/// @dev Allow compatibility with dApps expecting this precompile to be
/// a WETH-like contract.
interface WrappedNativeCurrency {
    /// @dev Provide compatibility for contracts that expect wETH design.
    /// Returns funds to sender as this precompile tokens and the native tokens are the same.
    /// @custom:selector d0e30db0
    function deposit() external payable;

    /// @dev Provide compatibility for contracts that expect wETH design.
    /// Does nothing.
    /// @custom:selector 2e1a7d4d
    /// @param value uint256 The amount to withdraw/unwrap.
    function withdraw(uint256 value) external;

    /// @dev Event emited when deposit() has been called.
    /// @custom:selector e1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c
    /// @param owner address Owner of the tokens
    /// @param value uint256 The amount of tokens "wrapped".
    event Deposit(address indexed owner, uint256 value);

    /// @dev Event emited when withdraw(uint256) has been called.
    /// @custom:selector 7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65
    /// @param owner address Owner of the tokens
    /// @param value uint256 The amount of tokens "unwrapped".
    event Withdrawal(address indexed owner, uint256 value);
}

    ```


!!! note
    A prÃ©-compilaÃ§Ã£o de ativos externos ERC-20 nÃ£o inclui funÃ§Ãµes `deposit` e `withdraw` e eventos subsequentes esperados de um contrato de token embrulhado, como WETH.

## Adicionar Token Ã  uma Carteira EVM {: #add-token-to-evm-wallet }

Se vocÃª quiser interagir com os ativos externos registrados da sua rede como faria com um ERC-20, pode adicionÃ¡-los Ã  sua carteira usando o prefixo de endereÃ§o de prÃ©-compilaÃ§Ã£o e o ID do ativo. Esta seÃ§Ã£o irÃ¡ guiÃ¡-lo atravÃ©s da adiÃ§Ã£o de um ativo externo ao [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}.

Para comeÃ§ar, abra o MetaMask e certifique-se de que vocÃª estÃ¡ conectado Ã  sua rede e:

1. VÃ¡ para a aba **Tokens**

2. Clique em **Importar tokens**

   ![Importar tokens na aba Tokens do MetaMask](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-2.webp)

```text
{{networks.demo_evm.precompiles.external_assets_erc20_example}}
```

1. Insira o endereÃ§o de prÃ©-compilaÃ§Ã£o para o endereÃ§o do contrato do token. Ao inserir o endereÃ§o, os campos **SÃ­mbolo do token** e **Decimais do token** devem ser preenchidos automaticamente. Se nÃ£o preencherem, vocÃª pode inserir `UNIT` para o sÃ­mbolo e `12` para as casas decimais
2. Clique em **PrÃ³ximo**

![Adicionar ativo externo](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-3.webp)

MetaMask solicitarÃ¡ que vocÃª confirme a importaÃ§Ã£o. VocÃª pode verificar os detalhes do token e clicar em **Importar tokens** para importar tokens UNIT para sua carteira.

![Confirmar e Importar Tokens](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-4.webp)

E Ã© isso! VocÃª adicionou com sucesso o ativo externo do token UNIT como um token ERC-20 personalizado na rede demo Tanssi EVM.

## Interagir com a Interface Solidity via Remix {: #interact-with-the-solidity-interface-via-remix }

### ConfiguraÃ§Ã£o do Remix {: #remix-set-up }

VocÃª pode interagir com a prÃ©-compilaÃ§Ã£o de ativos externos ERC-20 usando [Remix](https://remix.ethereum.org){target=\_blank}. Para adicionar a prÃ©-compilaÃ§Ã£o ao Remix, vocÃª precisarÃ¡:

1. Obter uma cÃ³pia de [`ERC20.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/ERC20.sol){target=\_blank}
2. Cole o conteÃºdo do arquivo em um arquivo Remix chamado `IERC20.sol`

### Compilar o Contrato {: #compile-the-contract }

Em seguida, vocÃª precisarÃ¡ compilar a interface no Remix:

1. Clique na aba **Compilar**, a segunda de cima
2. Compile a interface clicando em **Compilar IERC20.sol**

![Compilando IERC20.sol](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-5.webp)

Quando a compilaÃ§Ã£o for concluÃ­da, vocÃª verÃ¡ uma marca de seleÃ§Ã£o verde ao lado da aba **Compilar**.

### Acessar o Contrato {: #access-the-contract }

Em vez de implantar o contrato inteligente, vocÃª acessarÃ¡ a interface atravÃ©s do endereÃ§o da prÃ©-compilaÃ§Ã£o de ativos externos:

1. Clique na aba **Deploy and Run** diretamente abaixo da aba **Compilar** no Remix. Observe que os contratos prÃ©-compilados jÃ¡ estÃ£o acessÃ­veis em seus respectivos endereÃ§os. Portanto, nÃ£o hÃ¡ nenhuma etapa de implantaÃ§Ã£o
2. Certifique-se de que **Injected Web3** esteja selecionado no menu suspenso **ENVIRONMENT**. Depois de selecionar **Injected Web3**, vocÃª pode ser solicitado pelo MetaMask para conectar sua conta ao Remix, caso ela ainda nÃ£o esteja conectada
3. Certifique-se de que a conta correta seja exibida em **ACCOUNT**
4. Certifique-se de que **IERC20 - IERC20.sol** esteja selecionado no menu suspenso **CONTRACT**. Dado que Ã© um contrato prÃ©-compilado, nÃ£o hÃ¡ nenhuma etapa de implantaÃ§Ã£o. Em vez disso, vocÃª fornecerÃ¡ o endereÃ§o da prÃ©-compilaÃ§Ã£o no campo **At Address**
5. ForneÃ§a o endereÃ§o da prÃ©-compilaÃ§Ã£o ERC-20 (que Ã© `{{networks.demo_evm.precompiles.external_assets_erc20_example}}` neste exemplo) e clique em **At Address**
6. A prÃ©-compilaÃ§Ã£o **IERC20** aparecerÃ¡ na lista de **Deployed Contracts**
![Acessar o endereÃ§o](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-6.webp)

### Obter InformaÃ§Ãµes BÃ¡sicas do Token {: #get-basic-token-information }

A interface ERC-20 permite obter rapidamente informaÃ§Ãµes sobre o token, incluindo a oferta total do token, nome, sÃ­mbolo e casas decimais. VocÃª pode recuperar essas informaÃ§Ãµes seguindo estas etapas:

1. Expanda o contrato **IERC20** em **Deployed Contracts**
2. Clique em **decimals** para obter as casas decimais do token do protocolo nativo da sua rede
3. Clique em **name** para obter o nome do token
4. Clique em **symbol** para obter o sÃ­mbolo do token
5. Clique em **totalSupply** para obter a oferta total de tokens nativos em sua rede

![Obter informaÃ§Ãµes bÃ¡sicas do token](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-7.webp)

Os resultados de cada chamada de funÃ§Ã£o sÃ£o exibidos sob as respectivas funÃ§Ãµes.

### Obter Saldo da Conta {: #get-account-balance }

VocÃª pode verificar o saldo de qualquer endereÃ§o em sua rede chamando a funÃ§Ã£o `balanceOf` e passando um endereÃ§o:

1. Expanda a funÃ§Ã£o **balanceOf**
1. Insira um endereÃ§o para o qual vocÃª gostaria de verificar o saldo para o **owner**
1. Clique em **call**

![Obter Saldo de uma Conta](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-8.webp)

Seu saldo serÃ¡ exibido na funÃ§Ã£o `balanceOf`.

### Enviar TransferÃªncia {: #send-transfer }

Para enviar tokens da sua conta diretamente para outra conta, vocÃª pode chamar a funÃ§Ã£o `transfer` seguindo estas etapas:

1. Expanda a funÃ§Ã£o **transfer**
2. Insira o endereÃ§o para enviar tokens UNIT
3. Insira a quantidade de tokens UNIT para enviar. Para este exemplo, vocÃª pode enviar 1 token UNIT (`1000000000000`)
4. Clique em **transact**
5. O MetaMask aparecerÃ¡ e vocÃª serÃ¡ solicitado a revisar os detalhes da transaÃ§Ã£o. Clique em **Confirmar** para enviar a transaÃ§Ã£o

![Enviar TransferÃªncia PadrÃ£o](/images/builders/toolkit/ethereum-api/precompiles/external-assets-erc20/external-assets-erc20-9.webp)

Assim que a transaÃ§Ã£o for concluÃ­da, vocÃª poderÃ¡ [verificar seu saldo](#get-account-balance) usando a funÃ§Ã£o `balanceOf` ou olhando para o MetaMask. VocÃª notarÃ¡ que seu saldo diminuiu em 1 token UNIT. VocÃª tambÃ©m pode usar a funÃ§Ã£o `balanceOf` para garantir que o saldo dos destinatÃ¡rios tenha aumentado em 1 token UNIT, conforme o esperado.

E Ã© isso! VocÃª interagiu com sucesso com a prÃ©-compilaÃ§Ã£o de ativos externos ERC-20 usando MetaMask e Remix!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/precompiles/
--- BEGIN CONTENT ---
---
title: Solidity Precompiles
description: Estes guias demonstram como interagir com precompiles para acessar os recursos do Substrate atravÃ©s da familiar API Ethereum em redes compatÃ­veis com EVM da Tanssi.
icon: octicons-file-code-24
template: index-page.html
---

# Precompiles

Precompiles sÃ£o mÃ³dulos de blockchain integrados, projetados para lidar com tarefas especÃ­ficas de forma mais eficiente do que contratos inteligentes padrÃ£o. Esses mÃ³dulos sÃ£o prÃ©-implantados em endereÃ§os fixos e fornecem soluÃ§Ãµes otimizadas para operaÃ§Ãµes como funÃ§Ãµes criptogrÃ¡ficas, processamento de transaÃ§Ãµes em lote e gerenciamento de tokens.

Como as redes Powered by Tanssi sÃ£o baseadas em Substrate, os contratos precompilados podem suportar funÃ§Ãµes compatÃ­veis com Ethereum e operaÃ§Ãµes especÃ­ficas para a cadeia Substrate subjacente. Essa abordagem dupla garante que os desenvolvedores possam interagir com ferramentas Ethereum familiares, ao mesmo tempo em que aproveitam o desempenho e a flexibilidade exclusivos oferecidos pelo Substrate.

## Fluxo de InteraÃ§Ã£o com Precompiles

O fluxo abaixo ilustra como as solicitaÃ§Ãµes do usuÃ¡rio passam pela interface Ethereum, interagem com precompiles e, por fim, acessam a funcionalidade Substrate, simplificando operaÃ§Ãµes complexas para uma integraÃ§Ã£o perfeita.

```mermaid
graph LR
    
    A[UsuÃ¡rio]
    B[Interface Ethereum]
    C[Precompile]
    D[Interface Substrate]

    A -->|Interage atravÃ©s de| B
    B -->|Chama| C
    C -->|Acessa| D
```

## ReferÃªncia RÃ¡pida de EndereÃ§os Precompile

| Precompile          | EndereÃ§o                                                      |
|---------------------|--------------------------------------------------------------|
| Native Token ERC-20 | <pre>```0x0000000000000000000000000000000000000800```</pre>  |
| Call Permit         | <pre>```0x0000000000000000000000000000000000000802```</pre>  |
| Proxy               | <pre>```0x0000000000000000000000000000000000000805```</pre>  |
| Batch Transactions  | <pre>```0x0000000000000000000000000000000000000801```</pre>  |

Para saber mais sobre cada precompile, confira os guias listados na seÃ§Ã£o a seguir.

## Explore esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/precompiles/proxy/
--- BEGIN CONTENT ---
---
title: Proxy Precompile
description: Saiba como interagir com o Proxy Precompile para adicionar e remover contas proxy que executam transaÃ§Ãµes em nome de outra conta.
keywords: solidity, ethereum, proxy, tanssi, precompiled, contracts, substrate
icon: octicons-shield-lock-24
categories: EVM-Template
---

# Interagindo com o Proxy Precompile

## IntroduÃ§Ã£o {: #introduction }

A Proxy Precompile permite que as contas definam contas proxy por meio da API Ethereum. As contas proxy podem realizar aÃ§Ãµes limitadas em nome da conta com proxy, como governanÃ§a, transferÃªncias de saldo, gerenciamento ou transaÃ§Ãµes privilegiadas, entre outras.

Se um usuÃ¡rio quisesse fornecer a outro usuÃ¡rio acesso a um nÃºmero limitado de aÃ§Ãµes em seu nome, tradicionalmente, o Ãºnico mÃ©todo para fazÃª-lo seria compartilhar a chave privada dessa conta. No entanto, as redes EVM powered by Tanssi incluem o mÃ³dulo proxy, fornecendo uma camada adicional de seguranÃ§a. Com proxies, muitas contas podem realizar aÃ§Ãµes para uma conta primÃ¡ria, e tais permissÃµes podem ser revogadas a qualquer momento. Isto Ã© melhor se, por exemplo, um usuÃ¡rio quiser manter sua carteira segura em armazenamento a frio, mas ainda quiser acessar partes da funcionalidade da carteira, como governanÃ§a ou staking.

!!! note
    O Proxy Precompile sÃ³ pode ser chamado de uma Externally Owned Account (EOA) ou pela [Batch Precompile](/pt/builders/toolkit/ethereum-api/precompiles/batch/){target=\_blank}.

Para saber mais sobre contas proxy e como configurÃ¡-las para seus prÃ³prios propÃ³sitos sem o uso do Proxy Precompile, visite a pÃ¡gina [Proxy Accounts](/pt/builders/account-management/proxy-accounts/){target=\_blank}.

A Proxy Precompile estÃ¡ localizada no seguinte endereÃ§o:

```text
{{networks.demo_evm.precompiles.proxy}}
```

!!! note
    O uso de precompiladas pode trazer consequÃªncias inesperadas. As precompiladas do Tanssi sÃ£o derivadas das do Moonbeam; portanto, familiarize-se com as [consideraÃ§Ãµes de seguranÃ§a das precompiladas do Moonbeam](https://docs.moonbeam.network/builders/get-started/eth-compare/security){target=\_blank}.

## PrÃ©-requisitos {: #prerequisites }

Para acompanhar o conteÃºdo deste guia, vocÃª precisarÃ¡:

- Acesso a uma rede EVM powered by Tanssi executando [runtime 700](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank} ou superior
- Uma [carteira compatÃ­vel com EVM](/pt/builders/toolkit/ethereum-api/wallets/){target=\_blank} configurada para funcionar com sua rede. VocÃª tambÃ©m pode conectar sua carteira Ã  [rede EVM de demonstraÃ§Ã£o](https://apps.tanssi.network/demo){target=\_blank}
- Uma conta com fundos suficientes para pagar as taxas e depÃ³sitos necessÃ¡rios
- Uma segunda conta que vocÃª controla para usar como proxy

## A Interface Solidity do Proxy {: #the-proxy-solidity-interface }

[`Proxy.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/Proxy.sol){target=\_blank} Ã© uma interface que permite que desenvolvedores interajam com as funÃ§Ãµes da precompilaÃ§Ã£o.

??? code "Proxy.sol"

    ```solidity

    // SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.3;

/// @author The Moonsong Labs Team
/// @title Pallet Proxy Interface
/// @title The interface through which solidity contracts will interact with the Proxy pallet
interface Proxy {
    /// @dev Defines the proxy permission types.
    /// The values start at `0` (most permissive) and are represented as `uint8`
    enum ProxyType {
        Any,
        NonTransfer,
        Governance,
        Staking,
        CancelProxy,
        Balances,
        AuthorMapping,
        IdentityJudgement
    }

    /// @dev Register a proxy account for the sender that is able to make calls on its behalf
    /// @custom:selector 74a34dd3
    /// @param delegate The account that the caller would like to make a proxy
    /// @param proxyType The permissions allowed for this proxy account
    /// @param delay The announcement period required of the initial proxy, will generally be zero
    function addProxy(
        address delegate,
        ProxyType proxyType,
        uint32 delay
    ) external;

    /// @dev Removes a proxy account from the sender
    /// @custom:selector fef3f708
    /// @param delegate The account that the caller would like to remove as a proxy
    /// @param proxyType The permissions currently enabled for the removed proxy account
    /// @param delay The announcement period required of the initial proxy, will generally be zero
    function removeProxy(
        address delegate,
        ProxyType proxyType,
        uint32 delay
    ) external;

    /// @dev Unregister all proxy accounts for the sender
    /// @custom:selector 14a5b5fa
    function removeProxies() external;

    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender
    /// is authorised for through `addProxy`
    /// @custom:selector 0d3cff86
    /// @param real The account that the proxy will make a call on behalf of
    /// @param callTo Recipient of the call to be made by the `real` account
    /// @param callData Data of the call to be made by the `real` account
    function proxy(
        address real,
        address callTo,
        bytes memory callData
    ) external payable;

    /// @dev Dispatch the given subcall (`callTo`, `callData`) from an account that the sender
    /// is authorised for through `addProxy`
    /// @custom:selector 685b9d2f
    /// @param real The account that the proxy will make a call on behalf of
    /// @param forceProxyType Specify the exact proxy type to be used and checked for this call
    /// @param callTo Recipient of the call to be made by the `real` account
    /// @param callData Data of the call to be made by the `real` account
    function proxyForceType(
        address real,
        ProxyType forceProxyType,
        address callTo,
        bytes memory callData
    ) external payable;

    /// @dev Checks if the caller has an account proxied with a given proxy type
    /// @custom:selector e26d38ed
    /// @param real The real account that maybe has a proxy
    /// @param delegate The account that the caller has maybe proxied
    /// @param proxyType The permissions allowed for the proxy
    /// @param delay The announcement period required of the initial proxy, will generally be zero
    /// @return exists True if a proxy exists, False otherwise
    function isProxy(
        address real,
        address delegate,
        ProxyType proxyType,
        uint32 delay
    ) external view returns (bool exists);
}

    ```


A interface inclui as estruturas de dados necessÃ¡rias, juntamente com as seguintes funÃ§Ãµes:

???+ function "**addProxy**(delegate, proxyType, delay) â€” registra uma conta proxy para o remetente apÃ³s um nÃºmero especificado de blocos `delay` (geralmente zero). FalharÃ¡ se um proxy para o chamador jÃ¡ existir"

    === "ParÃ¢metros"

        - `delegate` ++"address"++ - o endereÃ§o do proxy
        - `proxyType` ++"ProxyType"++ - o tipo de delegaÃ§Ã£o que define as funÃ§Ãµes especÃ­ficas que o proxy terÃ¡ permissÃ£o para executar
        - `delay` ++"uint32"++ - nÃºmero de blocos a esperar atÃ© que o proxy seja habilitado

    === "Exemplo"

        - `delegate` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217
        - `proxyType` - "Any"
        - `delay` - 0


??? function "**removeProxy**(delegate, proxyType, delay) â€” remove um proxy registrado para o remetente"

    
    === "ParÃ¢metros"

        - `delegate` ++"address"++ - o endereÃ§o do proxy a ser removido
        - `proxyType` ++"ProxyType"++ - o tipo de delegaÃ§Ã£o a ser removido
        - `delay` ++"uint32"++ - nÃºmero de blocos a esperar atÃ© que a remoÃ§Ã£o entre em vigor

    === "Exemplo"

        - `delegate` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217
        - `proxyType` - "Any"
        - `delay` - 0
    

??? function "**removeProxies**() â€” remove todas as contas proxy delegadas ao remetente"

??? function "**isProxy**(real, delegate, proxyType, delay) â€” retorna `true` se o endereÃ§o delegado for um proxy do tipo `proxyType`, para o endereÃ§o `real`, com o `delay` especificado"

    
    === "ParÃ¢metros"

        - `real` ++"address"++ - a conta que concede permissÃµes ao proxy
        - `delegate` ++"address"++ - o endereÃ§o do proxy
        - `proxyType` ++"ProxyType"++ - o tipo de delegaÃ§Ã£o
        - `delay` ++"uint32"++ - nÃºmero de blocos a aguardar

    === "Exemplo"

        - `delegate` - 0xbB8919d5DDfc85F4D15820a9e58018f1cfB39a2F
        - `proxyType` - "Any"
        - `delay` - 0

    

[O parÃ¢metro `proxyType`](#proxy-types) Ã© definido pela seguinte enumeraÃ§Ã£o `ProxyType`, onde os valores comeÃ§am em `0` com o tipo de proxy mais permissivo e sÃ£o representados como valores `uint8`:

```solidity

enum ProxyType {
    Any,
    NonTransfer,
    Governance,
    Staking,
    CancelProxy,
    Balances,
    AuthorMapping,
    IdentityJudgement
}
```

### Tipos de Proxy {: #proxy-types }

HÃ¡ vÃ¡rios tipos de funÃ§Ãµes de proxy que podem ser delegadas a contas, representadas em `Proxy.sol` atravÃ©s da enumeraÃ§Ã£o `ProxyType`. A lista a seguir inclui todos os proxies possÃ­veis e o tipo de transaÃ§Ãµes que eles podem fazer em nome da conta principal:

- **Any** â€” o proxy any permitirÃ¡ que a conta proxy faÃ§a qualquer tipo de transaÃ§Ã£o. Observe que as transferÃªncias de saldo sÃ³ sÃ£o permitidas para EOAs, nÃ£o para contratos ou Precompiles
- **NonTransfer** â€” o proxy de nÃ£o transferÃªncia permite que a conta proxy faÃ§a qualquer tipo de transaÃ§Ã£o em que o `msg.value` seja verificado como zero
- **Governance** - o proxy de governanÃ§a permitirÃ¡ que a conta proxy faÃ§a qualquer tipo de transaÃ§Ã£o relacionada Ã  governanÃ§a
- **CancelProxy** - o proxy de cancelamento permitirÃ¡ que a conta proxy rejeite e remova anÃºncios de proxy atrasados â€‹â€‹(da conta principal). Atualmente, esta nÃ£o Ã© uma aÃ§Ã£o suportada pelo Proxy Precompile
- **Balances** - o proxy de saldos permitirÃ¡ que a conta proxy faÃ§a apenas transferÃªncias de saldo para EOAs

!!! note
    A interface Solidity contÃ©m mais tipos de proxy do que os listados acima. A lista anterior inclui apenas os tipos de proxy implementados no [baseline EVM Template](/builders/build/templates/evm/){target=\_blank}.

## Interaja com a interface Solidity via Remix {: #interact-with-the-solidity-interface-via-remix }

Esta seÃ§Ã£o irÃ¡ guiÃ¡-lo pelas etapas para criar um proxy, verificar sua criaÃ§Ã£o e revogar os privilÃ©gios do proxy. Estes exemplos sÃ£o baseados na [Tanssi demo EVM Network](https://apps.tanssi.network/demo){target=\_blank} e usam [Metamask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank}. Este guia pode ser adaptado para sua prÃ³pria rede EVM powered by Tanssi adicionando a URL RPC da sua rede para a carteira EVM de sua escolha.

### ConfiguraÃ§Ã£o do Remix {: #remix-set-up }

VocÃª pode interagir com a precompilaÃ§Ã£o do Proxy usando [Remix](https://remix.ethereum.org){target=\_blank}. Para adicionar a precompilaÃ§Ã£o ao Remix, vocÃª precisarÃ¡:

1. Obter uma cÃ³pia de [`Proxy.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/Proxy.sol){target=\_blank}
2. Cole o conteÃºdo do arquivo em um arquivo Remix chamado `Proxy.sol`

### Compile o Contrato {: #compile-the-contract }

Em seguida, vocÃª precisarÃ¡ compilar a interface no Remix:

1. Clique na guia **Compilar**, a segunda de cima
2. Em seguida, para compilar a interface, clique em **Compilar Proxy.sol**

![Compilando Proxy.sol](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-1.webp)

Quando a compilaÃ§Ã£o estiver concluÃ­da, vocÃª verÃ¡ uma marca de seleÃ§Ã£o verde ao lado da guia **Compilar**.

### Acessar o Contrato {: #access-the-contract }

Em vez de implantar o contrato inteligente, vocÃª acessarÃ¡ a interface atravÃ©s de seu endereÃ§o:

1. Clique na guia **Deploy and Run** diretamente abaixo da guia **Compile** no Remix
2. Certifique-se de que **Injected Provider - Metamask** esteja selecionado no menu suspenso **ENVIRONMENT**. VocÃª pode ser solicitado pelo MetaMask para conectar sua conta ao Remix, caso ainda nÃ£o esteja conectado
3. Certifique-se de que a conta primÃ¡ria seja exibida em **ACCOUNT**
4. Certifique-se de que **Proxy - Proxy.sol** esteja selecionado no menu suspenso **CONTRACT**. Dado que Ã© um contrato prÃ©-compilado, nÃ£o hÃ¡ etapa de implantaÃ§Ã£o. Em vez disso, vocÃª fornecerÃ¡ o endereÃ§o da precompilaÃ§Ã£o no campo **At Address**
5. ForneÃ§a o endereÃ§o da precompilaÃ§Ã£o do Proxy (que Ã© `{{networks.demo_evm.precompiles.proxy}}` neste exemplo) e clique em **At Address**
6. A precompilaÃ§Ã£o do **Proxy** aparecerÃ¡ na lista de **Deployed Contracts**
![Acessar o endereÃ§o](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-2.webp)

### Adicionar um Proxy {: #add-proxy }

VocÃª pode adicionar proxies para sua conta chamando as funÃ§Ãµes de precompilaÃ§Ã£o. No exemplo a seguir, vocÃª adicionarÃ¡ um proxy autorizado a executar qualquer transaÃ§Ã£o em seu nome:

1. Expanda o contrato Proxy Precompile para ver as funÃ§Ãµes disponÃ­veis
2. Encontre a funÃ§Ã£o **addProxy** e pressione o botÃ£o para expandir a seÃ§Ã£o
3. Insira o endereÃ§o de sua segunda conta como **delegate**, `0` como **proxyType**, o que significa `any`, e `0` como **delay**
4. Clique em **transact**
5. O MetaMask aparecerÃ¡ e vocÃª serÃ¡ solicitado a revisar os detalhes da transaÃ§Ã£o. Clique em Confirmar para executar a transaÃ§Ã£o

!!! note
    Ao construir a transaÃ§Ã£o no Remix, o **proxyType** Ã© representado como um `uint8`, em vez do enum `ProxyType` esperado. Em Solidity, os enums sÃ£o compilados como `uint8`, entÃ£o, quando vocÃª passa `0` para **proxyType**, vocÃª indica o primeiro elemento no enum `ProxyType`, que Ã© o proxy `any`.

![Chamar a funÃ§Ã£o addProxy](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-3.webp)

### Verifique uma existÃªncia de Proxy {: #check-proxy }

A funÃ§Ã£o `isProxy` verifica se uma conta proxy existe. ApÃ³s criar um proxy na [etapa anterior](#add-proxy), use os mesmos parÃ¢metros para verificar se o proxy foi adicionado com sucesso:

1. Expanda a funÃ§Ã£o **isProxy**
2. Insira sua conta principal como **real**, sua segunda conta (proxy) como **delegate**, `0` como **proxyType** e `0` como **delay**
3. Clique em **call**
4. As funÃ§Ãµes retornam se existe um proxy ou nÃ£o. Neste exemplo, o proxy existe, portanto, a funÃ§Ã£o retorna `true`

![Chamar a funÃ§Ã£o isProxy](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-4.webp)

### Remover um Proxy {: #remove-proxy }

VocÃª pode revogar uma permissÃ£o de proxy quando nÃ£o for mais necessÃ¡ria. ApÃ³s criar um proxy na [Adicionar Proxy](#add-proxy), etapa, ele pode ser removido seguindo estas etapas:

1. Expanda a funÃ§Ã£o **removeProxy**
2. Insira a conta proxy como **delegate**, `0` como **proxyType** e `0` como **delay**
3. Clique em **transact**
4. O MetaMask aparecerÃ¡ e vocÃª serÃ¡ solicitado a revisar os detalhes da transaÃ§Ã£o. Clique em Confirmar para executar a transaÃ§Ã£o

Depois que a transaÃ§Ã£o for confirmada, se vocÃª repetir as etapas para [verificar a existÃªncia de um proxy](#check-proxy), o resultado deverÃ¡ ser `false`.

![Chamar a funÃ§Ã£o removeProxy](/images/builders/toolkit/ethereum-api/precompiles/proxy/proxy-5.webp)

E Ã© isso! VocÃª interagiu com sucesso com a precompilaÃ§Ã£o do Proxy usando MetaMask e Remix!

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/rpc/
--- BEGIN CONTENT ---
---
title: MÃ©todos da API JSON-RPC
description: Saiba quais mÃ©todos JSON-RPC sÃ£o suportados para consultar sua rede EVM da Tanssi, incluindo mÃ©todos Ethereum padrÃ£o e mÃ©todos personalizados da Tanssi.
icon: material-code-json
categories: Reference
---

# MÃ©todos da API JSON-RPC

## MÃ©todos Ethereum PadrÃ£o {: #standard-rpc-methods }

A compatibilidade EVM da Tanssi Ã© derivada do [Frontier](https://github.com/polkadot-evm/frontier){target=\_blank} e segue de perto a compatibilidade Ethereum do Moonbeam. Os nÃ³s da Tanssi suportam uma ampla variedade de mÃ©todos JSON-RPC padrÃ£o do Ethereum.

Nem todos os mÃ©todos sÃ£o suportados; alguns retornam valores padrÃ£o (especialmente os ligados ao PoW). Abaixo estÃ¡ a lista dos mÃ©todos Ethereum JSON-RPC suportados na Tanssi para que os desenvolvedores saibam o que estÃ¡ disponÃ­vel ao interagir com redes EVM da Tanssi.

MÃ©todos bÃ¡sicos da API Ethereum suportados:

- **[eth_protocolVersion](https://ethereum.org/developers/docs/apis/json-rpc/#eth_protocolversion){target=\_blank}** â€” retorna `1` por padrÃ£o
- **[eth_syncing](https://ethereum.org/developers/docs/apis/json-rpc/#eth_syncing){target=\_blank}** â€” retorna um objeto com o status de sincronizaÃ§Ã£o ou `false`
- **[eth_hashrate](https://ethereum.org/developers/docs/apis/json-rpc/#eth_hashrate){target=\_blank}** â€” retorna `"0x0"` por padrÃ£o
- **[eth_coinbase](https://ethereum.org/developers/docs/apis/json-rpc/#eth_coinbase){target=\_blank}** â€” retorna o autor do Ãºltimo bloco (nÃ£o necessariamente finalizado)
- **[eth_mining](https://ethereum.org/developers/docs/apis/json-rpc/#eth_mining){target=\_blank}** â€” retorna `false` por padrÃ£o
- **[eth_chainId](https://ethereum.org/developers/docs/apis/json-rpc/#eth_chainid){target=\_blank}** â€” retorna o chain ID usado para assinar no bloco atual
- **[eth_gasPrice](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gasprice){target=\_blank}** â€” retorna a base fee por unidade de gas. Atualmente Ã© o gas price mÃ­nimo da rede
- **[eth_accounts](https://ethereum.org/developers/docs/apis/json-rpc/#eth_accounts){target=\_blank}** â€” lista de endereÃ§os do cliente
- **[eth_blockNumber](https://ethereum.org/developers/docs/apis/json-rpc/#eth_blocknumber){target=\_blank}** â€” maior nÃºmero de bloco disponÃ­vel
- **[eth_getBalance](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getbalance){target=\_blank}** â€” saldo do endereÃ§o fornecido
- **[eth_getStorageAt](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getstorageat){target=\_blank}** â€” conteÃºdo do storage em um endereÃ§o
- **[eth_getBlockByHash](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getblockbyhash){target=\_blank}** â€” informaÃ§Ãµes do bloco por hash, incluindo `baseFeePerGas` em blocos pÃ³s-London
- **[eth_getBlockByNumber](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getblockbynumber){target=\_blank}** â€” informaÃ§Ãµes do bloco por nÃºmero, incluindo `baseFeePerGas` em blocos pÃ³s-London
- **[eth_getBlockReceipts](https://www.alchemy.com/docs/chains/ethereum/ethereum-api-endpoints/eth-get-block-receipts){target=\_blank}** â€” todos os receipts de transaÃ§Ãµes de um bloco.
- **[eth_getTransactionCount](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactioncount){target=\_blank}** â€” nÃºmero de transaÃ§Ãµes (nonce) enviadas pelo endereÃ§o
- **[eth_getBlockTransactionCountByHash](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash){target=\_blank}** â€” nÃºmero de transaÃ§Ãµes em um bloco por hash
- **[eth_getBlockTransactionCountByNumber](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber){target=\_blank}** â€” nÃºmero de transaÃ§Ãµes em um bloco por nÃºmero
- **[eth_getUncleCountByBlockHash](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getunclecountbyblockhash){target=\_blank}** â€” retorna `"0x0"` por padrÃ£o
- **[eth_getUncleCountByBlockNumber](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getunclecountbyblocknumber){target=\_blank}** â€” retorna `"0x0"` por padrÃ£o
- **[eth_getCode](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getcode){target=\_blank}** â€” cÃ³digo no endereÃ§o informado e bloco informado
- **[eth_sendTransaction](https://ethereum.org/developers/docs/apis/json-rpc/#eth_sendtransaction){target=\_blank}** â€” cria transaÃ§Ã£o de chamada ou criaÃ§Ã£o de contrato (se houver cÃ³digo em `data`). Retorna o hash da transaÃ§Ã£o ou zero hash se ainda nÃ£o disponÃ­vel
- **[eth_sendRawTransaction](https://ethereum.org/developers/docs/apis/json-rpc/#eth_sendrawtransaction){target=\_blank}** â€” cria transaÃ§Ã£o de chamada ou criaÃ§Ã£o para transaÃ§Ãµes assinadas. Retorna hash ou zero hash se ainda nÃ£o disponÃ­vel
- **[eth_call](https://ethereum.org/developers/docs/apis/json-rpc/#eth_call){target=\_blank}** â€” executa chamada sem criar transaÃ§Ã£o, retornando o valor da execuÃ§Ã£o
- **[eth_estimateGas](https://ethereum.org/developers/docs/apis/json-rpc/#eth_estimategas){target=\_blank}** â€” estima o gas necessÃ¡rio para uma transaÃ§Ã£o. Pode receber `gasPrice` ou `maxFeePerGas` e `maxPriorityFeePerGas`
- **[eth_feeHistory](https://www.alchemy.com/docs/chains/ethereum/ethereum-api-endpoints/eth-fee-history){target=\_blank}** â€” retorna `baseFeePerGas`, `gasUsedRatio`, `oldestBlock` e `reward` para um intervalo de atÃ© 1024 blocos
- **[eth_getTransactionByHash](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactionbyhash){target=\_blank}** â€” informaÃ§Ãµes de uma transaÃ§Ã£o por hash; transaÃ§Ãµes EIP-1559 incluem `maxPriorityFeePerGas` e `maxFeePerGas`
- **[eth_getTransactionByBlockHashAndIndex](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactionbyblockhashandindex){target=\_blank}** â€” informaÃ§Ãµes de uma transaÃ§Ã£o por hash do bloco e Ã­ndice; inclui campos EIP-1559
- **[eth_getTransactionByBlockNumberAndIndex](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactionbyblocknumberandindex){target=\_blank}** â€” informaÃ§Ãµes de uma transaÃ§Ã£o por nÃºmero do bloco e Ã­ndice; inclui campos EIP-1559
- **[eth_getTransactionReceipt](https://ethereum.org/developers/docs/apis/json-rpc/#eth_gettransactionreceipt){target=\_blank}** â€” receipt de uma transaÃ§Ã£o por hash
- **[eth_getUncleByBlockHashAndIndex](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getunclebyblockhashandindex){target=\_blank}** â€” retorna `null` por padrÃ£o
- **[eth_getUncleByBlockNumberAndIndex](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getunclebyblocknumberandindex){target=\_blank}** â€” retorna `null` por padrÃ£o
- **[eth_getLogs](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getlogs){target=\_blank}** â€” array de logs que correspondem ao filtro
- **[eth_newFilter](https://ethereum.org/developers/docs/apis/json-rpc/#eth_newfilter){target=\_blank}** â€” cria filtro com base nos parÃ¢metros fornecidos; retorna o ID do filtro
- **[eth_newBlockFilter](https://ethereum.org/developers/docs/apis/json-rpc/#eth_newblockfilter){target=\_blank}** â€” cria filtro para avisar quando chegar um novo bloco; retorna ID
- **[eth_getFilterChanges](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getfilterchanges){target=\_blank}** â€” mÃ©todo de polling para filtros; retorna logs desde o Ãºltimo poll
- **[eth_getFilterLogs](https://ethereum.org/developers/docs/apis/json-rpc/#eth_getfilterlogs){target=\_blank}** â€” array de logs que correspondem ao filtro com ID fornecido
- **[eth_uninstallFilter](https://ethereum.org/developers/docs/apis/json-rpc/#eth_uninstallfilter){target=\_blank}** â€” remove um filtro pelo ID; use quando o polling nÃ£o for mais necessÃ¡rio (filtros expiram se nÃ£o forem consultados)

## MÃ©todos JSON-RPC Personalizados {: #custom-json-rpc-methods }

Os nÃ³s da Tanssi expÃµem dois endpoints personalizados: `frnt_isBlockFinalized` e `frnt_isTxFinalized`. Como a Tanssi tem finalizaÃ§Ã£o determinÃ­stica, Ã© possÃ­vel saber com certeza se um bloco ou transaÃ§Ã£o estÃ¡ finalizado ou nÃ£o. Esses endpoints ajudam a verificar a finalizaÃ§Ã£o de eventos on-chain.

???+ function "frnt_isBlockFinalized - verifica a finalizaÃ§Ã£o do bloco pelo hash"

    === "ParÃ¢metros"

        - `block_hash` ++"string"++ - hash do bloco (aceita hash estilo Substrate ou Ethereum)

    === "Retorno"

        ++"boolean"++ - `true` se o bloco estiver finalizado; `false` se nÃ£o estiver finalizado ou nÃ£o encontrado

    === "Exemplo"

        ```bash
        curl -H "Content-Type: application/json" -X POST --data '{
          "jsonrpc": "2.0",
          "id": "1",
          "method": "frnt_isBlockFinalized",
          "params": ["INSERT_BLOCK_HASH"]
        }' {{ networks.dancelight.demo_evm_rpc_url }}
        ```

???+ function "frnt_isTxFinalized - verifica a finalizaÃ§Ã£o de uma transaÃ§Ã£o pelo hash EVM"

    === "ParÃ¢metros"

        - `tx_hash` ++"string"++ - hash EVM da transaÃ§Ã£o

    === "Retorno"

        ++"boolean"++ - `true` se a transaÃ§Ã£o estiver finalizada; `false` se nÃ£o estiver finalizada ou nÃ£o encontrada

    === "Exemplo"

        ```bash
        curl -H "Content-Type: application/json" -X POST --data '{
          "jsonrpc": "2.0",
          "id": "1",
          "method": "frnt_isTxFinalized",
          "params": ["INSERT_TRANSACTION_HASH"]
        }' {{ networks.dancelight.demo_evm_rpc_url }}
        ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/wallets/
--- BEGIN CONTENT ---
---
title: Carteiras da API Ethereum
description: Saiba como interagir com sua rede EVM powered by Tanssi por meio da API Ethereum, incluindo a configuraÃ§Ã£o de carteiras, a adiÃ§Ã£o de URLs RPC e o envio de fundos.
icon: material-wallet-outline
template: index-page.html
---

# Carteiras

Carteiras sÃ£o ferramentas digitais que permitem aos usuÃ¡rios armazenar, gerenciar e transacionar com seguranÃ§a seus ativos digitais. Elas armazenam as chaves criptogrÃ¡ficas necessÃ¡rias para acessar ativos digitais e permitem executar transaÃ§Ãµes em redes blockchain.

Para redes compatÃ­veis com EVM, vocÃª pode usar qualquer carteira que suporte EVM, com a flexibilidade de adicionar configuraÃ§Ãµes de rede personalizadas, permitindo conexÃ£o e interaÃ§Ã£o contÃ­nuas com sua rede.

As pÃ¡ginas desta seÃ§Ã£o fornecem uma visÃ£o geral de como comeÃ§ar com vÃ¡rios provedores de carteira. Ela aborda como criar e importar contas, conectar-se Ã  sua rede e comeÃ§ar a interagir com ela.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/wallets/ledger/
--- BEGIN CONTENT ---
---
title: Usando Ledger com Sua EVM Appchain
description: Aprenda a configurar e usar carteiras de hardware Ledger com EVM appchains powered by Tanssi para armazenamento seguro de chaves offline e assinatura de transaÃ§Ãµes.
icon: material-wallet-outline
categories: EVM-Template
---

# Interagindo com EVM appchains powered by Tanssi Usando Ledger

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores e usuÃ¡rios de EVM appchains powered by Tanssi, como a [demonstraÃ§Ã£o Tanssi](https://apps.tanssi.network/demo){target=\_blank}, tÃªm uma variedade de opÃ§Ãµes quando se trata de carteiras. Em relaÃ§Ã£o Ã s carteiras frias, que armazenam suas chaves privadas em um ambiente seguro e offline, [Ledger](https://www.ledger.com/){target=\_blank} Ã© uma das opÃ§Ãµes mais populares. A Ledger oferece suporte total para blockchains Substrate, como a rede Tanssi.

Os dispositivos Ledger sÃ£o carteiras de hardware projetadas para armazenar as chaves privadas offline. Eles sÃ£o usados para verificar e assinar as transaÃ§Ãµes, mas ainda precisam de uma camada de software para fornecer a interface do usuÃ¡rio que interage com as redes, constrÃ³i as transaÃ§Ãµes e envia as transaÃ§Ãµes assinadas de volta para a rede assim que o usuÃ¡rio as tiver verificado.

Este guia leva vocÃª por todas as etapas necessÃ¡rias para usar seu dispositivo Ledger com EVM appchains powered by Tanssi.

## Configurando Seu Dispositivo Ledger {: #setting-up-ledger-device }

Se vocÃª tem um dispositivo Ledger novo, consulte o [site oficial](https://support.ledger.com/article/4404389503889-zd){target=\_blank} para obter um guia sobre como iniciÃ¡-lo com a configuraÃ§Ã£o inicial.

Agora, com seu Ledger jÃ¡ iniciado, instale o aplicativo _Ethereum_ seguindo as seguintes etapas:

1. Abra o aplicativo Ledger Live em seu computador.
2. VÃ¡ para My Ledger.
3. Conecte e desbloqueie o dispositivo.

Por fim, procure o aplicativo **Ethereum (ETH)** no Ledger Live e instale-o em seu dispositivo.

![Instale Ethereum no Ledger Live](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-1.webp)

E Ã© isso. Seu dispositivo agora tem uma conta Ethereum e Ã© capaz de assinar transaÃ§Ãµes em qualquer EVM appchain powered by Tanssi.

## Adicionando o Ledger a uma Carteira Quente {: #adding-Ledger-hot-wallet }

Conforme apresentado na [introduÃ§Ã£o](#introduction), uma carteira de hardware Ledger fornece armazenamento seguro offline para chaves privadas, permitindo que os usuÃ¡rios verifiquem e assinem transaÃ§Ãµes. No entanto, por design, ela nÃ£o pode interagir com blockchains ou dApps sozinha, nem oferece uma interface do usuÃ¡rio para gerenciar ativos. Para complementar o dispositivo, uma carteira quente Ã© necessÃ¡ria. O usuÃ¡rio pode escolher qualquer carteira compatÃ­vel com Ethereum.

Para fins de demonstraÃ§Ã£o, mostraremos como configurar [Metamask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} para funcionar com sua carteira de hardware, mas essas etapas sÃ£o geralmente aplicÃ¡veis a qualquer outra carteira que suporte Ledger. Para seguir as etapas, certifique-se de ter o Metamask instalado em seu navegador, abra a extensÃ£o e clique no Ã­cone suspenso ao lado do nome da conta.

![Conectar Ledger](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-2.webp)

Agora clique no botÃ£o **+ Adicionar conta ou carteira de hardware**.

![Conectar Ledger](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-3.webp)

Selecione **Carteira de hardware** nas opÃ§Ãµes disponÃ­veis.

![Conectar Ledger](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-4.webp)

Na tela seguinte:

1. Selecione a caixa **LEDGER**. VocÃª serÃ¡ solicitado a conectar seu Ledger, desbloqueÃ¡-lo e abrir o aplicativo Ethereum.
2. Clique em **Continuar**.

![Conectar Ledger](/images/builders/toolkit/ethereum-api/wallets/ledger/ledger-5.webp)

Finalmente, vocÃª serÃ¡ apresentado com uma lista de contas derivadas. Selecione aquela que vocÃª deseja importar, clique em **Desbloquear** e pronto! Sua carteira Metamask agora pode assinar transaÃ§Ãµes usando seu dispositivo Ledger.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/wallets/metamask/
--- BEGIN CONTENT ---
---
title: Como Conectar a MetaMask
description: Este guia mostra como conectar a MetaMask, uma carteira Ethereum baseada em navegador, Ã  sua rede compatÃ­vel com EVM Powered by Tanssi e como transferir fundos.
icon: material-wallet-outline
categories: EVM-Template
---

# Interagindo com Sua Rede EVM Tanssi Usando MetaMask

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores que constroem dApps em cima de redes EVM Powered by Tanssi podem aproveitar seus recursos de compatibilidade Ethereum integrando carteiras Ethereum conhecidas, como [MetaMask](https://metamask.io){target=\_blank}. Ao fazer isso, eles podem usar a biblioteca injetada que MetaMask fornece para interagir com a rede EVM Tanssi.

Este guia leva vocÃª por todas as etapas necessÃ¡rias: desde a instalaÃ§Ã£o da Metamask, configuraÃ§Ã£o de uma carteira e, finalmente, conectando-a Ã  sua rede EVM Tanssi.

!!! note
    VocÃª nunca deve compartilhar sua frase semente (mnemÃ´nico) ou chave privada com ninguÃ©m. Isso lhes dÃ¡ acesso direto aos seus fundos. Este guia Ã© apenas para fins educacionais.

## Instale a ExtensÃ£o MetaMask {: #install-the-metamask-extension }

Primeiro, vocÃª comeÃ§arÃ¡ com uma instalaÃ§Ã£o [MetaMask](https://metamask.io){target=\_blank} nova e padrÃ£o da Chrome store. ApÃ³s baixar, instalar e inicializar a extensÃ£o, siga as etapas de **ComeÃ§ar** para [configurar a carteira](#setup-a-wallet). LÃ¡, vocÃª precisa criar uma carteira, definir uma senha e armazenar sua frase secreta de backup (isso dÃ¡ acesso direto aos seus fundos, portanto, certifique-se de armazenÃ¡-los em um local seguro).

!!! note
    A extensÃ£o do navegador Metamask Ã© compatÃ­vel com Chrome, navegadores baseados em Chromium (como Microsoft Edge e Opera) e Firefox. Metamask tambÃ©m estÃ¡ disponÃ­vel como um aplicativo mÃ³vel para dispositivos iOS e Android.

## Configurar uma Carteira {: #setup-a-wallet }

ApÃ³s instalar [MetaMask](https://metamask.io){target=\_blank}, a configuraÃ§Ã£o abrirÃ¡ automaticamente uma nova tarefa com uma tela de boas-vindas. Aqui, vocÃª tem duas opÃ§Ãµes:

- **Criar uma nova carteira** - vocÃª passarÃ¡ por algumas etapas para obter uma nova frase semente. Certifique-se de armazenar esta frase com seguranÃ§a e nÃ£o compartilhÃ¡-la publicamente
- **Importar uma carteira existente** - vocÃª jÃ¡ tem uma frase semente armazenada e deseja restaurar uma conta a partir dessa frase de recuperaÃ§Ã£o

![Interface de ConfiguraÃ§Ã£o do Metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-1.webp)

Depois de clicar na opÃ§Ã£o que se adapta Ã s suas necessidades, siga as etapas e vocÃª deverÃ¡ estar totalmente configurado.

!!! note
    VÃ¡rias contas podem ser derivadas de uma frase semente alterando o que Ã© conhecido como o Ã­ndice de endereÃ§o. Por padrÃ£o, ao criar ou importar uma conta a partir da frase semente, vocÃª obtÃ©m a conta com o Ã­ndice de endereÃ§o 0. VocÃª pode obter os outros Ã­ndices apenas adicionando novas contas na tela principal da Metamask.

## Importar Contas {: #import-accounts }

Depois de criar uma carteira ou importar uma existente, vocÃª tambÃ©m pode importar qualquer conta para a MetaMask se tiver as chaves privadas.

Para este exemplo, vocÃª usarÃ¡ chaves privadas da conta de desenvolvimento. Clique no botÃ£o de troca de conta para importar uma conta usando suas chaves privadas. Ã‰ onde diz **Account 1**.

![Importando conta do menu de chaves privadas da metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-2.webp)

Em seguida, clique em **Import Account**.

![Importando conta do menu de troca de conta de chave privada](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-3.webp)

Finalmente, insira as chaves privadas da conta que vocÃª estÃ¡ tentando importar. Depois de inserir a chave privada, clique em **Import**.

![Cole sua chave de conta na MetaMask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-4.webp)

VocÃª deve terminar com uma **Conta 2** importada que se parece com isto:

![MetaMask mostrando sua nova Conta 2](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-5.webp)

## Conecte a MetaMask Ã  Sua Rede EVM Tanssi {: #connect-metamask-to-evm-network }

Depois de ter [MetaMask](https://metamask.io){target=\_blank} instalado e ter criado ou importado uma conta, vocÃª pode conectÃ¡-la Ã  sua rede EVM Tanssi. Para fazer isso, siga os seguintes passos:

1. Clique no menu do seletor de rede no canto superior esquerdo
2. Selecione **Adicionar Rede**

![Adicionar nova rede no menu Metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-6.webp)

Em seguida, vÃ¡ para a parte inferior da pÃ¡gina e clique em **Adicionar rede manualmente**:

![Adicionar rede manualmente na Metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-7.webp)

Aqui, vocÃª pode configurar a MetaMask para as seguintes redes:

|         VariÃ¡vel          |                        Valor                        |
|:-------------------------:|:---------------------------------------------------:|
|       Nome da Rede        |             `Tanssi demo EVM appchain`              |
|          RPC URL          |    `{{ networks.dancelight.demo_evm_rpc_url }}`     |
|         Chain ID          |    `{{ networks.dancelight.demo_evm_chain_id }}`    |
|     SÃ­mbolo (Opcional)     |  `{{ networks.dancelight.demo_evm_token_symbol }}`  |
| Block Explorer (Opcional) | `{{ networks.dancelight.demo_evm_blockscout_url }}` |

Para fazer isso, preencha as seguintes informaÃ§Ãµes:

1. **Nome da rede** - nome que representa a rede Ã  qual vocÃª estÃ¡ se conectando
2. **RPC URL** - Endpoint RPC da rede
3. **Chain ID** - ID da cadeia da rede compatÃ­vel com Ethereum
4. **SÃ­mbolo** - (opcional) sÃ­mbolo do token nativo da rede
5. **Block Explorer** - (opcional) URL do block explorer
6. Depois de verificar todas as informaÃ§Ãµes, clique em **Salvar**
![Adicionar rede na Metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-8.webp)

Depois de adicionar a rede, vocÃª serÃ¡ redirecionado para uma tela informando que vocÃª adicionou uma rede com sucesso. AlÃ©m disso, vocÃª serÃ¡ solicitado a **Mudar para Tanssi demo EVM appchain**, a rede adicionada neste exemplo.

![Rede adicionada com sucesso na Metamask](/images/builders/toolkit/ethereum-api/wallets/metamask/metamask-9.webp)

## Interaja com a Rede {: #interact-with-network }

Depois de [conectar a Metamask](#connect-metamask-to-evm-network) Ã  sua rede EVM Tanssi, vocÃª pode comeÃ§ar a usar sua carteira por:

- Solicitando tokens {{ networks.dancelight.demo_evm_token_symbol }} do [demo EVM network faucet](/pt/builders/tanssi-network/testnet/demo-evm-network/#faucet)
- Enviando uma transferÃªncia de token para outro endereÃ§o
- Adicionando ERC-20s Ã  Metamask e interagindo com eles
- Adicionando ERC-721s Ã  Metamask e interagindo com eles

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/wallets/subwallet/
--- BEGIN CONTENT ---
---
title: Como Conectar a SubWallet Ã  Tanssi
description: Este guia mostra como conectar o SubWallet, uma carteira abrangente para Polkadot, Substrate e Ethereum, Ã  sua rede compatÃ­vel com EVM Powered by Tanssi.
icon: material-wallet-outline
categories: EVM-Template
---

# Interagindo com Sua Rede EVM Tanssi Usando o SubWallet

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores e usuÃ¡rios de redes EVM Powered by Tanssi tÃªm uma variedade de opÃ§Ãµes quando se trata de carteiras. GraÃ§as Ã  sua compatibilidade perfeita com o Ethereum, as redes EVM Tanssi suportam uma grande variedade de carteiras populares, incluindo SubWallet.

SubWallet Ã© uma carteira Web3 abrangente que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API do Ethereum, mas vocÃª pode consultar um [tutorial semelhante para interagir com o SubWallet usando a API do Substrate](/pt/builders/toolkit/substrate-api/wallets/subwallet/){target=\_blank}. A extensÃ£o da carteira do navegador SubWallet [pode ser baixada](https://www.subwallet.app/download.html){target=\_blank} para todos os navegadores suportados, incluindo Chrome, Brave, Firefox e MS Edge. O SubWallet tambÃ©m possui um aplicativo mÃ³vel para iOS e Android, mas isso estÃ¡ alÃ©m do escopo deste guia. Um painel de ativos online completo Ã© acessÃ­vel em [web.subwallet.app](https://web.subwallet.app){target=\_blank}.

Este guia leva vocÃª por todas as etapas necessÃ¡rias, desde a instalaÃ§Ã£o do SubWallet atÃ© a configuraÃ§Ã£o de uma carteira, conectando-a Ã  sua rede EVM Tanssi e enviando fundos.

## Criando Sua Primeira Conta Ethereum {: #creating-your-first-ethereum-account }

Primeiro, baixe e instale a [extensÃ£o SubWallet](https://www.subwallet.app/download.html){target=\_blank}. A criaÃ§Ã£o de uma nova conta gerarÃ¡ uma frase semente que pode derivar vÃ¡rias contas Ethereum e Substrate. Por padrÃ£o, o SubWallet gerarÃ¡ uma Ãºnica conta Ethereum e uma Ãºnica conta Substrate, mas vocÃª pode facilmente derivar mais da mesma frase semente. Clique em **Criar uma nova conta** para comeÃ§ar.

![Comece a usar o SubWallet](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-1.webp)

Na tela seguinte, vocÃª serÃ¡ solicitado a criar uma senha para proteger sua nova carteira.

![Crie uma senha para o SubWallet](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-2.webp)

VocÃª serÃ¡ solicitado a fazer backup de sua frase semente. Esta Ã© uma etapa importante, especialmente porque vocÃª tem a opÃ§Ã£o de, posteriormente, derivar contas adicionais desta frase semente.

![FaÃ§a backup de sua frase semente no SubWallet](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-3.webp)

!!! note
    VocÃª nunca deve compartilhar sua frase semente (mnemÃ´nico) ou chave privada com ninguÃ©m. Isso lhes dÃ¡ acesso direto aos seus fundos. Este guia Ã© apenas para fins educacionais.

## Importando uma Conta EVM Existente {: #importing-an-existing-evm-account }

Ã‰ claro que vocÃª pode importar uma conta EVM existente para o SubWallet. Para comeÃ§ar, siga estas etapas:

1. Pressione o botÃ£o **Todas as contas** na parte superior
2. Pressione o Ã­cone **Importar conta**

![Importar conta parte 1](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-4.webp)

Na tela seguinte, selecione o mÃ©todo pelo qual vocÃª gostaria de importar a conta existente.

![Importar conta existente parte 2](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-5.webp)

Na tela seguinte, vocÃª poderÃ¡ fornecer a frase semente relevante, a chave privada, o arquivo JSON ou o cÃ³digo QR, e poderÃ¡ comeÃ§ar a usar sua nova conta imediatamente.

## Configurando o SubWallet para Sua Rede EVM {: #configuring-subwallet-for-your-evm-network }

Para configurar o SubWallet para sua rede EVM Powered by Tanssi, pressione o Ã­cone **Mais opÃ§Ãµes** no canto superior esquerdo. Em seguida, clique em **Gerenciar redes**. Pressione o Ã­cone **+**. Na pÃ¡gina seguinte, vocÃª serÃ¡ solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstraÃ§Ã£o, a rede EVM de demonstraÃ§Ã£o Ã© usada aqui, mas vocÃª pode substituir esses detalhes pelos detalhes da sua prÃ³pria rede Tanssi. Para adicionar sua rede Tanssi ao SubWallet, siga estas etapas:

1. Cole a URL HTTPS RPC de sua rede Tanssi. A URL RPC da rede EVM de demonstraÃ§Ã£o Ã© `{{ networks.dancelight.demo_evm_rpc_url }}`. Outros parÃ¢metros serÃ£o preenchidos automaticamente
2. Cole a URL do block explorer de sua rede Tanssi. A URL do block explorer da rede EVM de demonstraÃ§Ã£o Ã© `{{ networks.dancelight.demo_evm_blockscout_url }}`
3. Pressione **Salvar**

![Adicione os Detalhes da Rede Alimentada pela Tanssi no SubWallet](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-6.webp)

Por padrÃ£o, todos os saldos sÃ£o ocultos no SubWallet, mas se vocÃª pressionar o Ã­cone de olho, poderÃ¡ alternar a visibilidade do saldo.

## Enviando Ativos em Sua Rede EVM {: #sending-assets-on-your-evm-network }

Para transferir o token nativo da sua rede Tanssi, siga estas etapas:

1. Especifique o ativo a ser enviado
2. Especifique a cadeia de destino (neste caso, a mesma cadeia da qual vocÃª estÃ¡ enviando)
3. Insira o endereÃ§o de destino
4. Insira o nÃºmero de tokens a serem enviados
5. Veja os detalhes da transaÃ§Ã£o e pressione **Transferir** e, em seguida, **Aprovar**

![Envie fundos em sua Rede EVM Tanssi](/images/builders/toolkit/ethereum-api/wallets/subwallet/subwallet-7.webp)

Este guia se concentrou especificamente na configuraÃ§Ã£o do SubWallet para trabalhar com sua rede EVM Tanssi, mas o SubWallet tambÃ©m Ã© uma carteira completa para contas Substrate (Polkadot). Na seÃ§Ã£o da API do Substrate, vocÃª encontrarÃ¡ um [guia semelhante para configurar o SubWallet para uso com sua rede Substrate](/pt/builders/toolkit/substrate-api/wallets/subwallet/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/ethereum-api/wallets/talisman/
--- BEGIN CONTENT ---
---
title: Como Conectar Talisman Ã  Tanssi
description: Este guia mostra como conectar o Talisman, uma carteira abrangente compatÃ­vel com Polkadot, Substrate e Ethereum, Ã  sua rede compatÃ­vel com EVM Powered by Tanssi.
icon: material-wallet-outline
categories: EVM-Template
---

# Interagindo com Sua Rede EVM Tanssi Usando Talisman

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores e usuÃ¡rios de redes EVM Powered by Tanssi tÃªm uma variedade de opÃ§Ãµes quando se trata de carteiras. GraÃ§as Ã  sua compatibilidade perfeita com o Ethereum, as redes EVM Tanssi suportam uma grande variedade de carteiras populares, como a Talisman.

A Talisman Ã© uma carteira Web3 que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API Ethereum, mas vocÃª pode conferir um [tutorial semelhante para interagir com a Talisman usando a API Substrate](/pt/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank}. A extensÃ£o de navegador da carteira Talisman estÃ¡ disponÃ­vel no [Google Chrome](https://chromewebstore.google.com/detail/talisman-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld){target=\_blank} e [Brave](https://chromewebstore.google.com/detail/talisman-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld){target=\_blank}, e um painel de ativos correspondente estÃ¡ acessÃ­vel em [app.talisman.xyz](https://app.talisman.xyz){target=\_blank}

Este guia leva vocÃª por todas as etapas necessÃ¡rias, desde a instalaÃ§Ã£o do Talisman atÃ© a configuraÃ§Ã£o de uma carteira, conectando-a Ã  sua rede EVM Tanssi e enviando fundos.

## Configurando o Talisman {: #setting-up-talisman }

Primeiro, baixe e instale a [extensÃ£o Talisman](https://talisman.xyz/){target=\_blank}. Este guia cobrirÃ¡ primeiro a criaÃ§Ã£o de uma nova carteira e, posteriormente, abordarÃ¡ a importaÃ§Ã£o de uma existente. Revise os termos e condiÃ§Ãµes e, em seguida, pressione **ComeÃ§ar**.

![Comece com Talisman](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-1.webp)

Na tela seguinte, vocÃª serÃ¡ solicitado a criar uma senha para proteger sua nova carteira.

![Insira a senha para a Carteira Talisman](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-2.webp)

## Criando uma Conta Ethereum {: #creating-an-ethereum-account }

Para criar sua primeira conta Ethereum, siga as seguintes etapas:

1. Selecione a opÃ§Ã£o **Ethereum**
2. DÃª um nome Ã  sua conta
3. Pressione **Criar**

![Crie sua primeira conta Ethereum no Talisman](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-3.webp)

ApÃ³s criar sua primeira conta, vocÃª serÃ¡ solicitado a fazer backup de sua frase de semente. Esta Ã© uma etapa importante, especialmente porque vocÃª tem a opÃ§Ã£o de derivar posteriormente contas adicionais dessa frase de semente.

![FaÃ§a backup de sua frase de semente](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-4.webp)

!!! note
    VocÃª nunca deve compartilhar sua frase de semente (mnemÃ´nico) ou chave privada com ninguÃ©m. Isso lhes dÃ¡ acesso direto aos seus fundos. Este guia Ã© apenas para fins educacionais.

## Importando uma Conta EVM Existente {: #importing-an-existing-evm-account }

Ã‰ claro que vocÃª pode importar uma conta EVM existente para o Talisman. Para fazer isso, siga as seguintes etapas:

1. Pressione **Adicionar conta**
2. Pressione **Importar**
3. Selecione **Importar via frase de recuperaÃ§Ã£o** (observe que isso funciona para sementes e chaves privadas)

![ConfiguraÃ§Ã£o de importaÃ§Ã£o de conta existente](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-9.webp)

Na tela seguinte, siga as seguintes etapas:

1. Selecione o tipo de conta **Ethereum**
2. ForneÃ§a um nome para sua conta
3. Cole sua semente ou chave privada
4. Se vocÃª importou uma frase de semente mnemÃ´nica na etapa anterior, selecione quais contas vocÃª gostaria de importar
5. Pressione **Importar**

![Etapas finais de importaÃ§Ã£o de conta existente](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-10.webp)

## Configurando o Talisman para Sua Rede EVM {: #configuring-talisman-for-your-evm-network }

Para configurar o Talisman para sua rede EVM Tanssi, abra a extensÃ£o Talisman e clique na guia **Mais OpÃ§Ãµes**. Em seguida, siga as seguintes etapas:

1. Selecione **ConfiguraÃ§Ãµes**
2. Marque a caixa **Habilitar testnets**
3. Pressione **Adicionar Rede**

![Adicionar Rede no Talisman](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-6.webp)

Na pÃ¡gina seguinte, vocÃª serÃ¡ solicitado a inserir os detalhes da rede para sua rede Powered by Tanssi. Para fins de demonstraÃ§Ã£o, a rede EVM de demonstraÃ§Ã£o Ã© usada aqui, mas vocÃª pode substituir esses detalhes por sua prÃ³pria rede. Para adicionar sua rede ao Talisman, siga as seguintes etapas:

1. Cole a URL RPC da sua rede Powered by Tanssi. A URL RPC da rede EVM de demonstraÃ§Ã£o Ã© `{{ networks.dancelight.demo_evm_rpc_url }}`. Outros parÃ¢metros serÃ£o preenchidos automaticamente
2. Cole a URL do block explorer da sua rede Powered by Tanssi. A URL do block explorer da rede EVM de demonstraÃ§Ã£o Ã© `{{ networks.dancelight.demo_evm_blockscout_url }}`
3. Marque a caixa **Esta Ã© uma testnet**, se aplicÃ¡vel
4. Pressione **Adicionar Rede**

![Adicione os Detalhes da Sua Rede Alimentada por Tanssi](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-7.webp)

Se vocÃª tiver um saldo de tokens em sua conta recÃ©m-criada para sua rede, verÃ¡ o saldo no painel Talisman.

## Enviando Ativos em Sua Rede EVM {: #sending-assets-on-your-evm-network }

Para transferir o token nativo da sua rede Tanssi, siga as seguintes etapas:

1. Clique no Ã­cone **Enviar**
2. Clique na conta **Enviar de** desejada
3. Digite o endereÃ§o de destino
4. Digite a quantidade de tokens a serem enviados
5. Revise os detalhes da transaÃ§Ã£o e, em seguida, pressione **Revisar** e, posteriormente, **Confirmar**

![Envie fundos em sua rede EVM](/images/builders/toolkit/ethereum-api/wallets/talisman/talisman-8.webp)

Este guia se concentrou especificamente na configuraÃ§Ã£o do Talisman para trabalhar com sua rede EVM Powered by Tanssi, mas o Talisman tambÃ©m Ã© uma carteira completa para contas Substrate (Polkadot). Na seÃ§Ã£o da API Substrate, vocÃª encontrarÃ¡ um tutorial semelhante para configurar o Talisman para trabalhar com cadeias baseadas em Substrate.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/
--- BEGIN CONTENT ---
---
title: Guias para Desenvolvimento de DApps
description: Mergulhe em tutoriais, ferramentas e recursos projetados para otimizar o processo de desenvolvimento ao construir dApps na Tanssi e redes baseadas em Tanssi.
icon: octicons-tools-24
template: index-page.html
---

# Kit de Ferramentas

A seÃ§Ã£o Toolkit Ã© o seu centro de recursos completo para construir, implantar e gerenciar redes baseadas em Tanssi. Ela reÃºne ferramentas Ethereum e Substrate, como bibliotecas, ambientes de desenvolvimento, precompiles, mÃ©todos JSON-RPC e muito mais. Seja aprimorando uma rede existente ou implementando novos recursos, este kit de ferramentas oferece tudo o que vocÃª precisa para simplificar o desenvolvimento e a operaÃ§Ã£o da sua rede.

!!! tip
    Se vocÃª estiver trabalhando com uma rede compatÃ­vel com EVM, pode usar as ferramentas Substrate para interagir com as funcionalidades de baixo nÃ­vel da sua rede. Com isso, vocÃª pode interagir com mÃ³dulos de Runtime personalizados, consultar o armazenamento, gerenciar a governanÃ§a ou trabalhar com recursos exclusivos do Substrate.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/
--- BEGIN CONTENT ---
---
title: IntegraÃ§Ãµes
description: Descubra algumas das integraÃ§Ãµes disponÃ­veis, prontas para integrar e estender perfeitamente a funcionalidade de seus aplicativos nas redes Tanssi EVM ou Substrate.
icon: octicons-package-24
template: index-page.html
---

# IntegraÃ§Ãµes

Descubra integraÃ§Ãµes que permitem estender a funcionalidade de seus dApps desenvolvidos com Tanssi. Essas integraÃ§Ãµes permitem a interaÃ§Ã£o perfeita com fontes de dados externas, aprimoram a experiÃªncia do usuÃ¡rio e habilitam recursos avanÃ§ados como feeds de dados on-chain, anÃ¡lise e suporte a carteiras.

Pronto para comeÃ§ar a construir? Confira as seguintes integraÃ§Ãµes:

- **Oracles** - [Acurast](/pt/builders/toolkit/integrations/oracles/acurast/), [Band](/pt/builders/toolkit/integrations/oracles/band/) e [Phala](/pt/builders/toolkit/integrations/oracles/phala/)
- **Indexadores** - [SQD](/pt/builders/toolkit/integrations/indexers/sqd/quick-start/)
- **Carteiras** - [RainbowKit](/pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/)

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/indexers/
--- BEGIN CONTENT ---
---
title: Indexadores de Dados de Blockchain EVM
description: Aprenda a usar indexadores de blockchain para ingerir, processar, refinar e consultar dados do Ethereum (EVM) em sua rede compatÃ­vel com EVM Powered by Tanssi.
icon: octicons-codescan-24
template: index-page.html
---

# Indexadores

Os indexadores permitem a ingestÃ£o, o processamento e a consulta eficientes de dados de blockchain, fornecendo aos desenvolvedores ferramentas poderosas para criar aplicaÃ§Ãµes responsivas e ricas em dados em redes Powered by Tanssi.

As principais caracterÃ­sticas dos indexadores incluem:

- **Velocidade de acesso a dados aprimorada** - consulta mais rÃ¡pida de dados na cadeia, organizando e indexando-os, permitindo tempos de recuperaÃ§Ã£o mais rÃ¡pidos
- **AgregaÃ§Ã£o de dados** - ingerir e transformar dados que sÃ£o mais fÃ¡ceis de consultar e trabalhar com grandes quantidades de dados
- **Capacidades de consulta aprimoradas** - usar mÃ©todos de consulta sofisticados, como filtragem, classificaÃ§Ã£o e paginaÃ§Ã£o
- **AtualizaÃ§Ãµes de dados em tempo real** - a sincronizaÃ§Ã£o com o blockchain permite que as aplicaÃ§Ãµes acessem as informaÃ§Ãµes mais recentes assim que estiverem disponÃ­veis

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/
--- BEGIN CONTENT ---
---
title: Indexar TransferÃªncias ERC-20 em uma Rede EVM
description: Aprenda a usar o Squid SDK, um framework de query node que indexa dados Substrate e EVM, para processar dados on-chain da sua rede powered by Tanssi.
icon: octicons-arrow-switch-24
categories: EVM-Template
---

# Indexando TransferÃªncias ERC-20 em uma Rede EVM da Tanssi

## IntroduÃ§Ã£o {: #introduction }

[SQD](https://www.sqd.ai/){target=\_blank} Ã© uma rede de dados que permite recuperar informaÃ§Ãµes de blockchain de mais de 100 cadeias de forma rÃ¡pida e econÃ´mica usando o data lake descentralizado da SQD e seu SDK open source. Em termos simples, o SQD funciona como uma ferramenta ETL (extract, transform, load) com um servidor [GraphQL](https://graphql.org){target=\_blank} incluÃ­do, permitindo filtragem, paginaÃ§Ã£o e atÃ© busca full-text.

O SQD tem suporte nativo e completo para dados EVM e Substrate, oferecendo um Archive e um Processor para cada. O Substrate Archive e o Processor podem indexar dados Substrate e EVM, permitindo extrair dados on-chain de qualquer rede powered by Tanssi e processar logs EVM e entidades Substrate (eventos, extrÃ­nsecos e itens de armazenamento) em um Ãºnico projeto, servindo tudo em um Ãºnico endpoint GraphQL. Se quiser indexar apenas dados EVM, use o EVM Archive e o Processor.

Este tutorial passo a passo mostra como construir um Squid para indexar dados EVM do inÃ­cio ao fim. O ideal Ã© seguir cada passo, mas vocÃª tambÃ©m pode conferir a [versÃ£o completa do Squid deste tutorial no repositÃ³rio tanssiSquid](https://github.com/themacexpert/tanssiSquid){target=\_blank}.

## Verificar PrÃ©-requisitos {: #check-prerequisites }

Para acompanhar este tutorial, vocÃª precisarÃ¡ de:

- [Docker instalado](https://docs.docker.com/get-started/get-docker/){target=\_blank}
- [Docker Compose instalado](https://docs.docker.com/compose/install){target=\_blank}
- Um projeto Hardhat vazio. Para instruÃ§Ãµes passo a passo, veja a seÃ§Ã£o [Criando um Projeto Hardhat](/pt/builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project){target=\_blank} na nossa documentaÃ§Ã£o do Hardhat

!!! note
    Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessÃ¡rio.
    
    Verifique tambÃ©m se vocÃª tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a [documentaÃ§Ã£o oficial](https://nodejs.org/en/download){target=\blank}.
    
    AlÃ©m disso, certifique-se de ter inicializado um arquivo `package.json` para mÃ³dulos ES6. VocÃª pode criar um `package.json` padrÃ£o com npm executando `npm init --yes`.

## Implantar um ERC-20 com Hardhat {: #deploy-an-erc20-with-hardhat }

Antes de indexar qualquer coisa com o SQD, precisamos ter algo para indexar! Esta seÃ§Ã£o mostra como implantar um token ERC-20 na sua rede com Tanssi para, em seguida, indexÃ¡-lo. VocÃª pode pular para [Criar um Projeto Squid](#create-a-squid-project) se:

- JÃ¡ implantou um token ERC-20 na sua rede (e fez vÃ¡rias transferÃªncias)
- Prefere usar um token ERC-20 jÃ¡ implantado na rede EVM de demonstraÃ§Ã£o (hÃ¡ vÃ¡rios eventos de transferÃªncia lÃ¡)

Se quiser usar um token existente na rede EVM de demonstraÃ§Ã£o, use o contrato `MyTok.sol` abaixo. Os hashes de transferÃªncias tambÃ©m sÃ£o fornecidos para ajudar na depuraÃ§Ã£o.

Nesta seÃ§Ã£o, vamos implantar um ERC-20 na sua rede EVM e criar um script rÃ¡pido para disparar uma sÃ©rie de transferÃªncias que serÃ£o capturadas pelo indexador SQD. Certifique-se de ter inicializado um projeto Hardhat vazio conforme as instruÃ§Ãµes em [Criando um Projeto Hardhat](/pt/builders/toolkit/ethereum-api/dev-env/hardhat/#creating-a-hardhat-project){target=\_blank}.

Antes de criar o projeto, instale algumas dependÃªncias: o [plugin Hardhat Ethers](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-ethers){target=\_blank} e os [contratos OpenZeppelin](https://docs.openzeppelin.com/contracts/4.x){target=\_blank}. O plugin Hardhat Ethers facilita o uso da biblioteca [Ethers](/pt/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank} para interagir com a rede. Usaremos a implementaÃ§Ã£o base ERC-20 do OpenZeppelin para criar o token. Para instalar as dependÃªncias:

=== "npm"

    ```bash
    npm install @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts
    ```

=== "yarn"

    ```bash
    yarn add @nomicfoundation/hardhat-ethers ethers @openzeppelin/contracts
    ```

Agora edite `hardhat.config.js` para incluir as configuraÃ§Ãµes de rede e conta. Substitua os valores da rede EVM de demonstraÃ§Ã£o pelos parÃ¢metros da sua rede powered by Tanssi, que podem ser encontrados em [apps.tanssi.network](https://apps.tanssi.network){target=\_blank}.

???+ code "hardhat.config.js"

    ```js
    // 1. Import the Ethers plugin required to interact with the contract
require('@nomicfoundation/hardhat-ethers');

// 2. Add your private key that is funded with tokens of your Tanssi-powered network
// This is for example purposes only - **never store your private keys in a JavaScript file**
const privateKey = 'INSERT_PRIVATE_KEY';

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  // 3. Specify the Solidity version
  solidity: '0.8.20',
  networks: {
    // 4. Add the network specification for your Tanssi EVM network
    demo: {
      url: 'https://services.tanssi-testnet.network/dancelight-2001/',
      chainId: 5678, // Fill in the EVM ChainID for your Tanssi-powered network
      accounts: [privateKey],
    },
  },
};
    ```

!!! remember
    Nunca armazene suas chaves privadas em arquivos JavaScript ou Python. Fazemos isso aqui apenas para fins de demonstraÃ§Ã£o. Use sempre um gerenciador de segredos ou serviÃ§o similar.

### Criar um contrato ERC-20 {: #create-an-erc-20-contract }

Para este tutorial, criaremos um contrato ERC-20 simples, usando a implementaÃ§Ã£o base do OpenZeppelin. Crie o arquivo do contrato `MyTok.sol`:

```bash
mkdir -p contracts && touch contracts/MyTok.sol
```

Agora edite `MyTok.sol` para incluir o contrato abaixo, que cunha uma oferta inicial de MYTOKs e permite que apenas o owner do contrato cunhe mais tokens:

???+ code "MyTok.sol"

    ```solidity
    // SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyTok is ERC20, Ownable {
    constructor() ERC20("MyToken", "MTK") Ownable(msg.sender) {
        _mint(msg.sender, 50000 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
    ```

### Implantar o Contrato ERC-20 {: #deploy-erc-20-contract }

Com o contrato pronto, podemos compilÃ¡-lo e implantÃ¡-lo.

Para compilar:

```bash
npx hardhat compile
```

![Compilar contratos no Hardhat](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-1.webp)

Esse comando compila o contrato e gera o diretÃ³rio `artifacts` contendo o ABI.

Para implantar, criaremos um script que faz o deploy do contrato ERC-20 e cunha uma oferta inicial de 1000 MYTOK usando a conta da Alith. A oferta inicial serÃ¡ enviada ao owner do contrato (Alith).

Siga os passos:

1. Crie o diretÃ³rio e o arquivo do script:

    ```bash
    mkdir -p scripts && touch scripts/deploy.js
    ```

2. No arquivo `deploy.js`, adicione:

    ???+ code "deploy.js"

        ```ts
        // scripts/deploy.js
const hre = require('hardhat');
require('@nomicfoundation/hardhat-ethers');

async function main() {
  // Get ERC-20 contract
  const MyTok = await hre.ethers.getContractFactory('MyTok');

  // Define custom gas price and gas limit
  // This is a temporary stopgap solution to a bug
  const customGasPrice = 50000000000; // example for 50 gwei
  const customGasLimit = 5000000; // example gas limit

  // Deploy the contract providing a gas price and gas limit
  const myTok = await MyTok.deploy({
    gasPrice: customGasPrice,
    gasLimit: customGasLimit,
  });

  // Wait for the deployment
  await myTok.waitForDeployment();

  console.log(`Contract deployed to ${myTok.target}`);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
        ```

3. Execute o script usando a configuraÃ§Ã£o da rede `demo` definida em `hardhat.config.js`:

    ```bash
    npx hardhat run scripts/deploy.js --network demo
    ```

O endereÃ§o do contrato implantado serÃ¡ exibido no terminal. Guarde-o; precisaremos dele para interagir com o contrato na prÃ³xima seÃ§Ã£o.

### Transferir ERC-20s {: #transfer-erc-20s }

Como vamos indexar eventos `Transfer`, enviaremos algumas transaÃ§Ãµes transferindo tokens da conta de Alith para outras contas de teste. Criaremos um script simples que transfere 10 MYTOKs para Baltathar, Charleth, Dorothy e Ethan. Siga:

Crie um novo script para enviar transaÃ§Ãµes:

```bash
touch scripts/transactions.js
```

No arquivo `transactions.js`, adicione o script abaixo e insira o endereÃ§o do contrato MyTok implantado (exibido no passo anterior):

???+ code "transactions.js"

    ```ts
    // We require the Hardhat Runtime Environment explicitly here. This is optional
// but useful for running the script in a standalone fashion through `node <script>`.
//
// You can also run a script with `npx hardhat run <script>`. If you do that, Hardhat
// will compile your contracts, add the Hardhat Runtime Environment's members to the
// global scope, and execute the script.
const hre = require('hardhat');

async function main() {
  // Get Contract ABI
  const MyTok = await hre.ethers.getContractFactory('MyTok');

  // Define custom gas price and gas limit
  // Gas price is typically specified in 'wei' and gas limit is just a number
  // You can use Ethers.js utility functions to convert from gwei or ether if needed
  const customGasPrice = 50000000000; // example for 50 gwei
  const customGasLimit = 5000000; // example gas limit

  // Plug ABI to address
  const myTok = await MyTok.attach('INSERT_CONTRACT_ADDRESS');

  const value = 100000000000000000n;

  let tx;
  // Transfer to Baltathar
  tx = await myTok.transfer(
    '0x3Cd0A705a2DC65e5b1E1205896BaA2be8A07c6e0',
    value,
    {
      gasPrice: customGasPrice,
      gasLimit: customGasLimit,
    }
  );
  await tx.wait();
  console.log(`Transfer to Baltathar with TxHash ${tx.hash}`);

  // Transfer to Charleth
  tx = await myTok.transfer(
    '0x798d4Ba9baf0064Ec19eB4F0a1a45785ae9D6DFc',
    value,
    {
      gasPrice: customGasPrice,
      gasLimit: customGasLimit,
    }
  );
  await tx.wait();
  console.log(`Transfer to Charleth with TxHash ${tx.hash}`);

  // Transfer to Dorothy
  tx = await myTok.transfer(
    '0x773539d4Ac0e786233D90A233654ccEE26a613D9',
    value,
    {
      gasPrice: customGasPrice,
      gasLimit: customGasLimit,
    }
  );
  await tx.wait();
  console.log(`Transfer to Dorothy with TxHash ${tx.hash}`);

  // Transfer to Ethan
  tx = await myTok.transfer(
    '0xFf64d3F6efE2317EE2807d223a0Bdc4c0c49dfDB',
    value,
    {
      gasPrice: customGasPrice,
      gasLimit: customGasLimit,
    }
  );
  await tx.wait();
  console.log(`Transfer to Ethan with TxHash ${tx.hash}`);
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
    ```

Execute o script para enviar as transaÃ§Ãµes:

```bash
npx hardhat run scripts/transactions.js --network demo
```

Cada transaÃ§Ã£o enviarÃ¡ um log para o terminal.

![Enviar transaÃ§Ãµes usando Hardhat](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-2.webp)

Agora podemos criar o Squid para indexar os dados no nÃ³ local de desenvolvimento.

## Criar um Projeto Squid {: #create-a-squid-project }

Vamos criar o projeto Subquid. Primeiro, instale o [Squid CLI](https://docs.sqd.ai/squid-cli/){target=\_blank}:

```bash
npm i -g @subsquid/cli@latest
```

Para verificar a instalaÃ§Ã£o:

```bash
sqd --version
```

Agora podemos usar o comando `sqd` no projeto. Para criÃ¡-lo, usaremos o flag `--template` (`-t`) e o template EVM Squid, que Ã© um projeto inicial para indexar cadeias EVM.

Execute o comando para criar um EVM Squid chamado `tanssi-squid`:

```bash
sqd init tanssi-squid --template evm
```

Isso criarÃ¡ um Squid com todas as dependÃªncias. Instale-as:

```bash
cd tanssi-squid && npm ci
```

Com o ponto de partida pronto, vamos configurar o projeto para indexar eventos `Transfer` do ERC-20 na nossa rede Tanssi.

##  Configurar o Indexador para TransferÃªncias ERC-20 {: #set-up-the-indexer-for-erc-20-transfers}

Para indexar transferÃªncias ERC-20, faremos:

1. Definir o schema do banco e gerar as classes de entidades
2. Usar o ABI do contrato `ERC20` para gerar classes de interface TypeScript
3. Configurar o processor especificando exatamente quais dados ingerir
4. Transformar os dados e inseri-los em um banco TypeORM em `main.ts`
5. Rodar o indexador e consultar o squid

Primeiro, defina o schema para os dados de transferÃªncia. Edite o arquivo `schema.graphql` (na raiz) e crie as entidades `Transfer` e `Account`. Copie o schema abaixo, removendo qualquer schema existente.

???+ code "schema.graphql"

    ```graphql
    type Account @entity {
  "Account address"
  id: ID!
  transfersFrom: [Transfer!] @derivedFrom(field: "from")
  transfersTo: [Transfer!] @derivedFrom(field: "to")
}

type Transfer @entity {
  id: ID!
  blockNumber: Int!
  timestamp: DateTime!
  txHash: String!
  from: Account!
  to: Account!
  amount: BigInt!
}
    ```

Agora gere as classes de entidades a partir do schema (criadas em `src/model/generated`):

```bash
sqd codegen
```

No prÃ³ximo passo, usaremos o ABI do ERC-20 para gerar classes de interface TypeScript. Abaixo hÃ¡ um ABI padrÃ£o do ERC-20. Copie-o para um arquivo `erc20.json` na pasta `abi` na raiz do projeto.

??? code "ERC-20 ABI"

    ```json
    [
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_spender",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_from",
        "type": "address"
      },
      {
        "name": "_to",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "name": "",
        "type": "uint8"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "name": "balance",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "name": "",
        "type": "string"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_to",
        "type": "address"
      },
      {
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "name": "",
        "type": "bool"
      }
    ],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      },
      {
        "name": "_spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "name": "",
        "type": "uint256"
      }
    ],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "payable": true,
    "stateMutability": "payable",
    "type": "fallback"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  }
]
    ```

Em seguida, use o ABI para gerar as interfaces TypeScript:

```bash
sqd typegen
```

![Executar comandos do Squid](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-3.webp)

Isso gera as classes em `src/abi/erc20.ts`. Neste tutorial, usaremos os `events`.

### Configurar o Processor {: #configure-the-processor}

O arquivo `processor.ts` indica ao SQD quais dados ingerir. A transformaÃ§Ã£o virÃ¡ depois. Em `processor.ts`, precisamos indicar fonte de dados, endereÃ§o do contrato, evento(s) a indexar e intervalo de blocos.

Abra `src/processor.ts`. Primeiro, informe ao processor qual contrato nos interessa. Crie a constante do endereÃ§o assim:

```ts
export const CONTRACT_ADDRESS = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();
```

O `.toLowerCase()` Ã© fundamental porque o processor diferencia maiÃºsculas/minÃºsculas e alguns explorers exibem endereÃ§os com capitalizaÃ§Ã£o. Em seguida, localize `export const processor = new EvmBatchProcessor()` seguido de `.setDataSource`. Faremos algumas alteraÃ§Ãµes. O SQD tem [archives disponÃ­veis para vÃ¡rias cadeias](https://docs.sqd.ai/subsquid-network/reference/networks/){target=\_blank} que aceleram a obtenÃ§Ã£o de dados, mas Ã© improvÃ¡vel que sua rede jÃ¡ tenha um archive hospedado. Sem problema: o SQD pode obter os dados via RPC da sua rede. Comente ou remova a linha do archive. O cÃ³digo deve ficar assim:

```ts
.setDataSource({
  chain: {
    url: assertNotNull(
      '{{ networks.dancelight.demo_evm_rpc_url }}'
    ),
    rateLimit: 300,
  },
})
```

O template vem com uma variÃ¡vel para a URL RPC no `.env`. VocÃª pode substituir pela URL da sua rede. Para demonstraÃ§Ã£o, a URL da rede EVM de teste estÃ¡ hardcoded acima. Se preferir definir no `.env`, a linha ficarÃ¡:

```text
RPC_ENDPOINT={{ networks.dancelight.demo_evm_rpc_url }}
```

Agora defina o evento a indexar:

```ts
.addLog({
  address: [contractAddress],
  topic0: [erc20.events.Transfer.topic],
  transaction: true,
})
```

O evento `Transfer` estÃ¡ em `erc20.ts`, gerado pelo `sqd typegen`. O import `import * as erc20 from './abi/erc20'` jÃ¡ vem no template.

O intervalo de blocos Ã© importante para restringir o escopo. Por exemplo, se vocÃª implantou o ERC-20 no bloco `650000`, nÃ£o hÃ¡ motivo para consultar blocos anteriores. Definir um intervalo preciso melhora a performance do indexador. Configure o bloco inicial assim:

```ts
.setBlockRange({from: 632400,})
```

O bloco escolhido corresponde ao inÃ­cio relevante na rede EVM de demonstraÃ§Ã£o; troque para o bloco adequado Ã  sua rede.

Altere `setFields` para especificar os dados a ingerir:

```ts
.setFields({
  log: {
    topics: true,
    data: true,
  },
  transaction: {
    hash: true,
  },
})
```

TambÃ©m adicione estes imports em `processor.ts`:

```ts
import { Store } from '@subsquid/typeorm-store';
import * as erc20 from './abi/erc20';
```

ApÃ³s concluir, seu `processor.ts` deve estar parecido com:

???+ code "processor.ts"

    ```ts
    import { assertNotNull } from '@subsquid/util-internal';
import {
  BlockHeader,
  DataHandlerContext,
  EvmBatchProcessor,
  EvmBatchProcessorFields,
  Log as _Log,
  Transaction as _Transaction,
} from '@subsquid/evm-processor';
import { Store } from '@subsquid/typeorm-store';
import * as erc20 from './abi/erc20';

// Here you'll need to import the contract
export const contractAddress = 'INSERT_CONTRACT_ADDRESS'.toLowerCase();

export const processor = new EvmBatchProcessor()
  .setDataSource({
    chain: {
      url: assertNotNull(
        'https://services.tanssi-testnet.network/dancelight-2001'
      ),
      rateLimit: 300,
    },
  })
  .setFinalityConfirmation(10)
  .setFields({
    log: {
      topics: true,
      data: true,
    },
    transaction: {
      hash: true,
    },
  })
  .addLog({
    address: [contractAddress],
    topic0: [erc20.events.Transfer.topic],
    transaction: true,
  })
  .setBlockRange({
    from: INSERT_START_BLOCK, // Note the lack of quotes here
  });

export type Fields = EvmBatchProcessorFields<typeof processor>;
export type Block = BlockHeader<Fields>;
export type Log = _Log<Fields>;
export type Transaction = _Transaction<Fields>;
    ```

### Transformar e Salvar os Dados {: #transform-and-save-the-data}

Enquanto `processor.ts` define o que Ã© consumido, `main.ts` define como processar e transformar os dados. Em resumo, processamos os dados ingeridos pelo processor e inserimos os trechos desejados em um banco TypeORM. Para detalhes, consulte a [documentaÃ§Ã£o SQD sobre desenvolvimento de Squid](https://docs.sqd.ai/sdk/how-to-start/squid-development/){target=\_blank}.

O `main.ts` vai percorrer cada bloco processado em busca de eventos `Transfer` e decodificar detalhes como remetente, destinatÃ¡rio e valor. Ele tambÃ©m busca detalhes de contas e cria objetos de transferÃªncia com os dados extraÃ­dos, inserindo-os no TypeORM para consulta fÃ¡cil. Em ordem:

1. `main.ts` roda o processor e refina os dados coletados. Em `processor.run`, o processor percorre os blocos selecionados e busca logs de `Transfer`, armazenando-os em um array de eventos de transferÃªncia para processamento posterior
2. A interface `transferEvent` define a estrutura que guarda os dados extraÃ­dos dos logs
3. `getTransfer` Ã© um helper que extrai e decodifica dados do evento `Transfer` de um log, retornando um objeto `TransferEvent` com ID da transaÃ§Ã£o, nÃºmero do bloco, remetente, destinatÃ¡rio e valor. Ã‰ chamado ao armazenar os eventos relevantes no array
4. `processTransfers` enriquece os dados e insere os registros no banco TypeORM usando `ctx.store`. O Template `account`, embora nÃ£o estritamente necessÃ¡rio, permite introduzir outra entidade no schema para demonstrar mÃºltiplas entidades no Squid
5. `getAccount` Ã© um helper que recupera/cria objetos de conta. Dado um ID e um mapa de contas existentes, retorna a conta correspondente; se nÃ£o existir, cria, adiciona ao mapa e retorna

Mostraremos uma query de exemplo adiante. Copie o cÃ³digo abaixo para `main.ts`:

???+ code "main.ts"

    ```ts
    import { In } from 'typeorm';
import { assertNotNull } from '@subsquid/evm-processor';
import { TypeormDatabase } from '@subsquid/typeorm-store';
import * as erc20 from './abi/erc20';
import { Account, Transfer } from './model';
import {
  Block,
  contractAddress,
  Log,
  Transaction,
  processor,
} from './processor';

// 1. Iterate through all selected blocks and look for transfer events,
// storing the relevant events in an array of transfer events
processor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) => {
  let transfers: TransferEvent[] = [];

  for (let block of ctx.blocks) {
    for (let log of block.logs) {
      if (
        log.address === contractAddress &&
        log.topics[0] === erc20.events.Transfer.topic
      ) {
        transfers.push(getTransfer(ctx, log));
      }
    }
  }

  await processTransfers(ctx, transfers);
});

// 2. Define an interface to hold the data from the transfer events
interface TransferEvent {
  id: string;
  block: Block;
  transaction: Transaction;
  from: string;
  to: string;
  amount: bigint;
}

// 3. Extract and decode ERC-20 transfer event data from a log entry
function getTransfer(ctx: any, log: Log): TransferEvent {
  let event = erc20.events.Transfer.decode(log);

  let from = event.from.toLowerCase();
  let to = event.to.toLowerCase();
  let amount = event.value;

  let transaction = assertNotNull(log.transaction, `Missing transaction`);

  return {
    id: log.id,
    block: log.block,
    transaction,
    from,
    to,
    amount,
  };
}

// 4. Enrich and insert data into typeorm database
async function processTransfers(ctx: any, transfersData: TransferEvent[]) {
  let accountIds = new Set<string>();
  for (let t of transfersData) {
    accountIds.add(t.from);
    accountIds.add(t.to);
  }

  let accounts = await ctx.store
    .findBy(Account, { id: In([...accountIds]) })
    .then((q: any[]) => new Map(q.map((i: any) => [i.id, i])));

  let transfers: Transfer[] = [];

  for (let t of transfersData) {
    let { id, block, transaction, amount } = t;

    let from = getAccount(accounts, t.from);
    let to = getAccount(accounts, t.to);

    transfers.push(
      new Transfer({
        id,
        blockNumber: block.height,
        timestamp: new Date(block.timestamp),
        txHash: transaction.hash,
        from,
        to,
        amount,
      })
    );
  }

  await ctx.store.upsert(Array.from(accounts.values()));
  await ctx.store.insert(transfers);
}

// 5. Helper function to get account object
function getAccount(m: Map<string, Account>, id: string): Account {
  let acc = m.get(id);
  if (acc == null) {
    acc = new Account();
    acc.id = id;
    m.set(id, acc);
  }
  return acc;
}
    ```

Pronto, jÃ¡ podemos rodar o indexador!

### Rodar o Indexador {: #run-the-indexer }

Para rodar, execute a sequÃªncia de comandos `sqd`:

Compile o projeto:

```bash
sqd build
```

Suba o banco:

```bash
sqd up
```

Remova o arquivo de migration que vem com o template EVM e gere um novo para nosso schema:

```bash
sqd migration:generate
```

```bash
sqd migration:apply
```

Inicie o processor:

```bash
sqd process
```

No terminal, vocÃª verÃ¡ o indexador comeÃ§ando a processar blocos!

![Executar o Squid](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-4.webp)

## Consultar o Squid {: #query-your-squid }

Para consultar o squid, abra um novo terminal no projeto e rode:

```bash
sqd serve
```

Pronto! Agora vocÃª pode fazer queries no playground GraphQL em `http://localhost:4350/graphql`. Crie sua prÃ³pria query ou use a abaixo:

???+ code "Exemplo de query"

    ```ts
    query {
  accounts {
    id
    transfersFrom {
      id
      blockNumber
      timestamp
      txHash
      to {
        id
      }
      amount
    }
    transfersTo {
      id
      blockNumber
      timestamp
      txHash
      from {
        id
      }
      amount
    }
  }
}
    ```

![Executando queries no GraphQL playground](/images/builders/toolkit/integrations/indexers/sqd/erc20-transfers/sqd-5.webp)

## Depurar o Squid {: #debug-your-squid }

Pode parecer difÃ­cil depurar erros ao construir o Squid, mas hÃ¡ tÃ©cnicas para facilitar. Primeiro, se encontrar erros, habilite o modo debug no `.env` descomentando a linha de debug. Isso gera logs bem mais verbosos e ajuda a localizar o problema.

```text
# Descomentar a linha abaixo habilita o modo debug
SQD_DEBUG=*
```

VocÃª tambÃ©m pode adicionar logs diretamente em `main.ts` para indicar parÃ¢metros especÃ­ficos, como altura de bloco. Por exemplo, veja esta versÃ£o de `main.ts` com logging detalhado:

??? code "main.ts"

    ```ts
    import { In } from 'typeorm';
import { assertNotNull } from '@subsquid/evm-processor';
import { TypeormDatabase } from '@subsquid/typeorm-store';
import * as erc20 from './abi/erc20';
import { Account, Transfer } from './model';
import {
  Block,
  contractAddress,
  Log,
  Transaction,
  processor,
} from './processor';

processor.run(new TypeormDatabase({ supportHotBlocks: true }), async (ctx) => {
  ctx.log.info('Processor started');
  let transfers: TransferEvent[] = [];

  ctx.log.info(`Processing ${ctx.blocks.length} blocks`);
  for (let block of ctx.blocks) {
    ctx.log.debug(`Processing block number ${block.header.height}`);
    for (let log of block.logs) {
      ctx.log.debug(`Processing log with address ${log.address}`);
      if (
        log.address === contractAddress &&
        log.topics[0] === erc20.events.Transfer.topic
      ) {
        ctx.log.info(`Transfer event found in block ${block.header.height}`);
        transfers.push(getTransfer(ctx, log));
      }
    }
  }

  ctx.log.info(`Found ${transfers.length} transfers, processing...`);
  await processTransfers(ctx, transfers);
  ctx.log.info('Processor finished');
});

interface TransferEvent {
  id: string;
  block: Block;
  transaction: Transaction;
  from: string;
  to: string;
  amount: bigint;
}

function getTransfer(ctx: any, log: Log): TransferEvent {
  let event = erc20.events.Transfer.decode(log);

  let from = event.from.toLowerCase();
  let to = event.to.toLowerCase();
  let amount = event.value;

  let transaction = assertNotNull(log.transaction, `Missing transaction`);

  ctx.log.debug(
    `Decoded transfer event: from ${from} to ${to} amount ${amount.toString()}`
  );
  return {
    id: log.id,
    block: log.block,
    transaction,
    from,
    to,
    amount,
  };
}

async function processTransfers(ctx: any, transfersData: TransferEvent[]) {
  ctx.log.info('Starting to process transfer data');
  let accountIds = new Set<string>();
  for (let t of transfersData) {
    accountIds.add(t.from);
    accountIds.add(t.to);
  }

  ctx.log.debug(`Fetching accounts for ${accountIds.size} addresses`);
  let accounts = await ctx.store
    .findBy(Account, { id: In([...accountIds]) })
    .then((q: any[]) => new Map(q.map((i: any) => [i.id, i])));
  ctx.log.info(
    `Accounts fetched, processing ${transfersData.length} transfers`
  );

  let transfers: Transfer[] = [];

  for (let t of transfersData) {
    let { id, block, transaction, amount } = t;

    let from = getAccount(accounts, t.from);
    let to = getAccount(accounts, t.to);

    transfers.push(
      new Transfer({
        id,
        blockNumber: block.height,
        timestamp: new Date(block.timestamp),
        txHash: transaction.hash,
        from,
        to,
        amount,
      })
    );
  }

  ctx.log.debug(`Upserting ${accounts.size} accounts`);
  await ctx.store.upsert(Array.from(accounts.values()));
  ctx.log.debug(`Inserting ${transfers.length} transfers`);
  await ctx.store.insert(transfers);
  ctx.log.info('Transfer data processing completed');
}

function getAccount(m: Map<string, Account>, id: string): Account {
  let acc = m.get(id);
  if (acc == null) {
    acc = new Account();
    acc.id = id;
    m.set(id, acc);
  }
  return acc;
}
    ```

Consulte o [guia de logging do SQD](https://docs.sqd.ai/sdk/reference/logger/){target=\_blank} para mais informaÃ§Ãµes sobre o modo debug.

### Erros Comuns {: #common-errors }

Alguns erros comuns ao construir o projeto e como resolvÃª-los:

```text
Error response from daemon: driver failed programming external connectivity on endpoint my-awesome-squid-db-1
(49df671a7b0531abbb5dc5d2a4a3f5dc7e7505af89bf0ad1e5480bd1cdc61052):
Bind for 0.0.0.0:23798 failed: port is already allocated
```

Esse erro indica que vocÃª tem outra instÃ¢ncia do SQD rodando. Pare-a com `sqd down` ou clicando em **Stop** no container no Docker Desktop.

```text
Error: connect ECONNREFUSED 127.0.0.1:23798
     at createConnectionError (node:net:1634:14)
     at afterConnectMultiple (node:net:1664:40) {
     errno: -61,code: 'ECONNREFUSED',syscall: 'connect',
     address: '127.0.0.1',port: 23798}
```

Para resolver, rode `sqd up` antes de `sqd migration:generate`.

Seu Squid estÃ¡ sem erros, mas nenhuma transferÃªncia aparece? Verifique se os logs estÃ£o consistentes e iguais aos esperados pelo processor. O endereÃ§o do contrato tambÃ©m precisa estar em minÃºsculas; garanta isso definindo assim:

```ts
export const contractAddress = '0x37822de108AFFdd5cDCFDaAa2E32756Da284DB85'.toLowerCase();
```

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/indexers/sqd/
--- BEGIN CONTENT ---
---
title: SQD
description: Explore tutoriais abrangentes que cobrem os fundamentos e tÃ©cnicas avanÃ§adas para indexar dados em sua rede Tanssi Substrate ou EVM com SQD.
icon: octicons-codescan-24
template: index-page.html
---

# SQD

SQD Ã© um serviÃ§o de indexaÃ§Ã£o e consulta de blockchain projetado para facilitar aos desenvolvedores a criaÃ§Ã£o de aplicaÃ§Ãµes ricas em dados em cadeias baseadas em Substrate, como as redes powered by Tanssi. Ele fornece uma soluÃ§Ã£o eficiente e escalÃ¡vel para processamento, indexaÃ§Ã£o e consulta de dados on-chain, permitindo que os desenvolvedores interajam facilmente com os dados de blockchain de que precisam, sem lidar diretamente com as complexidades dos dados brutos de blockchain.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/indexers/sqd/quick-start/
--- BEGIN CONTENT ---
---
title: Indexando uma Rede Tanssi com SQD
description: Aprenda a usar o Squid SDK, um framework de query node para cadeias baseadas em Substrate, para indexar e processar dados em uma rede EVM ou Substrate powered by Tanssi.
icon: octicons-rocket-24
categories: EVM-Template, Substrate-Template
---

# Indexando uma Rede Tanssi com SQD

## IntroduÃ§Ã£o {: #introduction }

[SQD](https://www.sqd.ai/){target=_blank} Ã© uma rede de dados que permite recuperar dados de blockchain de mais de 100 cadeias de forma rÃ¡pida e econÃ´mica usando o data lake descentralizado da SQD e o SDK open-source. Em termos simples, o SQD funciona como uma ferramenta ETL (extrair, transformar e carregar) com um servidor GraphQL incluÃ­do. Ele oferece filtragem abrangente, paginaÃ§Ã£o e atÃ© pesquisa de texto completo. O SQD tem suporte nativo e completo para dados EVM e Substrate, atÃ© no mesmo projeto.

Este guia rÃ¡pido mostra como criar um projeto Squid e configurÃ¡-lo para indexar dados em uma rede powered by Tanssi. HÃ¡ uma seÃ§Ã£o para [redes Substrate](#index-substrate-networks) e outra para [redes EVM](#index-evm-networks). Se vocÃª estiver em uma rede EVM, pode usar a seÃ§Ã£o Substrate caso tambÃ©m precise indexar dados Substrate.

Para um tutorial mais completo para redes EVM, confira [Indexando TransferÃªncias ERC-20 em uma Rede EVM Tanssi](/pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/){target=_blank}.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para os exemplos deste guia, vocÃª vai precisar de:

- [Node.js](https://nodejs.org/en/download){target=_blank} versÃ£o 16 ou superior
- [Docker](https://docs.docker.com/get-started/get-docker/){target=_blank}
- [Squid CLI](https://docs.sqd.ai/squid-cli/installation/){target=_blank}

## Indexar uma Rede Substrate Tanssi {: #index-substrate-networks }

Para comeÃ§ar a indexar dados Substrate na sua rede Tanssi, crie um projeto Squid e configure-o para sua rede com estes passos:

1. Crie um projeto Squid baseado no template Substrate executando:

    ```bash
    sqd init INSERT_SQUID_NAME --template substrate
    ```

    Para mais detalhes sobre este template, veja o guia [Primeiros passos: Cadeias Substrate](https://docs.sqd.ai/sdk/how-to-start/squid-development/?template-tech=substrate){target=_blank} na documentaÃ§Ã£o da SQD.

2. No diretÃ³rio raiz do projeto, instale as dependÃªncias:

    ```bash
    npm ci
    ```

3. Ajuste `src/processor.ts` para apontar para o RPC da sua rede Tanssi. Remova a linha `archive: lookupArchive`, pois nÃ£o serÃ¡ usado um arquivo Squid. Especifique o RPC da sua rede Substrate Tanssi, pois o endpoint Ã© usado para ingerir os dados da cadeia:

    ```ts
    const processor = new EvmBatchProcessor();
    processor.setDataSource({
      chain: 'INSERT_RPC_URL',
    })
    ```

4. Suba o Postgres executando:

    ```bash
    sqd up
    ```

5. Inspecione e execute o processador:

    ```bash
    sqd process
    ```

6. Em outro terminal, no mesmo diretÃ³rio, inicie o servidor GraphQL:

    ```bash
    sqd serve
    ```

7. Consulte o Squid Substrate de template com a query abaixo. Se vocÃª modificar o template para indexar dados diferentes, ajuste a query conforme necessÃ¡rio:

    ```graphql
    query MyQuery {
      accountsConnection(orderBy: id_ASC) {
        totalCount
      }
    }
    ```

Pronto! Agora vocÃª pode atualizar `schema.graphql`, `src/main.ts`, `typegen.json` e `src/processor.ts` para indexar os dados que precisa.

## Indexar uma Rede EVM Tanssi {: #index-evm-networks }

Para indexar dados EVM em uma rede EVM Tanssi, crie um projeto Squid e configure-o assim:

1. Crie um projeto Squid para EVM usando o [template EVM](https://github.com/subsquid-labs/squid-evm-template){target=_blank} genÃ©rico ou o [template ABI](https://github.com/subsquid-labs/squid-abi-template){target=_blank} para dados de um contrato especÃ­fico.

    === "EVM"

        ```bash
        sqd init INSERT_SQUID_NAME --template evm
        ```

    === "ABI"

        ```bash
        sqd init INSERT_SQUID_NAME --template abi
        ```

    Para saber mais sobre esses templates, consulte:

    - [Primeiros passos: Cadeias EVM](https://docs.sqd.ai/sdk/how-to-start/squid-development/?template-tech=evm){target=_blank}
    - [InÃ­cio rÃ¡pido: Ferramentas de geraÃ§Ã£o Squid](https://docs.sqd.ai/sdk/resources/tools/squid-gen/){target=_blank}

2. No diretÃ³rio raiz do projeto, instale as dependÃªncias:

    ```bash
    npm ci
    ```

3. Ajuste `src/processor.ts` para apontar para o RPC da sua rede Tanssi. Remova a linha `archive: lookupArchive('eth-mainnet')`, pois nÃ£o serÃ¡ usado um arquivo Squid. Abaixo, o RPC da rede EVM de demonstraÃ§Ã£o Ã© usado como exemplo; substitua pelo seu:

    ```ts
    const processor = new EvmBatchProcessor();
    processor.setDataSource({
      chain: 'INSERT_RPC_URL',
    })
    ```

    !!! note
        Para testar na rede EVM de demonstraÃ§Ã£o, vocÃª pode usar este RPC:

        ```text
        {{ networks.dancelight.demo_evm_rpc_url }}
        ```

4. Suba o Postgres executando:

    ```bash
    sqd up
    ```

5. Inspecione e execute o processador:

    ```bash
    sqd process
    ```

6. Em outro terminal, inicie o servidor GraphQL:

    ```bash
    sqd serve
    ```

7. Execute consultas no playground GraphQL em `http://localhost:4350/graphql`, por exemplo:

    ```graphql
    query MyQuery {
      burns(orderBy: value_DESC) {
        address
        block
        id
        txHash
        value
      }
    }
    ```

Pronto! Agora vocÃª pode atualizar `schema.graphql`, `src/main.ts` e `src/processor.ts` para indexar os dados necessÃ¡rios.

Para um guia passo a passo mais completo, veja o tutorial [Indexando TransferÃªncias ERC-20 em uma Rede EVM Tanssi](/pt/builders/toolkit/integrations/indexers/sqd/erc20-transfers/){target=_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/oracles/acurast/
--- BEGIN CONTENT ---
---
title: Usando Acurast para Oracles de Feeds de PreÃ§o
description: Aprenda a usar a nuvem serverless descentralizada da Acurast para obter feeds de preÃ§o confiÃ¡veis na sua rede EVM powered by Tanssi.
icon: octicons-eye-24
categories: EVM-Template
---

# Acessando Feeds de PreÃ§o com Acurast

## IntroduÃ§Ã£o {: #introduction }

[Acurast](https://acurast.com){target=_blank} oferece computaÃ§Ã£o permissionless, confiÃ¡vel e acessÃ­vel para implantar aplicaÃ§Ãµes. Um dos usos Ã© permitir que desenvolvedores criem oracles push/pull, consultando APIs off-chain para trazer preÃ§os on-chain. Os dados sÃ£o processados de forma confidencial pelos Processors e enviados a contratos de redes EVM compatÃ­veis com Tanssi via a [interface padrÃ£o Chainlink Aggregator](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=_blank}.

Este tutorial mostra um demo de [como interagir com feeds de preÃ§o](#fetch-price-data) fornecidos pela Acurast na [rede EVM de demonstraÃ§Ã£o da Tanssi](/builders/tanssi-network/testnet/demo-evm-network/){target=_blank}. VocÃª tambÃ©m pode implantar seus prÃ³prios feeds na sua rede EVM powered by Tanssi. Para produÃ§Ã£o, Ã© altamente recomendÃ¡vel contatar a [equipe Acurast](https://acurast.com){target=_blank} para auxiliar no lanÃ§amento e garantir a integridade do processo.

## O que Ã© Acurast? {: #what-is-acurast }

Acurast Ã© uma nuvem descentralizada e sem servidor em que qualquer pessoa pode contribuir poder de computaÃ§Ã£o (inclusive com celulares) e receber recompensas. Esses Processors formam uma rede distribuÃ­da mundialmente. Processors e desenvolvedores interagem pelo [Acurast Console](https://console.acurast.com){target=_blank}.

## Obter Dados de PreÃ§o {: #fetch-price-data }

VocÃª pode desenhar o feed de preÃ§o Acurast como quiser. Os dados ficam em uma sÃ©rie de contratos (um por feed) e podem ser consultados via a interface do agregador. O feed demo usa a mesma interface de preÃ§o da Chainlink:

???+ code "AggregatorV3Interface.sol"

    ```solidity
    // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    /**
     * Returns the decimals to offset on the getLatestPrice call
     */
    function decimals() external view returns (uint8);

    /**
     * Returns the description of the underlying price feed aggregator
     */
    function description() external view returns (string memory);

    /**
     * Returns the version number representing the type of aggregator the proxy points to
     */
    function version() external view returns (uint256);

    /**
     * Returns price data about a specific round
     */
    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);

    /**
     * Returns price data from the latest round
     */
    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
}
    ```

Na interface, cinco funÃ§Ãµes retornam dados: `decimals`, `description`, `version`, `getRoundData` e `latestRoundData`. Consulte a [referÃªncia da Chainlink](https://docs.chain.link/data-feeds/api-reference){target=_blank} para detalhes.

## Interagir com Feeds na Rede EVM Demo da Tanssi {: #interacting-with-price-feeds-demo-evm-network }

Vamos usar o feed BTC/USDT jÃ¡ implantado (veja [Ativos suportados](#supported-assets)). O contrato do agregador no Blockscout:

```text
{{ networks.demo_evm.oracles.acurast.btc_usd }}
```

Como interagir pelo Remix:

1. Conecte a MetaMask Ã  rede EVM demo ([guia Remix](/builders/toolkit/ethereum-api/dev-env/remix/){target=_blank}).  
2. Cole o [contrato Aggregator](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=_blank} em um novo arquivo e compile.  
3. Em **Deploy and Run**, defina **ENVIRONMENT** para **Injected Provider -- MetaMask**.  
4. Selecione **AggregatorV3Interface** em **CONTRACT**.  
5. No campo **At Address**, informe `{{ networks.demo_evm.oracles.acurast.btc_usd }}` e clique **At Address**.

![Compilar contrato agregador](/images/builders/toolkit/integrations/oracles/acurast/acurast-1.webp)

![Acessar contrato do agregador](/images/builders/toolkit/integrations/oracles/acurast/acurast-2.webp)

Para consultar:

1. Expanda **AggregatorV3Interface**.  
2. Clique em **decimals** para ver quantas casas decimais o preÃ§o usa.  
3. Clique em **description** para verificar o par.  
4. Clique em **latestRoundData** para ver o preÃ§o mais recente (retornado em **int256 answer**).

![Consultar dados de preÃ§o](/images/builders/toolkit/integrations/oracles/acurast/acurast-3.webp)

Lembre-se de ajustar pelo nÃºmero de decimais informado por `decimals()`. Ex.: se o feed retorna `51933620000` e `decimals = 6`, o preÃ§o Ã© `51,933.62`.

### Ativos Suportados {: #supported-assets }

Exemplo de chamada de API usada no demo:

```bash
curl "https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT"
```

SaÃ­da de exemplo:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>curl "https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT" </span>
  <span data-ty> </span>
  <span data-ty>{"symbol":"BTCUSDT","price":"51917.61000000"}</span>
  <span data-ty="input"><span class="file-path"></span> </span>
</div>

!!! note
    Este exemplo usa apenas uma fonte (uma exchange). Ã‰ possÃ­vel construir scripts que agreguem mÃºltiplas fontes.

Por design, a Acurast pode suportar o feed de qualquer ativo acessÃ­vel por API.

Feeds implantados na rede EVM demo:

| Ativo/Par | Contrato agregador |
|:--:|:--:|
| AAVE/USDT | [{{ networks.demo_evm.oracles.acurast.aave_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x6239Ff749De3a21DC219bcFeF9d27B0dfE171F42){target=_blank} |
| BTC/USDT | [{{ networks.demo_evm.oracles.acurast.btc_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x02093b190D9462d964C11587f7DedD92718D7B56){target=_blank} |
| CRV/USDT | [{{ networks.demo_evm.oracles.acurast.crv_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x01F143dfd745861902dA396ad7dfca962e5C83cA){target=_blank} |
| DAI/USDT | [{{ networks.demo_evm.oracles.acurast.dai_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x73aF6b14b73059686a9B93Cd28b2dEABF76AeC92){target=_blank} |
| ETH/USDT | [{{ networks.demo_evm.oracles.acurast.eth_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x007c3F3cc99302c19792F73b7434E3eCbbC3db25){target=_blank} |
| USDC/USDT | [{{ networks.demo_evm.oracles.acurast.usdc_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xe4a46ef4cFbf87D026C3eB293b7672998d932F62){target=_blank} |
| USDT/USD | [{{ networks.demo_evm.oracles.acurast.usdt_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xf9c885E3A5846CEA887a0D69655BC08e52afe569){target=_blank} |

Esses endereÃ§os estÃ£o disponÃ­veis para testes, mas vocÃª pode implantar feeds adicionais para outros pares conforme necessÃ¡rio.

## Criar e LanÃ§ar Seu PrÃ³prio Feed de PreÃ§o {: #designing-and-launching-your-own-price-feed }

VocÃª pode criar seu prÃ³prio feed Acurast na rede EVM da Tanssi. Este tutorial Ã© apenas demonstrativo; para produÃ§Ã£o, [contate a equipe Acurast](https://acurast.com){target=_blank}.

SÃ£o necessÃ¡rios dois componentes: contrato e script. No exemplo anterior de [interaÃ§Ã£o com BTC/USD](#interacting-with-price-feeds-demo-evm-network) usamos a interface Chainlink porque Ã© simples de demonstrar. O contrato subjacente segue a [interface Chainlink Aggregator](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=_blank}, mas o demo adiciona eventos e lÃ³gica exemplo. CÃ³digo de contrato e script estÃ£o no [repositÃ³rio da Acurast](https://github.com/Acurast/acurast-evm-oracle-sample/tree/main){target=_blank}.

O contrato de demo `InsecureDummyPriceFeed.sol` emite eventos quando o preÃ§o Ã© atualizado e quando um novo round inicia. O mÃ©todo `setPrice` Ã© inseguro e serve apenas para mostrar onde adicionar consenso, controle de acesso etc.

???+ code "InsecureDummyPriceFeed.sol"

    ```solidity
    // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces/chainlink/AggregatorV2V3Interface.sol";

/**
This Dummy Oracle is compatible with Chainlink's AggregatorV2V3Interface, meaning projects currently using
Chainlink can seamlessly migrate. The updating of the price feed happens in the interval you specified on
the Acurast script.

At the moment no check on the signer/source is being performed, making this implementation INSECURE. However
with a minimal effort you can extend the "setPrice" entrypoint to reflext the kind of logic you are looking for
(i.e. Aggregation Consensus, Check sources, thresholds, etc).
**/

contract DummyChainlinkCompatibleOracle is AggregatorV2V3Interface {
    int256 private latestPrice;
    uint256 private latestPriceTimestamp;
    uint256 private latestRoundId;

    // Assuming price can be set without restriction for simplicity
    // In a real-world scenario, there should be access control mechanisms
    function setPrice(int256 _price) external {
        latestPrice = _price;
        latestPriceTimestamp = block.timestamp;
        latestRoundId++;

        emit AnswerUpdated(latestPrice, latestRoundId, latestPriceTimestamp);
        emit NewRound(latestRoundId, msg.sender, latestPriceTimestamp);
    }

    // AggregatorInterface functions
    function latestAnswer() external view override returns (int256) {
        return latestPrice;
    }

    function latestTimestamp() external view override returns (uint256) {
        return latestPriceTimestamp;
    }

    function latestRound() external view override returns (uint256) {
        return latestRoundId;
    }

    function getAnswer(uint256 _roundId) external view override returns (int256) {
        if(_roundId == latestRoundId) {
            return latestPrice;
        }
        return 0; // Simplification, should handle historical data
    }

    function getTimestamp(uint256 _roundId) external view override returns (uint256) {
        if(_roundId == latestRoundId) {
            return latestPriceTimestamp;
        }
        return 0; // Simplification, should handle historical data
    }

    // AggregatorV3Interface functions
    function decimals() external pure override returns (uint8) {
        return 6; // Assume a common decimal value for simplicity
    }

    function description() external pure override returns (string memory) {
        return "Sample Price Feed";
    }

    function version() external pure override returns (uint256) {
        return 1;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        require(_roundId == latestRoundId, "Only latest round data available");
        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (uint80(latestRoundId), latestPrice, latestPriceTimestamp, latestPriceTimestamp, uint80(latestRoundId));
    }
}
    ```

!!! warning
    O contrato de demonstraÃ§Ã£o tem vulnerabilidades e nÃ£o possui controles de acesso; nÃ£o use em produÃ§Ã£o.

Antes de prosseguir, implante o contrato do seu feed na rede EVM da Tanssi (ou na rede demo). Guarde o endereÃ§o, pois serÃ¡ usado no script Acurast.

### Construindo o Script Acurast

O script Acurast atualiza o oracle on-chain com os preÃ§os, fazendo a bridge entre o feed de preÃ§o da rede Tanssi e a rede Acurast. No console vocÃª define parÃ¢metros como frequÃªncia, agenda e recompensa dos Processors. Para publicar jobs vocÃª precisarÃ¡ de tokens cACU (pegue no [faucet](https://faucet.acurast.com){target=_blank}) â€” eles sÃ£o a moeda nativa da rede Canary da Acurast.

O script atualiza o oracle on-chain com preÃ§os. Exemplo de script:

???+ code "AcurastScript.js"
    ```js
    /**
 * This Oracle Script observes the BTC USDT Pair and posts the price on-chain.
 * Deploying the script is easy using console.acurast.com and simply copy/pasting
 * this script. Make sure to update `DESTINATION_CONTRACT` and `EVM_RPC_NODE` to
 * reflect your deployment. For RPC's with API keys like i.e. infura make sure
 * to work with the Acurast confidential environment variables. After having set
 * them for your job, you can access them easily with a `_STD_.env["MY_KEY"]`. They
 * also come in handy for paid API KEYs, that you don't want to share publicly.
 */

const DESTINATION_CONTRACT = 'INSERT_CONTRACT_ADDRESS';
const EVM_RPC_NODE = 'INSERT_NETWORK_RPC_URL';

httpGET(
  'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT',
  {},
  (response, certificate) => {
    if (
      certificate ===
      '4795062d13e1ed971c6b6e5699764681e4d090bad39a7ef367cc9cb705652384'
    ) {
      //const price = BigInt(JSON.parse(response)["price"] * 10 ** 18); // if you need more precision, just keep in mind that JS stored bigger numbers in float format, rounding up/down your stuff.
      const price = BigInt(JSON.parse(response)['price'] * 10 ** 6);
      const int256AsBytes = '0x' + price.toString(16).padStart(64, '0');
      const payload = '0x' + _STD_.chains.ethereum.abi.encode(int256AsBytes);
      _STD_.chains.ethereum.fulfill(
        EVM_RPC_NODE,
        DESTINATION_CONTRACT,
        payload,
        {
          methodSignature: 'setPrice(int256)',
          gasLimit: '9000000',
          maxFeePerGas: '2550000000',
          maxPriorityFeePerGas: '2550000000',
        },
        (opHash) => {
          console.log('Succeeded: ' + opHash);
        },
        (err) => {
          console.log('Failed: ' + err);
        }
      );
    }
  },
  (err) => {
    console.log('Failed: ' + err);
  }
);
    ```

Se vocÃª reutilizar o script de exemplo da Acurast, lembre-se de atualizar o endereÃ§o do contrato e o RPC da sua rede.

No [console Acurast](https://console.acurast.com/create){target=_blank}, configure o job:

1. **Create Jobs** â†’ cadeia **Moonbeam**, ambiente **Moonbase** (Tanssi herda a compatibilidade EVM do Moonbeam).  
2. Selecione **Price Feeds**.  
3. Cole o script (altere o endereÃ§o do contrato implantado e o RPC da sua rede â€” disponÃ­vel no [Tanssi dApp](https://apps.tanssi.network){target=_blank}).  
4. Opcional: teste o cÃ³digo; erros aparecem no console do navegador.  
5. Em seguida, defina **Use Public Processors**, **Interval**, horÃ¡rio de inÃ­cio/fim, intervalo em minutos, duraÃ§Ã£o e max start delay.  
6. Defina o **Number of processors** (mais processadores exigem mais cACU; obtenha no [faucet](https://faucet.acurast.com){target=_blank}).  
7. Defina o **Max Reward** por execuÃ§Ã£o (exemplo: `0.01` cACU).  
8. Revise e clique **Publish Job**. Depois acompanhe o status na mesma pÃ¡gina.

![ConfiguraÃ§Ã£o do job no console Acurast](/images/builders/toolkit/integrations/oracles/acurast/acurast-4.webp)

![ConfiguraÃ§Ã£o do job no console Acurast (continuaÃ§Ã£o)](/images/builders/toolkit/integrations/oracles/acurast/acurast-5.webp)

Na tela seguinte vocÃª pode monitorar o status do job publicado.

Para mais detalhes sobre como construir e acessar feeds de preÃ§o na sua rede EVM Tanssi, consulte a [documentaÃ§Ã£o da Acurast](https://docs.acurast.com){target=_blank}.

Com isso vocÃª tem um fluxo completo: contrato on-chain, script de atualizaÃ§Ã£o e job publicado na Acurast para manter o feed de preÃ§os ativo.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/oracles/band/
--- BEGIN CONTENT ---
---
title: Usando o Band Protocol para Oracles de Feed de PreÃ§os
description: Aprenda a usar a rede de oracles descentralizada do Band Protocol para obter preÃ§os de tokens confiÃ¡veis, permitindo acesso seguro a dados para sua rede EVM da Tanssi.
icon: octicons-eye-24
categories: EVM-Template
---

# Acessando Feeds de PreÃ§os com o Band Protocol

## IntroduÃ§Ã£o {: #introduction }

[Band Protocol](https://www.bandprotocol.com/){target=\_blank} Ã© uma rede de oracles descentralizada que fornece dados confiÃ¡veis, seguros e em tempo real para contratos inteligentes em vÃ¡rias redes blockchain.

O protocolo Ã© construÃ­do sobre o BandChain, uma rede projetada para ser compatÃ­vel com a maioria das cadeias compatÃ­veis com EVM, como as redes EVM powered by Tanssi, e com frameworks de desenvolvimento. O protocolo busca oferecer uma soluÃ§Ã£o:

- Descentralizada, aproveitando o poder computacional de uma rede de validadores
- FlexÃ­vel, suportando ampla variedade de fontes e formatos de dados, facilitando integraÃ§Ãµes
- EscalÃ¡vel, projetada para lidar com alto volume de requisiÃ§Ãµes
- AcessÃ­vel, permitindo solicitar dados apenas quando necessÃ¡rio e pagar apenas as taxas associadas

Para implantar o orÃ¡culo na sua rede, entre em contato diretamente com a equipe do [Band Protocol](https://www.bandprotocol.com/){target=\_blank}.

Este tutorial percorre as etapas para interagir com feeds de preÃ§os usando o orÃ¡culo do Band Protocol na [rede EVM de demonstraÃ§Ã£o da Tanssi](https://apps.tanssi.network/demo){target=\_blank}. 

## ConfiguraÃ§Ã£o na Rede de DemonstraÃ§Ã£o EVM da Tanssi {: #setup-on-demo-evm-network }

O orÃ¡culo do Band Protocol jÃ¡ estÃ¡ implantado na rede EVM de demonstraÃ§Ã£o da Tanssi e configurado para fornecer preÃ§os para os tokens `ETH` e `DOT`.

Os feeds de preÃ§os sÃ£o enviados regularmente para um contrato inteligente acessÃ­vel no endereÃ§o:

```text
{{ networks.demo_evm.oracles.band.smart_contract }}
```

O contrato pode ser utilizado via a interface:

???+ code "IStdReference.sol"

    ```solidity
    // SPDX-License-Identifier: Apache-2.0

pragma solidity 0.8.26;

interface IStdReference {
    /// A structure returned whenever someone requests for standard reference data.
    struct ReferenceData {
        uint256 rate; // base/quote exchange rate, multiplied by 1e18.
        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.
        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.
    } 

    /// Returns the price data for the given base/quote pair. Revert if not available.
    function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory);

    /// Similar to getReferenceData, but with multiple base/quote pairs at once.
    function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes) external view returns (ReferenceData[] memory);
}
    ```

Como visto acima, hÃ¡ duas funÃ§Ãµes para buscar dados:

???+ function "**getReferenceData**(_base, _quote) â€” busca o preÃ§o de um par base/cotaÃ§Ã£o"

    === "ParÃ¢metros"

        - `_base` ++"string memory"++ - token cujo preÃ§o vocÃª quer obter
        - `_quote` ++"string memory"++ - token (ou `USD`) em que o preÃ§o Ã© expresso
        
    === "Exemplo"

        - `_base` - ETH
        - `_quote` - USD
        
??? function "**getReferenceDataBulk**(_bases, _quotes) â€” busca preÃ§os para os pares base/cotaÃ§Ã£o fornecidos simultaneamente"

    === "ParÃ¢metros"

        - `_bases` ++"string[] memory"++ - lista de tokens base para os quais deseja obter preÃ§os
        - `_quotes` ++"string[] memory"++ - lista de tokens (ou `USD`) em que os preÃ§os sÃ£o expressos

    === "Exemplo"

        - `_bases` - ["ETH", "DOT"]
        - `_quotes` - ["USD", "USD"]

A resposta de ambas as funÃ§Ãµes Ã© composta pelos seguintes dados, agrupados em uma tupla no caso de `getReferenceData` e em uma lista de tuplas (uma por par) no caso de `getReferenceDataBulk`:

- `rate` ++"uint256"++ - preÃ§o do par base/cotaÃ§Ã£o fornecido. Ajuste o resultado para considerar 18 casas decimais
- `lastUpdatedBase` ++"uint256"++ - timestamp de atualizaÃ§Ã£o do parÃ¢metro `_base`, em epoch UNIX (segundos desde `01-01-1970 00:00:00 UT`)
- `lastUpdatedQuote` ++"uint256"++ - timestamp de atualizaÃ§Ã£o do parÃ¢metro `_quote`, em epoch UNIX (segundos desde `01-01-1970 00:00:00 UT`)

### Buscar Feeds de PreÃ§o usando Remix {: #fetching-price-feeds-remix }

Nesta seÃ§Ã£o, usaremos o Remix para buscar o preÃ§o do par `ETH/USD`.

Primeiro, certifique-se de ter uma [carteira compatÃ­vel com EVM](/pt/builders/toolkit/ethereum-api/wallets/){target=\_blank} conectada Ã  [rede EVM de demonstraÃ§Ã£o](https://apps.tanssi.network/demo){target=\_blank}. [MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/){target=\_blank} Ã© usada como exemplo. Em seguida, acesse o [Remix](https://remix.ethereum.org/){target=\_blank}, cole a interface [`IStdReference`](#setup-on-demo-evm-network) em um novo arquivo e compile.

![Compilar contrato de interface](/images/builders/toolkit/integrations/oracles/band/band-1.webp)

Depois, siga:

1. VÃ¡ para a aba **Deploy & Run Transactions**
2. Defina **ENVIRONMENT** como **Injected Provider -- MetaMask**
3. Selecione o contrato `IStdReference.sol` no menu **CONTRACT**
4. Informe o endereÃ§o do contrato de feed de dados `{{ networks.demo_evm.oracles.band.smart_contract }}` da rede EVM de demonstraÃ§Ã£o no campo **At Address** e clique em **At Address**

![Acessar contrato de interface](/images/builders/toolkit/integrations/oracles/band/band-2.webp)

O contrato estarÃ¡ acessÃ­vel. Para interagir:

1. Expanda o contrato **IStdReference** para ver as funÃ§Ãµes disponÃ­veis
2. Expanda **getReferenceData** e defina `_base` e `_quote` como `ETH` e `USD`
3. Clique em **Call**
4. O resultado exibirÃ¡ trÃªs valores: o preÃ§o, o horÃ¡rio de atualizaÃ§Ã£o do parÃ¢metro `_base` e o horÃ¡rio de atualizaÃ§Ã£o do parÃ¢metro `_quote`

![Checar dados de preÃ§o](/images/builders/toolkit/integrations/oracles/band/band-3.webp)

Para obter um preÃ§o legÃ­vel, ajuste pelas casas decimais do feed (18). No exemplo, `2361167929271984201806` corresponde a um preÃ§o de `ETH` de `$2,361.167929271984201806` em `USD`. Observe tambÃ©m que os timestamps de atualizaÃ§Ã£o estÃ£o em epoch UNIX, ou seja, segundos desde `01-01-1970 00:00:00 UT`. 

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/oracles/
--- BEGIN CONTENT ---
---
title: Oracles
description: Aprenda a integrar ferramentas especializadas como Oracles de feed de preÃ§o descentralizados para fornecer feeds de preÃ§o de ativos aos builders e usuÃ¡rios da sua rede Tanssi.
icon: octicons-eye-24
template: index-page.html
---

# Oracles

Oracles de blockchain sÃ£o serviÃ§os que permitem que blockchains interajam com fontes de dados externas, preenchendo a lacuna entre contratos inteligentes e informaÃ§Ãµes do mundo real. Os oracles sÃ£o essenciais para aplicaÃ§Ãµes dinÃ¢micas que dependem de dados fora da cadeia precisos e oportunos.

As principais caracterÃ­sticas dos oracles incluem:

- **Conectividade externa** - permitindo que contratos inteligentes busquem e utilizem dados do mundo real
- **AutomaÃ§Ã£o** - acionar a execuÃ§Ã£o de contratos com base em condiÃ§Ãµes externas
- **Flexibilidade** - suportar vÃ¡rios tipos de dados, como feeds de preÃ§os, atualizaÃ§Ãµes meteorolÃ³gicas e resultados esportivos

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/oracles/phala/
--- BEGIN CONTENT ---
---
title: Usando Phala para Oracles de Feeds de PreÃ§o
description: Aprenda a usar a rede de computaÃ§Ã£o off-chain da Phala para obter feeds de preÃ§o Chainlink (Ethereum Mainnet) na sua rede EVM powered by Tanssi.
icon: octicons-eye-24
categories: EVM-Template
---

# LanÃ§ando Feeds de PreÃ§o com Phala

## IntroduÃ§Ã£o {: #introduction }

[Phala Network](https://phala.com/){target=_blank} Ã© uma rede de computaÃ§Ã£o off-chain apoiada por [Secure Enclaves](https://docs.phala.com/network/tech-specs/blockchain/overview#the-architecture){target=_blank} que permite a desenvolvedores criar contratos inteligentes potentes conectados a componentes off-chain, chamados Phat Contracts. Os Phat Contracts foram projetados para oferecer funcionalidades que superam as limitaÃ§Ãµes de contratos tradicionais (armazenamento, custo, computaÃ§Ã£o), mantendo-se trustless, verificÃ¡veis e sem permissÃ£o. Para saber mais sobre a arquitetura da Phala, consulte a [documentaÃ§Ã£o](https://docs.phala.com/overview/phala-network){target=_blank}.

A Phala nÃ£o Ã©, por si sÃ³, uma rede de oracles; ela habilita vÃ¡rias capacidades de computaÃ§Ã£o off-chain, incluindo uma rede descentralizada de oracles. A Phala tambÃ©m oferece o [Phala Bricks](https://bricks.phala.network){target=_blank}, um conjunto de ferramentas que facilita lanÃ§ar rapidamente esse tipo de funcionalidade sem precisar construir tudo do zero.

Este tutorial mostra um demo de [como interagir com feeds de preÃ§o](#fetch-price-data) habilitados por Phat Contracts na rede EVM de demonstraÃ§Ã£o da Tanssi. Em seguida, vocÃª verÃ¡ como [implantar feeds de preÃ§o na sua rede EVM powered by Tanssi](#launching-price-feeds-on-an-evm-network). Para produÃ§Ã£o, Ã© altamente recomendÃ¡vel [contatar a equipe Phala](https://dashboard.phala.network){target=_blank} para auxiliar no lanÃ§amento e garantir a integridade do processo.

Se vocÃª jÃ¡ usa outro provedor de oracles, a Phala serve como camada de execuÃ§Ã£o confidencial para trazer esses dados para sua rede Tanssi. Ã‰ possÃ­vel adaptar o fluxo descrito aqui para outros feeds ou APIs, mantendo a mesma interface de consumo no contrato EVM.

AlÃ©m disso, por usar enclaves seguros, a Phala reduz a superfÃ­cie de ataque ao processar dados sensÃ­veis ou agregados de mÃºltiplas fontes, reforÃ§ando a confianÃ§a no resultado final consumido pelos dApps.

## Como a Phala Habilita Feeds de PreÃ§o {: #how-phala-enables-price-feeds }

A Phala espelha os [Chainlink Price Feeds](https://docs.chain.link/data-feeds/price-feeds){target=_blank} do Ethereum Mainnet. Esses feeds sÃ£o amplamente adotados e sua coleta/agragaÃ§Ã£o Ã© feita por vÃ¡rios node operators independentes, evitando dependÃªncia de uma Ãºnica fonte de verdade e reduzindo risco de manipulaÃ§Ã£o.

O componente central do desenho do sistema Ã© o [Secure Enclave](https://docs.phala.com/network/tech-specs/blockchain/overview#the-architecture){target=_blank}, que processa as mensagens recebidas da blockchain Phala (fila de mensagens criptografada) e garante execuÃ§Ã£o fiel mesmo com trabalhadores maliciosos. A blockchain Phala solicita a atualizaÃ§Ã£o do feed; os workers off-chain buscam os preÃ§os no Ethereum Mainnet e devolvem para a blockchain Phala.

AlÃ©m de replicar oracles existentes, Ã© possÃ­vel criar novos oracles buscando dados off-chain via Phat Contracts. No [exemplo de Phat-EVM Oracle](https://github.com/Phala-Network/phat-offchain-rollup/blob/main/EvmRollup.md){target=_blank}, os preÃ§os vÃªm da API do CoinGecko e podem ser enviados continuamente (push) ou solicitados pelo contrato EVM (pull).

Em resumo: a Phala funciona como uma bridge segura entre dados externos e sua rede EVM, permitindo reutilizar feeds consolidados da Chainlink ou construir integraÃ§Ãµes sob medida usando Phat Contracts.

## Buscar Dados de PreÃ§o {: #fetch-price-data }

HÃ¡ vÃ¡rios feeds disponÃ­veis na rede EVM demo. Os feeds habilitados por Phat Contracts usam a mesma interface dos feeds Chainlink. Cada feed fica em um contrato e pode ser consultado pela interface agregadora:

VocÃª tambÃ©m pode reutilizar a mesma interface para feeds personalizados que a sua equipe decidir publicar, mantendo uma API consistente para contratos e frontends.

???+ code "AggregatorV3Interface.sol"

    ```solidity
    // SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    /**
     * Returns the decimals to offset on the getLatestPrice call
     */
    function decimals() external view returns (uint8);

    /**
     * Returns the description of the underlying price feed aggregator
     */
    function description() external view returns (string memory);

    /**
     * Returns the version number representing the type of aggregator the proxy points to
     */
    function version() external view returns (uint256);

    /**
     * Returns price data about a specific round
     */
    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);

    /**
     * Returns price data from the latest round
     */
    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
}
    ```

A interface expÃµe cinco funÃ§Ãµes: `decimals`, `description`, `version`, `getRoundData` e `latestRoundData`. Para mais detalhes, veja a [referÃªncia da Chainlink](https://docs.chain.link/data-feeds/api-reference){target=_blank}.

Essas funÃ§Ãµes permitem consultar metadados do feed, verificar o par de ativos, e obter o preÃ§o mais recente ou de uma rodada especÃ­fica.

### Ativos Suportados {: #supported-assets }

A Phala obtÃ©m os feeds espelhando os feeds Chainlink do Ethereum Mainnet. HÃ¡ contratos para a [rede EVM demo](/builders/tanssi-network/testnet/demo-evm-network/){target=_blank} e para o Ethereum Mainnet:

=== "Rede EVM demo Tanssi"
    | Par de Ativos | Contrato agregador |
    |:--:|:--:|
    | AAVE/USD | [{{ networks.demo_evm.oracles.phala.aave_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x2E1640853bB2dD9f47831582665477865F9240DB){target=_blank} |
    | BTC/USD  | [{{ networks.demo_evm.oracles.phala.btc_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x89BC5048d634859aef743fF2152363c0e83a6a49){target=_blank} |
    | CRV/USD  | [{{ networks.demo_evm.oracles.phala.crv_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0xf38b25b79A72393Fca2Af88cf948D98c64726273){target=_blank} |
    | DAI/USD  | [{{ networks.demo_evm.oracles.phala.dai_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x1f56d8c7D72CE2210Ef340E00119CDac2b05449B){target=_blank} |
    | ETH/USD  | [{{ networks.demo_evm.oracles.phala.eth_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x739d71fC66397a28B3A3b7d40eeB865CA05f0185){target=_blank} |
    | USDC/USD | [{{ networks.demo_evm.oracles.phala.usdc_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x4b8331Ce5Ae6cd33bE669c10Ded9AeBA774Bf252){target=_blank} |
    | USDT/USD | [{{ networks.demo_evm.oracles.phala.usdt_usd }}]({{ networks.dancelight.demo_evm_blockscout_url }}address/0x5018c16707500D2C89a0446C08f347A024f55AE3){target=_blank} |

=== "Ethereum Mainnet"
    | Par de Ativos | Contrato agregador |
    |:--:|:--:|
    | AAVE/USD | [0x547a514d5e3769680Ce22B2361c10Ea13619e8a9](https://etherscan.io/address/0x547a514d5e3769680Ce22B2361c10Ea13619e8a9){target=_blank} |
    | BTC/USD  | [0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c){target=_blank} |
    | CRV/USD  | [0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f](https://etherscan.io/address/0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f){target=_blank} |
    | DAI/USD  | [0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9](https://etherscan.io/address/0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9){target=_blank} |
    | ETH/USD  | [0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419](https://etherscan.io/address/0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419){target=_blank} |
    | USDC/USD | [0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6](https://etherscan.io/address/0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6){target=_blank} |
    | USDT/USD | [0x3E7d1eAB13ad0104d2750B8863b489D65364e32D](https://etherscan.io/address/0x3E7d1eAB13ad0104d2750B8863b489D65364e32D){target=_blank} |

### Interagir com Feeds na Rede EVM Demo {: #interacting-with-price-feeds-demo-evm-network }

1. Conecte a MetaMask Ã  rede EVM demo (veja o guia [Implantar contratos com Remix](/builders/toolkit/ethereum-api/dev-env/remix/){target=_blank}) e certifique-se de que a MetaMask estÃ¡ nessa rede.  
2. Cole o [contrato Aggregator](https://github.com/smartcontractkit/chainlink-evm/blob/develop/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol){target=_blank} em um novo arquivo no Remix e compile.  
3. VÃ¡ para **Deploy and Run Transactions** â†’ **ENVIRONMENT** = **Injected Provider -- MetaMask**.  
4. Selecione **AggregatorV3Interface** em **CONTRACT**.  
5. No campo **At Address**, insira o endereÃ§o do feed desejado (ex.: BTC/USD `{{ networks.demo_evm.oracles.phala.btc_usd }}`) e clique em **At Address**.

![Compilar contrato agregador](/images/builders/toolkit/integrations/oracles/phala/phala-1.webp)
![Acessar contrato agregador](/images/builders/toolkit/integrations/oracles/phala/phala-2.webp)

Para consultar:

1. Expanda **AggregatorV3Interface**.  
2. Clique em **decimals** para ver quantas casas decimais o feed usa.  
3. Clique em **description** para verificar o par.  
4. Clique em **latestRoundData** para ver o preÃ§o mais recente (**int256 answer**).

![Ver dados de preÃ§o](/images/builders/toolkit/integrations/oracles/phala/phala-3.webp)

Para obter um preÃ§o legÃ­vel, ajuste pelo valor de `decimals()`. Ex.: se o retorno for `5230364122303` e `decimals=8`, o preÃ§o Ã© `52.303,64`.

Se preferir outro feed (DAI, ETH etc.), basta repetir os passos usando o endereÃ§o correspondente da tabela de ativos suportados.

Caso esteja depurando valores inesperados, valide se o `decimals()` retornado confere com o esperado para aquele par. DivergÃªncias de escala sÃ£o a causa mais comum de leituras â€œestranhasâ€ no front-end.

## LanÃ§ando Feeds de PreÃ§o em uma Rede EVM {: #launching-price-feeds-on-an-evm-network }

Ã‰ fÃ¡cil lanÃ§ar feeds em uma rede EVM da Tanssi! As etapas a seguir funcionam para redes Trial e dedicadas em [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=_blank}. Este guia Ã© demonstrativo; para produÃ§Ã£o, [contate a equipe Phala](https://dashboard.phala.network){target=_blank}.

### Setup {: #setup }

Clone o repositÃ³rio [Phala Mirrored Price Feed](https://github.com/Phala-Network/mirrored-price-feed){target=_blank} e instale dependÃªncias:

```bash
cd mirrored-price-feed/ && yarn install
```

Crie o `.env` a partir do exemplo:

```bash
cp env.example .env
```

Edite o `.env` e insira a chave privada de uma conta financiada na sua rede e o RPC da sua rede. Se estiver na sua prÃ³pria rede, financie uma conta de teste via Sudo (dados no [Tanssi dApp](https://apps.tanssi.network){target=_blank}). Os demais campos podem ficar em branco.

```bash
PRIVATE_KEY=INSERT_PRIVATE_KEY
RPC_URL=INSERT_YOUR_NETWORK_RPC_URL
VERIFIER_URL=
VERIFY_ADDRESS=
```

!!! note
    Nunca compartilhe frase semente ou chave privada. Este guia Ã© apenas educacional.

### Configurar Script de ImplantaÃ§Ã£o {: #configure-deployment-script }

Edite `scripts/OffchainAggregator.s.sol`. Ele recebe `decimals` (mantenha `8`) e a descriÃ§Ã£o do feed (ex.: `BTC / USD`). Use exatamente as descriÃ§Ãµes suportadas listadas em [Ativos suportados](#supported-assets), ou o feed nÃ£o funcionarÃ¡.

???+ code "OffchainAggregator.s.sol"
    ```solidity
    // SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Script, console2} from "forge-std/Script.sol";
import {OffchainAggregator} from "../src/OffchainAggregator.sol";

contract OffchainAggregatorScript is Script {
    function setUp() public {}

    function run() public {
        vm.startBroadcast();
        OffchainAggregator aggregator = new OffchainAggregator(
          8,
          'BTC / USD'
        );
        console2.log(address(aggregator));
        vm.stopBroadcast();
    }
}
    ```

Defina sua cadeia com `defineChain`, informando o RPC e o chainId da sua rede:

```ts
const chain = defineChain({
  id: INSERT_EVM_CHAIN_ID,
  name: 'dancelight-evm-network',
  rpcUrls: {
    default: {
      http: ['INSERT_RPC_URL'],
    },
    public: {
      http: ['INSERT_RPC_URL'],
    },
  },
});
```

Em `feeder.ts`, insira os detalhes da sua cadeia (RPC, chainId). O array `mainnetFeedContracts` (endereÃ§os do Mainnet) permanece. Limpe `aggregatorContracts` por enquanto â€” mais adiante vocÃª adicionarÃ¡ os endereÃ§os implantados na sua rede.

???+ code "feeder.ts"
    ```ts
    import {
  createPublicClient,
  http,
  parseAbi,
  createWalletClient,
  defineChain,
} from 'viem';
import { mainnet } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts';
import * as dotenv from 'dotenv';

dotenv.config();

const mainnetFeedContracts = {
  'AAVE-USD': '0x547a514d5e3769680Ce22B2361c10Ea13619e8a9',
  'CRV-USD': '0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f',
  'ETH-USD': '0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419',
  'BTC-USD': '0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c',
  'DAI-USD': '0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9',
  'USDT-USD': '0x3E7d1eAB13ad0104d2750B8863b489D65364e32D',
  'USDC-USD': '0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6',
};

const aggregatorContracts = {};

const abi = parseAbi([
  'function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',
  'function transmit(uint80 _roundId, int192 _answer, uint64 _timestamp) external',
  'function getRoundData(uint80 _roundId) public view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)',
]);

// Insert your network details here
const chain = defineChain({
  id: INSERT_EVM_CHAIN_ID,
  name: 'dancelight-evm-network',
  rpcUrls: {
    default: {
      http: ['INSERT_RPC_URL'],
    },
    public: {
      http: ['INSERT_RPC_URL'],
    },
  },
});

const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
});

const targetChainPublicClient = createPublicClient({
  chain,
  transport: http(),
});

async function getLatestRoundData(pair: string) {
  const address = mainnetFeedContracts[pair];
  if (!address) {
    throw new Error(`${pair} mainnet feed contract did not exist.`);
  }
  const data = await publicClient.readContract({
    address,
    abi,
    functionName: 'latestRoundData',
  });
  return data;
}

async function getRoundDataFromAggregator(pair: string, roundId: number) {
  const address = aggregatorContracts[pair];
  if (!address) {
    throw new Error(`${pair} aggregator contract did not exist.`);
  }
  const publicClient = createPublicClient({
    chain,
    transport: http(),
  });
  try {
    const data = await publicClient.readContract({
      address,
      abi,
      functionName: 'getRoundData',
      args: [roundId],
    });
    return data;
  } catch {}
}

async function updateFeed(
  walletClient: ReturnType<createWalletClient>,
  pair: string
) {
  if (!aggregatorContracts[pair]) {
    throw new Error(`${pair} aggregator contract did not exist.`);
  }
  const [roundId, answer, startedAt, updatedAt, answeredInRound] =
    await getLatestRoundData(pair);
  const aggregatorRoundId = Number(roundId & BigInt('0xFFFFFFFFFFFFFFFF'));
  const data = await getRoundDataFromAggregator(pair, aggregatorRoundId);
  if (data[1] === answer) {
    console.info(
      `${pair} aggregatorRoundId ${aggregatorRoundId} data exists: ${data}`
    );
    return;
  }

  const hash = await walletClient.writeContract({
    address: aggregatorContracts[pair],
    abi,
    functionName: 'transmit',
    args: [roundId, answer, startedAt],
  });
  await targetChainPublicClient.waitForTransactionReceipt({ hash });
  console.info(`${pair} updated, transmit tx hash: ${hash}`);
}

async function main() {
  if (!process.env.PRIVATE_KEY) {
    throw new Error('missing process.env.PRIVATE_KEY');
  }
  const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`);
  const walletClient = createWalletClient({
    chain,
    transport: http(),
    account,
  });
  for (const pair in aggregatorContracts) {
    await updateFeed(walletClient, pair);
  }
}

main()
  .then(() => process.exit(0))
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
    ```

### Build e Testes {: #build-and-test }

```bash
yarn build
yarn test
```

SaÃ­da esperada:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>yarn build</span>
  <span data-ty>yarn run v1.22.10</span>
  <span data-ty="input" data-ty-prompt="$"> forge build</span>
  <span data-ty>[.] compiling</span>
  <span data-ty>No files changed, compilation skipped</span>
  <span data-ty>âœ¨ Done in 0.765.</span>
  <span data-ty> </span>
  <span data-ty="input"><span class="file-path"></span>yarn test</span>
  <span data-ty>yarn run v1.22.10</span>
  <span data-ty="input" data-ty-prompt="$"> forge test</span>
  <span data-ty>[.] compiling</span>
  <span data-ty>No files changed, compilation skipped</span>
  <span data-ty> </span>
  <span data-ty>Running 1 test for test/OffchainAggregator.t.sol:OffchainAggregatorTest</span>
  <span data-ty>[PASS] test_transmit() (gas: 60497)</span>
  <span data-ty>Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.96ms</span>
  <span data-ty>Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)</span>
  <span data-ty>âœ¨ Done in 0.765.</span>
  <span data-ty="input"><span class="file-path"></span> </span>
</div>

### Deploy {: #deploy }

Para implantar o contrato agregador do par escolhido:

```bash
yarn deploy
```

Anote o endereÃ§o retornado.

<div id="termynal" data-termynal>
  <span data-ty>Waiting for receipts.</span>
  <span data-ty>[O0:00:18]ã€######################################################ã€‘ 1/1 receipts CO.0s)</span>
  <span data-ty>#####7796</span>
  <span data-ty>âœ… [Success]Hash: Oxfb2f2dc6a35286c4595ce6e2bb64c93425b14c310a53f8224df0520666329fd</span>
  <span data-ty>âœ… Contract Address: OxBc788db88C3344a24706754c1203a267790D626</span>
  <span data-ty>Block: 4049</span>
  <span data-ty>Paid: 0.002392252 ETH (598063 gas * 4 gwei)</span>
  <span data-ty></span>
  <span data-ty>Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json</span>
  <span data-ty>Sensitive values saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json</span>
  <span data-ty></span>
  <span data-ty>==========================</span>
  <span data-ty>ONCHAIN EXECUTION COMPLETE & SUCCESSFUL.</span>
  <span data-ty></span>
  <span data-ty>Total Paid: 0.002392252 ETH (598063 gas * avg 4 gwei)</span>
  <span data-ty></span>
  <span data-ty>Transactions saved to: /Users/tanssi/workspace/phalaMirrored/mirrored-price-feed/broadcast/OffchainAggregator.s.sol/7796/run-latest.json</span>
  <span data-ty></span>
  <span data-ty>Sensitive values saved to: /Users/kevin/workspace/phalaMirrored/mirrored-price-feed/cache/OffchainAggregator.s.sol/7796/run-latest.json</span>
  <span data-ty></span>
  <span data-ty>âœ¨ Done in 30.765s.</span>
  <span data-ty="input"><span class="file-path"></span> </span>
</div>

### Acessar o Contrato Agregador {: #access-aggregator-contract }

No Remix, com a MetaMask na sua rede EVM, cole o endereÃ§o implantado em **At Address**. Expanda **AggregatorV3Interface** e clique em **latestRoundData** â€” inicialmente deve retornar `0` (sem preÃ§o atualizado ainda).

![Acessar contrato agregador](/images/builders/toolkit/integrations/oracles/phala/phala-4.webp)
![SaÃ­da do contrato implantado](/images/builders/toolkit/integrations/oracles/phala/phala-5.webp)

Se ainda nÃ£o tiver sua rede configurada na MetaMask, use o botÃ£o **Add to MetaMask** no dashboard do [Tanssi dApp](https://apps.tanssi.network){target=_blank} para adicionÃ¡-la rapidamente.

### Disparar AtualizaÃ§Ã£o de PreÃ§o {: #Trigger Price Feed Update }

Inclua o endereÃ§o do agregador em `aggregatorContracts` no `feeder.ts`:

```ts
const aggregatorContracts = {
  'BTC-USD': 'INSIRA_ENDERECO_DO_AGREGADOR',
}
```

Depois execute:

```bash
npx tsx feeder.ts
```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>npx tsx feeder.ts</span>
  <span data-ty>BTC-USD updated, transmit tx hash: Oxf1797cfc5bd71e2d848b099cae197ff30dafb5f6947481a5ef6c69271e059a96</span>
  <span data-ty="input"><span class="file-path"></span> </span>
</div>

No Remix, chame **latestRoundData** novamente para ver o preÃ§o atualizado.

![Ver preÃ§o apÃ³s atualizaÃ§Ã£o](/images/builders/toolkit/integrations/oracles/phala/phala-6.webp)

Para mais informaÃ§Ãµes sobre uso da Phala para dados off-chain, veja os [docs da Phala](https://docs.phala.com/overview/phala-network){target=_blank}.

Essa abordagem completa (contrato + script + atualizaÃ§Ã£o via feeder) garante que os feeds fiquem sincronizados com as fontes da Chainlink no Mainnet e que sua rede Tanssi receba preÃ§os confiÃ¡veis.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/wallet-integrations/
--- BEGIN CONTENT ---
---
title: IntegraÃ§Ãµes de Carteiras
description: Saiba como adicionar integraÃ§Ãµes de carteiras ao seu dApp em redes powered by Tanssi para que os utilizadores possam ligar-se automaticamente Ã s suas carteiras.
icon: material-wallet-outline
template: index-page.html
---

# IntegraÃ§Ãµes de Carteiras

As integraÃ§Ãµes de carteiras sÃ£o essenciais para permitir as interaÃ§Ãµes dos utilizadores com aplicaÃ§Ãµes descentralizadas (dApps), permitindo que os utilizadores gerenciem de forma segura os seus ativos digitais, assinem transaÃ§Ãµes e autentiquem a sua identidade. Estas integraÃ§Ãµes fornecem aos desenvolvedores as ferramentas para construir aplicaÃ§Ãµes que podem interagir com as carteiras dos utilizadores, facilitando transaÃ§Ãµes e interaÃ§Ãµes blockchain de forma amigÃ¡vel.

As principais caracterÃ­sticas das integraÃ§Ãµes de carteira incluem:

- **Suporte multi-carteira** - suporte imediato para vÃ¡rios provedores de carteira, reduzindo a necessidade de integraÃ§Ã£o personalizada
- **ExperiÃªncia do utilizador aprimorada** - os utilizadores podem facilmente conectar-se usando sua carteira preferida atravÃ©s de uma interface de utilizador intuitiva
- **Componentes de IU prÃ©-construÃ­dos** - componentes de IU prontos para usar para conexÃ£o de carteira, exibiÃ§Ã£o de conta e gerenciamento de saldo, agilizando o desenvolvimento
- **PersonalizaÃ§Ã£o** - personalize a aparÃªncia e o comportamento do modal da carteira para corresponder Ã  sua marca e ao design da interface do utilizador

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/integrations/wallet-integrations/rainbowkit/
--- BEGIN CONTENT ---
---
title: Como Adicionar RainbowKit a uma Rede EVM da Tanssi
description: Saiba como integrar o RainbowKit a uma rede compatÃ­vel com Ethereum implantada via Tanssi, facilitando a adiÃ§Ã£o de uma Ã³tima experiÃªncia de carteira ao seu dApp.
icon: material-wallet-outline
categories: EVM-Template
---

# Integrar RainbowKit a uma Rede Tanssi

## IntroduÃ§Ã£o

[RainbowKit](https://rainbowkit.com/docs/introduction){target=_blank} Ã© uma biblioteca React que adiciona conexÃ£o de carteiras a um dApp. Ela suporta vÃ¡rias carteiras e oferece recursos como alternar cadeias, resolver endereÃ§os ENS e exibir saldo. O RainbowKit traz opÃ§Ãµes de customizaÃ§Ã£o para cadeias compatÃ­veis com EVM, facilitando conectar carteiras a redes personalizadas.

O RainbowKit agrupa vÃ¡rias ferramentas para simplificar a conexÃ£o de carteiras em um dApp:

- [Wagmi](https://wagmi.sh/){target=\_blank} â€” hooks React para contas, carteiras, contratos, transaÃ§Ãµes, assinatura, ENS e mais
- [viem](https://viem.sh/){target=\_blank} â€” interface TypeScript com primitivas de baixo nÃ­vel para interagir com Ethereum
- [WalletConnect](https://walletconnect.com/){target=\_blank} â€” adiciona conexÃµes criptografadas e UX aprimorada (ex.: conectar carteira mÃ³vel via QR)
- [TanStack Query](https://tanstack.com/query/latest/docs/framework/react/overview){target=_blank} â€” ajuda a gerenciar e atualizar estado de servidor no app

Usando essas peÃ§as juntas, vocÃª evita reimplementar fluxo de conexÃ£o, persistÃªncia de sessÃ£o, atualizaÃ§Ã£o de saldo e troca de redes, acelerando a entrega do dApp.

Este guia explica como adicionar o RainbowKit a um dApp em uma rede powered by Tanssi usando a CLI, alÃ©m de opÃ§Ãµes para personalizar a integraÃ§Ã£o.

## InÃ­cio RÃ¡pido {: #quick-start }

Para comeÃ§ar um projeto novo, o RainbowKit pode gerar um esqueleto via CLI com RainbowKit e Wagmi em uma aplicaÃ§Ã£o [Next.js](https://nextjs.org/docs){target=\_blank}. Use o gerenciador de pacotes de sua preferÃªncia:

=== "npm"

    ```bash
    npm init @rainbow-me/rainbowkit@latest
    ```

=== "pnpm"

    ```bash
    pnpm create @rainbow-me/rainbowkit@latest
    ```

=== "yarn"

    ```bash
    yarn create @rainbow-me/rainbowkit
    ```

O script pedirÃ¡ o nome do projeto, criarÃ¡ o diretÃ³rio com o boilerplate e instalarÃ¡ as dependÃªncias.

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>npm init @rainbow-me/rainbowkit@latest
</span>
    <span data-ty="input" data-ty-prompt=""> ðŸŒˆ Welcome to RainbowKit!</span>
    <span data-ty="input" data-ty-prompt="âœ” What is the name of your project?"> rainbow-demo</span>
    <span data-ty="input" data-ty-prompt=""> ðŸš€ Creating a new RainbowKit app in /Users/papermoon/Documents/papermoon_builds/RainbowKit/add-rainbow-kit/rainbow-demo</span>
    <span data-ty="input" data-ty-prompt=""> ðŸ“¦ Installing dependencies with npm. This could take a while.</span>
    <span data-ty="input" data-ty-prompt="">ðŸ“š Initializing git repository</span>
    <span data-ty="input" data-ty-prompt=""> ðŸŒˆ Done! Thanks for using RainbowKit ðŸ™</span>
    <span data-ty="input" data-ty-prompt=""> ðŸ‘‰ To get started, run cd rainbow-demo and then npm run dev</span>
    <span data-ty="input"><span class="file-path"></span></span>
</div>

Em seguida, inicie o servidor de desenvolvimento e abra `http://localhost:3000`:

=== "npm"

    ```bash
    cd INSERT_PROJECT_NAME
    npm run dev
    ```

=== "pnpm"

    ```bash
    cd INSERT_PROJECT_NAME
    pnpm run dev
    ```

=== "yarn"

    ```bash
    cd INSERT_PROJECT_NAME
    yarn dev
    ```

VocÃª verÃ¡ a tela inicial:

![PÃ¡gina inicial do projeto RainbowKit gerado](/images/builders/toolkit/integrations/wallet-integrations/rainbowkit/rainbowkit-1.webp)

Abra o projeto no editor e veja o arquivo `wagmi.ts`. Ã‰ nele que vocÃª configura as cadeias disponÃ­veis para conexÃ£o.

Como a [rede EVM demo](https://apps.tanssi.network/demo/){target=\_blank} Ã© uma rede personalizada da Tanssi, ela nÃ£o pode ser importada direto de `wagmi/chains`. Defina a cadeia manualmente em `wagmi.ts`.

ConfiguraÃ§Ã£o para a rede EVM demo da Tanssi:

=== "Demo EVM Network"
    ```js title="src/wagmi.ts"
    import '@rainbow-me/rainbowkit/styles.css';
import { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';
import { WagmiProvider } from 'wagmi';
import { QueryClientProvider, QueryClient } from '@tanstack/react-query';

import { type Chain } from 'viem'

export const demoEVMChain = {
  id: 5678,
  name: "Tanssi demo EVM Network",
  nativeCurrency: { name: "TANGO", symbol: "TANGO", decimals: 18 },
  rpcUrls: {
    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }
  },
  blockExplorers: {
    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }
  },
} as const satisfies Chain


export const config = getDefaultConfig({
  appName: 'My Tanssi-powered Network',
  projectId: 'TODO: get project id from...',
  chains: [demoEVMChain], 
  ssr: true,
});
    ```

Atualize `wagmi.ts` conforme acima para suportar a rede demo. A prÃ³xima seÃ§Ã£o mostra como obter o `projectId` do WalletConnect.

## ConfiguraÃ§Ã£o Manual

As seÃ§Ãµes seguintes mostram como integrar o RainbowKit em um app React existente: instalar dependÃªncias, configurar cadeias, disponibilizar o RainbowKit no dApp, definir a cadeia padrÃ£o do **Connect Wallet** e personalizar o tema. O exemplo usa a rede EVM demo da Tanssi, mas pode ser adaptado mudando o RPC.

### Verificando PrÃ©-requisitos {: #checking-prerequisites }
- Uma rede compatÃ­vel com EVM na Tanssi
- Um dApp existente em [React](https://react.dev/){target=_blank}
- Exemplos do [repositÃ³rio RainbowKit](https://github.com/rainbow-me/rainbowkit/tree/main/examples){target=_blank} (hÃ¡ templates para vÃ¡rios frameworks)
- Para seguir este guia, crie um projeto Next.js (Typescript + App Router) seguindo a instalaÃ§Ã£o automÃ¡tica em [Next.js](https://nextjs.org/docs){target=_blank}
- A carteira deve suportar redes personalizadas (a rede demo serÃ¡ adicionada manualmente)
- Um `projectId` do WalletConnect (gratuito):
    1. VÃ¡ em [WalletConnect Cloud](https://cloud.walletconnect.com/){target=_blank}
    2. Em **Projects**, clique **Create**
    3. Preencha as informaÃ§Ãµes (pode deixar **Homepage URL** em branco se nÃ£o estiver deployado)
    4. Escolha o SDK **AppKit**
    5. Escolha o ambiente (React neste guia)
    6. Copie o `projectId` no menu lateral ou no snippet do Quickstart

### ComeÃ§ando {: #getting-started }

Instale RainbowKit e dependÃªncias:

=== "npm"

    ```bash
    npm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query
    ```

=== "pnpm"

    ```bash
    pnpm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query
    ```

=== "yarn"

    ```bash
    yarn add @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query
    ```

Suba o servidor de desenvolvimento:

=== "npm"

    ```bash
    npm run dev
    ```

=== "pnpm"

    ```bash
    pnpm run dev
    ```

=== "yarn"

    ```bash
    yarn dev
    ```

Abra `http://localhost:3000`.

Para testar, conecte a carteira MetaMask na rede EVM demo da Tanssi. Adicione a rede no MetaMask:

1. ConfiguraÃ§Ãµes > Redes > Adicionar Rede
2. Preencha:
   - Nome: `Demo EVM Chain`
   - RPC URL: `{{ networks.dancelight.demo_evm_rpc_url }}`
   - Chain ID: `{{ networks.dancelight.demo_evm_chain_id }}`
   - SÃ­mbolo: `{{ networks.dancelight.demo_evm_token_symbol }}`
   - Block Explorer: `{{ networks.dancelight.demo_evm_blockscout_url }}`

Para instruÃ§Ãµes detalhadas, veja [Conecte o MetaMask Ã  sua Rede EVM Tanssi](https://docs.tanssi.network/builders/toolkit/ethereum-api/wallets/metamask/#connect-metamask-to-evm-network){target=_blank}.

Depois, adicione o `projectId` ao app:

1. Crie `.env.local` na raiz:

    ```bash
    touch .env.local
    ```

2. Adicione o ID:

    ```text title=".env.local"
    NEXT_PUBLIC_PROJECT_ID='INSERT_PROJECT_ID'
    ```

3. Confirme que `.env*.local` estÃ¡ no `.gitignore` para evitar commit.

Se vocÃª usa vÃ¡rios ambientes (dev/homologaÃ§Ã£o/prod), crie um `projectId` separado para cada um e valide se o domÃ­nio cadastrado no WalletConnect Cloud corresponde ao ambiente correto.

### Conectar o dApp ao MetaMask

Passos principais:

1. Importar RainbowKit, Wagmi e TanStack Query
2. Configurar o Wagmi
3. Envolver o app com providers
4. Adicionar o botÃ£o de conexÃ£o

Seguir essa ordem garante que o estado de conexÃ£o e os modais do RainbowKit funcionem em toda a aplicaÃ§Ã£o.

### Importar RainbowKit, Wagmi e TanStack Query

Crie `wagmi.ts` na raiz com imports e a cadeia demo EVM:

```bash
touch wagmi.ts
```

```ts title="wagmi.ts"
import '@rainbow-me/rainbowkit/styles.css';
import { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';
import { WagmiProvider } from 'wagmi';
import { QueryClientProvider, QueryClient } from '@tanstack/react-query';

import { type Chain } from 'viem'

export const demoEVMChain = {
  id: 5678,
  name: "Tanssi demo EVM Network",
  nativeCurrency: { name: "TANGO", symbol: "TANGO", decimals: 18 },
  rpcUrls: {
    default: { http: ['https://services.tanssi-testnet.network/dancelight-2001'] }
  },
  blockExplorers: {
    default: { name: 'Demo EVM Explorer', url: 'https://dancelight-2001-blockscout.tanssi-chains.network/' }
  },
} as const satisfies Chain


export const config = getDefaultConfig({
  appName: 'My Tanssi-powered Network',
  projectId: 'process.env.NEXT_PUBLIC_PROJECT_ID',
  chains: [demoEVMChain ], 
  ssr: true,
});
```

### Envolver o aplicativo com providers

Crie `providers.tsx` para incluir `WagmiProvider` e `QueryClientProvider`:

```bash
cd app && touch providers.tsx
```

```ts title="providers.tsx"
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider } from 'wagmi';
import { RainbowKitProvider } from '@rainbow-me/rainbowkit';
import { config } from '../wagmi';

const queryClient = new QueryClient();

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider>{children}</RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

Depois, edite `app/layout.tsx` para usar `Providers`:

```ts title="layout.tsx"
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import '@rainbow-me/rainbowkit/styles.css';
import { Providers } from './providers';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'My Tanssi dApp',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang='en'>
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

### Adicionar o BotÃ£o Connect

Use o componente `ConnectButton` (pode ficar em `page.tsx` ou em um header/nav):

```ts title="page.tsx"
import { ConnectButton } from '@rainbow-me/rainbowkit';

export default function Home() {
  return (
    <div className="flex h-screen items-center justify-center">
      <ConnectButton />
    </div>
  );
}
```

Com o servidor rodando, aparecerÃ¡ **Connect Wallet**; clicar abre o modal RainbowKit. Selecione MetaMask e conecte. A configuraÃ§Ã£o padrÃ£o usa a Demo EVM Chain e mostra rede, saldo do token nativo e endereÃ§o.

Se vocÃª tiver vÃ¡rios botÃµes ou pÃ¡ginas, considere criar um componente compartilhado para evitar duplicar lÃ³gica de conexÃ£o e estilizaÃ§Ã£o.

## Personalizar o RainbowKit

O RainbowKit facilita a conexÃ£o e permite customizar UI/UX. Veja todas as opÃ§Ãµes na [docs do RainbowKit](https://rainbowkit.com/docs/introduction){target=\_blank}. Aqui vamos definir a cadeia inicial e aplicar tema customizado.

### Definir Cadeia Inicial

O RainbowKit conecta na primeira cadeia da lista do Wagmi. Melhor Ã© usar `initialChain` no `RainbowKitProvider`. Em `providers.tsx`, defina:

```ts title="providers.tsx"
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider } from 'wagmi';
import { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';
import { config, demoEVMChain } from '../wagmi';

const queryClient = new QueryClient();

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider initialChain={demoEVMChain}>
          {children}
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );

}
```

Isso forÃ§a conectar primeiro na Demo EVM Chain.

### Definir Cores de Tema

Use `lightTheme`, `darkTheme` ou `midnightTheme`. Exemplo com tema escuro customizado (adicione `darkTheme` ao import):

```js title="providers.tsx"
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { WagmiProvider } from 'wagmi';
import { RainbowKitProvider, darkTheme } from '@rainbow-me/rainbowkit';
import { config, demoEVMChain } from '../wagmi';

const queryClient = new QueryClient();

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider
          initialChain={demoEVMChain}
          theme={darkTheme({
            accentColor: '#189B9B', // Tanssi accent color
            accentColorForeground: 'white',
            borderRadius: 'medium',
            fontStack: 'system',
            overlayBlur: 'small'
          })}
        >
          {children}
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

Campos:
- `accentColor` â€” cor primÃ¡ria (ex.: #189B9B da Tanssi)
- `accentColorForeground` â€” cor do texto sobre a primÃ¡ria
- `borderRadius` â€” arredondamento
- `fontStack` â€” fontes (ex.: `system`)
- `overlayBlur` â€” desfoque de fundo em modais

VocÃª pode ainda ajustar Ã­cones, textos do modal e posiÃ§Ã£o do botÃ£o criando um tema customizado ou sobrescrevendo componentes via props do `ConnectButton`.

!!! tip
    Teste temas e cores para combinar com o estilo do seu dApp.

## Lidar com DesconexÃµes

### Desconectar no dApp {: #disconnect-from-dapp }

O modal RainbowKit inclui **Disconnect**; clique na seta ao lado da conta e depois **Disconnect**.

![BotÃ£o Desconectar integrado](/images/builders/toolkit/integrations/wallet-integrations/rainbowkit/rainbowkit-2.webp)

### Desconectar no MetaMask {: #disconnect-from-metamask }

1. Abra a extensÃ£o MetaMask  
2. Clique nos trÃªs pontos (canto superior direito)  
3. Selecione **Connected sites**  
4. Revise e clique **Disconnect** nos sites desejados

## Resultado final {: #final-result }

O botÃ£o **Connect Wallet** deve usar a cor definida em `accentColor`; o modal tambÃ©m. Escolha MetaMask, assine e veja a rede EVM demo conectada com o saldo de {{ networks.dancelight.demo_evm_token_symbol }} sem precisar trocar manualmente.

Se desejar suportar redes adicionais, basta adicionÃ¡-las em `wagmi.ts` e fornecer RPCs confiÃ¡veis; o modal exibirÃ¡ as opÃ§Ãµes no Switch Networks respeitando a ordem definida. Verifique tambÃ©m se os explorers configurados respondem corretamente para evitar erros de UX.

![CustomizaÃ§Ã£o de tema no modal](/images/builders/toolkit/integrations/wallet-integrations/rainbowkit/rainbowkit-3.webp)

Mais opÃ§Ãµes estÃ£o na [docs do RainbowKit](https://rainbowkit.com/docs/introduction){target=_blank}. CÃ³digo completo no repositÃ³rio [rainbowkit-manual-build-demo](https://github.com/papermoonio/rainbowkit-manual-build-demo){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/dev-env/chopsticks/
--- BEGIN CONTENT ---
---
title: Como usar o Chopsticks para bifurcar sua rede
description: Aprenda o bÃ¡sico de como usar o Chopsticks para reproduzir blocos, dissecar mudanÃ§as de estado, testar interaÃ§Ãµes XCM e criar um fork local da sua rede Tanssi.
icon: octicons-code-square-24
categories: Substrate-Template, EVM-Template
---

# Como usar o Chopsticks para bifurcar sua rede

## IntroduÃ§Ã£o {: #introduction }

[Chopsticks](https://github.com/AcalaNetwork/chopsticks){target=\_blank} oferece uma forma amigÃ¡vel para desenvolvedores bifurcarem localmente cadeias baseadas em [Substrate](/pt/learn/framework/overview/){target=\_blank}. Ele permite reproduzir blocos para examinar como transaÃ§Ãµes afetam o estado, bifurcar mÃºltiplas redes Tanssi para testes de XCM e muito mais. Isso facilita testar e experimentar configuraÃ§Ãµes personalizadas de blockchain em um ambiente local sem precisar implantar uma rede real.

Em resumo, o Chopsticks simplifica o processo de construir aplicaÃ§Ãµes em Substrate e o torna acessÃ­vel a mais desenvolvedores.

Este artigo mostra como usar o Chopsticks para bifurcar e interagir com uma cÃ³pia local de uma rede Tanssi.

!!! note
    O Chopsticks atualmente nÃ£o suporta chamadas via Ethereum JSON-RPC. Portanto, vocÃª nÃ£o pode bifurcar sua cadeia com o Chopsticks e conectar o Metamask a ela.

## PrÃ©-requisitos {: #prerequisites }

Para seguir este tutorial, clone o repositÃ³rio com seus submÃ³dulos ([Smoldot](https://github.com/smol-dot/smoldot.git){target=\_blank}):

```bash
git clone --recurse-submodules https://github.com/AcalaNetwork/chopsticks.git
```

Depois, entre na pasta e instale as dependÃªncias usando o [yarn](https://classic.yarnpkg.com/en/docs/install){target=\_blank}:

```bash
 cd chopsticks && yarn
```

Por fim, faÃ§a o build do projeto:

```bash
yarn build-wasm
```

Agora o ambiente de desenvolvimento estÃ¡ pronto para comeÃ§ar a testar e depurar redes implantadas com Tanssi.

## Bifurcando uma rede EVM de DemonstraÃ§Ã£o com o Chopsticks {: #forking-demo-chain }

Para bifurcar uma rede Tanssi usando o Chopsticks, execute o comando passando apenas o endpoint RPC:

```bash
yarn start --endpoint {{ networks.dancelight.demo_evm_rpc_wss_url }}
```

Esse comando inicia um clone local da cadeia no Ãºltimo bloco.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>
    chopsticks % yarn start --endpoint wss://services.tanssi-testnet.network/dancelight-2001
  </span>
  <span data-ty>
    [01:59:42.628] INFO (xcm/59650): Frontier Container 2001 RPC listening on port 8000
  </span>
</div>

Normalmente, os parÃ¢metros de configuraÃ§Ã£o ficam em um arquivo de configuraÃ§Ã£o, como os que estÃ£o na pasta `configs` do repositÃ³rio para relay chains e parachains do ecossistema Dotsama. O arquivo a seguir funciona para a [rede EVM de demonstraÃ§Ã£o](/pt/builders/tanssi-network/testnet/demo-evm-network/){target=\_blank}, sobrescrevendo a conta sudo da cadeia pela conta da Alith e financiando-a com tokens:

```yaml
endpoint: {{ networks.dancelight.demo_evm_rpc_wss_url }}
mock-signature-host: true
allow-unresolved-imports: true
db: ./tmp/db_ftrcon.sqlite

import-storage:
  System:
    Account:
      - - - "0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac" # Alith
        - providers: 1
          sufficients: 1
          consumers: 1
          data:
            free: "100000000000000000000000"
  Sudo:
    Key: "0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac"
```

O arquivo de configuraÃ§Ã£o aceita todos os parÃ¢metros a seguir:

|           OpÃ§Ã£o            |                                                 DescriÃ§Ã£o                                                  |
|:--------------------------:|:---------------------------------------------------------------------------------------------------------:|
|         `genesis`          |      Link para o raw genesis de uma parachain para construir o fork, em vez de usar um endpoint.          |
|        `timestamp`         |                                   Timestamp do bloco de origem do fork.                                   |
|         `endpoint`         |                                    Endpoint da parachain a ser bifurcada.                                 |
|          `block`           |                    Especifica em qual hash ou nÃºmero de bloco o fork deve ser reproduzido.                 |
|      `wasm-override`       |          Caminho do Wasm a usar como runtime da parachain em vez do runtime do endpoint.                  |
|            `db`            |                Caminho para o arquivo que armazena (ou armazenarÃ¡) o banco de dados da parachain.         |
|          `config`          |                                       Caminho ou URL do arquivo de configuraÃ§Ã£o.                           |
|           `port`           |                                      Porta para expor um endpoint.                                         |
|     `build-block-mode`     |                         Como os blocos devem ser construÃ­dos: batch, manual, instant.                      |
|      `import-storage`      |        Caminho JSON/YAML de um storage predefinido para sobrescrever o storage da parachain.               |
| `allow-unresolved-imports` |        Se permite imports Wasm nÃ£o resolvidos ao usar um Wasm para construir a parachain.                  |
|           `html`           |                        Inclua para gerar preview de diff de storage entre blocos.                         |
|   `mock-signature-host`    | Mock de assinatura: qualquer assinatura iniciada com `0xdeadbeef` e preenchida com `0xcd` Ã© vÃ¡lida.        |

VocÃª pode rodar `yarn start` para bifurcar cadeias informando um arquivo de configuraÃ§Ã£o local. Como alternativa, use o nome ou a URL do GitHub se a cadeia estiver listada na pasta `configs` do repositÃ³rio.

=== "Caminho de arquivo local"

    ```bash
    yarn start --config=configs/polkadot.yml
    ```

=== "Nome da cadeia"

    ```bash
    yarn start --config=polkadot
    ```

=== "URL do GitHub"

    ```bash
    yarn start \
    --config=https://github.com/AcalaNetwork/chopsticks.git/master/configs/polkadot.yml
    ```

Todas as configuraÃ§Ãµes (exceto `genesis` e `timestamp`) tambÃ©m podem ser passadas como flags para definir o ambiente apenas pela linha de comando. Por exemplo, o comando a seguir bifurca a rede EVM de demonstraÃ§Ã£o no bloco 100.

```bash
yarn start --endpoint {{ networks.dancelight.demo_evm_rpc_wss_url }} --block 100
```

### Interagir com um Fork {: #interacting-with-a-fork }

Ao executar um fork, por padrÃ£o ele fica acessÃ­vel em:

```text
ws://localhost:8000
```

VocÃª pode interagir com a parachain via bibliotecas como [Polkadot.js](https://github.com/polkadot-js/common){target=\_blank} e sua interface [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A8000#/explorer){target=\_blank}.

![Polkadot Js](/images/builders/toolkit/substrate-api/dev-env/chopsticks/chopsticks-1.webp)

Agora vocÃª deve conseguir interagir com a cadeia bifurcada como faria com a real.

!!! note
    Se o navegador nÃ£o conseguir conectar ao endpoint WebSocket do Chopsticks, talvez seja necessÃ¡rio permitir conexÃµes inseguras na URL do Polkadot.js Apps. Outra opÃ§Ã£o Ã© usar a [versÃ£o em Docker do Polkadot.js Apps](https://github.com/polkadot-js/apps#docker){target=\_blank}.

## Reproduzindo Blocos {: #replaying-blocks }

Se quiser reproduzir um bloco e recuperar suas informaÃ§Ãµes para dissecar os efeitos de um extrÃ­nseco, use o comando `yarn start run-block`. Os flags sÃ£o:

|            Flag            |                                       DescriÃ§Ã£o                                        |
|:--------------------------:|:--------------------------------------------------------------------------------------:|
|         `endpoint`         |                          Endpoint da parachain a ser bifurcada.                        |
|          `block`           |                 Especifica em qual hash ou nÃºmero de bloco reproduzir o fork.          |
|      `wasm-override`       |      Caminho do Wasm a usar como runtime da parachain em vez do runtime do endpoint.   |
|            `db`            |      Caminho para o arquivo que armazena (ou armazenarÃ¡) o banco de dados da cadeia.   |
|          `config`          |                             Caminho ou URL do arquivo de configuraÃ§Ã£o.                 |
| `output-path=/[file_path]` |      Imprime os resultados em um arquivo JSON em vez de exibi-los no console.          |
|           `html`           |   Inclua para gerar uma representaÃ§Ã£o HTML do diff de storage entre blocos.            |
|           `open`           |                         Define se abre a representaÃ§Ã£o HTML.                           |

Por exemplo, o comando abaixo executa novamente o bloco 1000 da rede EVM de demonstraÃ§Ã£o e grava o diff de storage e outros dados em `chain-output.json`:  

```bash
yarn start run-block  \
--endpoint {{ networks.dancelight.demo_evm_rpc_wss_url }}  \
--output-path=./chain-output.json  \
--block 1000
```

## Comandos WebSocket {: #websocket-commands }

O servidor WebSocket interno do Chopsticks possui endpoints especiais para manipular a cadeia Substrate local.

Estes sÃ£o os mÃ©todos que podem ser invocados e seus parÃ¢metros:

???+ function "**dev_newBlock** (options) â€” Gera um ou mais blocos novos"

    === "ParÃ¢metros"

        - **options** - `{ "to": number, "count": number }` - objeto JSON em que `"to"` cria blocos atÃ© certo valor e `"count"` aumenta em determinado nÃºmero de blocos. Use apenas uma entrada por vez no objeto

    === "Exemplo"

        ```js
        import { WsProvider } from '@polkadot/api'
        const ws = new WsProvider(`ws://localhost:8000`)
        // Cria cinco blocos novos
        await ws.send('dev_newBlock', [{ count: 5 }])
        ```

??? function "**dev_setStorage** (values, blockHash) â€” Cria ou sobrescreve o valor de qualquer storage"

    === "ParÃ¢metros"

         - **values** - Objeto - JSON semelhante ao caminho para um valor de storage, como vocÃª obteria via Polkadot.js  
        - **blockHash** - String - opcional, hash do bloco no qual o valor de storage Ã© alterado  
        
    === "Exemplo"

        ```js
        import { WsProvider } from '@polkadot/api';
        const ws = new WsProvider(`ws://localhost:8000`);
        // Sobrescreve a chave sudo
        await ws.send('dev_setStorage', 
            [{"Sudo": { "Key": "0x6Be02d1d3665660d22FF9624b7BE0551ee1Ac91b" }}]
        );
        ```

??? function "**dev_timeTravel** (date) â€” Define o timestamp do bloco para o valor informado"

    === "ParÃ¢metros"

         - **date** - Date - string compatÃ­vel com a biblioteca Date do JavaScript que altera o timestamp dos prÃ³ximos blocos. Todos os blocos futuros serÃ£o criados sequencialmente apÃ³s esse ponto no tempo  

    === "Exemplo"

        ```js
        import { WsProvider } from '@polkadot/api';
        const ws = new WsProvider(`ws://localhost:8000`);
        // Define o timestamp para 15 de agosto de 2030
        await ws.send('dev_timeTravel', ["2030-08-15T00:00:00"]);
        ```

??? function "**dev_setHead** (hashOrNumber) â€” Define a head da blockchain para um hash ou nÃºmero especÃ­fico"

    === "ParÃ¢metros"

         - **hashOrNumber** - number | string - se encontrado, a head serÃ¡ definida para o bloco com esse nÃºmero ou hash
        
    === "Exemplo"

        ```js
        import { WsProvider } from '@polkadot/api';
        const ws = new WsProvider(`ws://localhost:8000`);
        // Define a head para o bloco 500
        await ws.send('dev_setHead', [500]);
        ```

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/dev-env/
--- BEGIN CONTENT ---
---
title: Ambientes de Desenvolvimento Substrate
description: Confira os ambientes de desenvolvimento Substrate, que podem ser usados para desenvolver, testar e depurar uma rede Powered by Tanssi em um ambiente de desenvolvimento local.
icon: octicons-code-square-24
template: index-page.html
---

# Configure Seu EspaÃ§o de Trabalho

A construÃ§Ã£o no Substrate envolve trabalhar com uma estrutura de blockchain flexÃ­vel e modular. Ao contrÃ¡rio das blockchains tradicionais, a arquitetura baseada em paletes do Substrate permite que os desenvolvedores criem blockchains personalizadas e integrem recursos especializados, o que requer um ambiente de desenvolvimento adaptado Ã s suas complexidades.

Nesta seÃ§Ã£o, vocÃª explorarÃ¡ ferramentas e tÃ©cnicas que podem ajudÃ¡-lo a alcanÃ§ar o seguinte com um ambiente de desenvolvimento Substrate:

- **ConfiguraÃ§Ã£o do ambiente local** - inicie um ambiente de teste sem lidar com a complexidade de configurar um nÃ³ Substrate manualmente
- **InteraÃ§Ã£o com a rede** - conecte-se e interaja com redes Tanssi e Powered by Tanssi
- **SimulaÃ§Ã£o de transaÃ§Ã£o** - teste e simule transaÃ§Ãµes em redes bifurcadas para avaliar as alteraÃ§Ãµes antes de implantar
- **DepuraÃ§Ã£o** - use ferramentas de depuraÃ§Ã£o para solucionar problemas e analisar o fluxo de transaÃ§Ãµes, transiÃ§Ãµes de estado e muito mais em um ambiente controlado

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/
--- BEGIN CONTENT ---
---
title: API do Substrate
description: Aprenda a interagir com sua rede powered by Tanssi usando a API Substrate, alavancando ferramentas como a API Polkadot.js, a API Sidecar, Chopsticks e outras.
icon: simple-paritysubstrate
template: index-page.html
---

# Ferramentas Substrate

Ao desenvolver na Tanssi ou em qualquer rede powered by Tanssi, Ã© importante entender a infraestrutura subjacente que impulsiona essas cadeias. ConstruÃ­das sobre o framework Substrate, essas redes oferecem uma base robusta e flexÃ­vel para a construÃ§Ã£o de aplicaÃ§Ãµes e serviÃ§os descentralizados. Interagir com a API Substrate Ã© fundamental para interagir com as funcionalidades principais do blockchain.

Quer vocÃª esteja construindo aplicaÃ§Ãµes descentralizadas (dApps), implantando contratos inteligentes ou consultando dados de blockchain, ter as ferramentas e fluxos de trabalho corretos para interagir com esta API ajudarÃ¡ vocÃª a otimizar o desenvolvimento e garantir uma integraÃ§Ã£o perfeita com a rede.

Pronto para mergulhar? Confira algumas das seguintes ferramentas:

- **Ambientes de desenvolvimento** - [Chopsticks](/pt/builders/toolkit/substrate-api/dev-env/chopsticks/)
- **Bibliotecas** - [API Polkadot.js](/pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/) e [API REST Sidecar](/pt/builders/toolkit/substrate-api/libraries/sidecar-api/)
- **Carteiras** - [SubWallet](/pt/builders/toolkit/ethereum-api/wallets/subwallet/) e [Talisman](/pt/builders/toolkit/ethereum-api/wallets/talisman/)

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/libraries/
--- BEGIN CONTENT ---
---
title: Bibliotecas Substrate
description: Aprenda a usar bibliotecas Substrate como a API Polkadot.js para enviar transaÃ§Ãµes (extrÃ­nsecas) e interagir com a camada Substrate de uma rede.
icon: octicons-code-24
template: index-page.html
---

# Bibliotecas

Como Tanssi e as redes baseadas em Tanssi sÃ£o construÃ­das no Substrate, os desenvolvedores podem utilizar bibliotecas personalizadas para a API Substrate para aproveitar os recursos distintos da rede.

Essas bibliotecas simplificam a interaÃ§Ã£o com a arquitetura modular do Substrate, ajudando vocÃª a navegar pelas complexidades dos mÃ³dulos personalizados com facilidade e acelerar seu processo de desenvolvimento.

Alguns recursos principais de trabalhar com bibliotecas incluem:

- **Gerenciamento de transaÃ§Ãµes** - construir e assinar transaÃ§Ãµes para enviar extrÃ­nsecas (mudanÃ§as de estado) para o blockchain
- **InteraÃ§Ã£o com mÃ³dulos personalizados** - invocar as funÃ§Ãµes expostas de um mÃ³dulo, para consultar dados da cadeia ou acionar mudanÃ§as de estado
- **Gerenciamento de contas** - criar pares de chaves criptogrÃ¡ficas para assinar transaÃ§Ãµes e gerenciar informaÃ§Ãµes de contas na cadeia, como saldos

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/libraries/polkadot-js-api/
--- BEGIN CONTENT ---
---
title: Como usar a API Polkadot.js
description: Aprenda a usar a API Polkadot.js para interagir com uma rede Tanssi, obtendo dados da cadeia e enviando transaÃ§Ãµes (extrÃ­nsecas) via Substrate.
keywords: polkadot.js, substrate, tanssi, api, extrinsics, rpc, typescript
icon: octicons-code-24
categories: Substrate-Template
---

# Biblioteca da API Polkadot.js

## IntroduÃ§Ã£o {: #introduction }

[Polkadot.js](https://wiki.polkadot.com/general/polkadotjs/){target=\_blank} Ã© um conjunto de ferramentas que permite interagir com blockchains baseadas em Substrate, como a sua rede com Tanssi! A [API Polkadot.js](https://polkadot.js.org/docs/api){target=\_blank} Ã© um de seus componentes: uma biblioteca que permite aos desenvolvedores consultar a rede e interagir com as interfaces Substrate do nÃ³ usando JavaScript, possibilitando ler e escrever dados na rede.

VocÃª pode usar a API Polkadot.js para consultar dados on-chain e enviar transaÃ§Ãµes pelo lado Substrate da sua rede Tanssi. Ã‰ possÃ­vel consultar constantes do runtime, estado da cadeia, eventos, dados de transaÃ§Ãµes (extrÃ­nsecas) e muito mais.

Aqui vocÃª encontra uma visÃ£o geral das funcionalidades disponÃ­veis e exemplos de cÃ³digo em [TypeScript](https://www.typescriptlang.org){target=\_blank} para comeÃ§ar a interagir com sua rede Tanssi usando a biblioteca Polkadot.js API.

!!! note "Nota do editor (atualizaÃ§Ã£o 2025)"
    Polkadot.js Ã© o nome do conjunto de ferramentas para interaÃ§Ã£o com blockchains Substrate. Embora o nome faÃ§a referÃªncia ao Polkadot, a biblioteca Ã© agnÃ³stica de cadeia e funciona com qualquer rede baseada em Substrate, incluindo o Tanssi.

!!! note
    Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessÃ¡rio.
    
    Verifique tambÃ©m se vocÃª tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a [documentaÃ§Ã£o oficial](https://nodejs.org/en/download){target=\blank}.
    
    AlÃ©m disso, certifique-se de ter inicializado um arquivo `package.json` para mÃ³dulos ES6. VocÃª pode criar um `package.json` padrÃ£o com npm executando `npm init --yes`.

## Instalar a API Polkadot.js {: #installing-polkadot.js-api-library }

Primeiro, instale a biblioteca Polkadot.js API e a biblioteca RLP usando um gerenciador de pacotes como `yarn`. Ambas sÃ£o necessÃ¡rias para executar os exemplos deste guia.

Instale no diretÃ³rio do projeto com:

=== "npm"

    ```bash
    npm i @polkadot/api
    npm i @polkadot/util-rlp
    ```

=== "yarn"

    ```bash
    yarn add @polkadot/api
    yarn add @polkadot/util-rlp
    ```

A biblioteca tambÃ©m inclui outros componentes centrais, como o Keyring para gerenciamento de contas e utilitÃ¡rios usados ao longo do guia.

## Criar uma InstÃ¢ncia do Provedor da API {: #creating-an-API-provider-instance }

Para interagir com sua rede Tanssi usando a Polkadot.js API, crie uma instÃ¢ncia da API. Construa o `WsProvider` usando o endpoint WebSocket da sua rede Tanssi.

```typescript
// Importar
import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construir provedor da API
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Seu cÃ³digo aqui

  await api.disconnect();
};

main();
```

### Metadata e DecoraÃ§Ã£o DinÃ¢mica da API {: #metadata-and-dynamic-api-decoration }

Quando a API Polkadot.js se conecta a um nÃ³, uma das primeiras aÃ§Ãµes Ã© recuperar a metadata e decorar a API com base nela. A metadata fornece a estrutura:

```text
api.<type>.<module>.<section>
```

Onde `<type>` pode ser:

- `query` â€” endpoints de leitura de estado
- `tx` â€” endpoints relacionados a transaÃ§Ãµes
- `rpc` â€” endpoints especÃ­ficos para chamadas RPC
- `consts` â€” endpoints para constantes do runtime

Nada em `api.{query, tx, rpc, consts}.<module>.<method>` Ã© hardcoded. Isso torna a biblioteca modular e adaptÃ¡vel a qualquer cadeia Substrate com diferentes [mÃ³dulos](/pt/learn/framework/modules/){target=\_blank}, como sua rede Tanssi.

## Consultar Dados On-Chain {: #querying-for-information }

### Consultas de Estado {: #state-queries }

Recuperam informaÃ§Ãµes sobre o estado atual da cadeia. Esses endpoints geralmente tÃªm a forma `api.query.<module>.<method>`, decorados a partir da metadata. Liste endpoints inspecionando `api.query`, por exemplo:

```typescript
console.log(api.query);
```

ApÃ³s [inicializar a API](#creating-an-API-provider-instance), vocÃª pode obter informaÃ§Ãµes bÃ¡sicas de conta com:

```typescript
// Definir endereÃ§o da carteira
const addr = 'INSERT_ADDRESS';

// Obter o Ãºltimo timestamp
const now = await api.query.timestamp.now();

// Obter saldo da conta e nonce atual via mÃ³dulo system
const { nonce, data: balance } = await api.query.system.account(addr);

console.log(
  `${now}: balance of ${balance.free} and a current nonce of ${nonce}`
);
```

??? code "Veja o script completo"

    ```typescript
    import '@polkadot/api-augment';
import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Define wallet address
  const addr = 'INSERT_ADDRESS';

  // Retrieve the last timestamp via the timestamp module
  const now = await api.query.timestamp.now();

  // Retrieve the account balance & current nonce via the system module
  const { nonce, data: balance } = await api.query.system.account(addr);

  console.log(
    `${now}: balance of ${balance.free} and a current nonce of ${nonce}`
  );

  // Disconnect the API
  await api.disconnect();
};

main();
    ```

### Consultas RPC {: #rpc-queries }

As chamadas RPC sÃ£o a base para transmissÃ£o de dados com o nÃ³. Endpoints como `api.query`, `api.tx` ou `api.derive` encapsulam chamadas RPC, fornecendo informaÃ§Ãµes no formato esperado pelo nÃ³. Liste endpoints via:

```typescript
console.log(api.rpc);
```

O `api.rpc` segue formato semelhante ao `api.query`. Por exemplo, apÃ³s [inicializar a API](#creating-an-API-provider-instance), obtenha dados da cadeia e o cabeÃ§alho mais recente:

```typescript
// Obter nome da cadeia
const chain = await api.rpc.system.chain();

// Obter o cabeÃ§alho mais recente
const lastHeader = await api.rpc.chain.getHeader();

// Registrar as informaÃ§Ãµes
console.log(
  `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`
);
```

??? code "Veja o script completo"

    ```typescript
    import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Retrieve the chain name
  const chain = await api.rpc.system.chain();

  // Retrieve the latest header
  const lastHeader = await api.rpc.chain.getHeader();

  // Log the information
  console.log(
    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`
  );

  // Disconnect the API
  await api.disconnect();
};

main();
    ```

### Consultas por Assinatura {: #query-subscriptions }

O `rpc` tambÃ©m oferece endpoints de assinatura. ApÃ³s [inicializar a API](#creating-an-API-provider-instance), vocÃª pode ouvir novos blocos:

```typescript
// Obter nome da cadeia
const chain = await api.rpc.system.chain();

// Assinar novos cabeÃ§alhos
await api.rpc.chain.subscribeNewHeads((lastHeader) => {
  console.log(
    `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`
  );
});
```

O padrÃ£o geral em `api.rpc.subscribe*` Ã© passar um callback que Ã© acionado a cada novo item importado.

Chamadas em `api.query.*` tambÃ©m aceitam callbacks para modo assinado, inclusive chamadas com parÃ¢metros. Exemplo para monitorar saldo de uma conta:

```typescript
// Definir endereÃ§o da carteira
const addr = 'INSERT_ADDRESS';

// Assinar mudanÃ§as de saldo para uma conta especÃ­fica
await api.query.system.account(addr, ({ nonce, data: balance }) => {
  console.log(
    `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`
  );
});
```

??? code "Veja o script completo"

    ```typescript
    import '@polkadot/api-augment';
import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Retrieve the chain name
  const chain = await api.rpc.system.chain();

  // Subscribe to the new headers
  await api.rpc.chain.subscribeNewHeads((lastHeader) => {
    console.log(
      `${chain}: last block #${lastHeader.number} has hash ${lastHeader.hash}`
    );
  });

  // Define wallet address
  const addr = 'INSERT_ADDRESS';

  // Subscribe to balance changes for a specified account
  await api.query.system.account(addr, ({ nonce, data: balance }) => {
    console.log(
      `Free balance is ${balance.free} with ${balance.reserved} reserved and a nonce of ${nonce}`
    );

    // Handle API disconnect here if needed
  });
};

main();
    ```

## Criar um Keyring para uma Conta {: #keyrings }

O objeto Keyring mantÃ©m pares de chaves e assina quaisquer dados, seja transferÃªncia, mensagem ou interaÃ§Ã£o com contrato.

### Criar uma InstÃ¢ncia de Keyring {: #creating-a-keyring-instance }

Instancie a classe Keyring e defina o tipo padrÃ£o de endereÃ§o. O padrÃ£o Ã© `sr25519`, mas para redes Tanssi compatÃ­veis com EVM use `ethereum`.

```typescript
// Importe o keyring conforme necessÃ¡rio
import Keyring from '@polkadot/keyring';

// Crie uma instÃ¢ncia de keyring (ECDSA)
const keyringECDSA = new Keyring({ type: 'ethereum' });

// Crie uma instÃ¢ncia de keyring (SR25519)
const keyring = new Keyring({ type: 'sr25519' });
```

### Adicionar uma Conta ao Keyring {: #adding-accounts }

HÃ¡ vÃ¡rias formas de adicionar contas, incluindo frase mnemÃ´nica e chave privada curta. Exemplos:

=== "Mnemonic (ECDSA)"

    ```typescript
    // Import the required packages
import Keyring from '@polkadot/keyring';
import { u8aToHex } from '@polkadot/util';
import { mnemonicToLegacySeed, hdEthereum } from '@polkadot/util-crypto';

// Import Ethereum account from mnemonic
const keyringECDSA = new Keyring({ type: 'ethereum' });
const mnemonic = 'INSERT_MNEMONIC';

// Define index of the derivation path and the derivation path
const index = 0;
const ethDerPath = "m/44'/60'/0'/0/" + index;
console.log(`Mnemonic: ${mnemonic}`);
console.log(`--------------------------\n`);

// Extract Ethereum address from mnemonic
const newPairEth = keyringECDSA.addFromUri(`${mnemonic}/${ethDerPath}`);
console.log(`Ethereum Derivation Path: ${ethDerPath}`);
console.log(`Derived Ethereum Address from Mnemonic: ${newPairEth.address}`);

// Extract private key from mnemonic
const privateKey = u8aToHex(
  hdEthereum(mnemonicToLegacySeed(mnemonic, '', false, 64), ethDerPath)
    .secretKey
);
console.log(`Derived Private Key from Mnemonic: ${privateKey}`);
    ```

=== "Chave privada (ECDSA)"

    ```typescript
    // Import the required packages
import Keyring from '@polkadot/keyring';

// Import Ethereum account from private key
const keyringECDSA = new Keyring({ type: 'ethereum' });
const privateKeyInput = 'INSERT_PK';

// Extract address from private key
const otherPair = keyringECDSA.addFromUri(privateKeyInput);
console.log(`Derived Address from provided Private Key: ${otherPair.address}`);
    ```

=== "Mnemonic (SR25519)"

    ```typescript
    // Import the required packages
import Keyring from '@polkadot/keyring';
import { cryptoWaitReady } from '@polkadot/util-crypto';

const main = async () => {
  await cryptoWaitReady();

  // Import SR25519 account from mnemonic
  const keyring = new Keyring({ type: 'sr25519' });
  const mnemonic = 'INSERT_MNEMONIC';

  // Extract SR25519 address from mnemonic
  const newPair = keyring.addFromUri(`${mnemonic}`);
  console.log(`Derived SR25519 Address from Mnemonic: ${newPair.address}`);
};

main();
    ```

## Enviando TransaÃ§Ãµes {: #transactions }

Endpoints de transaÃ§Ã£o tÃªm a forma `api.tx.<module>.<method>`, decorados via metadata. Eles permitem enviar transaÃ§Ãµes para inclusÃ£o em blocos â€” transferÃªncias, interaÃ§Ãµes com pallets, ou qualquer coisa suportada. Liste endpoints via:

```typescript
console.log(api.tx);
```

### Enviar uma TransaÃ§Ã£o BÃ¡sica {: #sending-basic-transactions }

A Polkadot.js API pode enviar transaÃ§Ãµes. Supondo que vocÃª tenha [inicializado a API](#creating-an-API-provider-instance) e um [keyring](#creating-a-keyring-instance), use:

```typescript
// Inicializar pares de chaves da carteira
const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');

// Montar a transaÃ§Ã£o
const tx = await api.tx.balances.transferAllowDeath(
  'INSERT_BOBS_ADDRESS',
  BigInt(INSERT_VALUE)
);

// Obter o calldata codificado da transaÃ§Ã£o
const encodedCallData = tx.method.toHex()
console.log(`Encoded calldata: ${encodedCallData}`);

// Assinar e enviar a transaÃ§Ã£o
const txHash = await tx.signAndSend(alice);

// Exibir o hash da transaÃ§Ã£o
console.log(`Submitted with hash ${txHash}`);
```

??? code "Veja o script completo"

    ```typescript
    import { ApiPromise, WsProvider } from '@polkadot/api';
import Keyring from '@polkadot/keyring';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Create a keyring instance (ECDSA)
  const keyring = new Keyring({ type: 'ethereum' });

  // Initialize wallet key pairs
  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');

  // Form the transaction
  const tx = await api.tx.balances.transferAllowDeath(
    'INSERT_BOBS_ADDRESS',
    BigInt(INSERT_VALUE)
  );

  // Retrieve the encoded calldata of the transaction
  const encodedCalldata = tx.method.toHex();
  console.log(`Encoded calldata: ${encodedCalldata}`);

  // Sign and send the transaction
  const txHash = await tx.signAndSend(alice);

  // Show the transaction hash
  console.log(`Submitted with hash ${txHash}`);

  // Disconnect the API
  await api.disconnect();
};

main();
    ```

Observe que `signAndSend` aceita parÃ¢metros opcionais, como `nonce`, por exemplo `signAndSend(alice, { nonce: aliceNonce })`. VocÃª pode usar o cÃ³digo da seÃ§Ã£o [Consultas de estado](#state-queries){target=\_blank} para obter o nonce correto, incluindo transaÃ§Ãµes no mempool.

### InformaÃ§Ãµes de Taxa {: #fees}

Os endpoints de transaÃ§Ã£o tambÃ©m oferecem um mÃ©todo para obter o peso de um `api.tx.<module>.<method>`. Use `paymentInfo` apÃ³s montar a transaÃ§Ã£o com o mÃ³dulo e mÃ©todo especÃ­ficos.

`paymentInfo` retorna informaÃ§Ãµes de peso em `refTime` e `proofSize`, que podem ser usadas para determinar a taxa da transaÃ§Ã£o â€” Ãºtil ao criar execuÃ§Ãµes remotas via XCM.

Exemplo, apÃ³s [inicializar a API](#creating-an-API-provider-instance), para obter peso de uma transferÃªncia simples:

```typescript
// TransaÃ§Ã£o para obter informaÃ§Ãµes de peso
const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));

// Obter informaÃ§Ãµes de peso
const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');

console.log(`Transaction weight: ${weight}`);
console.log(`Transaction fee: ${partialFee.toHuman()}`);
```

??? code "Veja o script completo"
    ```typescript
    import { ApiPromise, WsProvider } from '@polkadot/api';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Transaction to get weight information
  const tx = api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE));

  // Get weight info
  const { partialFee, weight } = await tx.paymentInfo('INSERT_SENDERS_ADDRESS');

  console.log(`Transaction weight: ${weight}`);
  console.log(`Transaction fee: ${partialFee.toHuman()}`);

  // Disconnect the API
  await api.disconnect();
};

main();
    ```

### Eventos de TransaÃ§Ã£o {: #transaction-events }

Qualquer transaÃ§Ã£o emite eventos; no mÃ­nimo, haverÃ¡ `system.ExtrinsicSuccess` ou `system.ExtrinsicFailed`, indicando sucesso ou falha na execuÃ§Ã£o. Dependendo da transaÃ§Ã£o, outros eventos podem ser emitidos, por exemplo `balances.Transfer` em uma transferÃªncia.

### Agrupar TransaÃ§Ãµes {: #batching-transactions }

A Polkadot.js API permite processar transaÃ§Ãµes em lote via `api.tx.utility.batch`. As transaÃ§Ãµes sÃ£o processadas sequencialmente de um Ãºnico remetente. A taxa pode ser estimada com `paymentInfo`.

Assumindo que vocÃª tenha [inicializado a API](#creating-an-API-provider-instance), um [keyring](#creating-a-keyring-instance) e [adicionado uma conta](#adding-accounts), o exemplo abaixo faz duas transferÃªncias em uma transaÃ§Ã£o:

```typescript
// Construir lista de transaÃ§Ãµes para o batch
const txs = [
  api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),
  api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),
];

// Estime as taxas como RuntimeDispatchInfo usando o assinante
// (endereÃ§o ou par de chaves bloqueado/desbloqueado)
const info = await api.tx.utility
  .batch(txs)
  .paymentInfo(alice);

console.log(`Estimated fees: ${info}`);

// Construir o batch e enviar as transaÃ§Ãµes
await api.tx.utility
  .batch(txs)
  .signAndSend(alice, ({ status }) => {
    if (status.isInBlock) {
      console.log(`included in ${status.asInBlock}`);

      // Desconecte a API aqui!
    }
  });
```

??? code "Veja o script completo"

    ```typescript
    import { ApiPromise, WsProvider } from '@polkadot/api';
import Keyring from '@polkadot/keyring';

const main = async () => {
  // Construct API provider
  const wsProvider = new WsProvider('INSERT_NETWORK_WSS_ENDPOINT');
  const api = await ApiPromise.create({ provider: wsProvider });

  // Create a keyring instance (ECDSA)
  const keyring = new Keyring({ type: 'ethereum' });

  // Initialize wallet key pairs
  const alice = keyring.addFromUri('INSERT_ALICES_PRIVATE_KEY');

  // Construct a list of transactions to batch
  const txs = [
    api.tx.balances.transferAllowDeath('INSERT_BOBS_ADDRESS', BigInt(INSERT_VALUE)),
    api.tx.balances.transferAllowDeath('INSERT_CHARLEYS_ADDRESS', BigInt(INSERT_VALUE)),
  ];

  // Estimate the fees as RuntimeDispatchInfo, using the signer (either
  // address or locked/unlocked keypair)
  const info = await api.tx.utility.batch(txs).paymentInfo(alice);

  console.log(`Estimated fees: ${info}`);

  // Construct the batch and send the transactions
  await api.tx.utility.batch(txs).signAndSend(alice, async ({ status }) => {
    if (status.isInBlock) {
      console.log(`Included in ${status.asInBlock}`);

      // Disconnect the API
      await api.disconnect();
    }
  });
};

main();
    ```

## CÃ³digo de Exemplo para Monitorar TransferÃªncias do Token Nativo { #sample-code-for-monitoring-native-token-transfers }

Os cÃ³digos a seguir mostram como escutar transferÃªncias do token nativo, enviadas via Substrate ou Ethereum API, usando a [biblioteca Polkadot.js](https://polkadot.js.org/docs/api/start){target=\_blank} ou o [Substrate API Sidecar](https://github.com/paritytech/substrate-api-sidecar){target=\_blank}. Os snippets sÃ£o para demonstraÃ§Ã£o e precisam de ajustes e testes antes de produÃ§Ã£o.

O snippet abaixo usa [`subscribeFinalizedHeads`](https://polkadot.js.org/docs/substrate/rpc/#subscribefinalizedheads-header){target=\_blank} para assinar cabeÃ§alhos de blocos finalizados, percorre as extrÃ­nsecas do bloco e recupera eventos de cada extrÃ­nseca. Se encontrar um evento `balances.Transfer`, extrai `from`, `to`, `amount` e o `tx hash` e mostra no console. O `amount` aparece na menor unidade (Wei). Veja a documentaÃ§Ã£o oficial para detalhes da API Polkadot.js e do JSON RPC do Substrate.

```typescript
import '@polkadot/api-augment';
import { ApiPromise, WsProvider } from '@polkadot/api';

// This script will listen to all Native token transfers (Substrate & Ethereum) and extract the tx hash
// It can be adapted for any Tanssi-powered network

const main = async () => {
  // Define the provider
  const wsProvider = new WsProvider('INSERT_WSS_ENDPOINT');
  // Create the provider
  const polkadotApi = await ApiPromise.create({
    provider: wsProvider,
  });

  // Subscribe to finalized blocks
  await polkadotApi.rpc.chain.subscribeFinalizedHeads(
    async (lastFinalizedHeader) => {
      const [{ block }, records] = await Promise.all([
        polkadotApi.rpc.chain.getBlock(lastFinalizedHeader.hash),
        (await polkadotApi.at(lastFinalizedHeader.hash)).query.system.events(),
      ]);

      block.extrinsics.forEach((extrinsic, index) => {
        const {
          method: { args, method, section },
        } = extrinsic;

        const isEthereum = section == 'ethereum' && method == 'transact';

        // Gets the transaction object
        const tx = args[0] as any;

        // Convert to the correct Ethereum Transaction format
        const ethereumTx =
          isEthereum &&
          ((tx.isLegacy && tx.asLegacy) ||
            (tx.isEip1559 && tx.asEip1559) ||
            (tx.isEip2930 && tx.asEip2930));

        // Check if the transaction is a transfer
        const isEthereumTransfer =
          ethereumTx &&
          ethereumTx.input.length === 0 &&
          ethereumTx.action.isCall;

        // Retrieve all events for this extrinsic
        const events = records.filter(
          ({ phase }) =>
            phase.isApplyExtrinsic && phase.asApplyExtrinsic.eq(index)
        );

        // This hash will only exist if the transaction was executed through Ethereum.
        let ethereumHash = '';

        if (isEthereum) {
          // Search for Ethereum execution
          events.forEach(({ event }) => {
            if (event.section == 'ethereum' && event.method == 'Executed') {
              ethereumHash = event.data[2].toString();
            }
          });
        }

        // Search if it is a transfer
        events.forEach(({ event }) => {
          if (event.section == 'balances' && event.method == 'Transfer') {
            const from = event.data[0].toString();
            const to = event.data[1].toString();
            const balance = (event.data[2] as any).toBigInt();

            const substrateHash = extrinsic.hash.toString();

            console.log(
              `Transfer from ${from} to ${to} of ${balance} (block #${lastFinalizedHeader.number})`
            );
            console.log(`  - Triggered by extrinsic: ${substrateHash}`);
            if (isEthereum) {
              console.log(
                `  - Ethereum (isTransfer: ${isEthereumTransfer}) hash: ${ethereumHash}`
              );
            }
          }
        });
      });
    }
  );
};

main();
```

HÃ¡ mais exemplos de transferÃªncias neste [gist](https://gist.github.com/crystalin/b2ce44a208af60d62b5ecd1bad513bce){target=\_blank}.

## FunÃ§Ãµes UtilitÃ¡rias {: #utilities }

A API Polkadot.js inclui utilitÃ¡rios para primitivas criptogrÃ¡ficas e funÃ§Ãµes de hash.

O exemplo a seguir calcula o hash determinÃ­stico de uma transaÃ§Ã£o Ethereum legacy crua: primeiro gera a codificaÃ§Ã£o RLP ([Recursive Length Prefix](https://ethereum.org/developers/docs/data-structures-and-encoding/rlp/){target=\_blank}) e depois aplica keccak256.

```typescript
import { encode } from '@polkadot/util-rlp';
import { keccakAsHex } from '@polkadot/util-crypto';
import { numberToHex } from '@polkadot/util';

// Defina o tipo da chave como string
type txType = {
  [key: string]: any;
};

// Defina a transaÃ§Ã£o assinada bruta
const txData: txType = {
  nonce: numberToHex(1),
  gasPrice: numberToHex(21000000000),
  gasLimit: numberToHex(21000),
  to: '0xc390cC49a32736a58733Cf46bE42f734dD4f53cb',
  value: numberToHex(1000000000000000000),
  data: '',
  v: '0507',
  r: '0x5ab2f48bdc6752191440ce62088b9e42f20215ee4305403579aa2e1eba615ce8',
  s: '0x3b172e53874422756d48b449438407e5478c985680d4aaa39d762fe0d1a11683',
};

// Extraia os valores para um array
var txDataArray = Object.keys(txData).map(function (key) {
  return txData[key];
});

// Calcule a transaÃ§Ã£o codificada em RLP
var encoded_tx = encode(txDataArray);

// FaÃ§a o hash da transaÃ§Ã£o codificada usando keccak256
console.log(keccakAsHex(encoded_tx));
```

Consulte o [repositÃ³rio NPM](https://www.npmjs.com/package/@polkadot/util-crypto){target=\_blank} para a lista de mÃ©todos disponÃ­veis em `@polkadot/util-crypto` e suas descriÃ§Ãµes.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/libraries/sidecar-api/
--- BEGIN CONTENT ---
---
title: Usando o Substrate API Sidecar
description: Aprenda a usar o serviÃ§o REST baseado em Substrate com redes Tanssi para acessar blocos, saldo de contas, calcular gas usado e muito mais.
icon: octicons-code-24
categories: Substrate-Template
---

# Usando o Substrate API Sidecar

## IntroduÃ§Ã£o {: #introduction }

O Substrate API Sidecar permite que aplicaÃ§Ãµes acessem blocos, saldo de contas e outras informaÃ§Ãµes de blockchains baseadas em Substrate por meio de uma API REST. Isso Ã© Ãºtil para exchanges, carteiras ou outras aplicaÃ§Ãµes que precisam acompanhar saldo e mudanÃ§as de estado em uma rede powered by Tanssi. Esta pÃ¡gina descreve como instalar e executar o Substrate API Sidecar para uma rede Tanssi e os endpoints mais usados.


## Instalando e Executando o Substrate API Sidecar {: #installing-and-running-substrate-api-sidecar }

Existem vÃ¡rias formas de instalar e executar o Substrate API Sidecar. Este guia descreve os passos para instalÃ¡-lo e executÃ¡-lo localmente via NPM. Para uso via Docker ou build e execuÃ§Ã£o a partir do cÃ³digo-fonte, consulte o [repositÃ³rio oficial do Substrate API Sidecar](https://github.com/paritytech/substrate-api-sidecar#readme){target=\_blank}.

!!! note
    Os exemplos deste guia partem de um ambiente MacOS ou Ubuntu 20.04. Se estiver usando Windows, adapte os comandos conforme necessÃ¡rio.
    
    Verifique tambÃ©m se vocÃª tem o Node.js e um gerenciador de pacotes (como npm ou yarn) instalados. Para saber como instalar o Node.js, consulte a [documentaÃ§Ã£o oficial](https://nodejs.org/en/download){target=\blank}.
    
    AlÃ©m disso, certifique-se de ter inicializado um arquivo `package.json` para mÃ³dulos ES6. VocÃª pode criar um `package.json` padrÃ£o com npm executando `npm init --yes`.

### Instalando o Substrate API Sidecar {: #installing-the-substrate-api-sidecar }

Para instalar o serviÃ§o localmente no diretÃ³rio atual, execute:

```bash
npm install @substrate/api-sidecar@{{ networks.mainnet.substrate_api_sidecar.stable_version }}
```

!!! note
    Se a pasta nÃ£o tiver um projeto Node.js, crie manualmente `node_modules` com `mkdir node_modules`.

O Substrate API Sidecar v{{ networks.mainnet.substrate_api_sidecar.stable_version }} Ã© a versÃ£o estÃ¡vel atual testada com redes Tanssi. Verifique a instalaÃ§Ã£o a partir da raiz do diretÃ³rio:

```bash
node_modules/.bin/substrate-api-sidecar --version
```

## Configurando o Substrate API Sidecar {: #setting-up-the-substrate-api-sidecar }

No terminal em que o Sidecar rodarÃ¡, exporte a variÃ¡vel de ambiente com o endpoint WS da rede que deseja usar. Exemplos:

=== "Tanssi MainNet"

    ```bash
    export SAS_SUBSTRATE_URL=wss://{{ networks.mainnet.dns_name }}
    ```

=== "Dancelight TestNet"

    ```bash
    export SAS_SUBSTRATE_URL=wss://{{ networks.dancelight.dns_name }}
    ```

=== "Rede EVM de DemonstraÃ§Ã£o"

    ```bash
    export SAS_SUBSTRATE_URL={{ networks.dancelight.demo_evm_rpc_wss_url }}
    ```

=== "Sua rede"

    ```bash
    export SAS_SUBSTRATE_URL=INSERIR_ENDPOINT_WSS_DA_REDE
    ```

Depois de definir, confirme com:

```bash
echo $SAS_SUBSTRATE_URL
```

Ele deve exibir o endpoint configurado.

## Executando o Substrate API Sidecar {: #running-substrate-api-sidecar }

Com a variÃ¡vel de ambiente configurada e a partir da raiz da instalaÃ§Ã£o, execute:

```bash
node_modules/.bin/substrate-api-sidecar
```

Se a instalaÃ§Ã£o e configuraÃ§Ã£o estiverem corretas, verÃ¡ uma saÃ­da semelhante a:

![SaÃ­da bem-sucedida](/images/builders/toolkit/substrate-api/libraries/sidecar-api/sidecar-1.webp)

## Endpoints do Substrate API Sidecar {: #substrate-api-sidecar-endpoints }

Endpoints comuns:

 - **GET /blocks/head** â€” bloco finalizado mais recente. O parÃ¢metro opcional `finalized=false` retorna o bloco mais novo, possivelmente nÃ£o finalizado
 - **GET /blocks/head/header** â€” cabeÃ§alho do Ãºltimo bloco. `finalized=false` opcional
 - **GET /blocks/{blockId}** â€” bloco por altura ou hash
 - **GET /accounts/{accountId}/balance-info** â€” saldo e informaÃ§Ãµes da conta
 - **GET /node/version** â€” implementaÃ§Ã£o e versÃ£o do nÃ³ Substrate
 - **GET /runtime/metadata** â€” metadata do runtime em JSON decodificado

Para a lista completa, consulte a [documentaÃ§Ã£o oficial](https://paritytech.github.io/substrate-api-sidecar/dist){target=\_blank}.

## Mapeamento de Campos no Objeto JSON do Bloco {: #fields-mapping-in-block-json-object }

O Sidecar retorna blocos em JSON. Parte do objeto Ã© a estrutura aninhada das extrÃ­nsecas processadas em um bloco especÃ­fico. Cada extrÃ­nseca chama um mÃ©todo de um mÃ³dulo. Em linhas gerais, a estrutura Ã©:

```text
RESPONSE JSON Block Object:
    |--extrinsics
        |--{extrinsic_number}
            |--method
                |--pallet: "MODULE_NAME"
                |--method: "METHOD_NAME"
            |--signature
            |--nonce
            |--args
                |--transaction
                    |--{transaction_type}
            |--hash
            |--events
                |--{event_number}
                    |--method
                        |--pallet: "MODULE_NAME"
                        |--method: "METHOD_EVENT_NAME"
                    |--data
                        |--0
                        |--1
                        |--2
                        |--3
    ...
```

Saber o mÃ³dulo e mÃ©todo chamados permite extrair informaÃ§Ãµes especÃ­ficas (por exemplo, transferÃªncias de saldo).

## Mapeamento EVM em Blocos {: #evm-fields-mapping-in-block-json-object }

Para redes EVM da Tanssi, execuÃ§Ãµes EVM sÃ£o identificadas por:

```text
{extrinsic_number}.method.pallet = "ethereum"
{extrinsic_number}.method.method = "transact"
```

Estrutura aninhada:

```text
RESPONSE JSON Block Object:
    |--extrinsics
        |--{extrinsic_number}
            |--method
                |--pallet: "ethereum"
                |--method: "transact"
            |--signature
            |--nonce
            |--args
                |--transaction
                    |--{transaction_type}
            |--hash
            |--events
                |--{event_number}
                    |--method
                        |--pallet: "ethereum"
                        |--method: "Executed"
                    |--data
                        |--0
                        |--1
                        |--2
                        |--3
    ...
```

Para transaÃ§Ãµes Substrate, campos como â€œNonceâ€ e â€œSignatureâ€ ficam em:

```text
extrinsics[extrinsic_number]
```

### Tipos de TransaÃ§Ã£o EVM e Payload {: #transaction-types-and-payload }

As redes EVM da Tanssi suportam `legacy`, `eip1559` e `eip2930`. Cada tipo contÃ©m o seguinte payload:

=== "EIP1559"

    ```text
        ...
        |--eip1559
            |--chainId
            |--nonce
            |--maxPriorityFeePerGas
            |--maxFeePerGas
            |--gasLimit
            |--action
            |--value
            |--input
            |--accessList
            |--oddYParity
            |--r
            |--s
        ...
    ```

=== "Legacy"

    ```text
        ...
        |--legacy
            |--nonce
            |--gasPrice
            |--gasLimit
            |--action
            |--value
            |--input
            |--signature
        ...
    ```

=== "EIP2930"

    ```text
        ...
        |--eip2930
            |--chainId
            |--nonce
            |--gasPrice
            |--gasLimit
            |--action
            |--value
            |--input
            |--accessList
            |--oddYParity
            |--r
            |--s
        ...
    ```

Para mais detalhes sobre [EIP1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} e [EIP2930](https://eips.ethereum.org/EIPS/eip-2930){target=\_blank}, veja as especificaÃ§Ãµes oficiais.

### Mapeamento de Campos da TransaÃ§Ã£o {: #transaction-field-mappings }

Para obter remetente, destinatÃ¡rio e hash EVM de qualquer transaÃ§Ã£o, verifique o evento em que:

```text
{event_number}.method.pallet: "ethereum"
{event_number}.method.method: "Executed"
```

Mapeamentos:

=== "EIP1559"
    |       Campo EVM       |                               Campo JSON do bloco                               |
    |:---------------------:|:-------------------------------------------------------------------------------:|
    |       Chain ID        |        `extrinsics[extrinsic_number].args.transaction.eip1559.chainId`          |
    |         Nonce         |         `extrinsics[extrinsic_number].args.transaction.eip1559.nonce`           |
    | Max priority fee/gas  |  `extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas`  |
    |     Max fee per gas   |      `extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas`       |
    |       Gas limit       |        `extrinsics[extrinsic_number].args.transaction.eip1559.gasLimit`         |
    |      Access list      |       `extrinsics[extrinsic_number].args.transaction.eip1559.accessList`        |
    |       Assinatura      |     `extrinsics[extrinsic_number].args.transaction.eip1559.oddYParity/r/s`      |
    |  EndereÃ§o remetente   |          `extrinsics[extrinsic_number].events[event_number].data[0]`            |
    | EndereÃ§o destinatÃ¡rio |          `extrinsics[extrinsic_number].events[event_number].data[1]`            |
    |        Hash EVM       |          `extrinsics[extrinsic_number].events[event_number].data[2]`            |
    | Status de execuÃ§Ã£o    |          `extrinsics[extrinsic_number].events[event_number].data[3]`            |

=== "Legacy"
    |    Campo EVM    |                         Campo JSON do bloco                          |
    |:---------------:|:--------------------------------------------------------------------:|
    |      Nonce      |   `extrinsics[extrinsic_number].args.transaction.legacy.nonce`       |
    |  Gas price      |  `extrinsics[extrinsic_number].args.transaction.legacy.gasPrice`     |
    |   Gas limit     |  `extrinsics[extrinsic_number].args.transaction.legacy.gasLimit`     |
    |      Valor      |   `extrinsics[extrinsic_number].args.transaction.legacy.value`       |
    |    Assinatura   | `extrinsics[extrinsic_number].args.transaction.legacy.signature`     |
    | Remetente EVM   |   `extrinsics[extrinsic_number].events[event_number].data[0]`        |
    | DestinatÃ¡rio EVM|   `extrinsics[extrinsic_number].events[event_number].data[1]`        |
    |     Hash EVM    |   `extrinsics[extrinsic_number].events[event_number].data[2]`        |
    | Status execuÃ§Ã£o |   `extrinsics[extrinsic_number].events[event_number].data[3]`        |

=== "EIP2930"
    |     Campo EVM      |                            Campo JSON do bloco                             |
    |:------------------:|:--------------------------------------------------------------------------:|
    |      Chain ID      |    `extrinsics[extrinsic_number].args.transaction.eip2930.chainId`         |
    |        Nonce       |     `extrinsics[extrinsic_number].args.transaction.eip2930.nonce`          |
    |     Gas price      |    `extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice`        |
    |     Gas limit      |    `extrinsics[extrinsic_number].args.transaction.eip2930.gasLimit`        |
    |       Valor        |     `extrinsics[extrinsic_number].args.transaction.eip2930.value`          |
    |    Access list     |   `extrinsics[extrinsic_number].args.transaction.eip2930.accessList`       |
    |     Assinatura     | `extrinsics[extrinsic_number].args.transaction.eip2930.oddYParity/r/s`     |
    | Remetente EVM      |      `extrinsics[extrinsic_number].events[event_number].data[0]`           |
    | DestinatÃ¡rio EVM   |      `extrinsics[extrinsic_number].events[event_number].data[1]`           |
    |     Hash EVM       |      `extrinsics[extrinsic_number].events[event_number].data[2]`           |
    | Status execuÃ§Ã£o    |      `extrinsics[extrinsic_number].events[event_number].data[3]`           |

Para transaÃ§Ãµes EVM, campos como â€œNonceâ€ e â€œSignatureâ€ ficam em:

```text
extrinsics[extrinsic_number].args.transaction[transaction_type]
```

Assim, â€œNonceâ€ e â€œSignatureâ€ no nÃ­vel Substrate (`extrinsics[extrinsic_number]`) ficam `null`.

Uma transaÃ§Ã£o EVM bem-sucedida retorna `succeed: "Stopped"` ou `succeed: "Returned"` no campo de status de execuÃ§Ã£o EVM.

## Monitorar TransferÃªncias de Tokens {: #monitor-transfers }

Os trechos a seguir mostram como escutar transferÃªncias do token nativo enviadas via Substrate ou Ethereum API, e transferÃªncias de tokens ERC-20 via Ethereum API, usando o Substrate API Sidecar. TransferÃªncias pela Ethereum API se aplicam apenas a redes EVM da Tanssi.

### TransferÃªncias de Token Nativo {: #native-token-transfers }

Redes Tanssi EVM e nÃ£o-EVM podem fazer transferÃªncias de saldo nativas baseadas em Substrate.

O snippet abaixo usa Axios para consultar o endpoint [`/blocks/head`](https://paritytech.github.io/substrate-api-sidecar/dist){target=\_blank} para o Ãºltimo bloco finalizado, e decodifica `from`, `to`, `value`, `tx hash` e `transaction status` de transferÃªncias nativas tanto no nÃ­vel EVM quanto Substrate.

```typescript
import axios from 'axios';

// This script will decode all native token transfers (Substrate & Ethereum)
// in a given Sidecar block, and extract the tx hash. It can be adapted for
// any Tanssi-powered network.

// Endpoint to retrieve the latest block
const endpoint = 'http://127.0.0.1:8080/blocks/head';

async function main() {
  try {
    // Retrieve the block from the Sidecar endpoint
    const response = await axios.get(endpoint);
    // Retrieve the block height of the current block
    console.log('Block Height: ' + response.data.number);

    // Iterate through all extrinsics in the block
    response.data.extrinsics.forEach((extrinsic) => {
      // Retrieve Ethereum Transfers
      if (
        extrinsic.method.pallet === 'ethereum' &&
        extrinsic.method.method === 'transact'
      ) {
        // Get the value for any of the three EIP transaction standards supported
        const value =
          (extrinsic.args.transaction.legacy &&
            extrinsic.args.transaction.legacy.value) ||
          (extrinsic.args.transaction.eip1559 &&
            extrinsic.args.transaction.eip1559.value) ||
          (extrinsic.args.transaction.eip2930 &&
            extrinsic.args.transaction.eip2930.value);

        // Iterate through the events to get transaction details
        extrinsic.events.forEach((event) => {
          if (
            event.method.pallet === 'ethereum' &&
            event.method.method === 'Executed'
          ) {
            console.log('From: ' + event.data[0]);
            console.log('To: ' + event.data[1]);
            console.log('Tx Hash: ' + event.data[2]);
            console.log('Value: ' + value);
            // Check the execution status
            if (event.data[3].succeed) {
              console.log('Status: Success');
            } else {
              console.log('Status: Failed');
            }
          }
        });
      }

      // Retrieve Substrate Transfers
      if (
        extrinsic.method.pallet === 'balances' &&
        (extrinsic.method.method === 'transferKeepAlive' ||
          extrinsic.method.method === 'transfer')
      ) {
        // Iterate through the events to get transaction details
        extrinsic.events.forEach((event) => {
          if (
            event.method.pallet === 'balances' &&
            event.method.method === 'Transfer'
          ) {
            console.log('From: ' + event.data[0]);
            console.log('To: ' + event.data[1]);
            console.log('Tx Hash: ' + extrinsic.hash);
            console.log('Value: ' + event.data[2]);
            // Check the execution status
            if (extrinsic.success) {
              console.log('Status: Success');
            } else {
              console.log('Status: Failed');
            }
          }
        });
      }
    });
  } catch (err) {
    console.log(err);
  }
}

main();
```

### TransferÃªncias de Tokens ERC-20 {: #erc-20-token-transfers }

Eventos emitidos por smart contracts (como um contrato ERC-20 implantado em redes EVM da Tanssi) podem ser decodificados a partir do JSON do bloco. A estrutura Ã©:

```text
RESPONSE JSON Block Object:
    |--extrinsics
        |--{extrinsic_number}
            |--method
                |--pallet: "ethereum"
                |--method: "transact"
            |--signature:
            |--nonce:
            |--args
                |--transaction
                    |--{transaction_type}
            |--hash
            |--events
                |--{event_number}
                    |--method
                        |--pallet: "evm"
                        |--method: "Log"
                    |--data
                        |--0
                            |-- address
                            |-- topics
                                |--0
                                |--1
                                |--2
\t\t\t\t        |-- data
            ...
    ...

```

TransferÃªncias ERC-20 emitem o evento [`Transfer`](https://eips.ethereum.org/EIPS/eip-20){target=\_blank}, que pode ser decodificado assim:

|  InformaÃ§Ã£o da tx   |                           Campo JSON do bloco                           |
|:-------------------:|:------------------------------------------------------------------------:|
| EndereÃ§o do contrato|  `extrinsics[extrinsic_number].events[event_number].data[0].address`    |
| Hash da assinatura  | `extrinsics[extrinsic_number].events[event_number].data[0].topics[0]`   |
| EndereÃ§o remetente  | `extrinsics[extrinsic_number].events[event_number].data[0].topics[1]`   |
| EndereÃ§o destinatÃ¡rio| `extrinsics[extrinsic_number].events[event_number].data[0].topics[2]`  |
|       Quantia       |   `extrinsics[extrinsic_number].events[event_number].data[0].data`      |

Outros eventos de contratos EVM podem ser decodificados de modo semelhante; o conteÃºdo de `topics` e `data` muda conforme a definiÃ§Ã£o do evento.

!!! note
    A quantia transferida leva em conta as casas decimais e vem em hexadecimal.

## Taxas de TransaÃ§Ã£o na Substrate API {: #substrate-api-transaction-fees }

Para redes Tanssi EVM e nÃ£o-EVM, todas as informaÃ§Ãµes sobre taxas de transaÃ§Ãµes enviadas via Substrate API podem ser extraÃ­das do endpoint:

```text
GET /blocks/{blockId}
```

Os endpoints de bloco retornam dados de um ou mais blocos. Saiba mais na [documentaÃ§Ã£o oficial do Sidecar](https://paritytech.github.io/substrate-api-sidecar/dist/#operations-tag-blocks){target=\_blank}.

Lendo como JSON, para um `pallet` (mÃ³dulo) e `method`, a taxa da transaÃ§Ã£o vem de um evento com:

```text
{event_number}.method.pallet: "transactionPayment"
{event_number}.method.method: "TransactionFeePaid"
```

Estrutura relevante:

```text
RESPONSE JSON Block Object:
    ...
    |--number
    |--extrinsics
        |--{extrinsic_number}
            |--method
            |--signature
            |--nonce
            |--args
            |--tip
            |--hash
            |--info
            |--era
            |--events
                |--{event_number}
                    |--method
                        |--pallet: "transactionPayment"
                        |--method: "TransactionFeePaid"
                    |--data
                        |--0
                        |--1
                        |--2
    ...

```

Mapeamento:

| InformaÃ§Ã£o da tx |                      Campo JSON do bloco                       |
|:----------------:|:--------------------------------------------------------------:|
| Conta que paga   | `extrinsics[extrinsic_number].events[event_number].data[0]`    |
| Taxas totais     | `extrinsics[extrinsic_number].events[event_number].data[1]`    |
| Gorjeta (tip)    | `extrinsics[extrinsic_number].events[event_number].data[2]`    |

A taxa total paga para a extrÃ­nseca estÃ¡ em:

```text
extrinsics[extrinsic_number].events[event_number].data[1]
```


## Taxas de TransaÃ§Ã£o na Ethereum API {: #ethereum-api-transaction-fees }

Para redes EVM da Tanssi, usuÃ¡rios tambÃ©m podem enviar fundos via Ethereum API. Para calcular a taxa de uma transaÃ§Ã£o Ethereum, use:

=== "EIP-1559"

    ```text
    GasPrice = BaseFee + MaxPriorityFeePerGas < MaxFeePerGas ?
                BaseFee + MaxPriorityFeePerGas : 
                MaxFeePerGas;
    Transaction Fee = (GasPrice * TransactionWeight) / 25000
    ```

=== "Legacy"

    ```text
    Transaction Fee = (GasPrice * TransactionWeight) / 25000
    ```

=== "EIP-2930"

    ```text
    Transaction Fee = (GasPrice * TransactionWeight) / 25000
    ```

As seÃ§Ãµes a seguir detalham cada componente.

### Base Fee {: #base-fee }

A `BaseFee` Ã© o valor mÃ­nimo cobrado para enviar uma transaÃ§Ã£o e Ã© definida pela rede. Foi introduzida na [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank}. Redes EVM da Tanssi usam um mecanismo dinÃ¢mico semelhante ao da EIP-1559, ajustando a base fee conforme congestionamento.

No template EVM da Tanssi, a gas price mÃ­nima Ã© `1 GWei`.

A `BaseFee` pode ser obtida em `baseFeePerGas` do mÃ³dulo `baseFee`:

```text
GET /pallets/baseFee/storage/baseFeePerGas?at={blockId}
```

Estrutura relevante:

```text
RESPONSE JSON Storage Object:
    |--at
        |--hash
        |--height
    |--pallet
    |--palletIndex
    |--storageItem
    |--keys
    |--value
```

O valor estÃ¡ em `value` (fixed point); divida pelas casas decimais para obter o valor real.

### GasPrice, MaxFeePerGas e MaxPriorityFeePerGas {: #gasprice-maxfeepergas-maxpriorityfeepergas }

`GasPrice` define o gas price em transaÃ§Ãµes legacy (prÃ©â€‘EIP-1559). `MaxFeePerGas` e `MaxPriorityFeePerGas` foram introduzidos com a EIP-1559 junto da `BaseFee`. `MaxFeePerGas` define a taxa mÃ¡xima por unidade de gas (BaseFee + MaxPriorityFeePerGas). `MaxPriorityFeePerGas` Ã© a gorjeta mÃ¡xima configurada para priorizar a transaÃ§Ã£o.

Embora redes EVM da Tanssi sejam compatÃ­veis com Ethereum, sÃ£o cadeias Substrate, e prioridades funcionam de forma diferente: no Substrate transaÃ§Ãµes nÃ£o sÃ£o priorizadas por gas price. O Tanssi usa um sistema de priorizaÃ§Ã£o ajustado que reordena transaÃ§Ãµes Substrate com base na taxa por gas (derivada de tip e weight). Para transaÃ§Ãµes Ethereum, a prioridade Ã© definida pela priority fee.

Nota: prioridade nÃ£o Ã© o Ãºnico fator para ordenar transaÃ§Ãµes; longevidade tambÃ©m influencia.

Os valores de `GasPrice`, `MaxFeePerGas` e `MaxPriorityFeePerGas` podem ser lidos do JSON do bloco conforme descrito em [Mapeamento EVM](#evm-fields-mapping-in-block-json-object).

Os dados de uma transaÃ§Ã£o Ethereum em um bloco podem ser obtidos de:

```text
GET /blocks/{blockId}
```

Trajetos relevantes:

=== "EIP1559"
    |      Campo EVM       |                               Campo JSON                               |
    |:--------------------:|:---------------------------------------------------------------------:|
    |     MaxFeePerGas     |     `extrinsics[extrinsic_number].args.transaction.eip1559.maxFeePerGas`     |
    | MaxPriorityFeePerGas | `extrinsics[extrinsic_number].args.transaction.eip1559.maxPriorityFeePerGas` |

=== "Legacy"
    | Campo EVM |                        Campo JSON                         |
    |:---------:|:---------------------------------------------------------:|
    | GasPrice  | `extrinsics[extrinsic_number].args.transaction.legacy.gasPrice` |

=== "EIP2930"
    | Campo EVM |                         Campo JSON                         |
    |:---------:|:----------------------------------------------------------:|
    | GasPrice  | `extrinsics[extrinsic_number].args.transaction.eip2930.gasPrice` |

### Transaction Weight {: #transaction-weight }

`TransactionWeight` mede o Runtime de uma transaÃ§Ã£o no bloco. Para todos os tipos, pode ser obtido no evento da extrÃ­nseca em que:

```text
pallet: "system", method: "ExtrinsicSuccess"
```

E entÃ£o `TransactionWeight` estÃ¡ em:

```text
extrinsics[extrinsic_number].events[event_number].data[0].weight
```

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/wallets/
--- BEGIN CONTENT ---
---
title: Substrate Wallets
description: Aprenda a interagir com sua rede Substrate Powered by Tanssi atravÃ©s da API Substrate, incluindo a configuraÃ§Ã£o de carteiras, adiÃ§Ã£o de URLs RPC e envio de fundos.
icon: material-wallet-outline
template: index-page.html
---

# Carteiras

Carteiras sÃ£o ferramentas digitais que permitem aos usuÃ¡rios armazenar, gerenciar e transacionar com seguranÃ§a seus ativos digitais. Elas armazenam as chaves criptogrÃ¡ficas necessÃ¡rias para acessar ativos digitais e permitem que se executem transaÃ§Ãµes em redes blockchain.

as pÃ¡ginas desta seÃ§Ã£o fornecem uma visÃ£o geral de como comeÃ§ar a usar vÃ¡rios provedores de carteira. Ela aborda como criar e importar contas, conectar-se Ã  sua rede e comeÃ§ar a interagir com ela.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/wallets/ledger/
--- BEGIN CONTENT ---
---
title: Usando Ledger com Sua Substrate do Appchain
description: Este guia orienta vocÃª na configuraÃ§Ã£o e uso de um dispositivo Ledger para interagir com a rede Tanssi ou qualquer uma das appchains Substrate Powered by Tanssi.
icon: material-wallet-outline
categories: Substrate-Template
---

# Interagindo com as Tanssi Chains do Substrate Usando Ledger

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores e usuÃ¡rios de redes Substrate, como a rede Tanssi ou appchains Substrate nÃ£o-EVM Powered by Tanssi, tÃªm uma variedade de opÃ§Ãµes quando se trata de carteiras. Em relaÃ§Ã£o Ã s carteiras frias, que armazenam suas chaves privadas em um ambiente seguro e offline, [Ledger](https://www.ledger.com/){target=\_blank} Ã© uma das opÃ§Ãµes mais populares. Ledger oferece suporte total para blockchains Substrate, como a rede Tanssi.

Os dispositivos Ledger sÃ£o carteiras de hardware projetadas para armazenar as chaves privadas offline. Eles sÃ£o usados para verificar e assinar as transaÃ§Ãµes, mas ainda precisam de uma camada de software para fornecer a interface do usuÃ¡rio que interage com as redes, constrÃ³i as transaÃ§Ãµes e envia as transaÃ§Ãµes assinadas de volta para a rede assim que o usuÃ¡rio as verifica.

Este guia leva vocÃª por todas as etapas necessÃ¡rias para usar seu dispositivo Ledger com as Tanssi Chains do Substrate.

## Configurando Seu Dispositivo Ledger {: #setting-up-ledger-device }

Se vocÃª tiver um dispositivo Ledger novo, consulte o [site oficial](https://support.ledger.com/article/4404389503889-zd){target=\_blank} para obter um guia sobre como iniciÃ¡-lo com a configuraÃ§Ã£o inicial.

Agora, com seu Ledger jÃ¡ iniciado, instale o aplicativo _Polkadot_ seguindo estas etapas:

1. Abra o aplicativo Ledger Live no seu computador.
2. VÃ¡ para My Ledger.
3. Conecte e desbloqueie o dispositivo.

Por fim, procure o aplicativo **Polkadot (DOT)** no Ledger Live e instale-o em seu dispositivo.

!!! note
    Por que Polkadot? Tanssi Ã© construÃ­do usando Substrate, a mesma estrutura que alimenta Polkadot. Como resultado, embora Tanssi e Polkadot sejam redes separadas, eles compartilham o mesmo esquema de assinatura criptogrÃ¡fica. Isso significa que o aplicativo Ledger chamado **Polkadot (DOT)** Ã© totalmente compatÃ­vel com Tanssi.

![Instalar Polkadot no Ledger Live](/images/builders/toolkit/substrate-api/wallets/ledger/ledger-1.webp)

E Ã© isso. Seu dispositivo agora possui uma conta Substrate e Ã© capaz de assinar transaÃ§Ãµes na Tanssi e em qualquer appchain nÃ£o-EVM Powered by Tanssi.

## Adicionando o Ledger a uma Carteira Quente {: #adding-Ledger-hot-wallet }

Conforme apresentado na [introduÃ§Ã£o](#introduction), uma carteira de hardware Ledger fornece armazenamento seguro offline para chaves privadas, permitindo que os usuÃ¡rios verifiquem e assinem transaÃ§Ãµes. No entanto, por design, ele nÃ£o pode interagir com blockchains ou dApps por si sÃ³, nem oferece uma interface do usuÃ¡rio para gerenciar ativos. Para complementar o dispositivo, uma carteira quente Ã© necessÃ¡ria. O usuÃ¡rio pode escolher qualquer carteira Substrate, como [Talisman](/builders/toolkit/substrate-api/wallets/talisman/){target=\_blank} ou [SubWallet](/builders/toolkit/substrate-api/wallets/subwallet/){target=\_blank}.

Para fins de demonstraÃ§Ã£o, mostraremos como configurar o Talisman para funcionar com sua carteira de hardware, mas essas etapas sÃ£o geralmente aplicÃ¡veis a qualquer outra carteira habilitada para Substrate que suporte Ledger. Para acompanhar as etapas, certifique-se de ter [o Talisman instalado](/builders/toolkit/substrate-api/wallets/talisman/#setting-up-talisman){target=\_blank} no seu navegador, em seguida, abra a extensÃ£o e:

1. Pressione o Ã­cone **+** (Adicionar conta).
2. Clique na guia **Conectar**.
3. Selecione **Conectar Ledger**.

![Conectar Ledger](/images/builders/toolkit/substrate-api/wallets/ledger/ledger-2.webp)

Na tela seguinte, siga estas etapas:

1. Selecione **Polkadot**. Outras opÃ§Ãµes serÃ£o apresentadas abaixo.
2. Selecione **Polkadot** no menu suspenso.
3. Selecione **Aplicativo Polkadot** na caixa. VocÃª serÃ¡ solicitado a conectar seu ledger e abrir o aplicativo Polkadot.
4. Certifique-se de que seu ledger estÃ¡ conectado com sucesso.
5. Clique em **Continuar**.

![Conectar Ledger](/images/builders/toolkit/substrate-api/wallets/ledger/ledger-3.webp)

Na prÃ³xima etapa, vocÃª serÃ¡ apresentado a uma lista de contas derivadas. Selecione aquela que vocÃª deseja importar, clique em **Continuar**, e pronto! Sua carteira Talisman agora pode assinar transaÃ§Ãµes usando seu dispositivo Ledger.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/wallets/subwallet/
--- BEGIN CONTENT ---
--- 
title: Como Conectar SubWallet Ã  Tanssi Substrate 
description: Este guia mostra como conectar SubWallet, uma carteira abrangente para Polkadot, Substrate e Ethereum, Ã  sua rede Substrate powered by Tanssi. 
icon: material-wallet-outline 
categories: Substrate-Template
---


# Interagindo com Sua Rede Tanssi Substrate Usando SubWallet

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores e usuÃ¡rios de redes Substrate powered by Tanssi tÃªm uma variedade de opÃ§Ãµes quando se trata de carteiras. SubWallet Ã© uma carteira Web3 abrangente que suporta nativamente contas Substrate (Polkadot) e Ethereum. Este tutorial se concentra na API Substrate, mas vocÃª pode consultar um [tutorial semelhante para interagir com SubWallet usando a API Ethereum](/pt/builders/toolkit/ethereum-api/wallets/subwallet/){target=\_blank}.

A extensÃ£o de navegador da carteira SubWallet [pode ser baixada](https://www.subwallet.app/download.html){target=\_blank} para todos os navegadores suportados, incluindo Chrome, Brave, Firefox e MS Edge. SubWallet tambÃ©m possui um aplicativo mÃ³vel para iOS e Android, mas isso estÃ¡ alÃ©m do escopo deste guia. Um painel de ativos online completo Ã© acessÃ­vel em [web.subwallet.app](https://web.subwallet.app){target=\_blank}.

Este guia leva vocÃª por todas as etapas necessÃ¡rias, desde a instalaÃ§Ã£o do SubWallet atÃ© a configuraÃ§Ã£o de uma carteira, conectando-a Ã  sua rede Tanssi Substrate e enviando fundos.

## Criando Sua Primeira Conta Substrate {: #creating-your-first-substrate-account }

Primeiro, baixe e instale a [extensÃ£o SubWallet](https://www.subwallet.app/download.html){target=\_blank}. Criar uma nova conta gerarÃ¡ uma frase semente que pode derivar vÃ¡rias contas Ethereum e Substrate. Por padrÃ£o, SubWallet gerarÃ¡ uma Ãºnica conta Ethereum e uma Ãºnica conta Substrate, mas vocÃª pode facilmente derivar mais da mesma frase semente. Clique em **Criar uma nova conta** para comeÃ§ar.

![Comece a usar o SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-1.webp)

Na tela seguinte, vocÃª serÃ¡ solicitado a criar uma senha para proteger sua nova carteira.

![Crie uma senha para SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-2.webp)

VocÃª serÃ¡ solicitado a fazer backup de sua frase semente. Esta Ã© uma etapa importante, especialmente porque vocÃª tem a opÃ§Ã£o de derivar posteriormente contas adicionais desta frase semente.

![FaÃ§a backup de sua frase semente no SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-3.webp)

!!! note
    VocÃª nunca deve compartilhar sua frase semente (mnemÃ´nico) ou chave privada com ninguÃ©m. Isso lhes dÃ¡ acesso direto aos seus fundos. Este guia Ã© apenas para fins educacionais.

## Importando uma Conta Substrate Existente {: #importing-an-existing-substrate-account }

Ã‰ claro que vocÃª pode importar uma conta Substrate existente para o SubWallet. Para comeÃ§ar, siga estas etapas:

1. Pressione o botÃ£o **Todas as contas** na parte superior
2. Pressione o Ã­cone **Importar conta**

![Importar conta parte 1](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-4.webp)

Na tela seguinte, selecione o mÃ©todo pelo qual vocÃª gostaria de importar a conta existente. Se vocÃª estiver importando uma conta Substrate, pode escolher entre as opÃ§Ãµes de frase semente, Polkadot.js (JSON) ou cÃ³digo QR.

![Importar conta existente parte 2](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-5.webp)

Na tela seguinte, vocÃª poderÃ¡ fornecer a frase semente relevante, o arquivo JSON ou o cÃ³digo QR, e poderÃ¡ comeÃ§ar a usar sua nova conta imediatamente.

## Conectando SubWallet Ã  Dancelight {: #connecting-Subwallet-to-dancelight }

O SubWallet vem prÃ©-configurado com suporte para Dancelight, a Tanssi TestNet, mas pode nÃ£o estar habilitado por padrÃ£o. VocÃª sÃ³ precisa ir para a pÃ¡gina **Gerenciar redes** para ativÃ¡-lo. Lembre-se de que [Dancelight](/pt/builders/tanssi-network/testnet/dancelight/){target=\_blank} em si Ã© a rede baseada em Substrate que orquestra e gerencia o lanÃ§amento de redes powered by Tanssi. Para configurar seu SubWallet para funcionar com Dancelight, pressione o Ã­cone **Mais opÃ§Ãµes** no canto superior esquerdo. Em seguida, clique em **Gerenciar redes** e siga estas etapas:

1. Procure por **Dancelight**
2. Ative o controle deslizante para habilitar o suporte para Dancelight

![Ativar suporte para Dancelight](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-6.webp)

Se vocÃª tiver um saldo de tokens Dancelight, verÃ¡ o saldo da sua conta na pÃ¡gina inicial da carteira SubWallet. Por padrÃ£o, todos os saldos sÃ£o ocultos no SubWallet, mas se vocÃª pressionar o Ã­cone de olho, poderÃ¡ alternar a visibilidade do saldo.

![Veja os saldos da sua conta TestNet no SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-7.webp)

## Conectando SubWallet Ã  Sua Rede Substrate {: #connecting-Subwallet-to-your-substrate-network }

Para configurar o SubWallet para sua rede Substrate, pressione o Ã­cone **Mais opÃ§Ãµes** no canto superior esquerdo. Em seguida, clique em **Gerenciar redes**. Pressione o Ã­cone **+**. Na pÃ¡gina seguinte, vocÃª serÃ¡ solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstraÃ§Ã£o, a Dancelight Ã© usada aqui; no entanto, vocÃª pode substituir esses detalhes por sua prÃ³pria rede Tanssi. Para adicionar sua rede Tanssi ao SubWallet, siga estas etapas:

1. Cole a URL WSS da sua rede Tanssi. Outros parÃ¢metros, como a ID da parachain e as casas decimais dos tokens, podem ser preenchidos automaticamente
2. ForneÃ§a um nome para sua rede Tanssi
3. Pressione **Salvar**

![Adicionar Rede no SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-8.webp)

## Conectando ao Polkadot.js {: #connecting-to-polkadotjs}

Para conectar sua rede Tanssi Substrate ao Polkadot.js Apps, primeiro vÃ¡ para [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank}. Neste exemplo, Polkadot.js Apps estÃ¡ conectado Ã  Dancelight, mas vocÃª pode apontar o Polkadot.js para sua rede Tanssi clicando no menu suspenso da rede e preenchendo o endpoint WSS da sua rede Tanssi no campo **endpoint personalizado**.

![Conectar ao Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-9.webp)

A extensÃ£o SubWallet solicitarÃ¡ que vocÃª selecione as contas que deseja usar com o Polkadot.js Apps. Se ele nÃ£o aparecer automaticamente, vocÃª pode abrir a extensÃ£o SubWallet e clicar no Ã­cone **Conectado** ao lado da sua conta na parte superior. Para configurar o SubWallet para interagir corretamente com sua rede Tanssi no Polkadot.js Apps, vocÃª deve seguir estas etapas:

1. Selecione as contas Substrate que vocÃª gostaria de usar com o Polkadot.js Apps
2. Pressione **Conectar**

![Conectar SubWallet ao Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-10.webp)

Sua carteira SubWallet agora estÃ¡ conectada ao Polkadot.js Apps. ApÃ³s atualizar o Polkadot.js Apps, vocÃª deverÃ¡ ver sua conta SubWallet na \[pÃ¡gina Contas do Polkadot.js Apps\](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\\\_blank} sob o cabeÃ§alho **extensÃ£o**.

## Enviando uma TransaÃ§Ã£o {: #sending-a-transaction}

Para enviar uma transaÃ§Ã£o por meio da API Substrate, clique em **Enviar** ao lado da sua conta no Polkadot.js Apps. Em seguida, siga estas etapas:

1. Insira o **enviar para endereÃ§o**
2. Insira o **valor**
3. Pressione **Fazer TransferÃªncia** e confirme a transaÃ§Ã£o no pop-up do Polkadot.js resultante
4. Pressione **Ver Detalhes** se vocÃª quiser inspecionar o conteÃºdo da transaÃ§Ã£o
5. Pressione **Aprovar** para enviar a transaÃ§Ã£o

![Enviar fundos por meio da API Substrate com o Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-11.webp)

VocÃª tambÃ©m pode enviar uma transaÃ§Ã£o por meio da API Substrate diretamente da extensÃ£o SubWallet sem usar o Polkadot.js Apps. Para fazer isso, pressione o Ã­cone **Enviar** e siga estas etapas:

1. Especifique o ativo a ser enviado
2. Especifique a cadeia de destino (neste caso, a mesma cadeia de onde vocÃª estÃ¡ enviando)
3. Insira o endereÃ§o de destino
4. Insira o nÃºmero de tokens a serem enviados
5. Analise os detalhes da transaÃ§Ã£o e, em seguida, pressione **Transferir** e, em seguida, **Aprovar**

![Enviar fundos por meio da API Substrate diretamente no SubWallet](/images/builders/toolkit/substrate-api/wallets/subwallet/subwallet-12.webp)

Este guia se concentrou especificamente na configuraÃ§Ã£o do SubWallet para funcionar com sua rede Tanssi Substrate, mas o SubWallet tambÃ©m Ã© uma carteira completa para contas EVM. Na seÃ§Ã£o da API Ethereum, vocÃª encontrarÃ¡ um [guia semelhante para configurar o SubWallet para uso com sua rede Tanssi EVM](/pt/builders/toolkit/ethereum-api/wallets/subwallet/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/builders/toolkit/substrate-api/wallets/talisman/
--- BEGIN CONTENT ---
---
title: Como conectar Talisman Ã  Tanssi
description: Este guia explica como conectar Talisman, uma carteira Substrate e Ethereum, Ã  rede Tanssi ou Ã  sua appchain Substrate powered by Tanssi.
icon: material-wallet-outline
categories: Substrate-Template
---

# Interagindo com Tanssi ou Sua Appchain Substrate Usando Talisman

## IntroduÃ§Ã£o {: #introduction }

Desenvolvedores e usuÃ¡rios de redes Substrate, como a rede Tanssi ou appchains Substrate powered by Tanssi, tÃªm uma variedade de opÃ§Ãµes quando se trata de carteiras. Talisman Ã© uma Ã³tima opÃ§Ã£o, pois oferece suporte nativo total para contas Substrate e Ethereum. Este guia se concentra na API Substrate. VocÃª tambÃ©m pode conferir um [guia semelhante para configurar o Talisman para uso com sua rede Tanssi EVM](/pt/builders/toolkit/ethereum-api/wallets/talisman/){target=\_blank}.

Talisman Ã© uma carteira Web3 que suporta nativamente contas Substrate e Ethereum. A extensÃ£o do navegador da carteira Talisman estÃ¡ disponÃ­vel no [Google Chrome, Brave e outros navegadores baseados em Chromium](https://chromewebstore.google.com/detail/talisman-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld){target=\_blank}, bem como no [Firefox](https://addons.mozilla.org/en-US/firefox/addon/talisman-wallet-extension/){target=\_blank}. Um painel de ativos Ã© acessÃ­vel em [app.talisman.xyz](https://app.talisman.xyz){target=\_blank}

Este guia leva vocÃª por todas as etapas necessÃ¡rias, desde a instalaÃ§Ã£o do Talisman atÃ© a configuraÃ§Ã£o de uma carteira, conectando-a Ã  sua rede Substrate Tanssi e enviando fundos.

!!! note "Nota do Editor (AtualizaÃ§Ã£o de 2025)"
    Este guia faz referÃªncia a opÃ§Ãµes como Polkadot.js Apps ou tipo de conta Polkadot porque esses sÃ£o os rÃ³tulos usados em ferramentas Substrate comuns. A prÃ³pria Tanssi Ã© independente â€” construÃ­da com Substrate e alinhada com a seguranÃ§a apoiada pela Ethereum.

## Configurando o Talisman {: #setting-up-talisman }

Primeiro, baixe e instale a [extensÃ£o Talisman](https://talisman.xyz/){target=\_blank}. Este guia primeiro abordarÃ¡ a criaÃ§Ã£o de uma nova carteira e, mais tarde, tratarÃ¡ da importaÃ§Ã£o de uma existente. Revise os termos e condiÃ§Ãµes e, em seguida, pressione **ComeÃ§ar**.

![Comece a usar o Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-1.webp)

Na tela seguinte, vocÃª serÃ¡ solicitado a criar uma senha para proteger sua nova carteira.

![Insira a senha para a Carteira Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-2.webp)

## Criar uma Conta Substrate {: #create-a-substrate-account }

Para criar sua primeira conta Substrate no Talisman, siga as seguintes etapas:

1. Selecione a opÃ§Ã£o **Polkadot**.
2. DÃª um nome para sua conta.
3. Pressione **Criar**.

!!! note
    Por que Polkadot? Tanssi e appchains powered by Tanssi sÃ£o construÃ­dos usando Substrate, a mesma estrutura que alimenta Polkadot. Como resultado, embora Tanssi e Polkadot sejam redes separadas, eles compartilham o mesmo esquema de assinatura criptogrÃ¡fica.

![Crie sua primeira conta Polkadot no Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-3.webp)

ApÃ³s criar sua primeira conta, vocÃª serÃ¡ solicitado a fazer backup de sua frase semente. Esta Ã© uma etapa importante, especialmente porque vocÃª tem a opÃ§Ã£o de, mais tarde, derivar contas adicionais dessa frase semente.

![FaÃ§a backup de sua frase semente](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-4.webp)

!!! note
    VocÃª nunca deve compartilhar sua frase semente (mnemÃ´nico) ou chave privada com ninguÃ©m. Isso lhes dÃ¡ acesso direto aos seus fundos. Este guia Ã© apenas para fins educacionais.

## Importando uma Conta Substrate Existente {: #importing-an-existing-substrate-account }

Ã‰ claro que vocÃª pode importar uma conta Substrate existente para o Talisman. Para fazer isso, siga as seguintes etapas:

1. Pressione **Adicionar Conta**.
2. Pressione **Importar**.
3. Selecione **Importar via Frase de RecuperaÃ§Ã£o**.

![ConfiguraÃ§Ã£o de importaÃ§Ã£o de conta existente](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-12.webp)

Na tela seguinte, siga as seguintes etapas:

1. Selecione o tipo de conta **Polkadot**.
2. ForneÃ§a um nome para sua conta.
3. Cole sua semente.
4. Selecione quais contas vocÃª gostaria de importar.
5. Pressione **Importar**.

![Etapas finais de importaÃ§Ã£o de conta existente](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-13.webp)

## Conectando o Talisman Ã  Rede Tanssi {: #connecting-talisman-to-the-tanssi-network }

Talisman jÃ¡ vem prÃ©-configurado com suporte para Tanssi MainNet e [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}. Para se conectar Ã  Dancelight, vocÃª primeiro precisa garantir que ativou o suporte para TestNets no Talisman. Para fazer isso, siga as seguintes etapas:

1. Abra a extensÃ£o Talisman e clique no logotipo do Talisman.
2. Selecione **ConfiguraÃ§Ãµes**.
3. Certifique-se de que **Habilitar testnets** esteja marcado.

![Veja os saldos da sua conta TestNet no Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-5.webp)

Se vocÃª tiver um saldo de tokens Tanssi MainNet ou Dancelight, verÃ¡ o saldo da sua conta na pÃ¡gina inicial da carteira Talisman. Quando vocÃª nÃ£o tem um saldo, a rede Ã© omitida da sua lista de ativos.

![Veja os saldos da sua conta TestNet no Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-6.webp)

## Conectando o Talisman Ã  Sua Rede Substrate {: #connecting-talisman-to-your-substrate-network }

Para configurar o Talisman para sua rede Substrate powered by Tanssi, abra a extensÃ£o Talisman e clique na guia **Mais OpÃ§Ãµes**. Clique em **ConfiguraÃ§Ãµes** > **Redes e Tokens** > **Gerenciar Redes**.

1. Deslize o controle deslizante da rede para **Polkadot**.
2. Marque a caixa **Habilitar testnets**.
3. Pressione **Adicionar Rede**.

![Adicionar Rede no Talisman](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-7.webp)

Na pÃ¡gina seguinte, vocÃª serÃ¡ solicitado a inserir os detalhes da rede para sua rede Tanssi. Para fins de demonstraÃ§Ã£o, a Dancelight Ã© usada aqui, mas vocÃª pode substituir esses detalhes pela sua prÃ³pria rede Tanssi. Para adicionar sua rede Tanssi ao Talisman, siga as seguintes etapas:

1. Cole a URL RPC da sua rede Tanssi. Outros parÃ¢metros serÃ£o preenchidos automaticamente.
2. Opcionalmente, insira a URL do block explorer da sua rede Tanssi, se aplicÃ¡vel.
3. Marque a caixa **Esta Ã© uma testnet**, se aplicÃ¡vel.
4. Pressione **Adicionar Rede**.

![Adicione seus Detalhes de Rede powered by Tanssi](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-8.webp)

## Conectando ao Polkadot.js {: #connecting-to-polkadotjs}

Para conectar sua rede Substrate Tanssi aos Polkadot.js Apps, primeiro acesse \[Polkadot.js Apps\](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank}. Neste exemplo, os Polkadot.js Apps estÃ£o conectados Ã  Dancelight, mas vocÃª pode apontar o Polkadot.js para sua rede Tanssi clicando no menu suspenso da rede e preenchendo o endpoint WSS da sua rede Tanssi no campo de **endpoint personalizado**.

![Conecte-se aos Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-9.webp)

A extensÃ£o Talisman solicitarÃ¡ que vocÃª selecione as contas que deseja usar com os Polkadot.js Apps. Se ela nÃ£o aparecer automaticamente, vocÃª pode abrir a extensÃ£o Talisman e clicar no tÃ­tulo **polkadot.js.org** na parte superior. Para configurar o Talisman para interagir corretamente com sua rede Tanssi nos Polkadot.js Apps, vocÃª deve seguir as seguintes etapas:

1. Selecione a(s) conta(s) Substrate que vocÃª deseja usar com os Polkadot.js Apps
2. Pressione **Conectar 1**. O valor mudarÃ¡ dependendo do nÃºmero de contas que vocÃª estÃ¡ conectando

![Conecte o Talisman aos Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-10.webp)

Sua carteira Talisman agora estÃ¡ conectada aos Polkadot.js Apps. ApÃ³s atualizar os Polkadot.js Apps, vocÃª deve ver sua conta Talisman na \[pÃ¡gina Contas dos Polkadot.js Apps\](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} abaixo do tÃ­tulo **extensÃ£o**.

## Enviando uma TransaÃ§Ã£o {: #sending-a-transaction}

Para enviar uma transaÃ§Ã£o por meio da API Substrate, clique em **Enviar** prÃ³ximo Ã  sua conta nos Polkadot.js Apps. Em seguida, siga as seguintes etapas:

1. Insira o **endereÃ§o para enviar**.
2. Insira o **valor**.
3. Pressione **Fazer TransferÃªncia** e confirme a transaÃ§Ã£o no pop-up Polkadot.js resultante.
4. Pressione **Ver Detalhes** se vocÃª quiser inspecionar o conteÃºdo da transaÃ§Ã£o.
5. Pressione **Aprovar** para enviar a transaÃ§Ã£o.

![Envie fundos por meio da API Substrate com os Polkadot.js Apps](/images/builders/toolkit/substrate-api/wallets/talisman/talisman-11.webp)

Este guia se concentrou especificamente na configuraÃ§Ã£o do Talisman para funcionar com sua rede Substrate Tanssi, mas o Talisman tambÃ©m Ã© uma carteira completa para contas EVM. Na seÃ§Ã£o da API Ethereum, vocÃª encontrarÃ¡ um [guia semelhante para configurar o Talisman para uso com sua rede Tanssi EVM](/pt/builders/toolkit/ethereum-api/wallets/talisman/){target=\_blank}.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/
--- BEGIN CONTENT ---
---
title: Home
description: Bem-vindo ao site de documentaÃ§Ã£o da Tanssi Network. Seu ponto de partida para implantar redes descentralizadas de forma rÃ¡pida, eficiente e sem esforÃ§o.
template: home.html
hide:
- footer
- toc
- feedback
- navigation
---
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/decentralized-networks/included-templates/
--- BEGIN CONTENT ---
---
title: Templates de Rede IncluÃ­dos na Tanssi
description: O protocolo Tanssi fornece Templates Ãºteis para comeÃ§ar a construir sua rede descentralizada, incluindo um Template EVM pronto para uso para compatibilidade com Ethereum.
icon: octicons-copy-24
categories: Basics
---

# Templates de Rede IncluÃ­dos na Tanssi {: #network-templates-included-in-tanssi }

## IntroduÃ§Ã£o {: #introduction }

A construÃ§Ã£o de uma nova rede do zero pode ser uma tarefa assustadora. Felizmente, graÃ§as ao [framework de desenvolvimento de rede](/pt/learn/framework/overview/){target=\_blank} usado pela Tanssi e sua arquitetura orientada a mÃ³dulos, os desenvolvedores podem aproveitar alguns Templates de rede prÃ©-empacotados que os ajudam a dar o pontapÃ© inicial no processo e se beneficiar em alguns aspectos, como:

- **Head Start** - Os Templates de rede Tanssi fornecem um ponto de partida para seu projeto, economizando tempo e esforÃ§o significativos, fornecendo uma estrutura bÃ¡sica e um conjunto de funcionalidades testadas e prontas para uso. Ele permite que os desenvolvedores acelerem a construÃ§Ã£o de protÃ³tipos ou produtos minimamente viÃ¡veis (MVPs) e reduzam o tempo de lanÃ§amento

- **ConsistÃªncia** - os Templates de rede Tanssi incluÃ­dos seguem padrÃµes de design estabelecidos, padrÃµes de codificaÃ§Ã£o e melhores prÃ¡ticas amplamente aceitos entre a comunidade de desenvolvedores. Eles tambÃ©m fornecem um conjunto padrÃ£o de definiÃ§Ãµes de arquitetura para otimizar o desenvolvimento de blockchain

- **UX** - Os Templates de rede Tanssi cobrem os casos de uso mais exigidos, como o suporte EVM para uma rede compatÃ­vel com Ethereum

- **CustomizaÃ§Ã£o** - Os Templates de rede Tanssi sÃ£o um Ã³timo ponto de partida e sÃ£o totalmente personalizÃ¡veis. As funcionalidades e configuraÃ§Ãµes padrÃ£o que eles incluem podem ser modificadas, substituÃ­das ou estendidas para atender aos requisitos especÃ­ficos do caso de uso

- **AtualizaÃ§Ãµes e Compatibilidade** - Tanssi Ã© construÃ­do sobre um framework em evoluÃ§Ã£o, com novos recursos, aprimoramentos e correÃ§Ãµes de bugs sendo introduzidos regularmente. Os Templates de rede Tanssi fornecidos sÃ£o mantidos atualizados com essas atualizaÃ§Ãµes

## Comece a Construir uma Rede {: #start-building }

Para comeÃ§ar a construir uma rede descentralizada para implantaÃ§Ã£o em Tanssi, alguns Templates de rede Tanssi Ãºteis para iniciar o processo de desenvolvimento sÃ£o fornecidos no [repositÃ³rio oficial](https://github.com/moondance-labs/tanssi){target=\_blank}.

O processo Ã© tÃ£o simples quanto:

1. Selecione um dos Templates
2. Adicione a lÃ³gica especÃ­fica para adaptar o Runtime aos requisitos do caso de uso
3. Implante na Tanssi

![Usando Templates para Acelerar o Processo de Desenvolvimento](/images/learn/decentralized-networks/templates/templates-1.webp)

Os dois Templates incluÃ­dos sÃ£o o *Template de rede de linha de base* e o *Template EVM de linha de base*, que sÃ£o apresentados nas seÃ§Ãµes a seguir.

### Template de Rede Baseline {: #baseline-network-template }

Conforme apresentado no artigo [VisÃ£o geral](/pt/learn/tanssi/overview/){target=\_blank}, as redes implantadas por meio da Tanssi sÃ£o blockchains totalmente soberanas e personalizÃ¡veis.

Como parte do ecossistema Tanssi, as redes devem incluir os componentes essenciais para implementar o mecanismo de consenso e ser capazes de interagir e sincronizar com o provedor de seguranÃ§a de sua escolha (por exemplo, [Symbiotic](https://symbiotic.fi/){target=\_blank} no Ethereum). O Template de rede Tanssi de linha de base inclui toda a funcionalidade necessÃ¡ria para a lÃ³gica de Sequencers, p2p, banco de dados e camadas de sincronizaÃ§Ã£o entre a rede e o provedor de seguranÃ§a, permitindo que os desenvolvedores se concentrem exclusivamente na personalizaÃ§Ã£o de seu produto.

Este Template tambÃ©m inclui o mÃ³dulo [Author Noting](https://github.com/moondance-labs/tanssi/blob/master/pallets/author-noting/src/lib.rs){target=\_blank} da Tanssi, que implementa a lÃ³gica para recuperar e validar o conjunto de Sequencers atribuÃ­dos para fornecer serviÃ§os de produÃ§Ã£o de blocos Ã  rede. Ele tambÃ©m inclui a lÃ³gica que permite que um Sequencer assine o bloco quando o mecanismo de consenso determina que Ã© a vez do Sequencer produzir o bloco (e, portanto, ser recompensado de acordo).

O cÃ³digo fonte para este Template Ã© pÃºblico e acessÃ­vel no [repositÃ³rio Tanssi GitHub](https://github.com/moondance-labs/tanssi/blob/master/chains/container-chains/runtime-templates/simple/src/lib.rs){target=\_blank}.

### Template Baseline EVM (Ethereum Virtual Machine) {: #baseline-evm-template }

Estendendo o [Template de rede Tanssi de linha de base](#baseline-network-template), este Template fornece nÃ£o apenas suporte ao protocolo Tanssi, mas tambÃ©m um EVM e compatibilidade total com Ethereum.

Aproveitando um conjunto de [mÃ³dulos especÃ­ficos para EVM](https://github.com/polkadot-evm/frontier){target=\_blank}, este Template inclui uma camada de compatibilidade com Ethereum para que as redes possam executar dApps Ethereum nÃ£o modificadas.

Usando este Template, as redes suportam a implantaÃ§Ã£o e execuÃ§Ã£o de qualquer contrato inteligente existente escrito em Solidity ou Vyper, sem alteraÃ§Ãµes. Ao emular a produÃ§Ã£o de blocos Ethereum e expor a interface RPC esperada, os desenvolvedores tambÃ©m podem continuar usando as mesmas ferramentas como [Metamask](https://metamask.io){target=\_blank}, [Hardhat](https://hardhat.org){target=\_blank}, [Remix](https://remix.ethereum.org){target=\_blank}, [Foundry](https://github.com/foundry-rs/foundry){target=\_blank}, e muitos mais prontos para uso, sem adaptadores extras.

Com este Template EVM, os desenvolvedores podem implantar uma rede semelhante a [Moonbeam](https://moonbeam.network){target=\_blank} em nenhum momento e adicionar sua lÃ³gica e recursos personalizados, especÃ­ficos para seu caso de uso.

O cÃ³digo fonte para este Template Ã© pÃºblico e acessÃ­vel no [repositÃ³rio Tanssi GitHub](https://github.com/moondance-labs/tanssi/blob/master/chains/container-chains/runtime-templates/frontier/src/lib.rs){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/decentralized-networks/
--- BEGIN CONTENT ---
---
title: Aprenda sobre as Redes Tanssi-Powered
description: Descubra as funcionalidades em redes EVM e Substrate implementadas atravÃ©s da Tanssi, utilizando Templates fÃ¡ceis de usar e de implementar para capacidades melhoradas.
icon: octicons-workflow-24
template: index-page.html
---

# Redes Tanssi-Powered

Desenvolver uma blockchain que equilibre escalabilidade, eficiÃªncia e personalizaÃ§Ã£o Ã© uma tarefa complexa. As Redes Tanssi-Powered abordam estes desafios atravÃ©s da sua integraÃ§Ã£o na infraestrutura modular da Tanssi. Esta secÃ§Ã£o explica a estrutura, funcionalidade e caracterÃ­sticas Ãºnicas das redes no ecossistema Tanssi.

Principais funcionalidades das redes Tanssi-powered:

- **PersonalizaÃ§Ã£o de Runtime** - adapte os tipos de transacÃ§Ãµes, a lÃ³gica de execuÃ§Ã£o e as transiÃ§Ãµes de estado para se adequar aos requisitos especÃ­ficos da sua rede
- **EficiÃªncia de transacÃ§Ãµes** - otimize as taxas de transacÃ§Ãµes para escalabilidade e sustentabilidade econÃ³mica
- **Escalabilidade no seu nÃºcleo** - construa redes preparadas para crescer juntamente com o seu ecossistema

## Explore Esta SecÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/decentralized-networks/overview/
--- BEGIN CONTENT ---
---
title: VisÃ£o Geral da Rede
description: Saiba, em alto nÃ­vel, como funciona uma rede Tanssi, sua arquitetura e o mecanismo de produÃ§Ã£o de blocos como serviÃ§o com finalidade determinÃ­stica.
icon: octicons-home-24
categories: Basics
---

# VisÃ£o Geral das Redes Tanssi {: #networks-tanssi-overview }

## IntroduÃ§Ã£o {: #introduction }

As redes implantadas via Tanssi recebem vÃ¡rios [benefÃ­cios](/pt/learn/tanssi/overview/#what-tanssi-provides){target=\_blank}, como produÃ§Ã£o de blocos como serviÃ§o, recuperabilidade de dados como serviÃ§o e seguranÃ§a por meio de [provedores externos de seguranÃ§a](/pt/learn/tanssi/external-security-providers/){target=\_blank}, como [Symbiotic](https://symbiotic.fi/){target=\_blank} na Ethereum.

AlÃ©m disso, como as redes powered by Tanssi se baseiam em uma [pilha modular](/pt/learn/framework/){target=\_blank}, elas ganham vantagens Ãºnicas quando sÃ£o necessÃ¡rias customizaÃ§Ãµes em nÃ­vel de runtime. Essa [modularidade](/pt/learn/framework/modules/){target=\_blank} permite adicionar funcionalidades direto no runtime ou estender as capacidades da prÃ³pria EVM via precompilados.

Por exemplo, a Tanssi fornece um [template](/pt/learn/decentralized-networks/included-templates#baseline-evm-template){target=\_blank} pronto para uso que inclui os mÃ³dulos [Frontier](https://github.com/polkadot-evm/frontier){target=\_blank}, possibilitando implantar facilmente redes compatÃ­veis com EVM, similar ao [Moonbeam](https://moonbeam.network){target=\_blank}.

Esta seÃ§Ã£o aborda os fundamentos de uma rede Tanssi, sua arquitetura, mÃ³dulos e funcionalidades principais e o mecanismo de taxas de transaÃ§Ã£o.

## Arquitetura Geral {: #general-architecture}

Como mencionado, as redes implantadas via Tanssi sÃ£o blockchains customizÃ¡veis que, entre outras caracterÃ­sticas, recebem produÃ§Ã£o de blocos como serviÃ§o e herdam seguranÃ§a com finalizaÃ§Ã£o determinÃ­stica em segundos de um provedor externo de seguranÃ§a.

As redes powered by Tanssi sÃ£o totalmente descentralizadas. Essa natureza descentralizada aumenta consideravelmente a resiliÃªncia e a tolerÃ¢ncia a falhas, jÃ¡ que nÃ£o dependem de uma autoridade Ãºnica para garantir disponibilidade, seguranÃ§a e desempenho, mas sim de protocolos trustless e descentralizados. Por exemplo, recebem serviÃ§os de produÃ§Ã£o de blocos de um conjunto descentralizado e incentivado de Sequencers gerenciados pela Tanssi.

O protocolo Tanssi funciona com um [provedor externo de seguranÃ§a](/pt/learn/tanssi/external-security-providers/){target=\_blank}, que possui um conjunto de operators (validadores) com ativos em stake, validando as transaÃ§Ãµes da prÃ³pria rede Tanssi e de todas as redes implantadas via Tanssi. Assim, todas as redes powered by Tanssi herdam a seguranÃ§a econÃ´mica do protocolo Tanssi e, indiretamente, dos operators, que verificam cada transaÃ§Ã£o de cada rede. As redes Tanssi nÃ£o precisam manter seu prÃ³prio conjunto de operators nem fazer bootstrapping de liquidez para proteger o protocolo.

As redes Tanssi tambÃ©m se beneficiam de um conjunto de Data-Preservers, com nÃ³s de arquivo completos, garantindo a disponibilidade da camada de dados. Esses data-preservers sÃ£o incentivados pelos serviÃ§os de recuperaÃ§Ã£o de dados da Tanssi e tambÃ©m fornecem a infraestrutura RPC para apps e usuÃ¡rios que interagem com redes Tanssi.

```mermaid
flowchart TB
    networks["Tanssi Networks<br/>(Decentralized Networks)"]

    subgraph tanssi["Tanssi Protocol"]
        direction TB
        sequencers["Decentralized Sequencers Set"]
        node["Full Archive Nodes with<br/>RPC Services"]
    end

    security["External Security Provider<br/>Operators"]
    
    networks<--Block Production-->tanssi
    networks<--Shared Security Model-->tanssi
    networks<--Data Availability<br/>RPC endpoints-->tanssi
    tanssi<--Transactions<br/>Validation and Finality-->security
```

## Fluxo de TransaÃ§Ãµes da Rede {: #network-transaction-flow }

Uma transaÃ§Ã£o enviada a uma rede Tanssi segue um caminho complexo porÃ©m transparente, desde o envio atÃ© a inclusÃ£o no bloco e finalizaÃ§Ã£o. A infraestrutura da rede, a Tanssi e o [provedor de seguranÃ§a](/pt/learn/tanssi/external-security-providers/){target=\_blank} escolhido atuam em nÃ­veis diferentes para que o processo ocorra o mais rÃ¡pido possÃ­vel, geralmente em cerca de 30 segundos. Uma transaÃ§Ã£o em uma rede Tanssi atinge finalizaÃ§Ã£o determinÃ­stica; uma vez final, torna-se irreversÃ­vel e imutÃ¡vel, e a transiÃ§Ã£o de estado resultante Ã© definitiva.

Por exemplo, um usuÃ¡rio inicia uma transaÃ§Ã£o ao interagir com um aplicativo implantado em uma rede Tanssi. O provedor RPC compartilha a transaÃ§Ã£o, que permanece no pool de transaÃ§Ãµes da cadeia, com todos os participantes. Um Sequencer designado pela Tanssi para essa rede capturarÃ¡ a transaÃ§Ã£o e a incluirÃ¡ no prÃ³ximo bloco.

Em seguida, o Sequencer compartilharÃ¡ com os operators do provedor de seguranÃ§a:

- O bloco em si com as transiÃ§Ãµes de estado
- Os componentes de armazenamento no banco de dados da rede Tanssi que o bloco estÃ¡ modificando
- Os hashes necessÃ¡rios dos pontos nÃ£o afetados na Ã¡rvore de Merkle do armazenamento

Esses componentes constituem a prova de validade (PoV).

Depois, a PoV Ã© verificada pelos operators do provedor de seguranÃ§a. Observe que os operators nÃ£o verificam se o storage da rede Tanssi Ã© vÃ¡lido, mas se as transiÃ§Ãµes de estado que o afetam sÃ£o vÃ¡lidas. Um resumo dessa verificaÃ§Ã£o Ã© disseminado para outros operators, para que verifiquem e incluam no prÃ³ximo bloco da Tanssi. Por fim, esse bloco da Tanssi com todas as verificaÃ§Ãµes Ã© finalizado.

O fluxo da transaÃ§Ã£o estÃ¡ resumido no diagrama a seguir:

![Path of a Tanssi Network Block in Tanssi](/images/learn/decentralized-networks/overview/overview-1.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/decentralized-networks/runtime-features/
--- BEGIN CONTENT ---
---
title: Recursos Essenciais de Runtime
description: ConheÃ§a os recursos centrais de uma rede Tanssi, os tipos de transaÃ§Ã£o, como sÃ£o executadas e incluÃ­das em um bloco e os upgrades de runtime sem fork.
icon: octicons-package-24
categories: Basics
---

# Recursos Essenciais de Runtime {: #core-runtime-features }

## IntroduÃ§Ã£o {: #introduction}

As redes implantadas via Tanssi tÃªm [muitos benefÃ­cios](/pt/learn/tanssi/overview/#what-tanssi-provides){target=\_blank} devido Ã  sua [arquitetura](/pt/learn/tanssi/overview/#tanssi-architecture){target=\_blank} exclusiva.

AlÃ©m disso, redes powered by Tanssi sÃ£o Ãºnicas pelo [framework](/pt/learn/framework/){target=\_blank} (Substrate) em que sÃ£o construÃ­das, que oferece caracterÃ­sticas que os desenvolvedores podem aproveitar para ajustar comportamentos especÃ­ficos no runtime.

Esta seÃ§Ã£o aborda alguns desses recursos essenciais de runtime em redes Tanssi, incluindo as diferentes origens que uma transaÃ§Ã£o pode ter, os diferentes tipos de transaÃ§Ã£o e como sÃ£o executadas e incluÃ­das em um bloco, a conta especial conhecida como _SUDO_ e o recurso bastante singular das redes Tanssi: os upgrades de runtime sem fork.

## Origens {: #origins}

De modo geral, todas as chamadas em uma rede Tanssi tÃªm uma origem. Mas o que Ã© uma origem? Desenvolvedores do mundo EVM conhecem o _msg.sender_ em transaÃ§Ãµes EVM. As origens sÃ£o para redes Tanssi o que _msg.sender_ Ã© para uma transaÃ§Ã£o EVM, mas com diversas funcionalidades extras.

Uma origem define de onde a chamada vem. Diferentemente de cadeias compatÃ­veis com Ethereum, pode haver muitas origens em redes Tanssi. Por exemplo, o _msg.sender_ de uma transaÃ§Ã£o EVM Ã© uma _signed origin_, o que significa que a chamada Ã© uma transaÃ§Ã£o assinada pela chave privada de alguma conta on-chain. Isso permite ao runtime autenticar a origem da chamada e, por exemplo, cobrar taxas da conta associada.

No entanto, origens podem fazer mais do que representar um par de chaves privada/pÃºblica. Elas tambÃ©m tÃªm diferentes nÃ­veis de privilÃ©gio. Por exemplo, uma _signed origin_ pode enviar uma transaÃ§Ã£o despachada pelo par de chaves, mas nÃ£o deveria poder autorizar um upgrade de runtime.

Alguns dos tipos mais comuns de origem sÃ£o:

- **Root** - origem em nÃ­vel de sistema com o nÃ­vel mais alto de privilÃ©gio; pode ser vista como o superusuÃ¡rio da cadeia, capaz de executar qualquer chamada
- **Signed** - como mencionado, a origem de uma transaÃ§Ã£o assinada pela chave privada de uma conta on-chain, que inclui o identificador da conta (endereÃ§o) como assinante
- **None** - ausÃªncia de origem. Usada em aÃ§Ãµes especÃ­ficas que devem ser acordadas no nÃ­vel do runtime. Por exemplo, Ã© possÃ­vel programar o runtime para que uma transaÃ§Ã£o com origem _none_ efetive um upgrade de runtime prÃ©-autorizado, sem taxa associada
- **Custom** - desenvolvedores podem criar origens personalizadas para casos especÃ­ficos. Por exemplo, a [governanÃ§a on-chain da Moonbeam](https://docs.moonbeam.network/learn/features/governance){target=\_blank} tem origens especÃ­ficas para cada tipo de voto, chamadas _tracks_. Cada track pode ser configurada para executar chamadas com nÃ­veis de privilÃ©gio especÃ­ficos. Uma track Ã© _Root_, cuja origem Ã© a _Root_ mencionada, com configuraÃ§Ã£o bem restritiva para aprovaÃ§Ã£o. Outras tracks tÃªm nÃ­veis de privilÃ©gio muito menores para operaÃ§Ãµes menos crÃ­ticas

## Tipos de TransaÃ§Ã£o {: #transaction-types}

Redes Tanssi possuem trÃªs tipos principais de transaÃ§Ãµes:

- **Signed Transactions** - incluem um payload assinado solicitando executar alguma chamada de runtime. Em geral, a assinatura estÃ¡ associada a um par de chaves privada/pÃºblica. Dependendo da lÃ³gica do runtime, a conta associada Ã  assinatura paga a taxa de transaÃ§Ã£o
- **Unsigned Transactions** - incluem um payload nÃ£o assinado solicitando executar alguma chamada de runtime. Como sÃ£o nÃ£o assinadas, nÃ£o hÃ¡ conta associada. Portanto, os runtimes precisam definir condiÃ§Ãµes especÃ­ficas para evitar spam ou replay, pois nÃ£o hÃ¡ mecanismo de taxa para impedir comportamentos maliciosos. Um exemplo de transaÃ§Ã£o nÃ£o assinada Ã© executar aÃ§Ãµes prÃ©-aprovadas, como um upgrade de runtime
- **Inherent Transactions** - transaÃ§Ã£o nÃ£o assinada que um Sequencer insere em um bloco ao iniciar sua construÃ§Ã£o. Elas fazem parte do bloco e nÃ£o ficam no pool de transaÃ§Ãµes nem sÃ£o compartilhadas entre participantes. AlÃ©m disso, os dados inseridos por transaÃ§Ãµes inherents podem pular validaÃ§Ã£o de runtime, ficando a cargo dos operators aceitÃ¡-los. Um exemplo Ã© o timestamp do bloco, injetado por uma transaÃ§Ã£o inherent; operators podem aceitar ou rejeitar o bloco com base em o timestamp estar dentro de um intervalo aceitÃ¡vel

## ExecuÃ§Ã£o de TransaÃ§Ãµes {: #transaction-execution}

Quando um usuÃ¡rio ou aplicativo envia uma transaÃ§Ã£o assinada a uma rede Tanssi, a transaÃ§Ã£o Ã© validada em nÃ­vel de nÃ³ completo usando regras definidas no runtime e, em seguida, Ã© enfileirada no transaction pool. Isso garante que apenas transaÃ§Ãµes que cumpram certas condiÃ§Ãµes especÃ­ficas da cadeia sejam consideradas para inclusÃ£o em um bloco.

!!! note
    O tipo de transaÃ§Ã£o mais comum Ã© a assinada. Ainda assim, transaÃ§Ãµes nÃ£o assinadas tambÃ©m sÃ£o validadas antes de entrarem no transaction pool.

A fila de transaÃ§Ãµes vÃ¡lidas tem dois pools: ready e future. O pool ready contÃ©m todas as transaÃ§Ãµes que podem ser incluÃ­das em um novo bloco pendente. O pool future Ã© para transaÃ§Ãµes que nÃ£o atendem a todos os critÃ©rios agora, mas podem se tornar vÃ¡lidas (por exemplo, nonce futura). TransaÃ§Ãµes invÃ¡lidas sÃ£o rejeitadas diretamente.

Durante a construÃ§Ã£o do bloco, um Sequencer usa um [sistema de prioridade](https://github.com/paritytech/substrate/blob/fb24fda76d613305ebb2e5728c75362c94b64aa1/frame/transaction-payment/src/lib.rs#L614-L681){target=\_blank} via um mÃ³dulo de orquestraÃ§Ã£o de transaÃ§Ãµes para ordenar as transaÃ§Ãµes do prÃ³ximo bloco atÃ© atingir a capacidade mÃ¡xima. A ordem de construÃ§Ã£o e execuÃ§Ã£o do bloco tem as seguintes operaÃ§Ãµes:

- **Initializing a Block** - conhecido como `on_initialize`, permite definir lÃ³gica de runtime executada antes de qualquer outra transaÃ§Ã£o. Por exemplo, transaÃ§Ãµes inherents como o timestamp sÃ£o comumente executadas ao inicializar o bloco. ApÃ³s a lÃ³gica de inicializaÃ§Ã£o, o mÃ³dulo de orquestraÃ§Ã£o verifica o parent hash no cabeÃ§alho e a trie root para garantir que as informaÃ§Ãµes estejam corretas
- **Transaction Execution** - com o bloco jÃ¡ inicializado, o mÃ³dulo de orquestraÃ§Ã£o executa cada transaÃ§Ã£o vÃ¡lida conforme sua prioridade. O estado inicial nÃ£o Ã© armazenado em cache antes da execuÃ§Ã£o; se uma transaÃ§Ã£o falhar no meio, quaisquer alteraÃ§Ãµes de estado jÃ¡ cometidas nÃ£o podem ser revertidas, e o bloco subsequente serÃ¡ invÃ¡lido. Portanto, a lÃ³gica de runtime deve realizar todas as verificaÃ§Ãµes necessÃ¡rias para garantir que as transaÃ§Ãµes vÃ¡lidas serÃ£o bem-sucedidas
- **Finalizing a Block** - apÃ³s executar todas as transaÃ§Ãµes vÃ¡lidas em fila ou atingir o limite do bloco, o mÃ³dulo de orquestraÃ§Ã£o chama, em cada mÃ³dulo do runtime, as funÃ§Ãµes `on_idle` e `on_finalize`. Essas funÃ§Ãµes permitem definir lÃ³gica extra executada automaticamente na finalizaÃ§Ã£o do bloco. Depois da Ãºltima `on_finalize`, o mÃ³dulo de orquestraÃ§Ã£o garante que o block digest e o storage root correspondam ao que foi calculado ao inicializar o bloco

## Upgrades sem Fork {: #forkless-upgrades}

Redes implantadas via Tanssi tÃªm um recurso empolgante: [forkless upgrades](https://docs.polkadot.com/develop/parachains/maintenance/runtime-upgrades/){target=\_blank}. Eles permitem alterar a funÃ§Ã£o de transiÃ§Ã£o de estado que governa a cadeia sem criar um fork, como jÃ¡ visto vÃ¡rias vezes na Ethereum. AlÃ©m disso, se a rede Tanssi estiver configurada com governanÃ§a on-chain, upgrades podem ocorrer de forma realmente descentralizada e trustless.

Os forkless upgrades sÃ£o possÃ­veis porque a funÃ§Ã£o de transiÃ§Ã£o de estado fica armazenada como um blob Wasm tanto na rede Tanssi quanto na rede powered by Tanssi. Quando um novo runtime Ã© agendado por uma chamada na rede powered by Tanssi, a rede Tanssi valida esse bloco e se prepara para validar blocos usando a funÃ§Ã£o mais recente. ApÃ³s um perÃ­odo de atraso configurado para o upgrade, um Sequencer na rede powered by Tanssi constrÃ³i um bloco que referencia um bloco da rede Tanssi, sinalizando que o novo runtime pode ser aplicado. Assim, essa nova funÃ§Ã£o de transiÃ§Ã£o de estado Ã© usada para aquele bloco. Como todos os participantes usam o blob Wasm on-chain, cada node operator da rede Tanssi pode validar novos blocos com a funÃ§Ã£o mais recente.

Um resumo em alto nÃ­vel do processo de upgrade de runtime estÃ¡ no diagrama a seguir:

![Runtime Upgrade Process Tanssi Networks](/images/learn/decentralized-networks/runtime-features/runtime-features-1.webp)

## Conta SUDO {: #sudo-account}

Redes Tanssi podem usar um mÃ³dulo especÃ­fico chamado [SUDO](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/pallet/struct.Pallet.html){target=\_blank}. Esse mÃ³dulo introduz um novo tipo de conta, tambÃ©m chamada _SUDO_, que pode executar transaÃ§Ãµes com a [_Root_ origin](#origins).

Consequentemente, a conta SUDO pode realizar **qualquer** aÃ§Ã£o que o runtime permita Ã  origem _Root_. Isso inclui:

- Cunhar novos tokens nativos da rede Tanssi
- Realizar [upgrades de runtime sem fork](#forkless-upgrades)
- Enviar transaÃ§Ãµes se passando por outros [tipos de origem](#origins). Assim, SUDO pode enviar transaÃ§Ãµes em nome de outros usuÃ¡rios sem acessar suas chaves privadas

_SUDO_ Ã© recomendada para TestNets, pois permite fazer mudanÃ§as rapidamente sem um processo longo de governanÃ§a on-chain. Ã‰ boa prÃ¡tica manter as chaves _SUDO_ em seguranÃ§a e conceder acesso a chamadas _SUDO_ por meio de contas proxy. Contudo, manter _SUDO_ habilitada em produÃ§Ã£o pode trazer consequÃªncias indesejadas.

**Entender os riscos de centralizaÃ§Ã£o de ter _SUDO_ em produÃ§Ã£o Ã© fundamental.**
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/decentralized-networks/tx-fees/
--- BEGIN CONTENT ---
---
title: Taxas de TransaÃ§Ã£o
description: Saiba como funciona o mecanismo de taxas em redes Tanssi, do ponto de vista Substrate e na camada EVM compatÃ­vel com EIP-1559.
icon: material-piggy-bank-outline 
categories: Basics
---

# Taxas de TransaÃ§Ã£o {: #transaction-fees }

## IntroduÃ§Ã£o {: #introduction}

Redes powered by Tanssi sÃ£o construÃ­das com um [framework modular](/pt/learn/framework/){target=\_blank} chamado [Substrate](https://docs.polkadot.com/develop/parachains/intro-polkadot-sdk/){target=\_blank}. Com esse framework, vocÃª pode criar formas prÃ³prias de lidar com taxas de transaÃ§Ã£o. Por exemplo, a maioria das transaÃ§Ãµes usa um mÃ³dulo especÃ­fico chamado [Transaction Payment](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment){target=\_blank}. Contudo, em redes Tanssi compatÃ­veis com EVM, as taxas podem ser cobradas no nÃ­vel da execuÃ§Ã£o EVM, contornando outros mÃ³dulos relacionados a taxas.

Sob o capÃ´, para Runtime, em vez de um mecanismo baseado em gas, todas as redes Tanssi usam um [mecanismo baseado em weight](https://docs.polkadot.com/polkadot-protocol/parachain-basics/blocks-transactions-fees/fees/){target=\_blank}. Weight refere-se ao tempo (em picosegundos) para validar um bloco. De modo geral, para redes Tanssi EVM e nÃ£o EVM, todas as chamadas tÃªm um weight associado, que define limites de entrada/saÃ­da de storage e de computaÃ§Ã£o. Para redes Tanssi EVM, hÃ¡ um mapeamento gas-to-weight totalmente compatÃ­vel com os requisitos de gas esperados por ferramentas baseadas na Ethereum API.

Um esquema de taxas Ã© aplicado sobre o mecanismo de weight para alinhar incentivos econÃ´micos, limitando Runtime, computaÃ§Ã£o e nÃºmero de chamadas (leituras/gravaÃ§Ãµes). Taxas sÃ£o fundamentais para evitar spam, pois representam o custo de usar o serviÃ§o da rede Tanssi. Assim, um usuÃ¡rio que interage com a rede por meio de uma chamada paga uma taxa determinada por um algoritmo de taxa base.

Esta pÃ¡gina aborda os fundamentos das taxas em redes Tanssi. Primeiro cobre a arquitetura subjacente de taxas e como ela Ã© adaptada a um Template totalmente compatÃ­vel com EIP-1559 para redes Tanssi EVM.

## Baseline Fees Calculation {: #baseline-fees }

Cada aÃ§Ã£o que altera o estado de uma rede Tanssi gera uma taxa de transaÃ§Ã£o. Essa taxa Ã© essencial para a operaÃ§Ã£o da rede, cobrindo os recursos computacionais necessÃ¡rios para processar transaÃ§Ãµes, de forma similar aos parÃ¢metros de gas e gas price em cadeias compatÃ­veis com EVM como a Ethereum.

O [framework modular](/pt/learn/framework/){target=\_blank} das redes Tanssi usa um mecanismo de cÃ¡lculo baseado em weight para determinar taxas. Essa abordagem considera vÃ¡rios fatores, incluindo recursos computacionais e operaÃ§Ãµes de storage (inputs/outputs), para refletir com precisÃ£o o custo real das transaÃ§Ãµes. Ao contabilizar esses elementos, a rede garante alocaÃ§Ã£o de recursos justa e eficiente.

AlÃ©m disso, a modularidade das redes Tanssi garante que redes compatÃ­veis com EVM suportem mecanismos de precificaÃ§Ã£o legados e [compatÃ­veis com EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank}, assegurando compatibilidade total com ambientes de desenvolvimento usados na Ethereum.

Esta seÃ§Ã£o apresenta os diferentes conceitos associados Ã s taxas em redes Tanssi.

### Weight {: #baseline-weight}

De forma ampla, weight refere-se ao Runtime para validar um bloco, medido em picosegundos. O weight se divide em duas variÃ¡veis:

- **`refTime`** - peso associado a tempo de computaÃ§Ã£o e leituras/gravaÃ§Ãµes em banco de dados
- **`proofSize`** - peso associado ao tamanho da Prova de Validade (PoV). A PoV se relaciona ao estado relevante de uma transaÃ§Ã£o, e Ã© o que o Sequencer da rede Tanssi compartilha com os operators do provedor de seguranÃ§a para validar e finalizar um bloco como parte do [fluxo de transaÃ§Ãµes da rede](/pt/learn/decentralized-networks/overview/#network-transaction-flow){target=\_blank}

Para descobrir os weights de todas as chamadas, elas sÃ£o benchmarked em hardware de referÃªncia, e valores aproximados de `refTime` e `proofSize` sÃ£o definidos. Esse processo se repete para todas as chamadas que consomem espaÃ§o de bloco e afetam a PoV.

Para transaÃ§Ãµes em que as taxas sÃ£o tratadas pelo mÃ³dulo [transaction payment](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment){target=\_blank}, todos os parÃ¢metros baseados em weight passam por um algoritmo _weight to fee_ que converte tudo em um valor final, deduzido da conta do remetente ao executar a chamada. O algoritmo pode ser personalizado, mas redes Tanssi definem um valor constante.

Para transaÃ§Ãµes EVM, o gas Ã© convertido em weight por meio de um algoritmo gas-to-weight, para que todas as chamadas EVM possam ser mapeadas para o Runtime do bloco. Ainda assim, as taxas sÃ£o tratadas no nÃ­vel da execuÃ§Ã£o EVM.

### Baseline Transaction Fees {: #baseline-transaction-fees}

<!-- https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/transaction-payment/src/lib.rs#L627-L652 -->

Com todas as chamadas benchmarked, a taxa de transaÃ§Ã£o para cada chamada especÃ­fica pode ser obtida. As taxas geralmente sÃ£o compostas pelos seguintes elementos:

- **`BaseFee`** - custo bÃ¡sico para incluir a transaÃ§Ã£o. Cobre a sobrecarga de inclusÃ£o, como verificaÃ§Ã£o de assinatura. A taxa Ã© definida por dois parÃ¢metros:
    - **`ExtrinsicBaseWeight`** - valor constante que representa o weight da sobrecarga de inclusÃ£o
    - **`WeightToFee`** - funÃ§Ã£o polinomial que converte weight em taxa
- **`WeightFee`** - taxa definida por dois parÃ¢metros:
    - **`BenchmarkedWeight`** - weight que reflete a complexidade (Runtime) de uma chamada especÃ­fica
    - **`CongestionMultiplier`** - funÃ§Ã£o que converte weight em taxa e pode ser ajustada para considerar a congestÃ£o da rede (weight consumido no bloco anterior). A estratÃ©gia padrÃ£o nas redes Tanssi Ã© [`SlowAdjustingFeeUpdate`](https://research.web3.foundation/Polkadot/overview/token-economics#2-slow-adjusting-mechanism){target=\_blank}, que ajusta esse multiplicador lentamente conforme a carga da rede
- **`LengthFee`** - taxa correlacionada ao tamanho em bytes da chamada. Definida por dois parÃ¢metros:
    - **`ByteLengthFunctionCall`** - tamanho em bytes da chamada
    - **`LengthToFee`** - funÃ§Ã£o que define o algoritmo de taxa por byte. Nas redes Tanssi, Ã© um valor constante
- **`Tip`** - valor opcional que aumenta a taxa total, elevando a prioridade da transaÃ§Ã£o ao incentivar Sequencers a incluÃ­-la no prÃ³ximo bloco

Assim, em termos gerais, a taxa de transaÃ§Ã£o pode ser calculada pela equaÃ§Ã£o:

<!-- https://github.com/moondance-labs/substrate/blob/master/frame/support/src/weights/extrinsic_weights.rs#L57 -->
<!-- https://github.com/moondance-labs/tanssi/blob/master/container-chains/templates/frontier/runtime/src/lib.rs#L265-L277 -->

```text
BaseFee = ExtrinsicBaseWeight * WeightToFee
WeightFee = BenchmarkedWeight  * CongestionMultiplier
LengthFee = ByteLengthFunctionCall * LengthToFee

InclusionFee = BaseFee + WeightFee + LengthFee
FinalFee = InclusionFee + Tip
```

Todas as chamadas nÃ£o EVM disponÃ­veis aos desenvolvedores usam esses cÃ¡lculos bÃ¡sicos para taxas. Redes Tanssi EVM adicionam uma camada extra para traduzir esse esquema para algo semelhante ao Template Ethereum do ponto de vista da Ethereum JSON-RPC e da EVM.

### EVM Transaction Fees {: #evm-transaction-fees }

<!-- https://github.com/polkadot-evm/frontier/blob/272fe8839f87161ed89350de166b379f1f4c6136/frame/base-fee/src/lib.rs#L126-L199 -->

A Tanssi oferece [templates para redes EVM completas](/builders/build/templates/evm/){target=\_blank}. Essas redes fornecem um ambiente similar ao Ethereum, onde os desenvolvedores podem usar bibliotecas como [Ethers.js](/pt/builders/toolkit/ethereum-api/libraries/ethersjs/){target=\_blank}, [Hardhat](/pt/builders/toolkit/ethereum-api/dev-env/hardhat/){target=_blank} e [Foundry](/pt/builders/toolkit/ethereum-api/dev-env/foundry/){target=\_blank}.

AlÃ©m disso, todas as redes Tanssi compatÃ­veis com EVM tÃªm um mecanismo de precificaÃ§Ã£o [compatÃ­vel com EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} para transaÃ§Ãµes EVM. Elas suportam os dois tipos de transaÃ§Ã£o EVM mais comuns:

- **Tipo 0 (Legacy)** - a taxa Ã© calculada por um valor Ãºnico de gas price incluÃ­do no blob da transaÃ§Ã£o assinada. Como as redes Tanssi EVM tÃªm precificaÃ§Ã£o dinÃ¢mica, o gas price deve ser maior que o `baseFee` do bloco atual para a transaÃ§Ã£o ser vÃ¡lida
- **Tipo 2 (EIP-1559)** - a taxa Ã© calculada com a combinaÃ§Ã£o de `maxFeePerGas` e `maxPriorityFeePerGas` no blob da transaÃ§Ã£o, e o `baseFee` da rede muda dinamicamente com base na congestÃ£o do bloco

Independentemente do tipo de transaÃ§Ã£o, o resultado Ã© um custo em tokens nativos que a rede deve cobrar.

Por padrÃ£o, redes Tanssi compatÃ­veis com EVM tÃªm os seguintes parÃ¢metros:

- **Minimum BaseFee** - gas price mÃ­nimo da rede caso nÃ£o haja transaÃ§Ãµes por longos perÃ­odos. O valor padrÃ£o Ã© 1 GWei
- **Block Fulness Target (Elasticity)** - alvo de gas usado em um bloco para manter o `baseFee` estÃ¡vel. A [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} define esse valor como 2, significando que a meta de uso Ã© 50% do limite de gas do bloco. Todas as redes Tanssi EVM usam a mesma meta
- **Maximum BaseFee Increase** - aumento mÃ¡ximo do `baseFee`, em pontos percentuais, com base no uso-alvo do bloco anterior. A [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559){target=\_blank} define esse valor como 12,5%. Assim, se o bloco estiver cheio/vazio, o `baseFee` aumenta/diminui 12,5%, ajustando-se linearmente para valores intermediÃ¡rios. Esse valor Ã© configurÃ¡vel, mas o padrÃ£o nas redes Tanssi EVM Ã© 12,5%

!!! note
    Uma diferenÃ§a importante na implementaÃ§Ã£o EIP-1559 das redes Tanssi EVM Ã© que as taxas sÃ£o calculadas usando o `baseFee` do bloco anterior.

O custo de taxa de transaÃ§Ã£o para chamadas EVM nas redes Tanssi Ã© capturado no nÃ­vel de execuÃ§Ã£o EVM. Ainda assim, transaÃ§Ãµes EVM consomem Runtime de bloco. Portanto, Ã© necessÃ¡rio um algoritmo gas-to-weight para contabilizar o weight consumido por uma chamada em relaÃ§Ã£o ao gas usado.

<!-- https://github.com/moondance-labs/tanssi/blob/master/container-chains/templates/frontier/runtime/src/lib.rs#L825 -->
<!-- https://github.com/polkadot-evm/frontier/blob/272fe8839f87161ed89350de166b379f1f4c6136/primitives/evm/src/lib.rs#L253-L265 -->

Por fim, a taxa e o weight associados a uma chamada EVM em uma rede Tanssi compatÃ­vel com EVM podem ser calculados assim:

=== "EIP-1559"
    ```text
    Gas Price = baseFee + maxPriorityFeePerGas < maxFeePerGas ? 
               baseFee + maxPriorityFeePerGas : 
               maxFeePerGas;
    Transaction Fee = Gas Price * Gas Used
    Transaction Weight = Gas Used * GasToWeight
    ```

=== "Legacy"
    ```text
    Transaction Fee = GasPrice * GasUsed
    Transaction Weight = GasUsed * GasToWeight
    ```

`GasToWeight` Ã© um valor constante definido como `{{ templates.evm.gas_to_weight }}`.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/framework/architecture/
--- BEGIN CONTENT ---
---
title: Arquitetura do Framework
description: Em um nÃ³ Substrate, dois componentes principais sÃ£o o runtime, que controla a transiÃ§Ã£o de estado da blockchain, e o cliente, que gerencia todo o resto.
icon: octicons-stack-24
categories: Basics
---

# Arquitetura do Framework {: #framework-architecture }

## IntroduÃ§Ã£o {: #introduction }

Substrate Ã© um kit de desenvolvimento de software (SDK) para a construÃ§Ã£o de blockchains. Este framework Ã© a base e o motor que impulsionam muitos projetos em todo o ecossistema Web3, incluindo a prÃ³pria rede Tanssi e as redes implantadas atravÃ©s da Tanssi.

Escrito na linguagem Rust e projetado com uma arquitetura modular, o Substrate Ã© extremamente performÃ¡tico, flexÃ­vel e altamente personalizÃ¡vel, tornando-o a melhor opÃ§Ã£o para o desenvolvimento de blockchains.

Neste artigo, a arquitetura de um nÃ³ Substrate Ã© abordada.

## Arquitetura {: #architecture }

O framework Substrate Ã© projetado para mÃ¡xima personalizaÃ§Ã£o, fornecendo uma implementaÃ§Ã£o totalmente funcional para todos os aspectos internos importantes de uma blockchain. Ele permite que os desenvolvedores se concentrem nos detalhes do caso de uso e nas caracterÃ­sticas do runtime, e oferece a capacidade de alterar qualquer um dos recursos padrÃ£o (se necessÃ¡rio).

A arquitetura de um nÃ³ Substrate contÃ©m dois componentes principais:

- **Cliente Core** - lida com a comunicaÃ§Ã£o com o mundo exterior (outros nÃ³s, dApps, usuÃ¡rios finais, entre outros), e muitas outras responsabilidades internas, como armazenamento e comunicaÃ§Ã£o
- **Runtime** - implementa a lÃ³gica personalizada da rede Tanssi, executa transaÃ§Ãµes e gerencia as transiÃ§Ãµes de estado

Da perspectiva do usuÃ¡rio final, toda a interaÃ§Ã£o com a rede Tanssi Ã© geralmente feita atravÃ©s de dApps ou diretamente atravÃ©s dos endpoints RPC do nÃ³, por exemplo, usando uma carteira. Quando um usuÃ¡rio aciona uma solicitaÃ§Ã£o para buscar dados ou envia transaÃ§Ãµes para um nÃ³, o cliente core Ã© responsÃ¡vel por responder ou enfileirar as transaÃ§Ãµes atÃ© a execuÃ§Ã£o no runtime. Ainda assim, todos esses aspectos internos do design do nÃ³ sÃ£o mantidos transparentes para o usuÃ¡rio.

![Arquitetura bÃ¡sica de um nÃ³ Substrate](/images/learn/framework/architecture/architecture-1.webp)

## O Cliente Core {: #core-client }

O cliente core compreende componentes responsÃ¡veis por tudo na operaÃ§Ã£o de um nÃ³ na rede, exceto pelo que acontece no runtime.

Alguns dos principais componentes sÃ£o:

- **Networking** - este componente lida com a comunicaÃ§Ã£o com os pares na rede (sincronizaÃ§Ã£o de blocos, propagaÃ§Ã£o de transaÃ§Ãµes e assim por diante) e expÃµe os endpoints que permitem que os dApps se integrem e interajam com a rede Tanssi
- **Storage** - este componente gerencia o armazenamento de estado da rede Tanssi em um banco de dados chave-valor altamente eficiente
- **Consenso** - este componente garante que todos os participantes da rede concordem com o estado da blockchain, validando transaÃ§Ãµes, transiÃ§Ãµes de estado e os blocos resultantes

A configuraÃ§Ã£o padrÃ£o de um nÃ³ Substrate e as implementaÃ§Ãµes embutidas dos componentes sÃ£o geralmente a melhor escolha para a maioria dos casos de uso. Ainda assim, as equipes sÃ£o bem-vindas para inovar e alterar ou substituir qualquer parte do nÃ³ ou atÃ© mesmo escrever uma implementaÃ§Ã£o completamente diferente do cliente core, como [Kagome](https://github.com/soramitsu/kagome#intro){target=\_blank} (implementaÃ§Ã£o C++) e [Gossamer](https://github.com/ChainSafe/gossamer#a-go-implementation-of-the-polkadot-host){target=\_blank} (implementaÃ§Ã£o Golang).

## O Runtime {: #runtime }

O runtime desempenha um papel crucial na operaÃ§Ã£o da rede Tanssi. Ele contÃ©m a lÃ³gica e as regras principais para atender aos requisitos do caso de uso que os desenvolvedores estÃ£o construindo e, portanto, Ã© responsÃ¡vel por validar as transaÃ§Ãµes e executar as transiÃ§Ãµes de estado.

Sendo o elemento central em uma rede Tanssi, projetar a arquitetura Substrate uma decisÃ£o importante foi tomada em relaÃ§Ã£o ao formato para o runtime: ele Ã© compilado para cÃ³digo de bytes [WebAssembly (Wasm)](https://webassembly.org){target=\_blank}.

O formato Wasm oferece muitas vantagens para uma rede Tanssi implantada, incluindo:

- **Portabilidade** - o formato Wasm Ã© independente de plataforma, o que significa que o mesmo binÃ¡rio pode ser distribuÃ­do e executado em diferentes nÃ³s usando diferentes arquiteturas de hardware e sistemas operacionais
- **ExecuÃ§Ã£o DeterminÃ­stica** - o formato Wasm garante a execuÃ§Ã£o determinÃ­stica do cÃ³digo, o que significa que a mesma entrada sempre produzirÃ¡ a mesma saÃ­da. A determinÃ¢ncia Ã© um aspecto crÃ­tico em blockchains para obter as mesmas transiÃ§Ãµes de estado em todos os nÃ³s da rede e alcanÃ§ar um consenso
- **AtualizaÃ§Ã£o sem fork** - Substrate armazena o blob Wasm do runtime on-chain, o que significa que o prÃ³prio runtime se torna parte do estado. Este projeto permite a atualizaÃ§Ã£o da lÃ³gica do runtime de forma sem fork usando uma transaÃ§Ã£o

AlÃ©m do formato, internamente, um runtime Substrate Ã© construÃ­do compondo diferentes mÃ³dulos, fornecidos e prontos para uso pelo Substrate ou feitos sob medida. Cada um desses mÃ³dulos define, entre outras coisas, as transaÃ§Ãµes que expÃµem, a lÃ³gica por trÃ¡s delas, o que precisa ser armazenado no estado da cadeia, o melhor formato para fazÃª-lo e como eles cooperam com outros mÃ³dulos para compor a funcionalidade. Mais detalhes sobre a construÃ§Ã£o de um runtime serÃ£o abordados na seÃ§Ã£o [mÃ³dulos](/pt/learn/framework/modules/){target=\_blank}.

## ComunicaÃ§Ã£o Cliente-Runtime {: #client-runtime-communication }

Como descrito anteriormente, os dois principais componentes de um nÃ³ Substrate (o cliente core e o runtime) tÃªm uma clara separaÃ§Ã£o de preocupaÃ§Ãµes. AlÃ©m das responsabilidades funcionais, em um nÃ­vel inferior, sua representaÃ§Ã£o binÃ¡ria e ambientes de execuÃ§Ã£o sÃ£o diferentes. Embora o nÃ³ seja compilado para ser instalado e executado em uma plataforma especÃ­fica (seja Linux x64 ou qualquer outra), o runtime da rede Tanssi Ã© compilado para um formato Wasm que Ã© agnÃ³stico Ã  plataforma e Ã© executado em um ambiente de execuÃ§Ã£o isolado.

Tendo em mente os ambientes de execuÃ§Ã£o separados, toda a comunicaÃ§Ã£o entre o cliente do nÃ³ e o runtime ocorre por meio de uma interface limitada e bem definida, permitindo as operaÃ§Ãµes necessÃ¡rias, como:

- **Executar TransaÃ§Ãµes** - quando um usuÃ¡rio envia uma transaÃ§Ã£o para o nÃ³ cliente, o nÃ³ passa essa transaÃ§Ã£o para o runtime atravÃ©s da API definida para sua execuÃ§Ã£o
- **Consultas de Estado** - o nÃ³ cliente pode consultar o estado atual da blockchain para recuperar informaÃ§Ãµes como saldos de contas e quaisquer outros dados especÃ­ficos do domÃ­nio
- **Consenso e Finalidade** - o nÃ³ cliente coordena o consenso e a finalizaÃ§Ã£o dos blocos, mas Ã© responsabilidade do runtime determinar a validade de novos blocos, validar transaÃ§Ãµes e garantir que as regras de consenso sejam seguidas
- **NotificaÃ§Ãµes de Eventos** - o runtime emite eventos ao executar transaÃ§Ãµes que o nÃ³ cliente pode usar para manter os usuÃ¡rios externos atualizados sobre aÃ§Ãµes ou alteraÃ§Ãµes especÃ­ficas no estado
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/framework/
--- BEGIN CONTENT ---
---
title: Estrutura de Desenvolvimento de Rede
description: Saiba mais sobre o framework de desenvolvimento de rede, a linguagem de programaÃ§Ã£o Rust, o Substrate e suas funcionalidades, incluindo XCM e pallets prontos para usar para seu Runtime.
icon: octicons-code-24
template: index-page.html
---

# Estrutura de Desenvolvimento de Rede

A construÃ§Ã£o de uma blockchain do zero Ã© um processo intrincado que exige um profundo conhecimento de algoritmos de consenso, criptografia, estruturas de dados, governanÃ§a e muito mais. Tanssi simplifica esse processo, aproveitando o Substrate, um poderoso framework de desenvolvimento de blockchain que fornece todos os componentes essenciais para a criaÃ§Ã£o de blockchains personalizadas.

Com a arquitetura modular do Substrate, vocÃª pode modificar as caracterÃ­sticas do Runtime, integrar mÃ³dulos prÃ©-construÃ­dos ou desenvolver novos com base nas necessidades especÃ­ficas da sua rede. Tanssi fornece a base que vocÃª precisa para dar vida Ã  sua visÃ£o de blockchain.

Principais recursos do framework:

- **Arquitetura central do Substrate** - dividida em _core client_, que gerencia as comunicaÃ§Ãµes externas e as responsabilidades internas, como armazenamento, e o _runtime_, que executa transaÃ§Ãµes e gerencia as transiÃ§Ãµes de estado com lÃ³gica personalizÃ¡vel
- **Simplicidade para o usuÃ¡rio final** - o funcionamento interno do framework Ã© abstraÃ­do para os usuÃ¡rios finais, garantindo uma interaÃ§Ã£o perfeita por meio de dApps ou via endpoints RPC, como os usados â€‹â€‹por carteiras
- **Design de sistema modular** - incorpore mÃ³dulos prÃ©-construÃ­dos ou crie mÃ³dulos personalizados para atender Ã s necessidades especÃ­ficas
- **Flexibilidade centrada no desenvolvedor** - concentre-se nas caracterÃ­sticas de Runtime e nas especificidades dos casos de uso, permitindo que vocÃª crie um blockchain adaptado Ã  sua visÃ£o sem complexidade desnecessÃ¡ria

## Explore This Section

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/framework/modules/
--- BEGIN CONTENT ---
---
title: MÃ³dulos de Rede para o Seu Runtime
description: O Substrate Ã© um framework modular de desenvolvimento de blockchain com um conjunto extenso de componentes prontos para uso que podem ser associados Ã  lÃ³gica personalizada no Runtime da rede.
icon: material-puzzle-outline
categories: Custom-Runtime, Basics
---

# MÃ³dulos de Framework de Rede {: #network-framework-modules }

## IntroduÃ§Ã£o {: #introduction }

O framework Substrate fornece implementaÃ§Ãµes completas e prontas para uso das funÃ§Ãµes principais que uma rede Tanssi precisa para funcionar corretamente, incluindo criptografia, consenso, governanÃ§a e assim por diante. Estas implementaÃ§Ãµes sÃ£o totalmente personalizÃ¡veis e podem ser substituÃ­das por lÃ³gica personalizada, se necessÃ¡rio.

Ao criar o Runtime, que define as regras de transiÃ§Ã£o de estado entre dois blocos aplicados a um conjunto de transaÃ§Ãµes, o comportamento e as funcionalidades pretendidas da blockchain precisam de ser definidos ao determinar as regras da transiÃ§Ã£o de estado.

Para construir o Runtime, o Substrate fornece muitos mÃ³dulos integrados (tambÃ©m conhecidos como pallets) que podem ser livremente usados como blocos de construÃ§Ã£o para compor e interagir com quaisquer outros mÃ³dulos feitos sob medida, permitindo que as equipas criem comportamentos Ãºnicos de acordo com os requisitos especÃ­ficos da sua rede Tanssi.

![MÃ³dulos embutidos](/images/learn/framework/modules/modules-1.webp)

## MÃ³dulos Integrados {: #built-in-modules }

Ao projetar e escrever as regras de uma rede Tanssi, o conjunto disponÃ­vel de mÃ³dulos funcionais traz uma soluÃ§Ã£o para muitos dos requisitos de codificaÃ§Ã£o que, caso contrÃ¡rio, precisariam ser construÃ­dos do zero.

Aqui estÃ¡ uma lista de alguns dos mÃ³dulos mais populares:

- **[Balances](https://paritytech.github.io/substrate/master/pallet_balances/index.html){target=\_blank}** - fornece funÃ§Ãµes para lidar com contas e saldos para a moeda nativa da rede Tanssi
- **[Assets](https://paritytech.github.io/substrate/master/pallet_assets/index.html){target=\_blank}** - fornece funÃ§Ãµes para lidar com qualquer tipo de token fungÃ­vel
- **[NFTs](https://paritytech.github.io/substrate/master/pallet_nfts/index.html){target=\_blank}** - fornece funÃ§Ãµes para lidar com tokens nÃ£o fungÃ­veis
- **[Democracy](https://paritytech.github.io/substrate/master/pallet_democracy/index.html){target=\_blank}** - fornece funÃ§Ãµes para gerir e administrar a votaÃ§Ã£o geral dos stakeholders
- **[Multisig](https://paritytech.github.io/substrate/master/pallet_multisig/index.html){target=\_blank}** - fornece funÃ§Ãµes para envio de multi-assinaturas
- **[Recovery](https://paritytech.github.io/substrate/master/pallet_recovery/index.html){target=\_blank}** - fornece funÃ§Ãµes para permitir que os utilizadores recuperem o acesso Ã s suas contas quando a chave privada Ã© perdida. Isto funciona ao conceder a outras contas o direito de assinar transaÃ§Ãµes em nome da conta perdida (observe que Ã© necessÃ¡rio ter escolhido previamente as contas autorizadas)
- **[Staking](https://paritytech.github.io/substrate/master/pallet_staking/index.html){target=\_blank}** - fornece funÃ§Ãµes para administrar tokens apostados, apoiar recompensas, cortes, depÃ³sito, levantamento, e assim por diante

AlÃ©m daqueles jÃ¡ listados, outros mÃ³dulos como [identity](https://paritytech.github.io/substrate/master/pallet_identity/index.html){target=\_blank}, [smart contracts](https://paritytech.github.io/substrate/master/pallet_contracts/index.html){target=\_blank}, [vesting](https://paritytech.github.io/substrate/master/pallet_vesting/index.html){target=\_blank}, e muitos outros que estÃ£o livremente disponÃ­veis podem acelerar o desenvolvimento da rede Tanssi e, consequentemente, o tempo de lanÃ§amento.

!!! note
    O framework tambÃ©m inclui outros mÃ³dulos que fornecem funcionalidades essenciais de protocolo, como consenso e codificaÃ§Ã£o de dados de baixo nÃ­vel.

## MÃ³dulos Feitos sob Medida {: #custom-modules }

Os desenvolvedores que criam novos mÃ³dulos desfrutam de total liberdade para expressar qualquer comportamento desejado na lÃ³gica principal da blockchain, como expor novas transaÃ§Ãµes, armazenar informaÃ§Ãµes sensÃ­veis e validar e impor lÃ³gica de negÃ³cios.

Como explicado no artigo [Arquitetura](/pt/learn/framework/architecture/#client-runtime-communication){target=\_blank}, um mÃ³dulo precisa ser capaz de se comunicar com o cliente principal, expondo e integrando com uma API muito especÃ­fica que permite que o Runtime exponha transaÃ§Ãµes, acesse o armazenamento e code e decodifique informaÃ§Ãµes armazenadas na cadeia. TambÃ©m precisa incluir muitos outros cÃ³digos de ligaÃ§Ã£o necessÃ¡rios que fazem o mÃ³dulo funcionar no nÃ³.

Para melhorar a experiÃªncia do desenvolvedor ao escrever mÃ³dulos, o Substrate depende muito de [macros Rust](https://doc.rust-lang.org/book/ch19-06-macros.html){target=\_blank}. As macros sÃ£o instruÃ§Ãµes especiais que se expandem automaticamente para o cÃ³digo Rust pouco antes do tempo de compilaÃ§Ã£o, permitindo que os mÃ³dulos mantenham atÃ© sete vezes a quantidade de cÃ³digo fora da vista dos desenvolvedores. Isto permite que os desenvolvedores se concentrem nos requisitos funcionais especÃ­ficos ao escrever mÃ³dulos, em vez de lidar com tecnicidades e o cÃ³digo de suporte necessÃ¡rio.

Todos os mÃ³dulos no Substrate, incluindo os feitos sob medida, implementam estas macros de atributo, das quais as trÃªs primeiras sÃ£o obrigatÃ³rias:

- **`#[frame_support::pallet]`** - atributo de entrada que marca o mÃ³dulo como utilizÃ¡vel no runtime
- **`#[pallet::pallet]`** - aplicado a uma estrutura usada para recuperar informaÃ§Ãµes do mÃ³dulo com facilidade
- **`#[pallet::config]`** - atributo obrigatÃ³rio para definir a configuraÃ§Ã£o dos tipos de dados do mÃ³dulo
- **`#[pallet::call]`** - macro usada para definir funÃ§Ãµes expostas como transaÃ§Ãµes, permitindo que sejam despachadas para o runtime; aqui os desenvolvedores adicionam transaÃ§Ãµes e lÃ³gica personalizadas
- **`#[pallet::error]`** - como transaÃ§Ãµes podem falhar (por exemplo, fundos insuficientes) e, por seguranÃ§a, um mÃ³dulo nÃ£o deve gerar exceÃ§Ãµes, todos os possÃ­veis erros devem ser identificados e listados em um enum para serem retornados em uma execuÃ§Ã£o malsucedida
- **`#[pallet::event]`** - eventos podem ser definidos e usados para fornecer mais informaÃ§Ãµes ao usuÃ¡rio
- **`#[pallet::storage]`** - macro usada para definir elementos que serÃ£o persistidos em storage; como recursos sÃ£o escassos em uma blockchain, deve ser usada com parcimÃ´nia para armazenar apenas informaÃ§Ãµes essenciais

Todas estas macros atuam como atributos que devem ser aplicados ao cÃ³digo logo acima dos mÃ³dulos, funÃ§Ãµes, estruturas, enums, tipos, etc., Rust, permitindo que o mÃ³dulo seja construÃ­do e adicionado ao Runtime, que, com o tempo, irÃ¡ expor a lÃ³gica personalizada ao mundo exterior, conforme exposto na seÃ§Ã£o seguinte.

### Exemplo de MÃ³dulo Personalizado { #custom-module-example }

Como exemplo de um mÃ³dulo personalizado, o seguinte cÃ³digo (nÃ£o destinado a uso em produÃ§Ã£o) demonstra o uso das macros mencionadas anteriormente, apresentando uma loteria simples com funcionalidade mÃ­nima, expondo duas transaÃ§Ãµes:

- **buy_ticket** - esta transaÃ§Ã£o verifica se o utilizador que estÃ¡ a assinar o pedido ainda nÃ£o comprou um bilhete e tem fundos suficientes para pagar. Se tudo estiver bem, o mÃ³dulo transfere o preÃ§o do bilhete para uma conta especial e regista o utilizador como participante do prÃ©mio

- **award_prize** - esta transaÃ§Ã£o gera um nÃºmero aleatÃ³rio para escolher o vencedor da lista de participantes. O vencedor recebe a quantia total dos fundos transferidos para a conta especial do mÃ³dulo

```rust
#![cfg_attr(not(feature = "std"), no_std)]

/// Learn more about FRAME and the core library of Substrate FRAME pallets:
/// <https://docs.substrate.io/reference/frame-pallets/>
pub use pallet::*;

#[frame_support::pallet(dev_mode)]
pub mod pallet {

	use super::*;
	use frame_support::pallet_prelude::{*, ValueQuery, OptionQuery};
	use frame_system::pallet_prelude::*;
	use scale_info::prelude::vec::Vec;

	use frame_support::
	{
		sp_runtime::traits::AccountIdConversion,
		traits:: {
			Currency, ExistenceRequirement, Randomness
		},
		PalletId,
	};

	type BalanceOf<T> = 
		<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

	#[pallet::pallet]
	pub struct Pallet<T>(_);

	/// Configure the module by specifying the parameters and types on which it depends.
	#[pallet::config]
	pub trait Config: frame_system::Config {

		// Event definition
		type RuntimeEvent: From<Event<Self>> 
			+ IsType<<Self as frame_system::Config>::RuntimeEvent>;

		// Currency 
		type Currency: Currency<Self::AccountId>;

		// Randomness
		type MyRandomness: Randomness<Self::Hash, BlockNumberFor<Self>>;

		// Ticket cost
		#[pallet::constant]
		type TicketCost: Get<BalanceOf<Self>>;

		// Maximum number of participants
		#[pallet::constant]
		type MaxParticipants: Get<u32>;

		// Module Id
		#[pallet::constant]
		type PalletId: Get<PalletId>;
	}

	// The pallet's runtime storage items.
	#[pallet::storage]
	#[pallet::getter(fn get_participants)]
	pub(super) type Participants<T: Config> = StorageValue<
		_,
		BoundedVec<T::AccountId, T::MaxParticipants>,
		OptionQuery
	>;

	#[pallet::storage]
	#[pallet::getter(fn get_nonce)]
	pub(super) type Nonce<T: Config> = StorageValue<
		_,
		u64,
		ValueQuery
	>;

	// Pallets use events to inform users when important changes are made.
	// https://docs.substrate.io/main-docs/build/events-errors/
	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		/// Event emitted when a ticket is bought
		TicketBought { who: T::AccountId },
		/// Event emitted when the prize is awarded
		PrizeAwarded { winner: T::AccountId },
		/// Event emitted when the prize is to be awarded, but there are no participants
		ThereAreNoParticipants,
	}

	// Errors inform users that something went wrong
	#[pallet::error]
	pub enum Error<T> {
		NotEnoughCurrency,
		AccountAlreadyParticipating,
		CanNotAddParticipant,
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {

		#[pallet::call_index(0)]
		#[pallet::weight(0)]
		pub fn buy_ticket(origin: OriginFor<T>) -> DispatchResult {

			// 1. Validates the origin signature
			let buyer = ensure_signed(origin)?;

			// 2. Checks that the user has enough balance to afford the ticket price
			ensure!(
				T::Currency::free_balance(&buyer) >= T::TicketCost::get(),
				Error::<T>::NotEnoughCurrency
			);

			// 3. Checks that the user is not already participating
			if let Some(participants) = Self::get_participants() {
				ensure!(
					!participants.contains(&buyer),
					Error::<T>::AccountAlreadyParticipating
				);
			}

			// 4. Adds the user as a new participant for the prize
			match Self::get_participants() {
				Some(mut participants) => { 
					ensure!(
						participants.try_push(buyer.clone()).is_ok(), 
						Error::<T>::CanNotAddParticipant
					);
					Participants::<T>::set(Some(participants));
				}, 
				None => {
					let mut participants = BoundedVec::new();
					ensure!(
						participants.try_push(buyer.clone()).is_ok(), 
						Error::<T>::CanNotAddParticipant
					);
					Participants::<T>::set(Some(participants));
				}
			};

			// 5. Transfers the ticket cost to the module's account
			// to be hold until transferred to the winner
			T::Currency::transfer(
				&buyer, 
				&Self::get_pallet_account(), 
				T::TicketCost::get(), 
				ExistenceRequirement::KeepAlive)?;
			
			// 6. Notify the event
			Self::deposit_event(Event::TicketBought { who: buyer });
			Ok(())
		}

		#[pallet::call_index(1)]
		#[pallet::weight(0)]
		pub fn award_prize(origin: OriginFor<T>) -> DispatchResult {

			// 1. Validates the origin signature
			let _who = ensure_root(origin)?;

			match Self::get_participants() {
				Some(participants) => { 
					
					// 2. Gets a random number from the randomness module
					let nonce = Self::get_and_increment_nonce();
					let (random_seed, _) = T::MyRandomness::random(&nonce);
					let random_number = <u32>::decode(&mut random_seed.as_ref())
						.expect("secure hashes should always be bigger than u32; qed");
					
					// 3. Selects the winner from the participants lit
					let winner_index = random_number as usize % participants.len();
					let winner = participants.as_slice().get(winner_index).unwrap();

					// 4. Transfers the total prize to the winner's account
					let prize = T::Currency::free_balance(&Self::get_pallet_account());
					T::Currency::transfer(
						&Self::get_pallet_account(), 
						&winner, 
						prize, 
						ExistenceRequirement::AllowDeath)?;

					// 5. Resets the participants list, and gets ready for another lottery round
					Participants::<T>::kill();

					// 6. Notify the event
					Self::deposit_event(Event::PrizeAwarded { winner: winner.clone() } );
				}, 
				None => {
					// Notify the event (No participants)
					Self::deposit_event(Event::ThereAreNoParticipants);
				}
			};

			Ok(())
		}
	}

	impl<T: Config> Pallet<T> {

		fn get_pallet_account() -> T::AccountId {
			T::PalletId::get().into_account_truncating()
		}

		fn get_and_increment_nonce() -> Vec<u8> {
			let nonce = Nonce::<T>::get();
			Nonce::<T>::put(nonce.wrapping_add(1));
			nonce.encode()
		}
	}
}
```

Para mais informaÃ§Ãµes sobre o processo passo a passo de criaÃ§Ã£o de um mÃ³dulo feito sob medida para o Runtime, consulte [Adicionar um mÃ³dulo personalizado](/pt/builders/build/customize/adding-custom-made-module/){target=\_blank} na secÃ§Ã£o de Builder.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/framework/overview/
--- BEGIN CONTENT ---
---
title: VisÃ£o Geral da Estrutura de Desenvolvimento de Rede
description: Substrate Ã© uma estrutura de desenvolvimento de blockchain construÃ­da na Linguagem de ProgramaÃ§Ã£o Rust que agiliza e acelera o processo de desenvolvimento de novas redes.
icon: octicons-home-24
categories: Basics
---

# VisÃ£o Geral da Estrutura de Desenvolvimento de Rede {: #network-dev-framework-overview }

## IntroduÃ§Ã£o {: #introduction }

A construÃ§Ã£o de uma rede do zero Ã© uma tarefa muito complexa que exige profundo conhecimento em uma ampla gama de Ã¡reas, incluindo (mas nÃ£o se limitando a):

- **Algoritmos de Consenso** - o consenso garante que todos os participantes da rede blockchain concordem com a validade das transaÃ§Ãµes. Alguns mecanismos de consenso populares incluem Prova de Trabalho (PoW) e Prova de ParticipaÃ§Ã£o (PoS)

- **Criptografia** - a criptografia desempenha um papel crucial na seguranÃ§a da blockchain. VocÃª precisarÃ¡ de algoritmos criptogrÃ¡ficos para tarefas como criar assinaturas digitais, verificar transaÃ§Ãµes e criptografar dados

- **Rede DistribuÃ­da** - uma arquitetura de rede para permitir que os nÃ³s se comuniquem, validem transaÃ§Ãµes e sincronizem os dados da blockchain Ã© fundamental para manter um livro-razÃ£o compartilhado em uma rede descentralizada

- **Estruturas de Dados** - alÃ©m da lista de blocos, onde cada bloco contÃ©m um conjunto de transaÃ§Ãµes junto com uma referÃªncia ao bloco anterior, Ã© necessÃ¡ria uma estratÃ©gia otimizada e de alto desempenho para armazenar o estado da rede

- **GovernanÃ§a** - se a rede for projetada para ser sem permissÃ£o, um mecanismo de votaÃ§Ã£o Ã© importante para mantÃª-la evoluindo e refletindo a vontade da comunidade

- **AtualizaÃ§Ã£o** - Ã© necessÃ¡rio definir claramente como atualizar, como as modificaÃ§Ãµes sÃ£o implementadas e como os conflitos sÃ£o resolvidos dentro da rede

Felizmente, nÃ£o hÃ¡ necessidade de construir esses componentes de blockchain do zero, graÃ§as a uma excelente estrutura de cÃ³digo aberto chamada [Substrate](https://docs.polkadot.com/develop/parachains/intro-polkadot-sdk/){target=\_blank}. A prÃ³pria Tanssi Ã© construÃ­da com essa estrutura, aproveitando suas implementaÃ§Ãµes de base abrangentes, modularidade e flexibilidade para alcanÃ§ar um alto nÃ­vel de personalizaÃ§Ã£o.

## Estrutura Substrate {: #substrate-framework}

Substrate Ã© uma estrutura extremamente performÃ¡tica, flexÃ­vel, modular e altamente personalizÃ¡vel para construir blockchains. Essa estrutura Ã© a base e o motor que impulsionam muitos projetos no ecossistema Web3, incluindo a prÃ³pria rede Tanssi e as redes implantadas por meio da Tanssi.

Muitos de seus Ã³timos recursos, como desempenho, facilidade de uso e modularidade, resultam da linguagem de programaÃ§Ã£o escolhida para seu desenvolvimento. Ã‰ aqui que a [Linguagem de ProgramaÃ§Ã£o Rust](#rust-programming-language) se destaca: ela Ã© rÃ¡pida, portÃ¡til e fornece um Template maravilhoso para lidar com a memÃ³ria, entre outros motivos detalhados na [prÃ³xima seÃ§Ã£o](#rust-programming-language).

Ao desenvolver uma rede, Substrate representa uma grande vantagem ao fornecer um conjunto de implementaÃ§Ãµes prontas para uso dos principais blocos de construÃ§Ã£o que um projeto precisa:

- **Algoritmos de Consenso** - existem vÃ¡rios mecanismos de consenso integrados, como Aura (Prova de Autoridade), Babe (Prova de ParticipaÃ§Ã£o) e Grandpa (finalidade de bloco), mas devido ao alto grau de personalizaÃ§Ã£o que Substrate oferece, as equipes podem sempre optar por desenvolver seu consenso especÃ­fico para se adaptar Ã s necessidades do caso de uso, como a equipe Moonbeam fez com a [Estrutura de Consenso Nimbus Parachain](https://docs.moonbeam.network/learn/features/consensus){target=\_blank}

- **MÃ³dulos de Runtime** - muitos mÃ³dulos integrados (explicados em detalhes na seÃ§Ã£o [modules](/pt/learn/framework/modules/){target=\_blank}) podem ser selecionados e configurados em sua rede, como contas, saldos, staking, governanÃ§a, identidade e muito mais

- **Rede** - protocolos e bibliotecas integradas para estabelecer conexÃµes, propagar transaÃ§Ãµes e blocos, sincronizar o estado da blockchain e gerenciar interaÃ§Ãµes de rede

- **Armazenamento** - mecanismos de armazenamento integrados para armazenamento e recuperaÃ§Ã£o de dados eficientes

- **Fila de TransaÃ§Ãµes** - sistema de fila de transaÃ§Ãµes integrado que gerencia a validaÃ§Ã£o, priorizaÃ§Ã£o e inclusÃ£o de transaÃ§Ãµes em blocos, garantindo a consistÃªncia e integridade do estado da rede

- **APIs RPC** - Substrate fornece APIs de Chamada de Procedimento Remoto (RPC) que permitem que aplicativos externos interajam com a rede, consultando dados da blockchain, enviando transaÃ§Ãµes e acessando vÃ¡rias funcionalidades expostas pelo Runtime

Cada recurso que o Substrate oferece pode ser usado como estÃ¡, estendido, personalizado ou substituÃ­do para atender aos requisitos especÃ­ficos do caso de uso da rede.

Substrate agiliza e acelera o processo de desenvolvimento de novas redes. Quando usado em conjunto com Tanssi, que ajuda a lidar com a infraestrutura e supervisionar a implantaÃ§Ã£o, a tarefa de lanÃ§ar uma nova rede se torna significativamente mais simples!

## Linguagem de ProgramaÃ§Ã£o Rust {: #rust-programming-language}

[Rust](https://rust-lang.org/){target=\_blank} Ã© uma linguagem de programaÃ§Ã£o com recursos que os desenvolvedores classificam consistentemente em pesquisas como a [pesquisa anual de desenvolvedores do Stack Overflow](https://survey.stackoverflow.co/){target=\_blank}.

AlÃ©m de fornecer uma Ã³tima experiÃªncia para os desenvolvedores, o Rust se destaca em muitas Ã¡reas:

- **SeguranÃ§a da memÃ³ria** - O compilador Rust impÃµe verificaÃ§Ãµes estritas em tempo de compilaÃ§Ã£o para evitar erros de programaÃ§Ã£o comuns, como desreferÃªncias de ponteiros nulos, estouros de buffer e condiÃ§Ãµes de corrida de dados. AlÃ©m disso, a memÃ³ria Ã© gerenciada por meio de um novo sistema de propriedade (verificado pelo compilador), que elimina a necessidade de um coletor de lixo

- **Desempenho** - Rust atinge um desempenho comparÃ¡vel ao de C e C++, fornecendo controle de baixo nÃ­vel sobre os recursos do sistema e minimizando a sobrecarga de Runtime. Ele tem um princÃ­pio de abstraÃ§Ã£o de custo zero, semelhante a "o que vocÃª nÃ£o usa, vocÃª nÃ£o paga" de C++, o que significa que as abstraÃ§Ãµes nÃ£o tÃªm sobrecarga extra

- **ConcorrÃªncia** - Rust possui recursos integrados que facilitam a escrita de cÃ³digo concorrente e paralelo sem introduzir condiÃ§Ãµes de corrida de dados. Ele fornece threads leves (tarefas) e um Template de propriedade poderoso que garante o compartilhamento seguro de dados entre threads

- **AbstraÃ§Ãµes expressivas e seguras** - Rust oferece um rico conjunto de recursos de linguagem modernos, como correspondÃªncia de padrÃµes, tipos de dados algÃ©bricos, closures e inferÃªncia de tipos, permitindo que os desenvolvedores escrevam e leiam cÃ³digo expressivo e conciso. O compilador Rust impÃµe o forte sistema de tipos, evitando muitos erros em Runtime em tempo de compilaÃ§Ã£o

- **Compatibilidade entre plataformas** - Rust foi projetado para funcionar bem em uma variedade de plataformas e arquiteturas. Ele suporta os principais sistemas operacionais como Windows, macOS e Linux, bem como sistemas embarcados e WebAssembly. Essa versatilidade permite que os desenvolvedores escrevam cÃ³digo que pode ser implantado em diferentes ambientes

- **Ecossistema em crescimento** - Rust tem um ecossistema em rÃ¡pido crescimento com uma comunidade vibrante e uma rica coleÃ§Ã£o de bibliotecas e ferramentas. O gerenciador de pacotes oficial, Cargo, simplifica o gerenciamento de dependÃªncias, construÃ§Ã£o e teste

- **Interoperabilidade** - Rust fornece interoperabilidade perfeita com bases de cÃ³digo existentes escritas em C e C++. Ele tem uma Interface de FunÃ§Ã£o Estrangeira (FFI) que permite que o cÃ³digo Rust se interface com o cÃ³digo escrito em outras linguagens, permitindo que os desenvolvedores introduzam gradualmente Rust em projetos existentes, como o kernel Linux
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/framework/xcm/
--- BEGIN CONTENT ---
---
title: ComunicaÃ§Ã£o Nativa Cross-Chain
description: Tanssi networks benefit from XCM, a native cross-chain communication language, which allows fast and secure bridging guaranteed by Polkadot's relay chain.
categories: Basics
---

# ComunicaÃ§Ã£o Nativa Cross-Chain

## IntroduÃ§Ã£o {: #introduction }

Todas as redes Powered by Tanssi tÃªm uma capacidade inerente de se comunicar e interagir com qualquer outra rede no ecossistema. Esse recurso de comunicaÃ§Ã£o cross-chain nativo Ã© possÃ­vel graÃ§as Ã  infraestrutura exclusiva sobre a qual as redes sÃ£o construÃ­das, alavancando o formato de Mensagem Cross-Consensus (XCM para abreviar), que facilita a comunicaÃ§Ã£o entre diferentes sistemas de consenso.

XCM Ã© uma linguagem de mensagens projetada para ser genÃ©rica. Ela nÃ£o faz nenhuma suposiÃ§Ã£o sobre a cadeia de destino e pode comunicar diferentes intenÃ§Ãµes entre sistemas de consenso soberanos.

A mensagem XCM Ã© um programa que contÃ©m uma ou mais instruÃ§Ãµes que serÃ£o retransmitidas para execuÃ§Ã£o na cadeia de destino. Por si sÃ³, cada instruÃ§Ã£o XCM Ã© sem sentido, mas a combinaÃ§Ã£o de um conjunto especÃ­fico de instruÃ§Ãµes pode resultar em uma aÃ§Ã£o desejada quando a mensagem XCM Ã© executada na cadeia de destino.

Neste artigo, abordamos os conceitos bÃ¡sicos do mecanismo de comunicaÃ§Ã£o cross-chain nativo que permite pontes rÃ¡pidas e seguras dentro do ecossistema.

## PrincÃ­pios de Design {: #design-principles }

Concebido com uma mentalidade abstrata, o XCM nÃ£o foi projetado para estar em conformidade com um caso de uso especÃ­fico ou configuraÃ§Ã£o de rede de destino especÃ­fica, minimizando assim o efeito de acoplamento. Seus princÃ­pios bÃ¡sicos de design sÃ£o:

- **AssÃ­ncrono** - semelhante ao envio de um cartÃ£o postal - mas muito mais rÃ¡pido - o remetente continuarÃ¡ a realizar suas tarefas como de costume, sem se bloquear ou aguardar uma resposta do destino
- **Absoluto** - as mensagens tÃªm garantia de serem entregues ao destino pretendido, em ordem e em tempo hÃ¡bil
- **AssimÃ©trico** - as mensagens enviadas nÃ£o tÃªm contrapartida de resposta. Quaisquer valores de retorno, se necessÃ¡rios, devem ser enviados de volta do destino para o remetente com outra mensagem
- **AgnÃ³stico** - nÃ£o hÃ¡ qualquer suposiÃ§Ã£o sobre a configuraÃ§Ã£o ou propriedades de duas redes de comunicaÃ§Ã£o. As redes podem diferir em todos os aspectos, exceto na capacidade de entender o XCM. Por exemplo, uma cadeia pode ser compatÃ­vel com EVM e a outra nÃ£o, uma cadeia pode ser uma rede DeFi e a outra uma rede de jogos, e assim por diante.

## Taxas {: #fees }

Um usuÃ¡rio que executa uma transaÃ§Ã£o em uma rede deve pagar as taxas derivadas do esforÃ§o computacional associado Ã  tarefa, e a execuÃ§Ã£o cross-chain nÃ£o Ã© exceÃ§Ã£o a essa regra. Na comunicaÃ§Ã£o cross-chain, uma mensagem requer execuÃ§Ã£o em pelo menos duas cadeias diferentes, e o usuÃ¡rio precisa pagar as taxas associadas ao esforÃ§o computacional feito por cada cadeia envolvida. AlÃ©m dos custos relacionados Ã  execuÃ§Ã£o, as redes Tanssi incluem uma [taxa de entrega](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_common/xcm_sender/struct.ExponentialPrice.html){target=\_blank} padrÃ£o para evitar spam XCM.

Por exemplo, se um usuÃ¡rio na rede A deseja chamar um contrato inteligente na rede B, o usuÃ¡rio deve ter fundos suficientes para pagar a entrega da mensagem e incluir instruÃ§Ãµes na mensagem XCM para fornecer um ativo que a rede B aceite como pagamento por seus serviÃ§os para cobrir as taxas associadas. Uma vez que esse ativo Ã© fornecido, a execuÃ§Ã£o agora pode ser comprada na cadeia de destino.

!!! note
Como as redes sÃ£o soberanas, elas decidem quais tokens sÃ£o vÃ¡lidos para pagar suas taxas de execuÃ§Ã£o XCM.
Por exemplo, se a rede B aceitar tokens da rede A para pagamentos de taxas, qualquer usuÃ¡rio na rede A pode pagar por uma mensagem XCM destinada Ã  rede B usando apenas tokens da rede A.

## Casos de Uso Comuns {: #common-use-cases }

Muitos casos de uso podem ser abordados, beneficiando-se do terreno comum e da versatilidade que o XCM oferece. Dois dos mais recorrentes sÃ£o transferÃªncias de ativos e execuÃ§Ã£o remota.

### TransferÃªncias de Ativos {: #asset-transfer }

Mover ativos digitais de uma rede para outra Ã© essencial para criar um ecossistema blockchain mais dinÃ¢mico, eficiente e interconectado. O recurso cross-chain nativo permite duas estratÃ©gias principais para transferir ativos de uma cadeia para outra:

- **Teleporte** - teletransportar um ativo Ã© um mecanismo simples e eficiente, mas tem uma grande ressalva: requer confianÃ§a entre as partes. Essencialmente, quando a rede A deseja enviar X quantidade de ativos para a rede B, ela queima X quantidade de ativos e envia uma mensagem para a rede B instruindo-a a cunhar exatamente X quantidade de ativos, preservando o saldo geral de ativos e concluindo a aÃ§Ã£o de teletransporte. Nesse processo, a rede A confia na rede B para nÃ£o cunhar mais tokens do que o transferido, e a rede B confia na rede A para queimar os tokens que foram transferidos
- **TransferÃªncia de reserva** - Uma transferÃªncia de reserva envolve a **cadeia de reserva** de um ativo, que Ã© a cadeia onde o ativo Ã© nativo (por exemplo, [Moonbeam](https://moonbeam.network/){target=\_blank} Ã© a cadeia de reserva para o token GLMR). AlÃ©m disso, as redes nÃ£o reservadas mantÃªm uma *conta soberana* na cadeia de reserva, uma conta sem chave gerenciada pelo respectivo governador da rede. Assim, quando a rede de reserva A deseja enviar X quantidade de um ativo para a rede nÃ£o reservada B, ela transfere localmente os ativos para a conta soberana da rede B e, na mesma aÃ§Ã£o atÃ´mica, envia uma mensagem XCM para a rede B com instruÃ§Ãµes para cunhar X quantidade de uma forma derivada do ativo transferido. Por outro lado, se a rede nÃ£o reservada B deseja enviar X quantidade de um ativo para a rede de reserva A, as etapas sÃ£o: a rede B queima a forma derivada do ativo localmente e envia uma mensagem XCM para a rede A, com instruÃ§Ãµes para transferir os ativos da conta soberana da rede B para a conta de destino da rede A. Mesmo que a rede nÃ£o reservada cunhe tokens derivados em excesso (ou nÃ£o queime tokens ao transferir), esses tokens nÃ£o terÃ£o valor real porque nÃ£o sÃ£o apoiados um a um na cadeia de reserva

As taxas associadas Ã  execuÃ§Ã£o de transferÃªncias sÃ£o tipicamente deduzidas do valor transferido, para que o destinatÃ¡rio receba a quantia pretendida menos as taxas.

### ExecuÃ§Ã£o Remota {: #remote-execution }

A interoperabilidade nativa que o XCM fornece permite que uma rede envie uma mensagem a outra, acionando alguma aÃ§Ã£o. Por exemplo, se a cadeia de destino for compatÃ­vel com EVM, a rede A poderÃ¡ chamar um contrato inteligente implantado na rede B.

Conforme mencionado na [seÃ§Ã£o de taxas](#fees), para que qualquer solicitaÃ§Ã£o na cadeia seja executada, Ã© necessÃ¡rio cobrir suas taxas associadas. No XCM, a execuÃ§Ã£o remota pode ser comprada com duas etapas:

1. Reservar alguns ativos usando a instruÃ§Ã£o `WithdrawAsset` XCM, que retira fundos da origem da chamada e os coloca em um registro de retenÃ§Ã£o
2. Pagar pela execuÃ§Ã£o na cadeia, usando a instruÃ§Ã£o `BuyExecution` XCM, que usa os ativos previamente retirados

!!! note
    Quando uma rede envia uma mensagem XCM, sua fonte padrÃ£o no lado receptor Ã© a conta soberana da rede de origem. A rede remetente pode adicionar uma instruÃ§Ã£o XCM chamada `DescendOrigin` Ã  mensagem, alterando a conta de origem para corresponder Ã  conta do usuÃ¡rio que assina, garantindo que a execuÃ§Ã£o ocorra em nome da mesma entidade que inicia a mensagem XCM na cadeia de origem e evitando um cenÃ¡rio potencialmente inseguro.

Finalmente, a execuÃ§Ã£o ocorre na cadeia de destino, chamando um contrato inteligente ou qualquer outra transaÃ§Ã£o usando a instruÃ§Ã£o XCM chamada `Transact`.

O fluxo geral para execuÃ§Ã£o remota Ã© representado no seguinte diagrama:

![Fluxo de ExecuÃ§Ã£o Remota](/images/learn/framework/xcm/xcm-1.webp)

## Estabelecendo ComunicaÃ§Ã£o Cross-Chain {: #channel-registration }

Antes que duas cadeias possam se comunicar, um canal de mensagens deve ser estabelecido. Os canais sÃ£o unidirecionais, o que significa que canais separados sÃ£o necessÃ¡rios para enviar mensagens da cadeia A para a cadeia B e da B para a A.

Para que a cadeia A se comunique com a cadeia B, a cadeia A deve enviar uma transaÃ§Ã£o de canal aberto para a cadeia de retransmissÃ£o solicitando que um canal seja aberto com a cadeia B. A cadeia B deve entÃ£o aceitar a solicitaÃ§Ã£o enviando uma mensagem XCM correspondente para a cadeia de retransmissÃ£o. Somente quando ambas as cadeias concordam Ã© que o canal Ã© aberto na prÃ³xima Ã©poca. O mesmo processo Ã© necessÃ¡rio para estabelecer um canal da cadeia B para a cadeia A.

Ã‰ importante notar que um canal entre uma rede e a cadeia de retransmissÃ£o Ã© aberto automaticamente mediante registro e integraÃ§Ã£o da rede.

![VisÃ£o geral do registro de canal XCM](/images/learn/framework/xcm/xcm-2.webp)

Depois que o canal Ã© estabelecido, as mensagens cross-chain podem ser enviadas entre as redes. Para transferÃªncias de ativos, os ativos tambÃ©m precisarÃ£o ser registrados antes de serem transferidos.

!!! note
    XCM Ã© uma linguagem versionada e em constante evoluÃ§Ã£o. Quando duas redes de comunicaÃ§Ã£o usam versÃµes diferentes do XCM, elas devem usar a versÃ£o mais recente com suporte do lado menos atualizado. Para descobrir a versÃ£o XCM mais recente com a qual uma rede pode trabalhar, outras redes podem consultÃ¡-la e assinar atualizaÃ§Ãµes sempre que isso mudar.

## Destinos de Mensagens {: #message-destinations }

Para compor mensagens significativas em um ambiente multichain, Ã© necessÃ¡rio ter uma maneira precisa e abstrata de referenciar recursos localizados em diferentes sistemas de consenso. Um conceito chamado *multilocalizaÃ§Ã£o* Ã© usado para servir a esse propÃ³sito e direcionar uma cadeia especÃ­fica ou qualquer um de seus elementos internos, como uma conta, um ativo ou um contrato inteligente.

Os elementos de destino do XCM sÃ£o organizados em uma arquitetura hierÃ¡rquica, onde os elementos estÃ£o contidos em outros componentes. Por exemplo, um contrato inteligente Ã© um elemento contido em uma rede, e o mesmo pode ser dito para uma conta ou um ativo ERC20. As redes estÃ£o contidas pela cadeia de retransmissÃ£o, que desempenha um papel crucial no processo de mensagens cross-chain, retransmitindo mensagens de uma rede para outra.

MultilocalizaÃ§Ãµes nÃ£o sÃ£o um localizador de recursos universal. Eles se referem a elementos da perspectiva do remetente e sÃ£o compostos por dois componentes: `pais` e `interior`. Pais Ã© uma propriedade que indica se a rota deve "subir" na hierarquia, ou seja, de uma rede para a cadeia de retransmissÃ£o. Interior Ã© uma lista de junÃ§Ãµes que definem como localizar o destino. Aqui estÃ£o alguns exemplos de multilocalizaÃ§Ãµes:

- **Rede A referencia um contrato inteligente na rede B** - do ponto de vista da rede A, para alcanÃ§ar um contrato inteligente na rede B, Ã© necessÃ¡rio subir na hierarquia (para a cadeia de retransmissÃ£o) e, em seguida, descer para a rede B para, uma vez lÃ¡, referenciar o endereÃ§o do contrato inteligente. A multilocaÃ§Ã£o Ã©, portanto, definida com um valor de `pais` definido como `1`, que sobe, e duas junÃ§Ãµes, uma que define qual rede deve receber a mensagem e a outra que define o endereÃ§o H160 do contrato inteligente que serÃ¡ chamado

![Exemplo de MultilocalizaÃ§Ã£o de Contrato Inteligente](/images/learn/framework/xcm/xcm-3.webp)

- **Rede A referencia uma conta na cadeia de retransmissÃ£o** - do ponto de vista da rede A, para referenciar uma conta na cadeia de retransmissÃ£o, Ã© necessÃ¡rio subir e, em seguida, referenciar a conta. A multilocaÃ§Ã£o Ã© definida com um valor de `pais` definido como `1`, que sobe para a cadeia de retransmissÃ£o, e uma junÃ§Ã£o que referencia o endereÃ§o de destino do tipo substrato

![Exemplo de MultilocalizaÃ§Ã£o de Conta](/images/learn/framework/xcm/xcm-4.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/
--- BEGIN CONTENT ---
---
title: Aprenda
description: ConheÃ§a o protocolo Tanssi e como ele ajuda os desenvolvedores a construir e implantar redes, lidando com as complexidades de infraestrutura e fornecendo integraÃ§Ãµes essenciais.
template: root-index-page.html
---

# Aprenda

LanÃ§ar uma rede descentralizada tem sido tradicionalmente um processo desafiador e demorado, exigindo experiÃªncia em infraestrutura, seguranÃ§a e configuraÃ§Ã£o operacional. Tanssi simplifica essa jornada, removendo as complexidades e tornando a implantaÃ§Ã£o de rede rÃ¡pida e acessÃ­vel.

Esta seÃ§Ã£o explora os elementos centrais que definem Tanssi como uma soluÃ§Ã£o lÃ­der para o desenvolvimento de redes. Se vocÃª estÃ¡ comeÃ§ando sua jornada em redes descentralizadas ou aprofundando sua compreensÃ£o das capacidades Ãºnicas da Tanssi, estes documentos fornecem tudo que vocÃª precisa para entender como o Tanssi estabelece um novo padrÃ£o para a infraestrutura de rede.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::

## Comece a Construir Agora

Comece sua jornada Tanssi aqui se vocÃª preferir aprender fazendo.

<div class="subsection-wrapper">
  <div class="card">
    <a href="/builders/build/">
      <div class="card-header">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z"></path></svg>
        <h2 class="title">Construa Sua Rede</h2>
      </div>
      <p class="description">Aprenda a projetar e personalizar sua rede com Templates e ferramentas prontos para uso, adaptados Ã s suas necessidades tÃ©cnicas.</p>
    </a>
  </div>
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/account-types/
--- BEGIN CONTENT ---
---
title: Contas no Protocolo Tanssi
description: VisÃ£o geral das chaves criptogrÃ¡ficas essenciais para o protocolo Tanssi, detalhando os tipos de contas usados e suas funÃ§Ãµes gerais.
icon: octicons-key-24
categories: Basics
---

# Contas no Protocolo Tanssi

## IntroduÃ§Ã£o {: #introduction }

A tecnologia blockchain baseia-se na criptografia de chaves [pÃºblico-privadas](https://en.wikipedia.org/wiki/Public-key_cryptography){target=\_blank} para propriedade segura de ativos e verificaÃ§Ã£o de transaÃ§Ãµes. Chaves privadas autorizam transaÃ§Ãµes, enquanto chaves pÃºblicas servem como endereÃ§os para verificaÃ§Ã£o. Devido Ã  natureza hÃ­brida [Substrate](/pt/learn/framework/overview/#substrate-framework){target=\_blank} e Ethereum do protocolo Tanssi, entender os diferentes tipos de conta Ã© crucial para usuÃ¡rios e operators.

## Tipos de Conta no Protocolo Tanssi {: #key-types-in-tanssi-protocol }

| **Tipo de Conta** | **Algoritmo Subjacente** | **Uso Principal na Tanssi** |
| --- | --- | --- |
| [Sr25519](https://wiki.polkadot.com/learn/learn-cryptography/){target=\_blank} | Assinaturas Schnorr no grupo Ristretto | Esquema padrÃ£o de assinatura para transaÃ§Ãµes baseadas em Substrate e identidade de operator. |
| [Ed25519](https://wiki.polkadot.com/learn/learn-cryptography/){target=\_blank} | EdDSA usando Curve25519 | Usado para funÃ§Ãµes especÃ­ficas de consenso (ex.: produÃ§Ã£o de blocos, finalidade) no Substrate. |
| [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm){target=\_blank} | Algoritmo de Assinatura Digital de Curva ElÃ­ptica | Recebimento de recompensas via protocolo Symbiotic baseado em Ethereum para operators. |

## Identidade e OperaÃ§Ãµes {: #identity-and-operations }

A Tanssi, construÃ­da com o framework Substrate, utiliza esquemas criptogrÃ¡ficos distintos para funÃ§Ãµes diferentes, principalmente _Sr25519_ e _Ed25519_. Esses tipos de conta sÃ£o essenciais para interagir com os componentes Substrate do protocolo, assinando transaÃ§Ãµes.

**Sr25519 (Schnorrkel/Ristretto x25519)** â€“ Ã© o tipo de conta principal usado na maioria das operaÃ§Ãµes voltadas ao usuÃ¡rio dentro da Tanssi. Seus pontos fortes sÃ£o seguranÃ§a e eficiÃªncia. **Contas Sr25519 servem como sua identidade on-chain, usadas para manter tokens, participar de governanÃ§a, pagar taxas de transaÃ§Ã£o e outras interaÃ§Ãµes gerais com a rede.**

**Ed25519 (Algoritmo de Assinatura Digital de Curva Edwards)** â€“ enquanto Sr25519 cuida da identidade e transaÃ§Ãµes gerais, Ed25519 Ã© usado por seu alto desempenho em assinatura criptogrÃ¡fica, ideal para operaÃ§Ãµes de consenso. **Na Tanssi, contas Ed25519 sÃ£o usadas por node operators para mecanismos crÃ­ticos, como produÃ§Ã£o de blocos e finalidade.** UsuÃ¡rios comuns normalmente nÃ£o criam ou usam diretamente contas Ed25519, mas elas sÃ£o fundamentais para a seguranÃ§a e operaÃ§Ã£o da rede.

Operators de nÃ³ na Tanssi precisam de uma conta Substrate para registrar suas atividades, incluindo validadores que protegem a rede e Sequencers que produzem blocos. Esta conta tambÃ©m rastreia recompensas, com chaves de sessÃ£o mapeadas para ela para maior seguranÃ§a.

## SeguranÃ§a e Recompensas no Ethereum {: #security-and-rewards-on-ethereum }

O Algoritmo de Assinatura Digital de Curva ElÃ­ptica (ECDSA) Ã© fundamental para o Ethereum e Ã© usado pela Tanssi para integrar-se Ã  rede Ethereum via Symbiotic. Essa parceria alavanca a seguranÃ§a do Ethereum para redes powered by Tanssi.

Operators Tanssi precisam de uma conta ECDSA para receber recompensas distribuÃ­das no Ethereum, geralmente via protocolo Symbiotic. A necessidade de contas Substrate e ECDSA destaca o design hÃ­brido da Tanssi, em que as operaÃ§Ãµes sÃ£o baseadas em Substrate, e a seguranÃ§a e as recompensas estÃ£o vinculadas ao Ethereum.

## Mapeamentos de Conta na Tanssi {: #account-mappings-in-tanssi }

### VinculaÃ§Ã£o Interna de Chaves (_Sr25519_ e _Ed25519_)

Dentro do protocolo Substrate da Tanssi, a identidade _Sr25519_ primÃ¡ria de um operator se vincula a chaves _Ed25519_ especÃ­ficas usadas para tarefas de consenso (como produÃ§Ã£o de blocos). Os operators criam essa vinculaÃ§Ã£o com uma transaÃ§Ã£o on-chain, mapeando suas chaves pÃºblicas internas (â€œchaves de sessÃ£oâ€) para a conta de stash. Esse registro on-chain garante que a rede atribua corretamente todas as aÃ§Ãµes das chaves de sessÃ£o Ã  identidade primÃ¡ria do operator.

### Mapeamento de Recompensas entre Ecossistemas (_Sr25519_ e _ECDSA_)

Para recompensas no Ethereum (por exemplo, via [Symbiotic](/pt/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}), a identidade _Sr25519_ do operator Ã© mapeada para um endereÃ§o _ECDSA_ no Ethereum. As duas contas sÃ£o vinculadas pelo middleware da Tanssi, garantindo que as recompensas do trabalho do operator na rede Tanssi sejam roteadas para a conta Ethereum designada.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/external-security-providers/
--- BEGIN CONTENT ---
---
title: Provedores de SeguranÃ§a Externos
description: Aprenda sobre o design da Tanssi, que permite que os desenvolvedores se conectem a provedores de seguranÃ§a externos e se beneficiem da seguranÃ§a em nÃ­vel Ethereum desde o inÃ­cio.
icon: octicons-shield-check-24
template: index-page.html
---

# Provedores de SeguranÃ§a Externos

A Tanssi integra provedores de seguranÃ§a externos para fortalecer a flexibilidade e resiliÃªncia de seu ecossistema. Ao adotar Templates de seguranÃ§a descentralizados, esses provedores oferecem soluÃ§Ãµes personalizadas que atendem Ã s diversas necessidades operacionais, garantindo maiores nÃ­veis de seguranÃ§a e confianÃ§a em todas as redes.

Essa abordagem aborda desafios comuns que os desenvolvedores enfrentam, como garantir recursos econÃ´micos significativos ou negociar com operators para manter os nÃ³s. Por meio da estrutura de seguranÃ§a colaborativa da Tanssi, os desenvolvedores podem contornar esses obstÃ¡culos e se concentrar na inovaÃ§Ã£o, aproveitando uma infraestrutura segura e escalÃ¡vel para otimizar a implantaÃ§Ã£o de redes.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/external-security-providers/symbiotic/
--- BEGIN CONTENT ---
---
title: Symbiotic como Provedor Externo de SeguranÃ§a
description: O design da Tanssi permite conectar ao protocolo de reâ€‘staking Symbiotic, aproveitando seguranÃ§a em nÃ­vel de Ethereum desde o inÃ­cio.
icon: octicons-shield-check-24
categories: Basics
---

# Ethereum com Symbiotic {: #ethereum-symbiotic }

## IntroduÃ§Ã£o {: #introduction }

O protocolo Tanssi cuida de componentes crÃ­ticos de infraestrutura, facilitando que desenvolvedores lancem suas redes em poucos minutos. AlÃ©m da produÃ§Ã£o de blocos, recuperabilidade de dados e integraÃ§Ãµes com ferramentas essenciais como carteiras, endpoints RPC, exploradores de blocos e outras, outro grande desafio Ã© fornecer seguranÃ§a para a rede.

O Tanssi foi criado para oferecer aos desenvolvedores um Template de seguranÃ§a compartilhada, evitando que eles tenham de buscar seguranÃ§a econÃ´mica suficiente ou negociar com operators para rodar nÃ³s que faÃ§am opt-in para suas redes. Ao implantar redes por meio da Tanssi e escolher o [Symbiotic](https://symbiotic.fi/){target=\_blank} como provedor de seguranÃ§a, os desenvolvedores se beneficiam de seguranÃ§a em nÃ­vel de Ethereum, aproveitando bilhÃµes de dÃ³lares em seguranÃ§a compartilhada de ETH em stake.

As seÃ§Ãµes a seguir descrevem como funciona o protocolo Symbiotic e como as redes Tanssi podem aproveitÃ¡-lo como mecanismo de consenso.

## SeguranÃ§a em NÃ­vel de Ethereum com Symbiotic {: #symbiotic }

O [Symbiotic](https://symbiotic.fi/){target=\_blank} Ã© um protocolo de seguranÃ§a compartilhada projetado para ser permissionless, multi-ativo e agnÃ³stico Ã  rede. Ele promove eficiÃªncia de capital ao permitir que usuÃ¡rios estendam a funcionalidade de seus ativos em stake para proteger outras redes, oferecendo utilidade adicional.

O protocolo fornece uma camada de coordenaÃ§Ã£o para seus principais componentes e participantes, alinhando incentivos entre as partes enquanto minimiza riscos na camada de execuÃ§Ã£o ao implantar contratos centrais nÃ£o atualizÃ¡veis no Ethereum. O diagrama a seguir resume todos os componentes e atores que participam do protocolo:

```mermaid
flowchart TD
    %% Vaults subgraph
    subgraph Ethereum["Ethereum/Symbiotic"]
        slash[/Eventos de Slashing/]
        Restakers -- Depositar Ativos --> Vaults
        manager["Gerentes de Vaults"] -- Administram --> Vaults
        Resolvers -- Decidem Sobre --> slash
        slash -- Executa Em --> Vaults
    end

    %% Operators subgraph
    subgraph Operators
        direction BT
        operators["Operators (Validadores)"]
        node_operators["Operators de NÃ³s"]
        node_operators -- Operam --> operators
    end

    %% Networks subgraph
    subgraph Networks
        direction BT
        developers["Desenvolvedores"]
        networks["Redes Descentralizadas"]
        developers -- LanÃ§am --> networks
    end

    Vaults <--> Tanssi
    Tanssi <--> Operators
    Tanssi <--> Networks
```

O design flexÃ­vel do Symbiotic permite que cada parte decida configuraÃ§Ãµes que melhor atendam seus casos de uso. Por exemplo, os vaults podem escolher quais tipos de colateral aceitam, os operators podem determinar para quais redes querem prestar serviÃ§os e as redes descentralizadas podem personalizar seu caso de uso e definir o nÃ­vel de seguranÃ§a (quais colaterais sÃ£o aceitos, por exemplo) de que precisam.

As seÃ§Ãµes a seguir descrevem os principais componentes do protocolo.

### Vaults {: #vaults }

Os [Vaults](https://docs.symbiotic.fi/modules/vault/introduction){target=\_blank} sÃ£o o alicerce econÃ´mico do protocolo Symbiotic. Eles gerenciam liquidez e depÃ³sitos de restakers, conectam operators e redes e definem estratÃ©gias de delegaÃ§Ã£o.

Cada vault estÃ¡ vinculado a um token especÃ­fico que atende Ã  interface [ERC20](https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md){target=\_blank} e Ã© aceito como colateral. Internamente, os fundos dentro do vault sÃ£o representados como shares, o que fornece um mecanismo para rastrear propriedade e distribuir recompensas. No entanto, o token de recompensa pode ser diferente do token de colateral.

Um vault Ã© composto por trÃªs mÃ³dulos principais, cada um com uma funÃ§Ã£o distinta: o slasher, o delegator e o mÃ³dulo de contabilidade. A implementaÃ§Ã£o desses mÃ³dulos pode variar dependendo das decisÃµes do gerente do vault.

- **MÃ³dulo Slasher** - implementa a lÃ³gica de [slashing](#slashing-process), que penaliza maus atores
- **MÃ³dulo Delegator** - define como os fundos sÃ£o delegados entre operators e redes. Diversas [estratÃ©gias](https://docs.symbiotic.fi/modules/vault/delegator){target=\_blank} estÃ£o disponÃ­veis, permitindo ao gerente do vault selecionar quais operators e redes deseja atender
- **MÃ³dulo de Contabilidade** - lida com as operaÃ§Ãµes financeiras do vault, incluindo processar depÃ³sitos de usuÃ¡rios, gerenciar pedidos de saque, rastrear saldos ativos e oferta total, e implementar contabilidade baseada em Ã©pocas para saques e eventos de slashing. A implementaÃ§Ã£o padrÃ£o do mÃ³dulo de contabilidade Ã© o [ERC-4626](https://ethereum.org/developers/docs/standards/tokens/erc-4626/){target=\_blank}, que oferece um sistema de shares embutido

Como os operators recebem stake delegado do vault e podem ser alvo de slashing, eles devem ser aprovados previamente pelos gerentes de vault. Da mesma forma, os gerentes de vault analisam e autorizam cada rede que o vault protegerÃ¡, considerando, por exemplo, as recompensas que a rede oferece.

Os gerentes de vault tambÃ©m designam [resolvers](https://docs.symbiotic.fi/modules/counterparties/resolvers){target=\_blank}, responsÃ¡veis por aprovar ou vetar [eventos de slashing](https://docs.symbiotic.fi/modules/vault/slasher){target=\_blank} causados por operators em redes com suporte a [veto-slashing](https://docs.symbiotic.fi/modules/vault/slasher#veto-slashing){target=\_blank}, como a Tanssi Network.

### Operators {: #operators }

Os [node operators](/pt/node-operators/){target=\_blank} sÃ£o entidades ou indivÃ­duos responsÃ¡veis por executar os [nÃ³s (tambÃ©m conhecidos como operators ou validadores)](https://docs.symbiotic.fi/modules/counterparties/operators){target=\_blank}, que sÃ£o os componentes computacionais que validam as transaÃ§Ãµes das redes. Eles sÃ£o responsÃ¡veis pela configuraÃ§Ã£o dos nÃ³s, setup de hardware, disponibilidade e desempenho.

Os node operators fazem opt-in para prestar serviÃ§os a redes, que precisam aceitar sua solicitaÃ§Ã£o. Eles tambÃ©m fazem opt-in para prestar serviÃ§os em vaults, que igualmente precisam aceitar seu pedido.

Depois que um operator Ã© aceito por um vault e por uma rede conectada a esse vault, o nÃ³ pode comeÃ§ar a fornecer serviÃ§os de validaÃ§Ã£o para essa rede, recebendo recompensas em troca.

### Redes {: #networks }

As [Redes](https://docs.symbiotic.fi/modules/counterparties/networks){target=\_blank} sÃ£o os serviÃ§os ou redes ativamente validados. Essas blockchains especÃ­ficas de aplicaÃ§Ã£o podem ser de uma ampla gama de setores, como Gaming, DeFi, RWAs e outros, e sÃ£o as plataformas com as quais, por meio de dApps, os usuÃ¡rios finais interagem.

Como os operators fazem opt-in para prestar serviÃ§os Ã s redes e os gerentes de vault precisam aceitar as redes, os desenvolvedores sÃ£o responsÃ¡veis por definir, controlar e adaptar sua metodologia para onboarding, recompensa e slashing de operators.

!!! note
    As redes implantadas por meio da Tanssi nÃ£o precisam trabalhar o relacionamento com vaults e operators, pois o protocolo Tanssi lida com essas complexidades.

## Tanssi com Symbiotic {: #tanssi-symbiotic }

Desenvolvedores que lanÃ§am redes por meio da Tanssi se beneficiam dos [serviÃ§os de produÃ§Ã£o de blocos](/pt/learn/tanssi/network-services/block-production/){target=\_blank}, recuperabilidade de dados como serviÃ§o e do Template de seguranÃ§a compartilhada derivado de todos os vaults que fazem opt-in para suportar o protocolo Tanssi. Isso elimina o obstÃ¡culo de lidar com componentes de infraestrutura e seguranÃ§a que, de outra forma, os desenvolvedores precisariam assumir.

Gerentes de vaults podem se candidatar a oferecer os colaterais em restaking como seguranÃ§a econÃ´mica para a Tanssi Network. Como as redes Tanssi rodam em um ambiente semelhante a um sandbox, e o protocolo Tanssi gerencia todas as responsabilidades relacionadas Ã s redes, os gerentes de vaults sÃ³ precisam analisar e fazer opt-in para o protocolo Tanssi, independentemente da qualidade e quantidade de redes que estejam rodando pelo protocolo Tanssi em qualquer momento.

Operators que fazem opt-in para prestar serviÃ§os ao protocolo Tanssi (desde que participem de um vault que suporta o protocolo Tanssi) tÃªm a vantagem de rodar o mesmo setup para fornecer serviÃ§os de produÃ§Ã£o de blocos e validaÃ§Ã£o para a Tanssi Network e, consequentemente, para todas as redes implantadas via Tanssi. Essa arquitetura Ãºnica facilita todas as tarefas relacionadas a executar e manter os operators, jÃ¡ que nÃ£o hÃ¡ mudanÃ§as no setup quando uma nova rede Tanssi Ã© lanÃ§ada ou desativada.

!!! note
    O protocolo Tanssi efetivamente abstrai os detalhes do conjunto ativo de redes para longe dos gerentes de vaults e operators. Particularidades das redes nÃ£o exigem qualquer configuraÃ§Ã£o adicional dos operators nem representam riscos aos ativos do vault.

Tudo isso forma um ecossistema funcional e elegante no qual os desenvolvedores podem se concentrar em criar e inovar. O Tanssi cuida dos componentes de infraestrutura, garantindo disponibilidade e desempenho, e o Symbiotic fornece os mecanismos econÃ´micos que asseguram a validade das operaÃ§Ãµes.

```mermaid
flowchart LR
    subgraph Symbiotic
        direction LR
        Operators
        Vaults
    end
    Symbiotic  -- Valida/Protege --> tanssi["Tanssi Network"]
    tanssi -- ServiÃ§os de ProduÃ§Ã£o de Blocos--> Networks
    tanssi -- SeguranÃ§a--> Networks
    tanssi -- RecuperaÃ§Ã£o de Dados--> Networks

    class Symbiotic custom-container
```

### ComunicaÃ§Ã£o Tanssi-Ethereum {: #tanssi-ethereum-communication }

Ã‰ importante entender como Tanssi e Ethereum trocam dados para compreender a mecÃ¢nica do protocolo. Eles se conectam por meio de uma bridge bidirecional que permite que se comuniquem entre si. Cada protocolo tem um papel especÃ­fico para viabilizar operaÃ§Ãµes cross-chain.

Existem trÃªs componentes-chave entre Symbiotic e Tanssi:

```mermaid
flowchart LR

Tanssi["Tanssi"] <--> Relayer 
Relayer <--> Gateway 
Gateway["Gateway"] <--> Middleware
Middleware <--> Symbiotic["Symbiotic"]

class Tanssi tanssiNode;

class Middleware middlewareNode;

class Gateway gatewayNode;

class Symbiotic symbioticNode;

class Relayer relayerNode;
```

- **`Relayer`** - Ã© o software que monitora continuamente ambas as blockchains e transmite mensagens. Ele habilita comunicaÃ§Ã£o bidirecional confiÃ¡vel entre Tanssi e Ethereum, servindo como a camada de conexÃ£o que garante que mensagens sejam entregues corretamente entre as redes

- **`Gateway`** - opera no lado Ethereum da bridge e cumpre trÃªs funÃ§Ãµes essenciais. Ele recebe, verifica e encaminha mensagens recebidas da Tanssi para garantir que sejam processadas corretamente. O contrato aceita mensagens de saÃ­da destinadas Ã  rede Tanssi, preparando-as para o relay. Por fim, lida com funcionalidades de aplicaÃ§Ã£o de nÃ­vel superior, principalmente transferÃªncias de tokens entre as duas redes, fornecendo uma interface segura para movimentaÃ§Ã£o de ativos entre cadeias

- **`Middleware`** - Ã© a implementaÃ§Ã£o da Tanssi para lidar com eventos e operaÃ§Ãµes da rede. Ele Ã© o elo crÃ­tico entre o `Gateway` e o protocolo central da Tanssi

O `Middleware` desempenha um papel central na coordenaÃ§Ã£o da rede entre Tanssi e Symbiotic. Ele distribui recompensas a operators e vaults com base em suas contribuiÃ§Ãµes para seguranÃ§a e desempenho da rede. O contrato ordena os operators por stake para criar um sistema de ranking meritocrÃ¡tico para sua seleÃ§Ã£o e transmite a lista de chaves de operators ordenadas Ã  Tanssi para atribuiÃ§Ã£o. AlÃ©m disso, facilita os processos de registro de operators e gerencia os protocolos de recompensa e slashing que mantÃªm o alinhamento de incentivos da rede.

#### De Ethereum para Tanssi {: #from-ethereum-tanssi }

O `Middleware` transmite informaÃ§Ãµes sobre o conjunto de operators para a Tanssi para atribuiÃ§Ã£o de sessÃµes por meio da bridge. Ele envia detalhes sobre operators ativos para cada Ã©poca, ordenando-os por seu stake total agregado em todos os vaults. O Tanssi entÃ£o usa essas informaÃ§Ãµes para atribuir operators para as prÃ³ximas sessÃµes, garantindo que os mais alinhados economicamente protejam a rede. Esse mecanismo cria um processo de seleÃ§Ã£o de operators ponderado por stake, em que a seguranÃ§a econÃ´mica no Ethereum se traduz em seguranÃ§a operacional na Tanssi.

#### De Tanssi para Ethereum {: #from-tanssi-ethereum }

O Tanssi envia dados operacionais de volta ao Ethereum atravÃ©s do mesmo canal de comunicaÃ§Ã£o. Essa mensagem inclui informaÃ§Ãµes de recompensa que permitem a distribuiÃ§Ã£o adequada aos stakeholders com base no desempenho da rede. A rede tambÃ©m transmite dados de eventos de slashing quando os operators falham em desempenhar corretamente ou violam regras do protocolo, permitindo que o protocolo aplique penalidades. O Tanssi tambÃ©m pode solicitar a criaÃ§Ã£o de novos tokens no Ethereum e registrar tokens, facilitando o gerenciamento de ativos entre as duas redes.

### Recompensas {: #rewards }

Operators e restakers bem-comportados sÃ£o recompensados por sua participaÃ§Ã£o com tokens TANSSI. O processo de recompensa consiste em duas fases principais: [Fase de DistribuiÃ§Ã£o de Recompensas](#reward-distribution-phase) e [Fase de ReivindicaÃ§Ã£o de Recompensas](#reward-claiming-phase).

#### Fase de DistribuiÃ§Ã£o de Recompensas {: #reward-distribution-phase }

A fase de distribuiÃ§Ã£o de recompensas calcula e aloca recompensas por meio de cinco etapas principais que envolvem operators, restakers e contratos inteligentes. As etapas sÃ£o:

1. **CÃ¡lculo de Recompensas** - o Tanssi calcula recompensas com base na atividade de operators e stakers e entÃ£o cria uma [raiz de Merkle](https://en.wikipedia.org/wiki/Merkle_tree){target=\_blank}. Essa raiz de Merkle Ã© uma impressÃ£o digital criptogrÃ¡fica que resume as alocaÃ§Ãµes de recompensas, indicando quem recebe o quÃª. Stakers sÃ£o recompensados de acordo com seu stake em cada vault
2. **Dados de Recompensa Enviados via XCM** - os dados de alocaÃ§Ã£o de recompensas sÃ£o enviados usando [XCM](https://wiki.polkadot.com/learn/learn-xcm/){target=\_blank} (Cross-Consensus Messaging), um protocolo padronizado para comunicaÃ§Ã£o entre blockchains. A [Snowbridge](https://docs.snowbridge.network/){target=\_blank} atua como uma bridge sem confianÃ§a entre Tanssi e Ethereum
3. **RecepÃ§Ã£o da Mensagem no Ethereum** - uma vez que a mensagem Ã© encaminhada para o contrato `Gateway`, esse contrato serve como ponto de entrada autorizado da Tanssi no Ethereum para a bridge Snowbridge
4. **Processamento e ValidaÃ§Ã£o da Mensagem** - o `Gateway` encaminha os dados para o [`Middleware`](https://github.com/moondance-labs/tanssi-symbiotic/blob/main/src/contracts/middleware/Middleware.sol){target=\_blank}, que Ã© responsÃ¡vel por vÃ¡rias tarefas, incluindo passar as informaÃ§Ãµes para o contrato `OperatorReward`
5. **Armazenamento e DistribuiÃ§Ã£o de Recompensas** - este Ã© o destino final dos dados. O contrato [`OperatorRewards`](https://github.com/moondance-labs/tanssi-symbiotic/blob/main/src/contracts/rewarder/ODefaultOperatorRewards.sol){target=\_blank} armazena a Ã¡rvore de Merkle das alocaÃ§Ãµes de recompensa e lida com a transferÃªncia de tokens de recompensa quando um claim Ã© feito

```mermaid
%%{init: {'sequence': {'mirrorActors': false}}}%%
sequenceDiagram
    participant Rede Tanssi
    participant Snowbridge (XCM)
    participant Gateway
    participant Middleware
    participant OperatorRewards

    Rede Tanssi->>Rede Tanssi: 1. Calcular recompensas e gerar raiz de Merkle
    Rede Tanssi->>Snowbridge (XCM): 2. Dados de recompensa enviados via XCM (raiz de Merkle + dados)
    Snowbridge (XCM)->>Gateway: 3. Repassar a mensagem e enviar ao Ethereum 
    Gateway ->>Middleware: 4. Processamento e validaÃ§Ã£o da mensagem
    Middleware->>OperatorRewards: 5. Armazenamento e distribuiÃ§Ã£o de recompensas
```

#### Fase de ReivindicaÃ§Ã£o de Recompensas {: #reward-claiming-phase }

Na fase de reivindicaÃ§Ã£o de recompensas, operators e stakers podem reivindicar recompensas com base em sua participaÃ§Ã£o na rede. O Tanssi determina a divisÃ£o para operators e stakers, atualmente fixada em 20% para operators e 80% para stakers.

1. **ReivindicaÃ§Ã£o de Recompensa pelo Operator** - operators podem reivindicar sua parcela chamando o contrato `OperatorRewards` usando um recibo criptogrÃ¡fico que comprova seu direito
2. **LiberaÃ§Ã£o de Tokens** - a chamada do operator aciona a liberaÃ§Ã£o de tokens, e o `OperatorRewards` envia o valor estabelecido ao operator
3. **DistribuiÃ§Ã£o de Tokens aos Stakers** - as recompensas restantes sÃ£o encaminhadas ao contrato `StakerRewards` para posterior reivindicaÃ§Ã£o dos stakers
4. **AlocaÃ§Ã£o dos Stakers** - os 80% restantes das recompensas sÃ£o direcionados automaticamente ao contrato [`StakerRewards`](https://github.com/moondance-labs/tanssi-symbiotic/blob/main/src/contracts/rewarder/ODefaultStakerRewards.sol){target=\_blank}, onde os stakers podem reivindicar recompensas proporcionais ao seu stake nos vaults

```mermaid
%%{init: {'sequence': {'mirrorActors': false}}}%%
sequenceDiagram
 participant Operator
 participant OperatorRewards
 participant StakerRewards
 participant Stakers

 Operator->>OperatorRewards: 1. ReivindicaÃ§Ã£o de recompensa pelo operator
 OperatorRewards->>Operator: 2. Liberar recompensas para o operator
 OperatorRewards->>StakerRewards: 3. Encaminhar o restante para o StakerRewards
 Stakers->>StakerRewards: 4. Stakers reivindicam recompensas individuais
```

### Slashing {: #slashing }

O protocolo Tanssi implementa slashing para penalizar operators por mau comportamento. Quando um evento de slashing Ã© acionado, as autoridades designadas como resolvers pelos gerentes de vault podem aceitar ou reverter essa aÃ§Ã£o.

As seguintes aÃ§Ãµes podem acionar eventos de slashing:

- ProduÃ§Ã£o de blocos invÃ¡lidos (por exemplo, blocos que incluem transaÃ§Ãµes invÃ¡lidas)
- ValidaÃ§Ã£o invÃ¡lida (por exemplo, dupla assinatura ou quebra das regras do protocolo)
- Tempo de inatividade ou indisponibilidade
- ViolaÃ§Ãµes de consenso

!!! note
    Eventos de slashing sÃ³ podem ser acionados por mau comportamento dos operators dentro da Tanssi Network. Mesmo que redes Tanssi sejam defeituosas ou maliciosas, elas operam em um ambiente isolado e nÃ£o podem causar slashing.

#### Processo de Slashing {: #slashing-process }

O processo de slashing segue um caminho semelhante ao das recompensas. Quando um operator se comporta mal, a Tanssi Network envia uma mensagem de solicitaÃ§Ã£o de slashing para a bridge sem confianÃ§a (Snowbridge). A mensagem passa pelo `Gateway` e chega ao `Middleware`, onde o mÃ©todo de slashing Ã© chamado.

O mÃ©todo de slashing recebe um identificador exclusivo para a identidade do operator, a severidade do slash como uma porcentagem do stake do operator atribuÃ­do em cada vault e o contexto temporal em que a infraÃ§Ã£o ocorreu.

O processo de slashing consiste nas seguintes etapas:

1. **Slash Reportado** - o Tanssi envia a solicitaÃ§Ã£o de slashing ao `Middleware` com os parÃ¢metros `operatorKey`, `percentage` e `epoch`
2. **ValidaÃ§Ã£o do Operator** - o `Middleware` valida a identidade do operator e verifica se ele estÃ¡ sujeito ao slashing
3. **Recuperar Vaults Ativos** - o `Middleware` percorre todos os vaults ativos durante a Ã©poca da infraÃ§Ã£o, ignorando qualquer vault inativo
4. **Recuperar Stake do Operator** - para cada vault ativo, o `Middleware` recupera o stake do operator infrator
5. **Calcular Valor do Slash** - o `Middleware` calcula o valor do slashing aplicando a porcentagem de corte ao stake do operator em cada vault
6. **Slashing** - dependendo da implementaÃ§Ã£o de slashing do vault, existem duas rotas possÃ­veis

    - **Slashing InstantÃ¢neo** - se o vault usa slashing instantÃ¢neo, o stake Ã© reduzido imediatamente

    - **Veto Slashing** - se o vault usa veto slashing, o `Middleware` solicita o slashing a um resolver. Uma janela de veto com tempo limitado Ã© criada (por exemplo, 7 dias)

    O slashing Ã© cancelado se o resolver vetar a solicitaÃ§Ã£o dentro da janela de tempo. Caso contrÃ¡rio, a penalidade de slashing Ã© executada se nenhum veto ocorrer dentro da janela.

Esse processo garante que o slashing de cada vault seja tratado de forma independente, evitando contaminaÃ§Ã£o cruzada, e oferece slashing instantÃ¢neo e com atraso, com mecanismos de resoluÃ§Ã£o de disputas.

```mermaid
%%{init: {'sequence': {'mirrorActors': false}}}%%
sequenceDiagram
    participant Network
    participant Middleware
    participant Vault
    participant Slasher
    
    Network->>Middleware: 1. Slash reportado
    Middleware->>Middleware: 2. ValidaÃ§Ã£o do operator
    loop Cada Vault Ativo
        Middleware->>Vault: 3. Recuperar stake do operator
        Vault-->>Middleware: 4. Recuperar stake do vault
        Middleware->>Middleware: 5. Calcular valor do slash
        alt Slasher InstantÃ¢neo
            Middleware->>Slasher: 6.1 Slash
        else Veto Slasher
            Middleware->>Slasher: 6.2 Solicitar slash
            opt Se NÃ£o Vetado
                Slasher->>Slasher: 6.2 Executar slash
            end
        end
    end
```

#### Burner {: #burner }

O contrato `Burner` Ã© uma extensÃ£o responsÃ¡vel por lidar com aÃ§Ãµes que seguem um [evento de slashing](#slashing-process), especialmente a queima do colateral slashed. Uma vez que um slash Ã© executado, o contrato `Slasher` chama o `Burner` para realizar essas tarefas pÃ³s-slashing.

Dentro do protocolo, o contrato `Burner` desempenha um papel crucial ao decidir o que acontece apÃ³s o slashing. Embora existam diferentes maneiras de implementar o processo de queima, a abordagem recomendada Ã© queimar os ativos slashed.
Quando um slash Ã© executado, a funÃ§Ã£o `onSlash` do contrato `Burner` Ã© ativada. Essa funÃ§Ã£o dÃ¡ inÃ­cio ao processo de queimar os ativos slashed.

O gerente do vault escolhe a implementaÃ§Ã£o especÃ­fica do processo de queima durante a fase de inicializaÃ§Ã£o do vault e, uma vez definida, o gerente do vault nÃ£o pode modificÃ¡-la. O design exato do contrato `Burner` pode variar dependendo do tipo de ativo colateral envolvido. Abaixo estÃ£o algumas opÃ§Ãµes de implementaÃ§Ã£o em potencial:

- **Queima de Tokens** - se o colateral slashed for um token ERC-20 comum, o `Burner` destrÃ³i esses tokens, removendo-os permanentemente de circulaÃ§Ã£o
- **Desembrulhar e Queimar** - se os tokens slashed representarem algo como ativos em stake (por exemplo, tokens de staking lÃ­quido) ou tokens de provedor de liquidez (LP) de uma DEX, o `Burner` pode convertÃª-los de volta Ã  sua forma original antes de queimÃ¡-los
- **OperaÃ§Ãµes entre Cadeias** - se os tokens estiverem vinculados a ativos em outra blockchain, o `Burner` pode desembrulhÃ¡-los no Ethereum e acionar o processo de queima na rede original
- **Tratamento Alternativo** - Ã s vezes, queimar nÃ£o Ã© a melhor opÃ§Ã£o. Em vez disso, o `Burner` pode redistribuir os ativos slashed para outros operators, compensar usuÃ¡rios afetados ou bloqueÃ¡-los em pools de liquidez â€” conforme o sistema for projetado para fazer

Queimar o colateral slashed Ã© importante porque penaliza operators que se comportam mal e reduz a oferta total de tokens, o que pode ter efeitos deflacionÃ¡rios.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/glossary/
--- BEGIN CONTENT ---
---
title: GlossÃ¡rio
description: The Tanssi network's architecture is rich and complex. Here's a technical glossary for understanding Tanssi, including key terms, concepts, and definitions.
icon: octicons-book-24
---

# GlossÃ¡rio

## IntroduÃ§Ã£o {: #introduction }

O protocolo Tanssi oferece uma ampla gama de recursos e arquitetura em camadas, tornando-o rico e complexo. HÃ¡ uma grande quantidade de terminologia especÃ­fica para Tanssi, Appchains, Symbiotic e o espaÃ§o web3 em geral. Compilamos uma lista de termos que vocÃª vai querer conhecer ao revisar a documentaÃ§Ã£o da Tanssi.

## Appchain {: #appchain }

Um blockchain personalizÃ¡vel especÃ­fico para aplicaÃ§Ãµes implantado atravÃ©s da Tanssi que entra em operaÃ§Ã£o em minutos, beneficiando-se da seguranÃ§a compartilhada, serviÃ§os de produÃ§Ã£o de blocos, bridging integrado e outros serviÃ§os.

## BEEFY {: #beefy }

BEEFY significa _Bridge Efficiency Enabling Finality Yielder_. Ã‰ um protocolo de consenso que o Tanssi utiliza para bridging eficiente e sem confianÃ§a para o Ethereum.

## Bridge {: #bridge }

Uma bridge no contexto web3 conecta dois blockchains soberanos diferentes. Tanssi oferece uma bridge integrada baseada no Snowbridge, conectando a rede Tanssi ao Ethereum de forma descentralizada e sem confianÃ§a.

## Dancelight {: #dancelight }

A TestNet oficial da Tanssi para implantaÃ§Ã£o e experimentaÃ§Ã£o rÃ¡pida de redes.

## Data Preservers {: #data-preservers }

NÃ³s de arquivamento completo que garantem a disponibilidade de dados e fornecem infraestrutura RPC para as redes Tanssi e powered by Tanssi.

## ECDSA {: #ecdsa }

ECDSA significa _Elliptic Curve Digital Signature Algorithm_, que Ã© o esquema criptogrÃ¡fico usado para contas Ethereum.

## Ed25519 {: #ed25519 }

Ã‰ o esquema criptogrÃ¡fico para produzir assinaturas digitais usado por node operators para mecanismos de consenso como produÃ§Ã£o de blocos.

## Gateway Contract {: #gateway }

Um dos componentes da bridge Tanssi-Ethereum. Ele serve como o ponto central de mensagens do Ethereum que recebe e valida mensagens da Tanssi.

## Light Client {: #light-client }

Um dos componentes da bridge Tanssi-Ethereum. Serve como um verificador on-chain para a legitimidade dos dados em uma rede.

Um cliente leve Ã© um software que permite interagir com um blockchain sem ter que baixar todos os dados. Ele utiliza um subconjunto de informaÃ§Ãµes (como cabeÃ§alhos de blocos) e usa ferramentas como provas de Merkle para verificar a autenticidade de transaÃ§Ãµes e dados. Isso torna os clientes leves mais eficientes em termos de recursos do que os nÃ³s completos.

## Merkle Root {: #merkle-root }

Um Ãºnico hash criptogrÃ¡fico que permite a verificaÃ§Ã£o de um conjunto inteiro de dados, como todas as transaÃ§Ãµes em um bloco.

## Operator {: #operator }

Um nÃ³ que valida transaÃ§Ãµes, fornecendo seguranÃ§a atravÃ©s de um protocolo de restaking para Tanssi e todas as appchains movidas a Tanssi.

## Relayer {: #relayer }

Um componente sem estado que transporta mensagens e provas entre diferentes redes blockchain, como Tanssi e Ethereum.

## Restaking {: #restaking }

A prÃ¡tica de usar tokens jÃ¡ apostados para proteger protocolos ou serviÃ§os adicionais.

## Sequencer {: #sequencer }

Um nÃ³ responsÃ¡vel por executar transaÃ§Ãµes e produzir blocos para appchains movidas a Tanssi.

## Session {: #session }

Um perÃ­odo de tempo durante o qual o mesmo conjunto de autoridades (sequencers ou validadores) estÃ¡ ativo.

## Sr25519 {: #sr25519 }

O principal esquema de assinatura que Ã© usado para a maioria das operaÃ§Ãµes voltadas para o usuÃ¡rio dentro da rede Tanssi.

## Substrate {: #substrate }

Uma estrutura de desenvolvimento de blockchain modular e de alto desempenho usada para construir Tanssi e appchains Tanssi.

## Symbiotic {: #symbiotic }

Um protocolo de restaking baseado em Ethereum, fornecendo serviÃ§os de restaking e seguranÃ§a econÃ´mica para Tanssi e appchains powered by Tanssi.

## $TANSSI(Substrate) {: #tanssi-substrate }

O token de utilidade nativo do protocolo Tanssi. Ã‰ usado para staking, governanÃ§a, operaÃ§Ãµes de rede e muito mais.

## $TANSSI(ERC20) {: #tanssi-erc20 }

A representaÃ§Ã£o ERC20 Ethereum do token Tanssi. Ã‰ usado para pagar recompensas aos operators e muito mais.

## Trustless {: #trustless }

Assim como uma _bridge sem confianÃ§a_, ela permite a operaÃ§Ã£o sem exigir confianÃ§a em intermediÃ¡rios centralizados, contando, em vez disso, com provas criptogrÃ¡ficas.

## Vault {: #vault }

Um componente Symbiotic que recebe e gerencia colaterais em restaking, delegando aos operators e fornecendo seguranÃ§a econÃ´mica Ã s redes.

## Verifier {: #verifier }

O componente que valida provas criptogrÃ¡ficas.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/
--- BEGIN CONTENT ---
---
title: Saiba Mais Sobre Tanssi
description: Saiba mais sobre o protocolo Tanssi e como ele lida com as complexidades da infraestrutura, facilitando para os desenvolvedores a implantaÃ§Ã£o de redes descentralizadas em minutos.
icon: octicons-star-24
template: index-page.html
---

# Saiba mais Sobre Tanssi

Com Tanssi, os desenvolvedores podem contar com a produÃ§Ã£o contÃ­nua de blocos, integraÃ§Ã£o com ferramentas essenciais e a flexibilidade de escolher provedores de seguranÃ§a que melhor se adequem ao seu ambiente de blockchain, capacitando-os a se concentrar na inovaÃ§Ã£o, e nÃ£o nos obstÃ¡culos tÃ©cnicos.

A estrutura modular, a personalizaÃ§Ã£o de Runtime, o gerenciamento de transaÃ§Ãµes e a interoperabilidade da Tanssi transformam o desenvolvimento de rede em um processo acessÃ­vel e eficiente, reduzindo drasticamente o tempo de lanÃ§amento no mercado, garantindo, ao mesmo tempo, alto desempenho e escalabilidade.

Esta seÃ§Ã£o inclui uma visÃ£o geral dos principais recursos da Tanssi que suportam o desenvolvimento da rede, cobrindo tudo, desde infraestrutura e seguranÃ§a atÃ© integraÃ§Ãµes essenciais.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/network-features/
--- BEGIN CONTENT ---
---
title: Recursos da Rede
description: Explore os recursos da rede Tanssi, como staking, governanÃ§a e tesouraria, apoiando seu papel como um orquestrador de rede descentralizado para o ecossistema Web3.
icon: octicons-cpu-24
template: index-page.html
---

# Recursos da Rede

Os recursos da rede em Tanssi sÃ£o projetados para fornecer os mecanismos fundamentais que apoiam a descentralizaÃ§Ã£o, a seguranÃ§a e a escalabilidade. De proteger redes por meio de staking a capacidades futuras, esta seÃ§Ã£o descreve os elementos principais que capacitam a infraestrutura de rede da Tanssi.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/network-features/staking/
--- BEGIN CONTENT ---
---
title: Staking para ProduÃ§Ã£o de Blocos
description: Saiba como a Tanssi implementa um mecanismo de staking para prover disponibilidade por meio de um conjunto descentralizado e trustless de Sequencers para todas as redes powered by Tanssi.
icon: material-hand-coin-outline
categories: Basics
---

# Staking da Tanssi para ProduÃ§Ã£o de Blocos {: #tanssi-staking }

## IntroduÃ§Ã£o {: #introduction }

Uma das propostas centrais da Tanssi Ã© simplificar a complexidade de infraestrutura das redes. Um componente crucial Ã© iniciar um conjunto descentralizado de Sequencers, que a Tanssi oferece por meio de sua arquitetura e mecÃ¢nica de staking.

A mecÃ¢nica de staking da Tanssi garante que os Sequencers das redes powered by Tanssi sejam escolhidos de forma descentralizada e trustless, alÃ©m de incentivar a comunidade a delegar para Sequencers de melhor desempenho ou mais engajados.

Este conteÃºdo apresenta os conceitos fundamentais do staking da Tanssi e como ele mantÃ©m um conjunto descentralizado de produÃ§Ã£o de blocos que garante a disponibilidade das redes.

<div style="text-align: center; justify-content:center;" class="row hero-buttons">
  <a href="https://www.tanssi.network/post/staking-tanssi" aria-label="Learn How to Stake on Tanssi Apps" style="margin: .5em;">
    <button class="md-button primary-button" style="padding: 1em; font-size: 1em;">Learn How to Stake -></button>
  </a>
</div>

## Conceitos BÃ¡sicos {: #core-concepts }

A mecÃ¢nica do mÃ³dulo de staking da Tanssi foi inspirada no conceito de tokens de pool de liquidez (LP tokens) em AMMs tradicionais como Uniswap V2.

Cada Sequencer possui quatro pools de liquidez pelos quais os delegadores passam ao realizar diferentes operaÃ§Ãµes de staking. Cada pool representa um estado do processo: ingresso, recompensas manuais, recompensas com auto-compound e saÃ­da. Diferente dos LP tokens tradicionais, os tokens de participaÃ§Ã£o nesses pools nÃ£o sÃ£o transferÃ­veis.

O delegador tem quatro transaÃ§Ãµes simples para percorrer os estados (pools): delegar (para recompensas manuais ou auto-compound), undelegar, trocar e executar operaÃ§Ãµes pendentes. Por exemplo, para entrar em um dos pools de recompensas, o usuÃ¡rio delega e entra no Joining Pool imediatamente. ApÃ³s um atraso, o prÃ³prio usuÃ¡rio (ou qualquer pessoa) pode executar a operaÃ§Ã£o pendente e entrar no pool de recompensas escolhido. Depois, pode trocar entre pools de recompensa quando quiser. Por fim, quem estÃ¡ em um pool de recompensas pode usar *undelegate* para ir ao Leaving Pool e remover o stake; apÃ³s o atraso, qualquer pessoa pode executar a operaÃ§Ã£o pendente e concluir a saÃ­da.

Pools de liquidez possuem shares, anÃ¡logas a LP tokens em AMMs. Ao entrar em um novo pool, o usuÃ¡rio recebe shares conforme o tipo de pool, a quantidade delegada, o total de shares e o total delegado nesse pool.

Recompensas sÃ£o atribuÃ­das aos pools Manual ou Auto-Compound de um Sequencer quando a Tanssi atesta que o slot de produÃ§Ã£o de blocos designado foi cumprido com sucesso.

Todas as recompensas (de todos os pools) ficam em uma conta do protocolo, mas o protocolo rastreia internamente os tokens nativos de cada pool. A diferenÃ§a entre pools Manual e Auto-Compound Ã© como as recompensas sÃ£o distribuÃ­das: no **Manual Rewards Pool**, o usuÃ¡rio precisa reivindicar; no **Auto-Compound Rewards Pool**, as recompensas sÃ£o automaticamente reinvestidas a cada bloco da Tanssi.

As operaÃ§Ãµes de delegar e undelegar precisam ser enviadas pelo prÃ³prio delegador, sinalizando a intenÃ§Ã£o e pedindo ao protocolo para realizar as verificaÃ§Ãµes necessÃ¡rias. Essas aÃ§Ãµes sÃ³ podem ser executadas depois de um nÃºmero de sessÃµes, mas qualquer participante pode realizar a segunda etapa por meio da transaÃ§Ã£o *execute pending operation*.

O diagrama a seguir resume o fluxo de delegar e undelegar para um Sequencer; aÃ§Ãµes do usuÃ¡rio em ciano e pools em coral.

![VisÃ£o geral do mecanismo de staking da Tanssi](/images/learn/tanssi/staking/staking-1.webp)

## ParÃ¢metros de Staking {: #staking-parameters }

=== "Tanssi MainNet"
    |   VariÃ¡vel    |                                                         Valor                                                         |
    |:-------------:|:---------------------------------------------------------------------------------------------------------------------:|
    | Joining Delay | {{ networks.mainnet.staking.joining_delay_blocks }} blocos ({{ networks.mainnet.staking.joining_delay_hours }} horas) |
    | Leaving Delay | {{ networks.mainnet.staking.leaving_delay_blocks }} blocos ({{ networks.mainnet.staking.leaving_delay_hours }} horas) |
  
=== "Dancelight TestNet"
    |   VariÃ¡vel    |                                                            Valor                                                            |
    |:-------------:|:---------------------------------------------------------------------------------------------------------------------------:|
    | Joining Delay | {{ networks.dancelight.staking.joining_delay_blocks }} blocos ({{ networks.dancelight.staking.joining_delay_hours }} horas) |
    | Leaving Delay | {{ networks.dancelight.staking.leaving_delay_blocks }} blocos ({{ networks.dancelight.staking.leaving_delay_hours }} horas) |

## Pools de Staking {: #staking-pools}

Esta seÃ§Ã£o detalha cada pool que representa uma etapa do processo de staking.

### Joining Pool {: #joining-pool}

Ao delegar para iniciar o staking, o usuÃ¡rio escolhe o mecanismo de recompensas: manual ou auto-compound (cada um Ã© um pool). ApÃ³s a transaÃ§Ã£o, o usuÃ¡rio entra no Joining Pool e recebe shares proporcionais ao valor delegado. Esse pool oferece estabilidade aos Sequencers, impondo um atraso entre delegar e receber recompensas (pelo menos uma sessÃ£o).

Exemplo prÃ¡tico: Alice inicia o staking mirando o Manual Rewards Pool e entra no Joining Pool no meio de uma sessÃ£o; ela deve esperar atÃ© o fim da sessÃ£o seguinte para executar a operaÃ§Ã£o pendente e comeÃ§ar a receber recompensas.

Joining Pools tÃªm proporÃ§Ã£o 1:1 entre shares e tokens delegados. Se Alice delega 100 tokens, recebe 100 shares do Joining Pool. Quando a operaÃ§Ã£o pendente de delegate Ã© executada, o protocolo consome as shares do Joining Pool em troca dos tokens nativos, que sÃ£o imediatamente convertidos em shares do Manual ou Auto-Compound Rewards Pool.

O diagrama abaixo supÃµe que o usuÃ¡rio estÃ¡ direcionando stake para o Manual Rewards Pool.

![VisÃ£o geral do Joining Pool no staking](/images/learn/tanssi/staking/staking-2.webp)

### Manual Rewards Pool {: #manual-rewards-pool}

Ao entrar no Manual Rewards Pool, o protocolo destrÃ³i as shares do Joining Pool em favor do token nativo. No mesmo bloco, calcula quantas shares do Manual Pool podem ser cunhadas com esse valor, com base no preÃ§o da share:

```mathematica
SharePrice [Tokens/Shares] = NumberOfTokensInPool / NumberOfSharesInPool 
```

Shares nÃ£o tÃªm decimais; qualquer resto de tokens ao adquirir shares Ã© devolvido ao usuÃ¡rio. O preÃ§o da share nÃ£o muda com novas entradas, pois a razÃ£o Ã© mantida. Com shares do Manual Rewards Pool, o usuÃ¡rio passa a acumular recompensas (na mesma sessÃ£o) que precisam ser reivindicadas manualmente.

Ao contrÃ¡rio do Auto-Compound, a distribuiÃ§Ã£o no Manual ocorre por um mecanismo de checkpoint de recompensas. Ele rastreia o histÃ³rico de tokens nativos por share atribuÃ­do pelo protocolo naquele Manual Rewards Pool em um momento especÃ­fico. Quando a Tanssi atesta um bloco produzido por um Sequencer, novas recompensas sÃ£o atribuÃ­das ao Manual Rewards Pool para os usuÃ¡rios reivindicarem, e o contador de recompensas aumenta. Assim, as recompensas sÃ£o refletidas na razÃ£o de tokens por share, diferenÃ§a entre o contador atual do pool e o checkpoint do usuÃ¡rio.

O contador de recompensas por share Ã© essencial para calcular o valor devido ao reivindicar. ApÃ³s calcular, o protocolo envia os tokens para o usuÃ¡rio e redefine o checkpoint dele para o contador atual do pool, garantindo alinhamento e zero recompensas pendentes.

De forma semelhante, ao adicionar ou remover stake, as recompensas sÃ£o reivindicadas automaticamente e o checkpoint Ã© redefinido, pois a condiÃ§Ã£o de recompensas para aquele montante muda e precisa ser sincronizada com o pool.

![VisÃ£o geral do Manual Rewards Pool no staking](/images/learn/tanssi/staking/staking-3.webp)

### Auto-Compound Rewards Pool {: #autocompounded-rewards-pool}

Ao entrar no Auto-Compound Rewards Pool, o protocolo destrÃ³i as shares do Joining Pool em favor do token nativo. No mesmo bloco, calcula quantas shares de Auto-Compound podem ser cunhadas com esse valor, com base no preÃ§o da share:

```mathematica
SharePrice [Tokens/Shares] = NumberOfTokensInPool / NumberOfSharesInPool 
```

Shares nÃ£o tÃªm decimais; qualquer resto Ã© devolvido ao usuÃ¡rio. O preÃ§o da share nÃ£o muda na entrada. Com shares do Auto-Compound Rewards Pool, o usuÃ¡rio acumula recompensas na mesma sessÃ£o.

Ao contrÃ¡rio do Manual, as recompensas em tokens nativos no Auto-Compound sÃ£o atribuÃ­das automaticamente a cada bloco da Tanssi em que o protocolo atesta o Sequencer designado. Como o nÃºmero de tokens no pool cresce e o de shares permanece, o preÃ§o da share sobe; ao resgatar, o usuÃ¡rio recebe mais tokens por share do que na entrada.

![VisÃ£o geral do Auto-Compound Rewards Pool no staking](/images/learn/tanssi/staking/staking-4.webp)

As recompensas sÃ£o reinvestidas como novo stake no Auto-Compound Rewards Pool, caracterizando o auto-compound.

Contudo, quando recompensas auto-compound sÃ£o atribuÃ­das, elas nÃ£o ficam no saldo reservado do usuÃ¡rio; ainda estÃ£o na conta do protocolo, e o aumento do stake Ã© representado pelo aumento do preÃ§o da share. Em alguns cenÃ¡rios, o usuÃ¡rio pode querer que esse saldo conste no estado como saldo reservado (por exemplo, governanÃ§a).

Por isso, o protocolo oferece uma chamada especÃ­fica para atualizar o saldo reservado de qualquer delegado, movendo as recompensas auto-compound da conta do protocolo para o saldo reservado do usuÃ¡rio. Isso tambÃ©m Ã© executado automaticamente ao remover liquidez do Auto-Compound Rewards Pool.

### Leaving Pool {: #leaving-pool}

Ao sair de posiÃ§Ãµes no Manual ou Auto-Compound, o usuÃ¡rio pode iniciar uma undelegation. Como na entrada, Ã© um processo em duas etapas: assina a intenÃ§Ã£o de remover a delegaÃ§Ã£o e aguarda pelo menos uma sessÃ£o antes de a operaÃ§Ã£o ser executada por qualquer pessoa.

Ao executar a intenÃ§Ã£o de saÃ­da, o protocolo troca shares do pool especÃ­fico por tokens nativos ao preÃ§o atual. Para o Manual Rewards Pool, recompensas nÃ£o reivindicadas sÃ£o atribuÃ­das ao usuÃ¡rio. Em seguida, o protocolo compra shares do Leaving Pool em proporÃ§Ã£o 1:1 aos tokens nativos recebidos, garantindo que o usuÃ¡rio entre no Leaving Pool com shares equivalentes ao valor a ser retirado.

ApÃ³s uma sessÃ£o, qualquer usuÃ¡rio pode executar a operaÃ§Ã£o pendente; o protocolo entÃ£o troca shares do Leaving Pool por tokens nativos em proporÃ§Ã£o 1:1.

O objetivo principal do Leaving Pool Ã© fornecer um buffer para saÃ­das, permitindo implementar mecanismos de slashing para coibir mau comportamento. O slashing nÃ£o estÃ¡ implementado atualmente, mas pode ser adicionado no futuro.

O diagrama a seguir supÃµe que o usuÃ¡rio estÃ¡ saindo do Manual Rewards Pool.

![VisÃ£o geral do Leaving Pool no staking](/images/learn/tanssi/staking/staking-5.webp)

### Trocar entre Pools de Recompensa {: #swap-rewards-pool}

O mÃ³dulo de staking da Tanssi permite trocar o stake de um pool de recompensas para outro, total ou parcialmente, sem passar novamente pelos pools de entrada e saÃ­da.

Primeiro, todas as recompensas pendentes do Manual Rewards Pool sÃ£o reivindicadas em nÃ­vel de protocolo, pois a liquidez estÃ¡ sendo alterada e o checkpoint precisa ser sincronizado. Em seguida, shares do pool original sÃ£o consumidas e trocadas por tokens nativos ao preÃ§o atual; entÃ£o, shares do novo pool sÃ£o adquiridas ao preÃ§o do novo pool. Qualquer â€œpoeiraâ€ restante Ã© convertida em shares do Leaving Pool. Tudo ocorre no mesmo bloco; nÃ£o hÃ¡ atraso para comeÃ§ar a receber recompensas no novo pool. A poeira no Leaving Pool pode ser reivindicada apÃ³s os atrasos necessÃ¡rios.

![VisÃ£o geral da troca entre pools Manual e Auto-Compound no staking](/images/learn/tanssi/staking/staking-6.webp)
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/network-services/block-production/
--- BEGIN CONTENT ---
---
title: ServiÃ§os de ProduÃ§Ã£o de Blocos
description: A Tanssi abstrai as complexidades de infraestrutura, como a produÃ§Ã£o de blocos, permitindo lanÃ§ar redes descentralizadas com seguranÃ§a de nÃ­vel Ethereum.
icon: octicons-container-24
categories: Basics
---

# ServiÃ§os de ProduÃ§Ã£o de Blocos {: #block-production-services }

## IntroduÃ§Ã£o {: #introduction }

Como apresentado no artigo [VisÃ£o Geral](/pt/learn/tanssi/overview/){target=\_blank}, Tanssi Ã© um protocolo de infraestrutura que agiliza a implantaÃ§Ã£o de redes descentralizadas com lÃ³gica personalizada que se adequa a uma ampla gama de casos de uso, incluindo DeFi, NFTs, Jogos e qualquer outro caso de uso que as equipes de desenvolvimento possam querer abordar.

A infraestrutura representa um enorme desafio para os desenvolvedores, exigindo que eles inicializem Sequencers, preservadores de dados e endpoints RPC, alÃ©m de gerenciar integraÃ§Ãµes, interoperabilidade e seguranÃ§a. Isso exige tempo e recursos valiosos, desviando o foco do que realmente importa: entregar valor aos seus usuÃ¡rios.

Tanssi orquestra recursos, permitindo que os desenvolvedores implantem redes descentralizadas (tambÃ©m conhecidas como serviÃ§os validados ativamente ou AVSs) que sÃ£o totalmente adaptÃ¡veis a qualquer aplicativo ou caso de uso especÃ­fico. Nesta analogia, a rede Tanssi se assemelha ao [Kubernetes](https://kubernetes.io){target=\_blank} em seu papel como orquestrador, gerenciando recursos para garantir a atividade e o desempenho das redes.

O protocolo tambÃ©m aborda a frente de seguranÃ§a, permitindo que as redes selecionem e se conectem a provedores de seguranÃ§a externos (como [Symbiotic](/pt/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}), garantindo seguranÃ§a de nÃ­vel Ethereum desde o inÃ­cio.

Este artigo aborda os aspectos necessÃ¡rios a serem considerados ao construir e implantar seu prÃ³prio blockchain modular, juntamente com os aspectos tÃ©cnicos mais relevantes do protocolo Tanssi.

## ProduÃ§Ã£o de Blocos como ServiÃ§o {: #block-production-as-a-service }

O protocolo Tanssi fornece produÃ§Ã£o de blocos como serviÃ§o, orquestrando um conjunto descentralizado e confiÃ¡vel de Sequencers, garantindo a atividade das redes. Para fazer isso, o protocolo conecta ambas as extremidades:

- **Operators de nÃ³s**: Que executam Sequencers, oferecendo seus serviÃ§os de produÃ§Ã£o de blocos para obter recompensas.
- **Desenvolvedores**: Que lanÃ§am redes, que exigem Sequencers.

O protocolo atribui um subconjunto de Sequencers para fornecer serviÃ§os a cada rede, rotacionando-os apÃ³s um perÃ­odo de tempo. Os Sequencers podem servir qualquer rede baseada em Tanssi, independentemente da lÃ³gica personalizada que implementam. Por outro lado, as redes implantadas por meio da Tanssi podem personalizar seu Runtime tanto quanto precisarem para se adequar ao seu caso de uso e atualizar a lÃ³gica a qualquer momento de forma sem bifurcaÃ§Ã£o, sem se preocupar com a configuraÃ§Ã£o do Sequencer.

O diagrama a seguir ilustra como o Tanssi atribui dois Sequencers a cada rede ativa, selecionando-os de um conjunto descentralizado de Sequencers.

```mermaid
flowchart TB
    subgraph network1 [Rede 1]
        s1bis[Sequencer 1]
        s2bis[Sequencer 2]
    end

    subgraph network2 [Rede 2]
        s3bis[Sequencer 3]
        s4bis[Sequencer 4]
    end

    Tanssi[Rede Tanssi<br/>Orquestrador]

    subgraph sequencers [Pool de Sequencers]
        direction LR
        s1[Sequencer 1]
        s2[Sequencer 2]
        s3[Sequencer 3]
        s4[Sequencer 4]
        sn[Sequencer N]

        s1 --- s2 --- s3 --- s4 --- sn
    end

    sequencers -- Gerenciado por --> Tanssi
    Tanssi -- Atribui Sequencers --> network1
    Tanssi -- Atribui Sequencers --> network2
```

### Processo de SeleÃ§Ã£o do Sequencer {: #sequencer-selection-process}

A qualquer momento, todas as redes Tanssi exigem um certo nÃºmero de Sequencers, dependendo do nÃºmero de redes ativas e da configuraÃ§Ã£o atual de produÃ§Ã£o de blocos definida na Tanssi. A configuraÃ§Ã£o define o nÃºmero mÃ¡ximo de Sequencers totais no conjunto e o nÃºmero de Sequencers que cada rede deve ter atribuÃ­do.

=== "Tanssi MainNet"
|          VariÃ¡vel          |                                       Valor                                        |
|:--------------------------:|:----------------------------------------------------------------------------------:|
|    MÃ¡x. nÂº de Sequencers    |     {{ networks.mainnet.sequencers.configuration.max_block_producers }}      |
| nÂº de Sequencers (Redes) | {{ networks.mainnet.sequencers.configuration.block_producer_per_container }} |

=== "Dancelight TestNet"
|          VariÃ¡vel          |                                       Valor                                        |
|:--------------------------:|:----------------------------------------------------------------------------------:|
|    MÃ¡x. nÂº de Sequencers    |     {{ networks.dancelight.sequencers.configuration.max_block_producers }}      |
| nÂº de Sequencers (Redes) | {{ networks.dancelight.sequencers.configuration.block_producer_per_container }} |

Assim que o nÃºmero necessÃ¡rio de Sequencers para uma determinada sessÃ£o for conhecido, o Tanssi usa dois mecanismos para decidir o conjunto de Sequencers distribuÃ­dos entre todas as redes.

O primeiro mecanismo Ã© atravÃ©s do mÃ³dulo *InvulnerÃ¡veis*, que define uma lista de Sequencers fixos priorizados pelo protocolo e garante a estabilidade da produÃ§Ã£o de blocos em certos cenÃ¡rios, como TestNets.

O segundo mecanismo Ã© atravÃ©s do [mÃ³dulo de staking da Tanssi](/pt/learn/tanssi/network-features/staking/){target=\_blank}. O mÃ³dulo ajuda a criar um conjunto descentralizado de Sequencers para todas as redes Tanssi, fornecendo ao protocolo uma lista de Sequencers classificados por valor apostado. O Tanssi anexa a lista classificada por aposta de Sequencers aos invulnerÃ¡veis (se houver), em seguida, pega da lista apenas a quantidade exata de Sequencers necessÃ¡ria, comeÃ§ando do topo, deixando de fora da prÃ³xima sessÃ£o aqueles Sequencers que tÃªm menos valor apostado, para finalmente iniciar o processo de atribuiÃ§Ã£o do Sequencer.

### AtribuiÃ§Ã£o de Sequencers {: #block_producers-assignment }

Assim que o conjunto de Sequencers que participarÃ¡ da prÃ³xima sessÃ£o for conhecido, o Tanssi embaralha a lista e os atribui para fornecer serviÃ§os de produÃ§Ã£o de blocos Ã s redes Tanssi ativas.

O algoritmo de atribuiÃ§Ã£o comeÃ§arÃ¡ a distribuir os Sequencers que atendem Ã s redes pela data de registro em ordem de chegada. Depois que a atribuiÃ§Ã£o for feita, ela serÃ¡ mantida por pelo menos uma sessÃ£o, representando um perÃ­odo medido em blocos com um conjunto constante de Sequencers. No Tanssi MainNet, a duraÃ§Ã£o da sessÃ£o padrÃ£o Ã© definida como {{ networks.mainnet.session.blocks }} blocos, o que, com um tempo mÃ©dio de bloco de seis segundos, se traduz em (aproximadamente) {{ networks.mainnet.session.display }} horas.

Cada nova atribuiÃ§Ã£o funciona intencionalmente com um atraso de uma sessÃ£o, para que os Sequencers saibam com antecedÃªncia a qual das redes eles estÃ£o atribuÃ­dos. Os Sequencers comeÃ§arÃ£o a sincronizar a nova rede que terÃ£o que servir na prÃ³xima sessÃ£o com um mecanismo de sincronizaÃ§Ã£o especial chamado [warp sync](https://spec.polkadot.network/chap-sync#sect-sync-warp){target=\_blank}. O warp sync permite que os Sequencers sincronizem rapidamente a nova rede sem atuar como um nÃ³ de arquivo.

Quando uma nova sessÃ£o comeÃ§a, o protocolo Tanssi colocarÃ¡ a atribuiÃ§Ã£o na fila em vigor. Os Sequencers mudarÃ£o automaticamente e comeÃ§arÃ£o a produzir blocos na nova rede Tanssi a que foram atribuÃ­dos, descartando o estado da cadeia da atribuiÃ§Ã£o anterior. O Tanssi tambÃ©m calcularÃ¡ a nova atribuiÃ§Ã£o, considerando as alteraÃ§Ãµes nas redes Tanssi que podem ter sido ativadas ou desativadas e os Sequencers que podem ter sido adicionados ou removidos do pool ou alterado o valor total apostado. Esta nova atribuiÃ§Ã£o serÃ¡ enfileirada para a prÃ³xima sessÃ£o.

![SessÃµes](/images/learn/tanssi/network-services/block-production/block-production-1.webp)

### O Papel da Rede Tanssi {: #tanssi-newtwork }

Como discutido anteriormente, o protocolo Tanssi atribui Sequencers Ã s redes Tanssi, e o resultado desta atribuiÃ§Ã£o Ã© armazenado no estado da cadeia. AlÃ©m de executar o nÃ³ da rede, os Sequencers tambÃ©m executam o Tanssi. Portanto, ao acessar os dados armazenados nos blocos finalizados da Rede Tanssi, eles podem aprender sua atribuiÃ§Ã£o para a sessÃ£o, e as redes Tanssi podem confirmar que um determinado grupo de Sequencers foi atribuÃ­do a elas.

Ã€ medida que as redes Tanssi produzem blocos, esses blocos precisam ser validados e finalizados por um provedor de seguranÃ§a externo. Depois que um operator verifica um bloco, uma pequena prova de validade Ã© produzida e armazenada na Tanssi, mantendo o controle das provas para cada bloco de cada cadeia. Esta pequena representaÃ§Ã£o da prova de validade Ã© chamada de [recibo de candidato](https://wiki.polkadot.com/learn/learn-parachains-protocol/#candidate-receipts){target=\_blank} e Ã© composta por um conjunto de valores, incluindo a raiz do estado, que pode ser usada para verificar provas de estado.

Finalmente, o Tanssi pode verificar se o autor de um bloco de rede foi o esperado e recompensÃ¡-lo de acordo.

O diagrama a seguir mostra um Template simplificado dos dados que o Tanssi armazena em seu estado interno. Para cada rede ativa (neste exemplo, duas), o Tanssi armazena os Sequencers atribuÃ­dos, que sÃ£o os Ãºnicos autorizados a produzir blocos em nome da rede, prova de validade (recibos de candidatos) estendidos pelos operators do provedor de seguranÃ§a, a raiz do estado mais recente e o Sequencer mais recente.

![Estado interno da Tanssi](/images/learn/tanssi/network-services/block-production/block-production-2.webp)

### O Papel da Rede powered by Tanssi {: #network }

Como um Sequencer atribuÃ­do a uma rede powered by Tanssi inclui funcionalidade de nÃ³ Tanssi integrada, Ã© tecnicamente viÃ¡vel ler o estado da Rede Tanssi.

Aproveitando essa capacidade de acessar os estados, o Sequencer atual com a autoridade para produzir um bloco lerÃ¡ o estado do Ãºltimo bloco produzido na cadeia Tanssi. Ele prosseguirÃ¡ para incluir este estado no bloco da rede, o conjunto atual de Sequencers atribuÃ­dos Ã  rede e sua assinatura pÃºblica, permitindo que o Tanssi saiba quem produziu o bloco e recompense o operator do nÃ³.

Depois que o bloco for preenchido com as transaÃ§Ãµes da rede, ele serÃ¡ proposto como candidato e entregue Ã  cadeia Tanssi, onde os operators do provedor de seguranÃ§a garantirÃ£o que as provas de estado incluÃ­das correspondam Ã s provas de estado do Ãºltimo estado da Tanssi (impedindo a produÃ§Ã£o nÃ£o autorizada de blocos) e que as transaÃ§Ãµes produziram transiÃ§Ãµes de estado vÃ¡lidas. Tendo verificado o trabalho do Sequencer, os operators finalizarÃ£o o bloco proposto, incluindo seu recibo de candidato em um bloco de rede Tanssi.

![Bloco de rede powered by Tanssi](/images/learn/tanssi/network-services/block-production/block-production-3.webp)

## Taxas de ProduÃ§Ã£o de Blocos  {: #block-production-fees }

Como apresentado na [IntroduÃ§Ã£o](#introduction), Tanssi Ã© um protocolo de infraestrutura que aborda as complexidades e os altos custos associados Ã  configuraÃ§Ã£o e manutenÃ§Ã£o da infraestrutura blockchain, agilizando a implantaÃ§Ã£o de redes. Este protocolo traz benefÃ­cios para ambos os participantes:

- **Redes**: As equipes podem se concentrar na lÃ³gica principal de seu produto, na UX e na UI, sem lidar com os desafios da inicializaÃ§Ã£o da infraestrutura e seu gerenciamento.
- **Sequencers**: Assumindo a responsabilidade de manter sua configuraÃ§Ã£o de hardware e software em Ã³timas condiÃ§Ãµes, eles sÃ£o incentivados a executar transaÃ§Ãµes e produzir blocos em nome das redes Tanssi.

A [produÃ§Ã£o de blocos como serviÃ§o](#block-production-as-a-service) acarreta custos associados que devem ser cobertos pelas redes que desejam alavancar o Tanssi para tal fim. As seÃ§Ãµes a seguir cobrem os aspectos gerais desses custos e pagamentos de serviÃ§os associados.

### Pagamentos de ServiÃ§os {: #service-payments }

Existem trÃªs custos principais associados Ã  produÃ§Ã£o de blocos como serviÃ§o que qualquer rede deve cobrir usando tokens Tanssi para implantar com sucesso e obter os serviÃ§os de produÃ§Ã£o de blocos:

- **DepÃ³sito de registro**: O depÃ³sito inicial que Ã© bloqueado da conta que assina a transaÃ§Ã£o de registro da rede.
- **DepÃ³sito de armazenamento de registro**: O depÃ³sito inicial que Ã© bloqueado da conta que assina a transaÃ§Ã£o de registro da rede. Ã‰ um valor variÃ¡vel dependendo do tamanho do Runtime da appchain.
- **AtribuiÃ§Ã£o de Sequencers**: Toda vez que o protocolo Tanssi atribui Sequencers, o que acontece uma vez por sessÃ£o, uma taxa fixa Ã© cobrada. Esta taxa dÃ¡ Ã s redes o direito de serem atribuÃ­das Sequencers e desencoraja redes cuja lÃ³gica de Runtime nÃ£o consegue produzir transaÃ§Ãµes ou blocos vÃ¡lidos.
- **ProduÃ§Ã£o de blocos**: As redes devem pagar por cada bloco produzido em seu nome. Como o protocolo seleciona e atribui os Sequencers por sessÃ£o, as redes devem ter fundos suficientes para cobrir todos os blocos a serem produzidos em uma sessÃ£o inteira para serem atendidos.

A configuraÃ§Ã£o atual Ã© definida da seguinte forma:

=== "Tanssi MainNet"
|           VariÃ¡vel           |                                                                   Valor                                                                    |
|:----------------------------:|:------------------------------------------------------------------------------------------------------------------------------------------:|
|     DepÃ³sito de registro     |                         {{ networks.mainnet.costs.registration_deposit_fee }} {{ networks.mainnet.token_symbol }}                          |
| DepÃ³sito de armazenamento de registro | {{ networks.mainnet.costs.registration_deposit_per_byte }} x 10<sup>-5</sup> {{ networks.mainnet.token_symbol }} por byte de Runtime da appchain |
|    AtribuiÃ§Ã£o de Sequencers     |                      {{ networks.mainnet.costs.cost_per_assignment }} {{ networks.mainnet.token_symbol }} por sessÃ£o                      |
|       ProduÃ§Ã£o de blocos       |                         {{ networks.mainnet.costs.cost_per_block }} {{ networks.mainnet.token_symbol }} por bloco                          |

=== "Dancelight TestNet"
|       VariÃ¡vel        |                                                Valor                                                |
|:---------------------:|:---------------------------------------------------------------------------------------------------:|
| DepÃ³sito de registro  | {{ networks.dancelight.costs.registration_deposit_fee }} {{ networks.dancelight.token_symbol }} |
| DepÃ³sito de armazenamento de registro  | {{ networks.dancelight.costs.registration_deposit_per_byte }} x 10<sup>-5</sup> {{ networks.dancelight.token_symbol }} por byte de Runtime da appchain |
| AtribuiÃ§Ã£o de Sequencers |        {{ networks.dancelight.costs.cost_per_assignment }} x 10<sup>-6</sup> {{ networks.dancelight.token_symbol }} por sessÃ£o         |
|   ProduÃ§Ã£o de blocos    |            {{ networks.dancelight.costs.cost_per_block }} x 10<sup>-6</sup> {{ networks.dancelight.token_symbol }} por bloco            |

Para garantir a produÃ§Ã£o de blocos na prÃ³xima sessÃ£o, o saldo total deve ser pelo menos suficiente para cobrir o custo de atribuiÃ§Ã£o de Sequencers mais o custo de produÃ§Ã£o dos {{ networks.mainnet.session.blocks }} blocos que compÃµem uma sessÃ£o inteira.

!!! note
    Embora os custos de atribuiÃ§Ã£o de Sequencers e produÃ§Ã£o de blocos sejam atualmente fixos, Ã  medida que o desenvolvimento do protocolo progride, eles podem se tornar dinÃ¢micos, variando em resposta Ã  carga de trabalho da rede.

### Gorjetas {: #tipping }

Em algumas ocasiÃµes, o Tanssi pode experimentar uma alta demanda por seus serviÃ§os de produÃ§Ã£o de blocos que nÃ£o pode ser atendida com os recursos disponÃ­veis. Por exemplo, se houver dez redes ativas para a prÃ³xima sessÃ£o e o Tanssi sÃ³ puder servir oito, duas redes serÃ£o paralisadas durante toda a duraÃ§Ã£o da sessÃ£o.

Para lidar com esses perÃ­odos de alta carga de trabalho, o protocolo Tanssi implementa um mecanismo de gorjeta que permite que as redes compitam por uma prioridade maior em relaÃ§Ã£o ao restante. Semelhante Ã s redes compatÃ­veis com Ethereum, onde uma taxa de prioridade pode ser definida para superar as transaÃ§Ãµes concorrentes e obter tratamento de execuÃ§Ã£o preferencial, as redes Tanssi serÃ£o atendidas de acordo com a prioridade dada pelas gorjetas que oferecem. Seguindo o exemplo anterior, se houver dez redes ativas para a prÃ³xima sessÃ£o e o Tanssi sÃ³ puder servir oito, apenas as oito redes com maior lance receberÃ£o Sequencers atribuÃ­dos.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/network-services/
--- BEGIN CONTENT ---
---
title: ServiÃ§os de Rede
description: Saiba mais sobre a proposta de valor do protocolo Tanssi, incluindo recursos crÃ­ticos como produÃ§Ã£o de blocos e disponibilidade de dados como serviÃ§o, bridging e muito mais.
icon: octicons-browser-24
template: index-page.html
---

# ServiÃ§os de Rede

Os serviÃ§os de rede da Tanssi fornecem a infraestrutura essencial para operaÃ§Ãµes de blockchain seguras e eficientes. No cerne desses serviÃ§os, o protocolo Tanssi oferece produÃ§Ã£o de blocos como serviÃ§o, garantindo o desempenho contÃ­nuo e a escalabilidade de redes descentralizadas.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/overview/
--- BEGIN CONTENT ---
---
title: VisÃ£o Geral
description: Tanssi Ã© um protocolo de infraestrutura que simplifica o processo de implantaÃ§Ã£o de appchains descentralizadas, permitindo que os desenvolvedores se concentrem na criaÃ§Ã£o de seus produtos.
icon: octicons-home-24
categories: Basics
---

# O Que Ã© Tanssi? {: #what-is-tanssi }

Tanssi Ã© um protocolo de infraestrutura de appchain descentralizado que permite que os desenvolvedores lancem sua appchain em minutos. Em outras palavras, Tanssi reduz o processo de configuraÃ§Ã£o de seis a doze meses normalmente necessÃ¡rio para qualquer equipe entrar em funcionamento com uma nova cadeia para minutos.

Pode-se pensar em Tanssi como _AWS para appchains_. Em vez de lidar com toda a infraestrutura de rede vocÃª mesmo, Tanssi lida com todos os obstÃ¡culos, permitindo que vocÃª se concentre na criaÃ§Ã£o da lÃ³gica do seu aplicativo, no crescimento de sua comunidade e em outras tarefas essenciais para o sucesso do seu produto.

A seguranÃ§a Ã© outro obstÃ¡culo significativo que os desenvolvedores devem enfrentar, assumindo a responsabilidade de atrair ativos em stake para garantir a seguranÃ§a do consenso e inicializar um conjunto de validadores, o que pode ser particularmente desafiador para projetos em seus estÃ¡gios iniciais. Todas as appchains powered by Tanssi se beneficiam da seguranÃ§a de nÃ­vel Ethereum desde o inÃ­cio e, ao aproveitar o design descentralizado da Tanssi, as appchains nÃ£o estÃ£o expostas a pontos Ãºnicos de falha.

As appchains powered by Tanssi tambÃ©m se beneficiam de uma pilha de tecnologia modular, fornecendo controle mÃ¡ximo sobre a lÃ³gica que alimenta o Runtime do blockchain, oferecendo uma excelente maneira de os projetos escalarem e construÃ­rem soluÃ§Ãµes otimizadas para seus produtos. Esse controle completo sobre a lÃ³gica da appchain e o mecanismo de governanÃ§a se adequa perfeitamente a uma ampla gama de casos de uso, incluindo protocolos DeFi, Ativos do Mundo Real (RWA), plataformas de jogos e outros.

## O Problema com Appchains {: #the-problem-with-appchains }

Os desenvolvedores que buscam construir appchains descentralizadas geralmente tÃªm que lidar com os seguintes problemas:

- **Gerenciamento de Infraestrutura Complexo**: As implantaÃ§Ãµes de appchain normalmente exigem o manuseio de numerosos componentes de infraestrutura, incluindo bootstrapping de Sequencers, operators (tambÃ©m conhecidos como validadores), carteiras, exploradores de blocos, oracles, indexadores, endpoints RPC e muito mais. O gerenciamento adequado desses componentes consome tempo e recursos.

- **SeguranÃ§a Fraca e Ineficiente**: As appchains geralmente sofrem por ter um pequeno conjunto de operators ou seguranÃ§a econÃ´mica fraca. Projetos em estÃ¡gio inicial geralmente carecem de apoio econÃ´mico suficiente para oferecer suporte a um mecanismo de consenso robusto. AlÃ©m disso, os desenvolvedores geralmente tÃªm que pagar pela validaÃ§Ã£o total da capacidade do blockchain, mesmo quando podem nÃ£o ter alcanÃ§ado o ajuste produto-mercado, e os blocos podem estar quase vazios. Isso essencialmente significa que os operators estÃ£o sendo super pagos, e hÃ¡ um custo de oportunidade significativo, pois esses recursos poderiam ser usados em outros lugares para desenvolver o protocolo.

- **Cross-Chain e Interoperabilidade**: As appchains inerentemente carecem de recursos cross-chain, o que as impede de se conectar a outros ecossistemas de blockchain. AlÃ©m disso, o desenvolvimento de soluÃ§Ãµes de interoperabilidade requer expertise especializada e implementaÃ§Ã£o meticulosa.

- **Tempo para o mercado lento**: As complexidades da infraestrutura da appchain desviam o foco dos desenvolvedores da lÃ³gica do aplicativo, que Ã© o principal impulsionador de interfaces intuitivas e uma experiÃªncia do usuÃ¡rio perfeita, crÃ­tica para a adoÃ§Ã£o.

## O que Tanssi Fornece {: #what-tanssi-provides}

Tanssi aborda os pontos problemÃ¡ticos mais comuns da appchain:

- **Sequenciamento como ServiÃ§o**: As appchains construÃ­das com Tanssi tÃªm seus blocos produzidos pelos trabalhadores incentivados da Tanssi. Tanssi garante a atividade contÃ­nua da appchain, orquestrando um conjunto descentralizado de Sequencers.

- **SeguranÃ§a EconÃ´mica por Meio de Provedores Externos**: As appchains implantadas por meio da Tanssi aproveitam a seguranÃ§a de um provedor de escolha (por exemplo, [Symbiotic](https://symbiotic.fi/){target=\_blank} para Ethereum). O protocolo foi projetado para finalizar as transaÃ§Ãµes de forma determinÃ­stica em segundos por meio de um conjunto descentralizado de operators.

- **Tanssi/Ethereum Bridge**: Mova a liquidez de e para o Ethereum usando a [bridge integrada](/pt/learn/tanssi/tanssi-ethereum-bridge/){target=\_blank} com base no Snowbridge.

- **IntegraÃ§Ãµes Chave**: As appchains construÃ­das com Tanssi podem acessar componentes de infraestrutura importantes, juntamente com a produÃ§Ã£o de blocos, de forma totalmente automatizada e padronizada. As appchains powered by Tanssi vÃªm com suporte integrado para ferramentas essenciais, incluindo carteiras, exploradores de blocos, indexadores, provedores RPC e muito mais, economizando o esforÃ§o dos desenvolvedores de integrar esses componentes.

- **Estrutura Modular de Blockchain**: As appchains construÃ­das com Tanssi podem usar uma estrutura de blockchain modular chamada [Substrate](https://docs.polkadot.com/develop/parachains/intro-polkadot-sdk/){target=\_blank}, que permite que os desenvolvedores criem de forma rÃ¡pida e fÃ¡cil blockchains otimizadas e personalizÃ¡veis para qualquer caso de uso. Tanssi lida com a maioria das complexidades de infraestrutura, permitindo que os desenvolvedores se concentrem na lÃ³gica personalizada de sua appchain.

Em resumo, as appchains implantadas por meio da Tanssi sÃ£o soluÃ§Ãµes soberanas de Camada 1 projetadas para serem altamente modulares e interconectadas, com foco na simplificaÃ§Ã£o do processo de implantaÃ§Ã£o e no desenvolvimento da personalizaÃ§Ã£o da prÃ³pria appchain. Isso capacita os desenvolvedores a levar seus aplicativos blockchain ao mercado mais rÃ¡pido, com seguranÃ§a e com maior potencial de integraÃ§Ã£o e interaÃ§Ã£o nos ecossistemas blockchain mais amplos.

### Principais Aspectos da Tanssi {: #tanssi-key-aspects }

A tabela a seguir resume os principais benefÃ­cios que Tanssi traz para seu projeto:

| Aspecto                   | A soluÃ§Ã£o Tanssi                                                                                                               |
|--------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| Tempo de implantaÃ§Ã£o          | - Minutos para implantar<br/> - Tempo mais rÃ¡pido de lanÃ§amento no mercado                                                                                          |
| ProduÃ§Ã£o de bloco         | - Sequenciamento como serviÃ§o<br/>- Conjunto descentralizado de Sequencers por projeto                                                         |
| SeguranÃ§a                 | - SeguranÃ§a de nÃ­vel Ethereum desde o inÃ­cio                                                                                          |
| Finalidade/LiquidaÃ§Ã£o      | - DeterminÃ­stico<br/>- Finalidade em segundos                                                                                         |
| Custo                     | - TÃ­tulo de registro + Template de pagamento conforme o uso                                                                                         |
| PersonalizaÃ§Ã£o          | - Escolha o mecanismo de governanÃ§a que melhor se adapta ao seu projeto<br/> - Estrutura modular<br/>- PersonalizaÃ§Ã£o completa do Runtime<br/> |
| IntegraÃ§Ãµes e ferramentas | - Ferramentas essenciais disponÃ­veis desde o inÃ­cio                                                                                        |

## Arquitetura Geral da Tanssi e Appchains powered by Tanssi {: #tanssi-architecture }

Como discutido anteriormente, as appchains implantadas por meio da Tanssi sÃ£o blockchains soberanas e personalizÃ¡veis que, entre outros recursos, aproveitam o sequenciamento como serviÃ§o e herdam a finalidade do bloco de um provedor de seguranÃ§a externo.

Uma visÃ£o geral de alto nÃ­vel da arquitetura Ã© apresentada abaixo, apresentando [Symbiotic](https://symbiotic.fi/){target=\_blank} como o provedor de seguranÃ§a.

![VisÃ£o geral de alto nÃ­vel de uma appchain e Tanssi](/images/learn/tanssi/overview/overview-1.webp)

O protocolo Tanssi gerencia e orquestra um conjunto descentralizado de Sequencers atribuÃ­dos a fornecer serviÃ§os de produÃ§Ã£o de blocos para appchains powered by Tanssi. Os Sequencers executam transaÃ§Ãµes e as incluem em blocos, que os operators do provedor de seguranÃ§a prosseguem para validar. O protocolo de restaking da Symbiotic permite que seus operators ofereÃ§am seguranÃ§a econÃ´mica de nÃ­vel Ethereum. O mecanismo de como isso funciona Ã© explicado em dois artigos separados: [ServiÃ§os de ProduÃ§Ã£o de Blocos](/pt/learn/tanssi/network-services/block-production/){target=\_blank} e [Ethereum com Symbiotic](/pt/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}.

Embora os Sequencers que fornecem serviÃ§os de produÃ§Ã£o de blocos sejam rotacionados e realocados para uma appchain diferente a cada mudanÃ§a de sessÃ£o, cada appchain terÃ¡ seu prÃ³prio conjunto de Preservadores de Dados executando nÃ³s de arquivo completos, garantindo a disponibilidade de dados. Esses Preservadores de Dados fornecerÃ£o a infraestrutura RPC para aplicativos e usuÃ¡rios que interagem com appchains powered by Tanssi.

![Preservadores de dados de uma appchain e Tanssi](/images/learn/tanssi/overview/overview-2.webp)

## O Que Vem a Seguir? {: #whats-next }

- VÃ¡ para o [Tanssi dApp](https://apps.tanssi.network){target=\_blank} e lance sua appchain.
- Interaja com uma appchain powered by Tanssi ao vivo: a [Tanssi Demo EVM appchain](/pt/builders/tanssi-network/testnet/demo-evm-network/){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/learn/tanssi/tanssi-ethereum-bridge/
--- BEGIN CONTENT ---
---
title: Bridge Tanssi-Ethereum
description: Descubra como a bridge Tanssi permite interoperabilidade segura e sem confianÃ§a, facilitando transferÃªncias de ativos e mensagens entre Tanssi e Ethereum.
icon: octicons-link-24
categories: Basics
---

# Bridge Tanssi-Ethereum {: #tanssi-ethereum-bridge }

## IntroduÃ§Ã£o {: #introduction }

Blockchains tradicionais frequentemente criam silos, limitando a interoperabilidade de ativos e funcionalidades. A bridge Tanssi-Ethereum supera essas limitaÃ§Ãµes ao permitir operaÃ§Ãµes multichain contÃ­nuas que beneficiam ambos os ecossistemas.

A bridge Ã© mais do que uma troca de ativos. Ã‰ um protocolo seguro e padronizado para interaÃ§Ã£o direta entre cadeias, sem intermediÃ¡rios centralizados. Seu design sem confianÃ§a evita os riscos de pontos centrais de falha que muitas outras pontes enfrentam.

Este artigo apresenta a bridge Tanssi-Ethereum como uma camada fundamental de interoperabilidade entre as duas redes. VocÃª aprenderÃ¡ como ela funciona, incluindo sua arquitetura, gestÃ£o de operators, Template econÃ´mico, mecanismos de slashing e transferÃªncias de ativos.

VocÃª tambÃ©m conhecerÃ¡ as camadas de consenso que protegem a comunicaÃ§Ã£o ([BEEFY](https://docs.snowbridge.network/architecture/components#beefyclient){target=\_blank} em [Tanssi](/pt/learn/tanssi/){target=\_blank} e a [Beacon Chain do Ethereum](https://ethereum.org/roadmap/beacon-chain/){target=\_blank}), alÃ©m dos papÃ©is de provers, verifiers e relayers, oferecendo uma visÃ£o clara de como ativos e mensagens se movem com seguranÃ§a entre Tanssi e Ethereum.

## FunÃ§Ãµes Principais {: #core-functions }

A bridge facilita vÃ¡rias operaÃ§Ãµes crÃ­ticas entre Tanssi e Ethereum:

- **GestÃ£o de Operators** - mantÃ©m informaÃ§Ãµes de stake de operators no Ethereum via o protocolo [Symbiotic](/pt/learn/tanssi/external-security-providers/symbiotic/#tanssi-symbiotic){target=\_blank}, fornecendo esses dados Ã  Tanssi para selecionar operators ativos, descentralizados e economicamente alinhados a cada era
- **OperaÃ§Ãµes EconÃ´micas** - distribui [recompensas](/pt/learn/tanssi/external-security-providers/symbiotic/#rewards){target=\_blank} da Tanssi para stakers e operators no Ethereum
- **Slashing** - processa [solicitaÃ§Ãµes de slashing](/pt/learn/tanssi/external-security-providers/symbiotic/#slashing){target=\_blank} da Tanssi para o Ethereum quando operators violam as regras do protocolo
- **TransferÃªncia de Ativos** - permite transferÃªncias bilaterais e sem confianÃ§a de ativos entre Tanssi e Ethereum, aumentando a liquidez.

Essa interoperabilidade amplia o potencial de aplicaÃ§Ãµes descentralizadas e melhora significativamente a liquidez e a usabilidade de ativos em blockchain.

## Arquitetura da Bridge {: #bridge-architecture }

Entender a funcionalidade de consenso da bridge requer examinar seus componentes principais: provers, verifiers e relayers. Provers geram provas criptogrÃ¡ficas, verifiers as validam e relayers transportam dados entre as cadeias.

Os provers incluem o mÃ³dulo [BEEFY](https://docs.snowbridge.network/architecture/components#beefyclient){target=\_blank} da Tanssi e o consenso da Beacon Chain do Ethereum. Eles produzem dados de consenso transmitidos por relayers especializados.

Cada cadeia executa um [light client](https://ethereum.org/developers/docs/nodes-and-clients/light-clients/){target=\_blank} da outra, atuando como verificador on-chain da legitimidade dos dados. Por exemplo, quando o Tanssi envia uma mensagem ao Ethereum, ele gera provas compactas de eventos ou mudanÃ§as de estado baseadas em seu consenso. O light client do Ethereum verifica essas provas antes de agir. Esse mÃ©todo eficiente evita processar todo o estado da cadeia de origem, confiando em vez disso na verificaÃ§Ã£o de provas criptogrÃ¡ficas concisas.

### Consenso de Tanssi para Ethereum  {: #tanssi-ethereum-consensus }

BEEFY (Bridge Efficiency Enabling Finality Yielder) Ã© o protocolo de consenso da Tanssi, atuando como prover. Ele foi projetado para bridge sem confianÃ§a e eficiente para cadeias como o Ethereum, que nÃ£o sÃ£o nativamente construÃ­das para interoperabilidade.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Tanssi_Pallet as Tanssi <br/> Pallet BEEFY (prover)
    participant Beefy_Relayer as Relayer <br/> (Beefy)
    participant Eth_BeefyClient as Ethereum <br/> Cliente BEEFY (verifier)

    Tanssi_Pallet->>Beefy_Relayer: Gerar compromisso BEEFY
    activate Beefy_Relayer
    Beefy_Relayer->>Eth_BeefyClient: Enviar compromisso/prova
    deactivate Beefy_Relayer

    activate Eth_BeefyClient
    Eth_BeefyClient->>Eth_BeefyClient: Verificar compromisso
    deactivate Eth_BeefyClient

```

### Consenso de Ethereum para Tanssi {: #ethereum-tanssi-consensus }

Para a bridge de Ethereum para Tanssi, o consenso da Beacon Chain do Ethereum Ã© o prover. Ele fornece ao light client on-chain da Tanssi a prova do estado finalizado do Ethereum, incluindo eventos ou mensagens destinadas Ã  Tanssi.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Eth_BeaconCons as Ethereum <br/> Consenso da Beacon Chain (Prover)
    participant Beacon_Relayer as Relayer <br/> (Beacon)
    participant Tanssi_EthClient as Tanssi <br/> Cliente Light de Ethereum (verifier)

    Eth_BeaconCons->>Beacon_Relayer: AtualizaÃ§Ã£o da Beacon chain (Header/Proof)
    activate Beacon_Relayer
    Beacon_Relayer->>Tanssi_EthClient: Enviar atualizaÃ§Ã£o/prova
    deactivate Beacon_Relayer

    activate Tanssi_EthClient
    Tanssi_EthClient->>Tanssi_EthClient: Verificar atualizaÃ§Ã£o/prova
    deactivate Tanssi_EthClient
```

Do ponto de vista das mensagens, a bridge usa sua camada de verificaÃ§Ã£o de consenso para comunicaÃ§Ã£o multichain segura. Relayers dedicados transportam mensagens: o Execution Relay para Ethereum â†’ Tanssi e o Tanssi Relay para Tanssi â†’ Ethereum.

Relayers sÃ£o stateless e apenas submetem provas. Eles nÃ£o podem forjar mensagens ou roubar fundos, pois o mecanismo de consenso revalida cada prova on-chain. VÃ¡rios relayers em paralelo melhoram a responsividade sem centralizar poder.

O contrato `Gateway` do Ethereum Ã© o ponto central de mensagens. Ele recebe mensagens da Tanssi via relayers, valida-as usando provas de consenso e executa operaÃ§Ãµes como cunhagem/desbloqueio de tokens ou chamadas de contratos inteligentes.

### Mensagens de Entrada de Ethereum para Tanssi {: #ethereum-tanssi-messages }

Esta seÃ§Ã£o descreve mensagens de Ethereum para Tanssi, usando o consenso da Beacon Chain do Ethereum para provas e um Execution Relay (ou Beacon Relay).

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Eth_Gateway as Ethereum <br/> Contrato Gateway
    participant Exec_Relay as Relayer <br/> (Execution Relay)
    participant Tanssi_InQueue as Tanssi <br/> Fila de Entrada

    Note over Eth_Gateway: Mensagem pronta / Evento ocorre
    Eth_Gateway->>Exec_Relay: Mensagem + Prova
    activate Exec_Relay
    Exec_Relay->>Tanssi_InQueue: Submeter mensagem/prova
    deactivate Exec_Relay

    activate Tanssi_InQueue
    Tanssi_InQueue->>Tanssi_InQueue: Processar mensagem de entrada
    deactivate Tanssi_InQueue
```

### Mensagens de SaÃ­da de Tanssi para Ethereum {: #tanssi-ethereum-messages }

Esta seÃ§Ã£o descreve mensagens de Tanssi para Ethereum, usando o consenso BEEFY para provar o estado da Tanssi e um Tanssi Relay para a transmissÃ£o.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Tanssi_OutQueue as Tanssi <br/> Fila de SaÃ­da
    participant Para_Relay as Relayer <br/> (Tanssi Relay)
    participant Eth_Gateway as Ethereum <br/> Contrato Gateway

    Note over Tanssi_OutQueue: Mensagem pronta / Prova confirmada
    Tanssi_OutQueue->>Para_Relay: Mensagem + Prova
    activate Para_Relay
    Para_Relay->>Eth_Gateway: Submeter mensagem/prova
    deactivate Para_Relay

    activate Eth_Gateway
    Eth_Gateway->>Eth_Gateway: Processar mensagem de saÃ­da
    deactivate Eth_Gateway
```

O `Gateway` gerencia as comunicaÃ§Ãµes de saÃ­da do Ethereum. Para transferÃªncias entre cadeias, ele registra um evento, bloqueia tokens se necessÃ¡rio e empacota os dados para envio Ã  Tanssi. O Tanssi usa duas filas para processar mensagens com eficiÃªncia.

A `Fila de SaÃ­da` lida com mensagens para o Ethereum. Ela as agrupa e adiciona uma [raiz de Merkle](https://en.wikipedia.org/wiki/Merkle_tree){target=\_blank} (compromisso criptogrÃ¡fico) a cada cabeÃ§alho de bloco. Isso permite que o light client do Ethereum verifique a inclusÃ£o de mensagens usando provas de consenso de forma eficiente.

A `Fila de Entrada` processa mensagens vindas do Ethereum. Ela recebe e verifica provas de eventos do Ethereum por meio do light client de Ethereum on-chain da Tanssi. Eventos verificados tornam-se instruÃ§Ãµes internas na Tanssi. Essa arquitetura em camadas, protegida por consenso, garante interaÃ§Ãµes sem confianÃ§a entre cadeias.

## Fluxo de TransferÃªncia de Tokens {: #token-transfers-flow }

Esta seÃ§Ã£o explica como a bridge move ativos e mensagens. Ela envolve o bloqueio/cunhagem de ativos em uma cadeia e uma aÃ§Ã£o complementar na outra, protegida por provas verificadas. A seguir, sÃ£o descritas as sequÃªncias tÃ­picas de transferÃªncia.

1. **InÃ­cio (Cadeia de Origem)** - o usuÃ¡rio inicia a transferÃªncia de ativos
2. **Prova via Relay** - relayers off-chain coletam o evento e enviam provas criptogrÃ¡ficas para a cadeia de destino
3. **VerificaÃ§Ã£o (Cadeia de Destino)** - light clients on-chain verificam de forma independente as provas enviadas
4. **ExecuÃ§Ã£o** - apÃ³s verificaÃ§Ã£o bem-sucedida, tokens sÃ£o cunhados/desbloqueados na cadeia de destino

### TransferÃªncia de Ethereum para Tanssi

Esta seÃ§Ã£o detalha a movimentaÃ§Ã£o de ativos do Ethereum para a Tanssi (como ativos derivativos).

1. **Bloquear no Ethereum** - um usuÃ¡rio deposita ativos no contrato da Bridge do Ethereum. O contrato bloqueia os tokens e emite um evento de depÃ³sito
2. **Enviar Prova Ã  Tanssi** - um relayer off-chain detecta o evento finalizado, cria um pacote de prova (incluindo o cabeÃ§alho do bloco do Ethereum e a prova de Merkle do depÃ³sito) e o envia para a `Fila de Entrada` da Bridge da Tanssi
3. **Verificar na Tanssi** - o mÃ³dulo `EthereumClient` da Bridge da Tanssi (um light client on-chain) recebe a prova da `Fila de Entrada`. Ele verifica a finalizaÃ§Ã£o/validade do cabeÃ§alho do bloco do Ethereum e a autenticidade da prova de Merkle
4. **Cunhar na Tanssi** - apÃ³s a verificaÃ§Ã£o bem-sucedida pelo `EthereumClient`, a `Fila de Entrada` Ã© notificada e cunha o ativo correspondente na Tanssi

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant User
    participant EBridge as Contrato da Bridge <br/> no Ethereum
    participant Relayer
    participant TBP as Bridge da Tanssi<br/> (Fila de Entrada + Cliente ETH)
    participant TAH as Tanssi

    User->>EBridge: 1. Depositar ativo
    activate EBridge
    Note over EBridge: Bloquear tokens e emitir evento
    deactivate EBridge

    Relayer->>Relayer: Observar evento no Ethereum
    Relayer->>TBP: 2. Enviar cabeÃ§alho + prova de Merkle
    activate TBP
    Note over TBP: Receber prova (Fila de Entrada)
    TBP->>TBP: 3. Verificar prova (Pallet EthereumClient)
    TBP->>TAH: Enviar solicitaÃ§Ã£o de cunhagem
    deactivate TBP

    activate TAH
    TAH->>TAH: 4. Cunhar ativo
    TAH-->>User: (Ativo aparece na conta do destinatÃ¡rio)
    deactivate TAH
```

### TransferÃªncia de Tanssi para Ethereum

Este fluxo descreve o processo inverso, movendo ativos da Tanssi para o Ethereum.

1. **Iniciar e Confirmar na Tanssi** - o usuÃ¡rio inicia uma transferÃªncia na Tanssi. Uma mensagem com os detalhes da transferÃªncia vai para a `Fila de SaÃ­da` da Bridge. A fila processa, agrupa o payload e confirma sua raiz de Merkle no cabeÃ§alho do bloco da Tanssi, representando todas as mensagens de saÃ­da nesse bloco
2. **Enviar Prova ao Ethereum** - um relayer off-chain monitora o Tanssi em busca de blocos finalizados com raÃ­zes de Merkle da `Fila de SaÃ­da`. Ele obtÃ©m as provas: um compromisso BEEFY (declaraÃ§Ã£o assinada de cabeÃ§alhos de bloco finalizados da Tanssi) e uma prova de Merkle do payload da transferÃªncia do usuÃ¡rio sob a raiz confirmada
3. **Submeter Compromisso no Ethereum** - o relayer envia o compromisso BEEFY e a prova de Merkle para o contrato `Gateway` do Ethereum
4. **Verificar no Ethereum** - o contrato Beefy Client do Ethereum (light client on-chain da Tanssi) recebe o compromisso BEEFY do `Gateway` e verifica sua validade (incluindo assinaturas)
5. **Validar Payload** - apÃ³s a verificaÃ§Ã£o do compromisso, o `Gateway` valida a prova de Merkle do payload do usuÃ¡rio
6. **Executar no Ethereum** - com ambas as provas verificadas, o contrato `Gateway` executa a aÃ§Ã£o, normalmente liberando ativos bloqueados pelo contrato principal da Bridge para o destinatÃ¡rio ou executando uma chamada para o contrato-alvo no Ethereum

O diagrama a seguir ilustra a fase de inÃ­cio e confirmaÃ§Ã£o do processo de transferÃªncia de ativos na Tanssi.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant User
    participant TAH as Tanssi
    participant TBP as Bridge da Tanssi<br/> (Fila de SaÃ­da)
    participant Relayer

    User->>TAH: 1. Iniciar transferÃªncia e depositar ativo
    activate TAH
    TAH->>TBP: Enviar mensagem para a Fila de SaÃ­da
    deactivate TAH

    activate TBP
    Note over TBP: Processar mensagem, agrupar e<br/>confirmar raiz de Merkle no cabeÃ§alho da Tanssi
    deactivate TBP

    Relayer->>Relayer: 2. Observar cabeÃ§alho da Tanssi /<br/>compromisso BEEFY e obter prova
    Note over Relayer: O relayer agora estÃ¡ pronto para interagir<br/>com o Ethereum com base nos dados observados.
```

O diagrama seguinte detalha as etapas de relay, verificaÃ§Ã£o e execuÃ§Ã£o no lado do Ethereum para a transferÃªncia de ativos.

```mermaid
sequenceDiagram
    %%{init: {'sequence': {'mirrorActors': false}}}%%
    participant Relayer
    participant EGateway as Contrato Gateway <br/> do Ethereum
    participant EBeefy as Contrato Beefy Client <br/> do Ethereum
    participant EBridge as Contrato da Bridge <br/> do Ethereum
    participant User

    Relayer->>EGateway: 3. Submeter compromisso BEEFY + prova de Merkle
    activate EGateway
    EGateway->>EBeefy: 4. Verificar compromisso BEEFY
    activate EBeefy
    EBeefy-->>EGateway: VerificaÃ§Ã£o OK
    deactivate EBeefy

    EGateway->>EGateway: 5. Verificar prova de Merkle do payload
    Note over EGateway: Prova validada

    EGateway->>EBridge: 6. Executar: desbloquear tokens / chamar contrato-alvo
    activate EBridge
    Note over EBridge: Ativos transferidos ou<br/>chamada ao contrato-alvo executada
    EBridge-->>User: (Tokens recebidos / chamada executada)
    deactivate EBridge
    deactivate EGateway
```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/
--- BEGIN CONTENT ---
---
title: Executar Infraestrutura na Tanssi
description: Esta secÃ§Ã£o oferece guias para configurar infraestruturas e nÃ³s para serviÃ§os RPC, produÃ§Ã£o de blocos e validaÃ§Ã£o dentro do ecossistema Tanssi.
template: root-index-page.html
---

# Node Operators

A operaÃ§Ã£o de nÃ³s Ã© uma parte crucial para manter um ecossistema de blockchain, e o Tanssi garante que esse processo seja o mais perfeito possÃ­vel. Da execuÃ§Ã£o de nÃ³s de rede e gerenciamento de Sequencers Ã  integraÃ§Ã£o de operators, esta seÃ§Ã£o fornece tudo o que vocÃª precisa para comeÃ§ar e operar com eficiÃªncia.

Se vocÃª estÃ¡ configurando pela primeira vez, lidando com tarefas operacionais ou aposentando seu nÃ³, esses guias oferecem instruÃ§Ãµes claras e concisas para ajudÃ¡-lo a manter operaÃ§Ãµes seguras e confiÃ¡veis.

### Tipos de NÃ³s no Ecossistema Tanssi

A compreensÃ£o dos papÃ©is de diferentes nÃ³s na rede Powered by Tanssi ajuda vocÃª a escolher o certo com base no seu nÃ­vel desejado de participaÃ§Ã£o no ecossistema Tanssi:

- [**NÃ³s de Rede**](/pt/node-operators/network-node/) - fornecem endpoints RPC e serviÃ§os de disponibilidade de dados para fluxo de dados e interaÃ§Ã£o suaves entre cadeias e usuÃ¡rios
- [**Sequencers**](/pt/node-operators/sequencers/) - responsÃ¡veis pela produÃ§Ã£o de blocos dentro do ecossistema Tanssi, os Sequencers coletam transaÃ§Ãµes, as executam e as compilam em blocos, mantendo a vivacidade e a continuidade operacional para todas as redes Powered by Tanssi
- [**Operators**](/pt/node-operators/operators/) - tambÃ©m conhecidos como validadores de rede, os operators sÃ£o responsÃ¡veis por proteger o ecossistema. Eles verificam cada bloco produzido por Sequencers dentro das redes Powered by Tanssi, verificando se as transaÃ§Ãµes incluÃ­das sÃ£o vÃ¡lidas. Os operators devem se registrar e apostar no provedor de seguranÃ§a (por exemplo, [Symbiotic](/pt/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}). Eles tambÃ©m produzem blocos para a prÃ³pria rede Tanssi, mantendo sua vivacidade

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/network-node/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³
description: Aprenda como configurar e executar nÃ³s para Tanssi e redes Powered by Tanssi. Isso permitirÃ¡ que vocÃª hospede seus prÃ³prios endpoints RPC para interaÃ§Ã£o com a cadeia.
icon: octicons-globe-24
template: index-page.html
---

# Executar um NÃ³

A configuraÃ§Ã£o de um nÃ³ de rede Ã© essencial para interagir com a Tanssi ou sua rede Powered by Tanssi, fornecendo um endpoint RPC seguro e dedicado. Esta seÃ§Ã£o oferece guias passo a passo para ajudÃ¡-lo a configurar e gerenciar diferentes tipos de nÃ³s de forma eficaz.

- [**NÃ³ Tanssi**](/pt/node-operators/network-node/tanssi) - um nÃ³ Tanssi se conecta diretamente Ã  rede Tanssi, permitindo que vocÃª interaja via endpoint RPC
- [**NÃ³ de Rede Powered by Tanssi**](/pt/node-operators/network-node/tanssi-powered-network) - execute um nÃ³ para sua rede Powered by Tanssi, permitindo que vocÃª mantenha seu prÃ³prio endpoint RPC

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/network-node/tanssi-powered-network/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³ em uma Rede Tanssi-Powered
description: Aprenda como configurar e executar um nÃ³ em uma rede Tanssi-powered usando Docker ou Systemd, o que permite que vocÃª hospede seu prÃ³prio endpoint RPC para interaÃ§Ã£o com a cadeia.
icon: octicons-globe-24
template: index-page.html
---

# Executar um NÃ³ em uma Rede Tanssi-Powered

A configuraÃ§Ã£o de um nÃ³ de rede Ã© essencial para interagir com sua rede Tanssi-powered e fornecer um endpoint RPC seguro e dedicado. Esta seÃ§Ã£o oferece guias passo a passo para ajudÃ¡-lo a configurar e gerenciar seu nÃ³ de forma eficaz. Explore duas abordagens diferentes para executar seu nÃ³:

- [**Usando Docker**](/pt/node-operators/network-node/tanssi-powered-network/rpc-docker/) - instruÃ§Ãµes para configurar seu nÃ³ em um ambiente conteinerizado para fÃ¡cil implantaÃ§Ã£o e isolamento
- [**Usando Systemd**](/pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/) - orientaÃ§Ã£o para configurar seu nÃ³ como um serviÃ§o, permitindo o gerenciamento automatizado e a integraÃ§Ã£o do sistema

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/network-node/tanssi-powered-network/rpc-docker/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³ Appchain Usando Docker
description: Descubra como configurar e operar um nÃ³ appchain powered by Tanssi usando Docker, permitindo hospedar seu prÃ³prio endpoint RPC para interagir com sua appchain.
icon: material-docker
categories: RPC-Data-Preservers
---

# Executar um NÃ³ Appchain usando Docker

## IntroduÃ§Ã£o {: #introduction }

Executar um nÃ³ de appchain com Tanssi permite conectar e interagir com a appchain usando sua prÃ³pria infraestrutura via HTTP ou WebSocket.

Os nÃ³s armazenam dados de blocos e estado da rede. HÃ¡ diferentes tipos que os desenvolvedores podem operar:

- **NÃ³ Arquivo Completo** - armazena todos os dados de blocos e estados da rede em todas as alturas. Ãštil para consultar dados histÃ³ricos, mas consome muito espaÃ§o
- **NÃ³ Podado Completo** - armazena dados de blocos e estado atÃ© um certo nÃºmero de blocos antes da altura atual. Ãštil para consultar dados recentes ou enviar transaÃ§Ãµes pela sua infraestrutura. Requer bem menos espaÃ§o que um nÃ³ arquival, mas nÃ£o mantÃ©m todo o estado da rede

Neste guia, vocÃª aprenderÃ¡ como iniciar rapidamente um nÃ³ appchain Tanssi usando [Docker](https://www.docker.com){target=_blank} em um computador Linux. Ele pode ser adaptado para outros sistemas operacionais.

!!! note
    NÃ£o Ã© possÃ­vel executar um nÃ³ RPC para appchains de teste rÃ¡pidas, pois elas rodam em uma rede privada e, portanto, nÃ£o estÃ£o acessÃ­veis para sincronizaÃ§Ã£o.

## VerificaÃ§Ã£o de PrÃ©-requisitos {: #checking-prerequisites }

### Instalando o Docker {: #installing-docker}

Para comeÃ§ar, vocÃª precisarÃ¡ de um computador com Linux e instalar o [Docker](https://docs.docker.com/desktop/setup/install/linux/){target=\blank}.

Execute o comando a seguir para instalar o Docker em um Ubuntu:

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

E o comando abaixo para verificar a instalaÃ§Ã£o:

```bash
sudo docker run hello-world
```

Uma execuÃ§Ã£o bem-sucedida no terminal se parece com isto:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>sudo docker run hello-world</span>
  <span data-ty>
    <br> 
    <br> Hello from Docker!
    <br> This message shows that your installation appears to be working correctly.
    <br> 
    <br> To generate this message, Docker took the following steps:
    <br> 1. The Docker client contacted the Docker daemon.
    <br> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    <br>     (amd64)
    <br> 3. The Docker daemon created a new container from that image which runs the
    <br>     executable that produces the output you are currently reading.
    <br> 4. The Docker daemon streamed that output to the Docker client, which sent it
    <br>     to your terminal.
    <br>
    <br> To try something more ambitious, you can run an Ubuntu container with:
    <br> $ docker run -it ubuntu bash
    <br>
    <br> Share images, automate workflows, and more with a free Docker ID:
    <br> https://hub.docker.com/
    <br>
    <br> For more examples and ideas, visit:
    <br>  https://docs.docker.com/get-started/
  </span>
</div>

## Obtendo os arquivos de especificaÃ§Ã£o {: #getting-specifications-files }

Um nÃ³ de appchain precisa de informaÃ§Ãµes sobre duas blockchains para funcionar corretamente: a prÃ³pria appchain e a cadeia de orquestraÃ§Ã£o do Tanssi.

Essas informaÃ§Ãµes ficam em um arquivo de especificaÃ§Ãµes de cadeia, que inclui, entre outras coisas, o estado gÃªnesis, permitindo que o nÃ³ verifique e sincronize corretamente os blocos e estados recebidos de outros nÃ³s.

Para obter o arquivo de especificaÃ§Ã£o do Tanssi, execute:

=== "Tanssi MainNet"

    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json
    ```

=== "Dancelight TestNet"
    
    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json
    ```

Para obter o arquivo de especificaÃ§Ã£o da appchain, baixe-o no dashboard do [dApp](https://apps.tanssi.network){target=\_blank} clicando no link **Network Data**.

![Getting the chain specs](/images/node-operators/network-node/rpc-systemd/rpc-systemd-1.webp)

## Configurar o diretÃ³rio de dados {: #setup-data-directory }

Executar um sequenciador ou um nÃ³ de appchain exige sincronizar duas cadeias: a cadeia de orquestraÃ§Ã£o do Tanssi e a appchain para a qual ele trabalha.

Crie o diretÃ³rio onde o nÃ³ armazenarÃ¡ os bancos de dados contendo blocos e estados de cadeia:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the Docker image to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    chown INSERT_DOCKER_USER /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    chown INSERT_DOCKER_USER /var/lib/dancelight-data
    ```

Ou execute o comando abaixo se quiser rodar o sequenciador com o usuÃ¡rio logado:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data
    ```

Move the chain specification file to the folder:

=== "Tanssi MainNet"

    ```bash
    mv ./starlight-raw-specs.json /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    mv ./dancelight-raw-specs.json /var/lib/dancelight-data
    ```

!!! note
    O diretÃ³rio Ã© um parÃ¢metro no comando de inicializaÃ§Ã£o do Docker. Se optar por criar o diretÃ³rio em outro lugar, ajuste o comando.

## Extraindo a Imagem Docker {: #pulling-docker-image }

Duas imagens Docker sÃ£o criadas e publicadas para cada versÃ£o: uma para appchains compatÃ­veis com EVM e outra para appchains Substrate.

Essas imagens incluem todos os binÃ¡rios necessÃ¡rios para executar a versÃ£o estÃ¡vel mais recente do [nÃ³ cliente](/pt/learn/framework/architecture/#architecture){target=_blank}.

Puxe a imagem correspondente ao tipo de appchain que vocÃª deseja executar.

### Appchains CompatÃ­veis com EVM {: #pulling-evm-docker-image }

Se a appchain foi registrada escolhendo o Template EVM ou enviando uma especificaÃ§Ã£o personalizada compatÃ­vel com EVM, execute:

=== "Tanssi MainNet"

    ```bash
    docker pull moondancelabs/container-chain-evm-template
    ```

=== "Dancelight TestNet"

    ```bash
    docker pull moondancelabs/container-chain-evm-template
    ```

O comando farÃ¡ download e extraÃ§Ã£o da imagem e exibirÃ¡ o status apÃ³s a execuÃ§Ã£o:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker pull moondancelabs/container-chain-evm-template</span>
  <span data-ty>
    <br> 
    <br> Using default tag: latest
    <br> latest: Pulling from moondancelabs/container-chain-evm-template
    <br> 31ad3619f756: Already exists 
    <br> 8f3d9759dcde: Pull complete 
    <br> de5eaba9b289: Pull complete 
    <br> Digest: sha256:4930d631a8ac7f7852754d4cf77bb3317229d768f44092a00295ba50641b2a33
    <br> Status: Downloaded newer image for moondancelabs/container-chain-evm-template
    <br> docker.io/moondancelabs/container-chain-evm-template:latest
  </span>
</div>

### Appchains Substrate Simples {: #pulling-substrate-docker-image }

Se a appchain foi registrada escolhendo o Template Substrate bÃ¡sico ou enviando uma especificaÃ§Ã£o personalizada Substrate, execute:

=== "Tanssi MainNet"

    ```bash
    docker pull moondancelabs/container-chain-simple-template
    ```

=== "Dancelight TestNet"

    ```bash
    docker pull moondancelabs/container-chain-simple-template
    ```

O comando farÃ¡ download e extraÃ§Ã£o da imagem e exibirÃ¡ o status apÃ³s a execuÃ§Ã£o, semelhante ao exemplo anterior.

## Comando de InicializaÃ§Ã£o {: #start-up-command }

Para iniciar seu nÃ³, execute a imagem Docker com `docker run`. Altere conforme necessÃ¡rio:

- `Arquivo de especificaÃ§Ãµes da appchain` - substitua `INSERT_YOUR_APPCHAIN_SPECS_FILE` pelo nome do arquivo de specs baixado na etapa de [obtenÃ§Ã£o das especificaÃ§Ãµes](#checking-prerequisites).
- `Bootnode` - Ã© um nÃ³ arquivo completo usado para sincronizar a rede do zero. VocÃª precisarÃ¡ [recuperar o bootnode da sua rede Tanssi](#fetching-bootnode-information) e substituir `INSERT_YOUR_NETWORK_BOOTNODES` pela informaÃ§Ã£o real de bootnode.

=== "Tanssi MainNet"

    === "Appchain compatÃ­vel com EVM"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        moondancelabs/container-chain-evm-template \
        --chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \
--rpc-port=9944 \
--name=appchain \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--name=relay \
--chain=/data/starlight-raw-specs.json \
--rpc-port=9945 \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC
        ```

    === "Appchain Substrate Simples"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        moondancelabs/container-chain-simple-template \
        --chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \
--rpc-port=9944 \
--name=appchain \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--name=relay \
--chain=/data/starlight-raw-specs.json \
--rpc-port=9945 \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC
        ```

=== "Dancelight TestNet"

    === "Appchain compatÃ­vel com EVM"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        moondancelabs/container-chain-evm-template \
        --chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \
--rpc-port=9944 \
--name=appchain \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--name=relay \
--chain=/data/dancelight-raw-specs.json \
--rpc-port=9945 \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT
        ```

    === "Appchain Substrate Simples"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        moondancelabs/container-chain-simple-template \
        --chain=INSERT_YOUR_APPCHAIN_SPECS_FILE \
--rpc-port=9944 \
--name=appchain \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--name=relay \
--chain=/data/dancelight-raw-specs.json \
--rpc-port=9945 \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT
        ```

!!! note
    Por padrÃ£o, apenas o estado histÃ³rico dos Ãºltimos 256 blocos finalizados Ã© mantido. Para executar um nÃ³ de arquivo completo, defina a flag `--state-pruning archive`. Mais informaÃ§Ãµes na [seÃ§Ã£o de sinalizadores](#run-flags).

### Obtendo informaÃ§Ãµes de bootnode {: #fetching-bootnode-information}

As informaÃ§Ãµes de bootnode podem ser lidas diretamente no Tanssi. Por exemplo, vocÃª pode usar o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/chainstate){target=\_blank} para obter os bootnodes de uma rede especÃ­fica no [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.

Para isso, siga estas etapas:

1. Selecione **dataPreservers** como o mÃ³dulo a consultar
2. Defina a consulta de armazenamento como **bootNodes**
3. Informe o ID da sua rede Tanssi
4. Clique no sinal de **+**

![Obtendo o bootnode](/images/node-operators/network-node/rpc-docker-systemd-1.webp)

### Exemplo de NÃ³ Completo para Demo EVM Appchain {: #example-demo-evm-appchain }

O exemplo abaixo inicia um nÃ³ RPC de arquivo completo para a [rede demo EVM](/pt/builders/tanssi-network/testnet/demo-evm-network/){target=_blank} implantada na Dancelight (ID `2001`). Assume que os arquivos de specs estÃ£o na pasta de dados.

=== "Demo EVM Appchain (Dancelight)"

    ```bash
    docker run --network="host" -v "/var/lib/dancelight-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    moondancelabs/container-chain-evm-template \
    --chain=/data/container-2001-raw-specs.json \
    --rpc-port=9944 \
    --name=demoAppchain \
    --state-pruning=archive \
    --blocks-pruning=archive \
    --database=paritydb \
    --unsafe-rpc-external \
    --bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \
    --bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \
    -- \
    --chain=/data/dancelight-raw-specs.json \
    --rpc-port=9945 \
    --name=relay \
    --sync=fast \
    --database=paritydb \
    --bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
    --bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
    --bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT
    ```

### Executar Sinalizadores {: #run-flags }

As flags usadas no `docker run` podem ser ajustadas conforme suas preferÃªncias e hardware. Algumas das principais:

- `--name INSERT_NAME` - nome legÃ­vel para este nÃ³
- `--rpc-port INSERT_PORT` - define a porta TCP do JSON-RPC na qual o nÃ³ ouve
- `--unsafe-rpc-external` - expÃµe o serviÃ§o RPC em todas as interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser `archive` (nÃ³ atua como completo mantendo todo o estado), `archive-canonical` (mantÃ©m apenas estados de blocos finalizados) ou um `number` (quantidade de blocos cujos estados serÃ£o mantidos)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - define quantos blocos devem ser mantidos no banco de dados. Pode ser `archive` (nÃ³ completo mantendo todos os blocos), `archive-canonical` (mantÃ©m apenas blocos finalizados) ou um `number` (quantidade de blocos finalizados a manter)
- `--detailed-log-output` - habilita saÃ­da detalhada de logs

!!! warning
    O parÃ¢metro `--unsafe-rpc-external` permite acesso externo Ã  interface RPC do seu nÃ³, tornando-a acessÃ­vel de qualquer endereÃ§o IP. Certifique-se de que controles de seguranÃ§a adequados estejam configurados.

Para ver a lista completa de flags disponÃ­veis, descriÃ§Ã£o e valores possÃ­veis, execute:

=== "Appchain compatÃ­vel com EVM"

    ```bash
    docker run -ti moondancelabs/container-chain-evm-template --help
    ```

=== "Appchain Substrate Simples"

    ```bash
    docker run -ti moondancelabs/container-chain-simple-template --help
    ```

## Sincronizando Seu NÃ³ {: #syncing-your-node }

ApÃ³s iniciar, o processo de sincronizaÃ§Ã£o exibirÃ¡ muitos logs do nÃ³ e da appchain Tanssi. Alguns erros iniciais sÃ£o esperados e desaparecem quando a cadeia alcanÃ§a o Ãºltimo bloco.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker run ....</span>
  <span data-ty>
    <br> 2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] ðŸ’¤ Idle (0 peers), best: #0 (0x4a2bâ€¦7de3), finalized #0 (0x4a2bâ€¦7de3), â¬‡ 0 â¬† 0
    <br> 2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] âœ¨ Imported #14139635 (0x8c41â€¦8df6)    
    <br> 2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] ðŸ’¤ Idle (8 peers), best: #14139635 (0x8c41â€¦8df6), finalized #14139632 (0xa9a8â€¦cab9), â¬‡ 32.7kiB/s â¬†
  </span>
</div>

!!! note
    A duraÃ§Ã£o da sincronizaÃ§Ã£o Ã© proporcional ao tamanho da cadeia que estÃ¡ sendo sincronizada.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/network-node/tanssi-powered-network/rpc-systemd/
--- BEGIN CONTENT ---
---
title: Execute um NÃ³ Appchain Usando Systemd
description: Aprenda a configurar e executar um nÃ³ appchain powered by Tanssi usando Systemd, que permite ter seu prÃ³prio endpoint RPC para interagir com seu appchain.
icon: simple-linux
categories: RPC-Data-Preservers
---

# Execute um NÃ³ Appchain Usando Systemd

## IntroduÃ§Ã£o {: #introduction }

Executar um nÃ³ de appchain com Tanssi permite conectar e interagir com a appchain usando sua prÃ³pria infraestrutura via HTTP ou WebSocket.

Os nÃ³s armazenam dados de blocos e estado da rede. HÃ¡ diferentes tipos que os desenvolvedores podem operar:

- **NÃ³ Arquivo Completo** - armazena todos os dados de blocos e estados da rede em todas as alturas. Ãštil para consultar dados histÃ³ricos, mas consome muito espaÃ§o
- **NÃ³ Podado Completo** - armazena dados de blocos e estado atÃ© um certo nÃºmero de blocos antes da altura atual. Ãštil para consultar dados recentes ou enviar transaÃ§Ãµes pela sua infraestrutura. Requer bem menos espaÃ§o que um nÃ³ arquival, mas nÃ£o mantÃ©m todo o estado da rede

Neste guia, vocÃª aprenderÃ¡ a iniciar um nÃ³ appchain da Tanssi usando um binÃ¡rio executÃ¡vel e gerenciar o serviÃ§o com [Systemd](https://systemd.io){target=_blank} em sistemas Linux.

O artigo segue a boa prÃ¡tica de executar o serviÃ§o com uma conta nÃ£o-root e conceder a essa conta acesso de gravaÃ§Ã£o a um diretÃ³rio especÃ­fico. VocÃª pode adaptar as etapas Ã  sua configuraÃ§Ã£o, preferÃªncias e polÃ­ticas de seguranÃ§a.

!!! note
    NÃ£o Ã© possÃ­vel executar um nÃ³ RPC para appchains de teste rÃ¡pido, pois eles rodam em uma rede privada e, portanto, nÃ£o estÃ£o acessÃ­veis para sincronizaÃ§Ã£o.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para comeÃ§ar, vocÃª precisarÃ¡ de acesso a um computador executando Ubuntu Linux com privilÃ©gios de root. VocÃª tambÃ©m precisarÃ¡ de:

- **Arquivo binÃ¡rio do nÃ³** - as instruÃ§Ãµes executam a [versÃ£o estÃ¡vel mais recente](https://github.com/moondance-labs/tanssi/releases/latest){target=_blank}. Se quiser compilar e rodar o seu prÃ³prio arquivo, siga as instruÃ§Ãµes para [construir seu nÃ³ appchain](/pt/builders/build/customize/prerequisites/){target=_blank}.
- **Arquivos de especificaÃ§Ãµes de cadeia** - o nÃ³ precisa de informaÃ§Ãµes sobre duas blockchains diferentes para sincronizar e executar corretamente. A seÃ§Ã£o a seguir mostra como obtÃª-los.

## Obtendo os arquivos de especificaÃ§Ã£o {: #getting-specifications-files }

Um nÃ³ de appchain precisa de informaÃ§Ãµes sobre duas blockchains para funcionar corretamente: a prÃ³pria appchain e a cadeia de orquestraÃ§Ã£o do Tanssi.

Essas informaÃ§Ãµes ficam em um arquivo de especificaÃ§Ãµes de cadeia, que inclui, entre outras coisas, o estado gÃªnesis, permitindo que o nÃ³ verifique e sincronize corretamente os blocos e estados recebidos de outros nÃ³s.

Para obter o arquivo de especificaÃ§Ã£o do Tanssi, execute:

=== "Tanssi MainNet"

    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json
    ```

=== "Dancelight TestNet"
    
    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json
    ```

Para obter o arquivo de especificaÃ§Ã£o da appchain, baixe-o no dashboard do [dApp](https://apps.tanssi.network){target=\_blank} clicando no link **Network Data**.

![Getting the chain specs](/images/node-operators/network-node/rpc-systemd/rpc-systemd-1.webp)

## Baixe a VersÃ£o mais Recente {: #download-latest-release }

Cada nova versÃ£o inclui dois binÃ¡rios, um para redes compatÃ­veis com EVM e outro para redes Substrate. Para comeÃ§ar, execute o comando que corresponde ao seu tipo de rede e torne-o executÃ¡vel:

=== "Rede CompatÃ­vel com EVM"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/container-chain-frontier-node && \
    chmod +x ./container-chain-frontier-node
    ```

=== "Rede Substrate"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/container-chain-simple-node && \
    chmod +x ./container-chain-simple-node
    ```

!!! note
    Recomenda-se usar as versÃµes binÃ¡rias otimizadas para as arquiteturas [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} da Intel ou [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} da AMD para melhor desempenho.

## Configurar o serviÃ§o Systemd {: #setup-systemd-service }

O [Systemd](https://systemd.io){target=\_blank} Ã© um sistema de gerenciamento para Linux que controla serviÃ§os (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas inesperadas.

Os comandos a seguir configuram uma nova conta, o diretÃ³rio e movem os arquivos baixados para o local correto.

Crie uma nova conta para executar o serviÃ§o:

=== "Tanssi MainNet"

    ```bash
    adduser tanssi_service --system --no-create-home
    ```

=== "Dancelight TestNet"

    ```bash
    adduser dancelight_service --system --no-create-home
    ```

Crie um diretÃ³rio para armazenar os arquivos e dados necessÃ¡rios:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mkdir /var/lib/dancelight-data
    ```

Defina a propriedade da pasta para a conta que executarÃ¡ o serviÃ§o, garantindo permissÃ£o de escrita:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R tanssi_service /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    sudo chown -R dancelight_service /var/lib/dancelight-data
    ```

Mova o arquivo de especificaÃ§Ã£o da cadeia para a pasta:

=== "Tanssi MainNet"

    ```bash
    mv ./starlight-raw-specs.json /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mv ./dancelight-raw-specs.json /var/lib/dancelight-data
    ```

Mova tambÃ©m o binÃ¡rio do nÃ³:

=== "Tanssi MainNet"

    === "Appchain compatÃ­vel com EVM"

        ```bash
        mv ./container-chain-frontier-node /var/lib/tanssi-data
        ```

    === "Rede Substrate"

        ```bash
        mv ./container-chain-simple-node /var/lib/tanssi-data
        ```

=== "Dancelight TestNet"

    === "Appchain compatÃ­vel com EVM"

        ```bash
        mv ./container-chain-frontier-node /var/lib/dancelight-data
        ```

    === "Rede Substrate"

        ```bash
        mv ./container-chain-simple-node /var/lib/dancelight-data
        ```

Por fim, mova o arquivo de especificaÃ§Ãµes do seu appchain para a mesma pasta.

### Crie o Arquivo de ConfiguraÃ§Ã£o do ServiÃ§o Systemd {: #create-systemd-configuration }

A prÃ³xima etapa Ã© criar o arquivo de configuraÃ§Ã£o do Systemd.

VocÃª pode criar o arquivo executando:

```bash
sudo touch /etc/systemd/system/appchain.service
```

Em seguida, abra o arquivo no seu editor favorito e adicione a configuraÃ§Ã£o do serviÃ§o.

Note que o comando `ExecStart` tem parÃ¢metros que precisam ser ajustados para sua rede:

- `Arquivo de especificaÃ§Ã£o` - substitua `INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME` pelo nome do arquivo do seu appchain. Para um appchain MainNet, o caminho serÃ¡ parecido com `/var/lib/tanssi-data/SEU_ARQUIVO.json`.

- `Bootnode` - Ã© um nÃ³ arquivo completo usado para sincronizar a rede do zero. VocÃª precisarÃ¡ [recuperar o bootnode da sua rede Tanssi](#fetching-bootnode-information) e substituir `INSERT_YOUR_NETWORK_BOOTNODES` pela informaÃ§Ã£o real de bootnode.

=== "Tanssi MainNet"

    === "Appchain compatÃ­vel com EVM"

        ```bash
        [Unit]
        Description="ServiÃ§o systemd do Appchain"
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        Restart=on-failure
        RestartSec=10
        User=tanssi_service
        SyslogIdentifier=network
        SyslogFacility=local7
        KillSignal=SIGHUP
        ExecStart=/var/lib/tanssi-data/container-chain-frontier-node \
        --chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \
--rpc-port=9944 \
--name=para \
--base-path=/var/lib/tanssi-data \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--chain=/var/lib/tanssi-data/starlight-raw-specs.json \
--rpc-port=9945 \
--name=relay \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC

        [Install]
        WantedBy=multi-user.target
        ```

    === "Rede Substrate"

        ```bash
        [Unit]
        Description="ServiÃ§o systemd do Appchain"
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        Restart=on-failure
        RestartSec=10
        User=tanssi_service
        SyslogIdentifier=network
        SyslogFacility=local7
        KillSignal=SIGHUP
        ExecStart=/var/lib/tanssi-data/container-chain-simple-node \
        --chain=/var/lib/tanssi-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \
--rpc-port=9944 \
--name=para \
--base-path=/var/lib/tanssi-data \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--chain=/var/lib/tanssi-data/starlight-raw-specs.json \
--rpc-port=9945 \
--name=relay \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC

        [Install]
        WantedBy=multi-user.target
        ```

=== "Dancelight TestNet"

    === "Rede CompatÃ­vel com EVM"

        ```bash
        [Unit]
        Description="ServiÃ§o systemd do Appchain"
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        Restart=on-failure
        RestartSec=10
        User=dancelight_service
        SyslogIdentifier=network
        SyslogFacility=local7
        KillSignal=SIGHUP
        ExecStart=/var/lib/dancelight-data/container-chain-frontier-node \
        --chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \
--rpc-port=9944 \
--name=para \
--base-path=/var/lib/dancelight-data \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \
--rpc-port=9945 \
--name=relay \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT

        [Install]
        WantedBy=multi-user.target
        ```

    === "Rede Substrate"

        ```bash
        [Unit]
        Description="ServiÃ§o systemd do Appchain"
        After=network.target
        StartLimitIntervalSec=0

        [Service]
        Type=simple
        Restart=on-failure
        RestartSec=10
        User=dancelight_service
        SyslogIdentifier=network
        SyslogFacility=local7
        KillSignal=SIGHUP
        ExecStart=/var/lib/dancelight-data/container-chain-simple-node \
        --chain=/var/lib/dancelight-data/INSERT_YOUR_APPCHAIN_SPECS_FILE_NAME \
--rpc-port=9944 \
--name=para \
--base-path=/var/lib/dancelight-data \
--state-pruning=archive \
--blocks-pruning=archive \
--database=paritydb \
--unsafe-rpc-external \
--bootnodes=INSERT_YOUR_NETWORK_BOOTNODES \
-- \
--chain=/var/lib/dancelight-data/dancelight-raw-specs.json \
--rpc-port=9945 \
--name=relay \
--sync=fast \
--database=paritydb \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT

        [Install]
        WantedBy=multi-user.target
        ```

### Obtendo informaÃ§Ãµes de bootnode {: #fetching-bootnode-information}

As informaÃ§Ãµes de bootnode podem ser lidas diretamente no Tanssi. Por exemplo, vocÃª pode usar o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fservices.tanssi-testnet.network/dancelight#/chainstate){target=\_blank} para obter os bootnodes de uma rede especÃ­fica no [Dancelight](/builders/tanssi-network/testnet/dancelight/){target=\_blank}.

Para isso, siga estas etapas:

1. Selecione **dataPreservers** como o mÃ³dulo a consultar
2. Defina a consulta de armazenamento como **bootNodes**
3. Informe o ID da sua rede Tanssi
4. Clique no sinal de **+**

![Obtendo o bootnode](/images/node-operators/network-node/rpc-docker-systemd-1.webp)

### Exemplo de ConfiguraÃ§Ã£o Completa para a Rede EVM de DemonstraÃ§Ã£o {: #example-demo-evm-network }

O exemplo a seguir implanta um nÃ³ de arquivo completo e funcional para a [rede EVM de demonstraÃ§Ã£o](/pt/builders/tanssi-network/testnet/demo-evm-network/){target=_blank} implantada na Dancelight com ID `2001`.

O arquivo de especificaÃ§Ã£o de cadeia bruta Ã© necessÃ¡rio para executar o nÃ³ e pode ser baixado deste [repositÃ³rio pÃºblico no GitHub](https://github.com/papermoonio/external-files/blob/main/Tanssi/Demo-EVM-Appchain){target=_blank}. Baixe o arquivo e coloque-o em `/var/lib/dancelight-data/`.

=== "Demo EVM Appchain (Dancelight)"

    ```bash
    [Unit]
    Description="ServiÃ§o systemd do Appchain"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    Type=simple
    Restart=on-failure
    RestartSec=10
    User=dancelight_service
    SyslogIdentifier=network
    SyslogFacility=local7
    KillSignal=SIGHUP
    ExecStart=/var/lib/dancelight-data/container-chain-frontier-node \
    --chain=/var/lib/dancelight-data/container-2001-raw-specs.json \
    --rpc-port=9944 \
    --name=para \
    --state-pruning=archive \
    --blocks-pruning=archive \
    --base-path=/var/lib/dancelight-data \
    --database=paritydb \
    --unsafe-rpc-external \
    --bootnodes=/dns4/ukl-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWKDotMgTRpURvoZHsLWP4K9ymhkBByi1EJjMQAnCmqg8E \
    --bootnodes=/dns4/qco-dancelight-2001-rpc-1.rv.dancelight.tanssi.network/tcp/30333/p2p/12D3KooWB3kqqNhYgGtGbsdtgD18wUoFVeuXVXgWLXTFs91RNgAx \
    -- \
    --chain=/var/lib/dancelight-data/dancelight-raw-specs.json \
    --rpc-port=9945 \
    --name=relay \
    --sync=fast \
    --database=paritydb \
    --bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
    --bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
    --bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT

    [Install]
    WantedBy=multi-user.target
    ```

### Flags de ExecuÃ§Ã£o {: #run-flags }

As flags usadas no comando `ExecStart` podem ser ajustadas conforme suas preferÃªncias e configuraÃ§Ã£o de hardware. Algumas das mais importantes:

- `--name INSERT_NAME` - nome legÃ­vel para este nÃ³
- `--rpc-port INSERT_PORT` - define a porta TCP do JSON-RPC na qual o nÃ³ ouve
- `--unsafe-rpc-external` - expÃµe o serviÃ§o RPC em todas as interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser `archive` (nÃ³ atua como completo mantendo todo o estado), `archive-canonical` (mantÃ©m apenas estados de blocos finalizados) ou um `number` (quantidade de blocos cujos estados serÃ£o mantidos)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - define quantos blocos devem ser mantidos no banco de dados. Pode ser `archive` (nÃ³ completo mantendo todos os blocos), `archive-canonical` (mantÃ©m apenas blocos finalizados) ou um `number` (quantidade de blocos finalizados a manter)
- `--detailed-log-output` - habilita saÃ­da detalhada de logs

!!! warning
    O parÃ¢metro `--unsafe-rpc-external` permite acesso externo Ã  interface RPC do seu nÃ³, tornando-a acessÃ­vel de qualquer endereÃ§o IP. Certifique-se de que controles de seguranÃ§a adequados estejam configurados.

Para ver a lista completa de flags disponÃ­veis, descriÃ§Ã£o e valores possÃ­veis, execute:

=== "Rede compatÃ­vel com EVM"

    ```bash
    /var/lib/dancelight-data/container-chain-frontier-node --help
    ```

=== "Rede Substrate Simples"

    ```bash
    /var/lib/dancelight-data/container-chain-simple-node --help
    ```

## Execute o ServiÃ§o {: #run-the-service }

Finalmente, habilite o serviÃ§o e inicie-o pela primeira vez:

```bash
systemctl enable appchain.service && \
systemctl start appchain.service
```

Verifique se o serviÃ§o estÃ¡ funcionando corretamente executando:

```bash
systemctl status appchain.service
```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>systemctl status network.service</span>
  <span data-ty>
    <br> â— network.service - "Network systemd service"
    <br>&nbsp;&nbsp;&nbsp;Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)
    <br>&nbsp;&nbsp;&nbsp;Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago
    <br>&nbsp;&nbsp;Main PID: 4045278 (container-chain)
    <br>&nbsp;&nbsp;&nbsp;&nbsp;Tasks: 44 (limit: 9462)
    <br>&nbsp;&nbsp;&nbsp;Memory: 6.5G
    <br>&nbsp;&nbsp;&nbsp;CGroup: /system.slice/network.service
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â””â”€4045278 4045278 /var/lib/network-data/container-chain- ...
  </span>
</div>

E verifique os logs, se necessÃ¡rio:

```bash
journalctl -f -u appchain.service
```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>journalctl -f -u network.service</span>
  <span data-ty>
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 Parachain Collator Template
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 âœŒï¸  version 0.1.0-3b1fbbfdfe7
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 â¤ï¸  by Moondance Labs,     <br> 2020-2024
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ðŸ“‹ Chain specification: Frontier Container 2001
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ðŸ·  Node name: para
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ðŸ‘¤ Role: FULL
    <br> Feb 19 20:05:53 tutorials network[4066765]: 2024-02-19 20:05:53 ðŸ’¾ Database: RocksDb at /var/lib/network-data/chains/frontier_container_2001/db/full
    <br> Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain id: Id(2001)
    <br> Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain Account: 5Ec4AhPQLGvfWywVhJZwufTDvknLT3BVPQcbV977JmBDUsHP
    <br> Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V0: 0x000000000000000000000000000000000000000000000000000000000000000000e1324cc53e66
    <br> Feb 19 20:05:57 tutorials network[4066765]: 2024-02-19 20:05:57 Parachain genesis state V1: 0x000000000000000000000000000000000000000000000000000000000000000000327cfde8482b
  </span>
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/network-node/tanssi/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³ Tanssi
description: Aprenda como configurar e executar um nÃ³ Tanssi usando Docker ou Systemd para interagir com a rede Tanssi.
icon: octicons-server-24
template: index-page.html
categories: RPC-Data-Preservers
---

# Executar um NÃ³ Tanssi

A configuraÃ§Ã£o de um NÃ³ Tanssi Ã© um passo importante para interagir e consultar a rede Tanssi. VocÃª tem duas opÃ§Ãµes de configuraÃ§Ã£o: usar _Docker_ ou _Systemd_. Seja qual for o caminho escolhido, oferecemos tutoriais passo a passo para orientÃ¡-lo durante o processo.

## Requisitos de Hardware

O hardware adequado Ã© essencial para executar um nÃ³ Tanssi com sucesso. Uma configuraÃ§Ã£o de alto desempenho garante um serviÃ§o confiÃ¡vel e resposta rÃ¡pida Ã s consultas.

Hardware recomendado:

- **ConfiguraÃ§Ã£o Recomendada** - hardware bare metal executando Linux Debian ou Ubuntu
- **CPUs Recomendados** - Intel Ice Lake ou mais recente (Xeon ou sÃ©rie Core), AMD Zen3 ou mais recente (EPYC ou Ryzen). Oito nÃºcleos fÃ­sicos @ 3,4 GHz com hyperthreading desabilitado (SMT para processadores AMD)
- **NVMe Recomendado** - SSD NVMe de 500 GB
- **RAM Recomendada** - 32 GB de RAM ECC
- **Rede Recomendada** - conexÃ£o de 1 Gbps

!!! warning
    Manter o desempenho do seu NÃ³ Tanssi, mantÃª-lo atualizado e garantir sua seguranÃ§a sÃ£o cruciais para uma operaÃ§Ã£o confiÃ¡vel.

### Portas de Rede NecessÃ¡rias

Para garantir a comunicaÃ§Ã£o adequada com a rede Tanssi, certifique-se de que a seguinte porta esteja aberta para conexÃµes de entrada:

| Rede          | Porta        |
|------------------|-------------|
| Tanssi Chain     | 30333 (TCP) |

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/network-node/tanssi/tanssi-node-docker/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³ Tanssi Usando Docker
description: Aprenda como configurar e executar um nÃ³ para a rede Tanssi usando Docker para fornecer endpoints de API para aplicativos e usuÃ¡rios.
icon: simple-docker
categories: RPC-Data-Preservers
---

# Executar um NÃ³ Tanssi Usando Docker

## IntroduÃ§Ã£o {: #introduction }

Neste guia, vocÃª aprenderÃ¡ como iniciar um nÃ³ Tanssi usando a imagem oficial com [Docker](https://www.docker.com){target=\_blank} em sistemas Linux. Os nÃ³s sÃ£o cruciais para o ecossistema Tanssi, pois fornecem endpoints de API estÃ¡veis aos quais aplicativos e usuÃ¡rios podem se conectar para obter dados da cadeia e enviar transaÃ§Ãµes.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

### Instalando o Docker {: #installing-docker}

Para comeÃ§ar, vocÃª precisarÃ¡ de um computador com Linux e instalar o [Docker](https://docs.docker.com/desktop/setup/install/linux/){target=\blank}.

Execute o comando a seguir para instalar o Docker em um Ubuntu:

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

E o comando abaixo para verificar a instalaÃ§Ã£o:

```bash
sudo docker run hello-world
```

Uma execuÃ§Ã£o bem-sucedida no terminal se parece com isto:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>sudo docker run hello-world</span>
  <span data-ty>
    <br> 
    <br> Hello from Docker!
    <br> This message shows that your installation appears to be working correctly.
    <br> 
    <br> To generate this message, Docker took the following steps:
    <br> 1. The Docker client contacted the Docker daemon.
    <br> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    <br>     (amd64)
    <br> 3. The Docker daemon created a new container from that image which runs the
    <br>     executable that produces the output you are currently reading.
    <br> 4. The Docker daemon streamed that output to the Docker client, which sent it
    <br>     to your terminal.
    <br>
    <br> To try something more ambitious, you can run an Ubuntu container with:
    <br> $ docker run -it ubuntu bash
    <br>
    <br> Share images, automate workflows, and more with a free Docker ID:
    <br> https://hub.docker.com/
    <br>
    <br> For more examples and ideas, visit:
    <br>  https://docs.docker.com/get-started/
  </span>
</div>

### Puxar a Imagem Docker {: #pull-docker-image }

Para cada versÃ£o, uma imagem Docker Ã© construÃ­da e publicada. Ela contÃ©m todas as dependÃªncias que um nÃ³ Tanssi exige e o prÃ³prio binÃ¡rio.

A imagem combina o binÃ¡rio da versÃ£o estÃ¡vel mais recente do [nÃ³ cliente](/pt/learn/framework/architecture/#architecture){target=_blank} com o arquivo de especificaÃ§Ãµes do orquestrador Tanssi.

Execute o comando abaixo para puxar a imagem Docker:

=== "Tanssi MainNet"

    ```bash
    docker pull {{ networks.dancelight.operator_docker_image }}
    ```

=== "Dancelight TestNet"

    ```bash
    docker pull {{ networks.dancelight.operator_docker_image }}
    ```

O comando farÃ¡ download/extrair a imagem e exibirÃ¡ o status apÃ³s a execuÃ§Ã£o:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker pull moondancelabs/starlight</span>
  <span data-ty>
    <br> 
    <br> Using default tag: latest
    <br> latest: Pulling from moondancelabs/starlight
    <br> e1caac4eb9d2: Pull complete 
    <br> 1d4409959e6d: Pull complete 
    <br> b8beed19c122: Pull complete 
    <br> c0fab1f18601: Pull complete 
    <br> Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c
    <br> Status: Downloaded newer image for moondancelabs/starlight
    <br> docker.io/moondancelabs/starlight
  </span>
</div>

### Configure o diretÃ³rio de dados {: #set-up-data-directory }

Executar um nÃ³ requer sincronizar com a cadeia Tanssi e armazenar seu estado.

Crie o diretÃ³rio onde o nÃ³ armazenarÃ¡ os bancos de dados contendo blocos e estados de cadeia:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the Docker image to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    chown INSERT_DOCKER_USER /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    chown INSERT_DOCKER_USER /var/lib/dancelight-data
    ```

Ou execute o comando a seguir se quiser rodar o nÃ³ com o usuÃ¡rio atualmente logado:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data
    ```

!!! note
    O diretÃ³rio Ã© um parÃ¢metro no comando de inicializaÃ§Ã£o do Docker. Se decidir criÃ¡-lo em outro lugar, ajuste o comando.

### Gerar a Chave do NÃ³ {: #generate-node-key }

Para gerar e armazenar em disco as chaves de sessÃ£o referenciadas no comando de inicializaÃ§Ã£o, execute:

=== "Tanssi MainNet"

    ```bash
    docker run --network="host" -v "/var/lib/tanssi-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ networks.dancelight.operator_docker_image }} key generate-node-key --file /data/node-key
    ```

=== "Dancelight TestNet"

    ```bash
    docker run --network="host" -v "/var/lib/dancelight-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ networks.dancelight.operator_docker_image }} key generate-node-key --file /data/node-key
    ```

!!! note
    Esta etapa poderia ser evitada usando o parÃ¢metro `--unsafe-force-node-key-generation` no comando de inicializaÃ§Ã£o, embora essa nÃ£o seja a prÃ¡tica recomendada.

## Inicie Seu NÃ³ {: #start-your-node }

Para iniciar seu nÃ³, execute a imagem Docker com `docker run`.

Substitua `INSERT_YOUR_TANSSI_NODE_NAME` por um nome legÃ­vel e defina `INSERT_YOUR_IP_ADDRESS` com seu IP pÃºblico.

!!! note
    Recomenda-se usar as versÃµes binÃ¡rias otimizadas para as arquiteturas [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} da Intel ou [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} da AMD para melhor desempenho.

=== "Tanssi MainNet"

    === "GenÃ©rico"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

=== "Dancelight TestNet"

    === "GenÃ©rico"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path /data \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'
        ```

### Executar Flags {: #run-flags }

As flags do `docker run` podem ser ajustadas conforme suas preferÃªncias e hardware. Algumas das principais:

- **--state-pruning=archive** - mantÃ©m todos os dados de estado (necessÃ¡rio para consultas histÃ³ricas)
- **--blocks-pruning=archive** - mantÃ©m todos os blocos (necessÃ¡rio para dados histÃ³ricos de blocos)
- **--database=paritydb** - usa ParityDB como backend otimizado para desempenho de nÃ³ RPC
- **--unsafe-rpc-external** - permite conexÃµes externas ao RPC; exige medidas adicionais de seguranÃ§a em produÃ§Ã£o (proxy reverso, autenticaÃ§Ã£o, firewall)

!!! warning
    A flag `--unsafe-rpc-external` expÃµe seu nÃ³ RPC externamente. Em produÃ§Ã£o, proteja com firewall, proxy reverso, autenticaÃ§Ã£o e limitaÃ§Ã£o de taxa.

VocÃª pode visualizar todas as flags disponÃ­veis executando:

=== "Tanssi MainNet"

    ```bash
    docker run -ti {{ networks.dancelight.operator_docker_image }} --help
    ```

=== "Dancelight TestNet"

    ```bash
    docker run -ti {{ networks.dancelight.operator_docker_image }} --help
    ```

## Sincronizando Seu NÃ³ {: #syncing-your-node }

Na primeira execuÃ§Ã£o, o processo de sincronizaÃ§Ã£o exibirÃ¡ muitos logs do nÃ³ e da cadeia. Alguns erros iniciais sÃ£o esperados e desaparecem quando a cadeia alcanÃ§a o Ãºltimo bloco.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker run ....</span>
  <span data-ty>
    <br> 2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] ðŸ’¤ Idle (0 peers), best: #0 (0x4a2bâ€¦7de3), finalized #0 (0x4a2bâ€¦7de3), â¬‡ 0 â¬† 0
    <br> 2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] âœ¨ Imported #14139635 (0x8c41â€¦8df6)    
    <br> 2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] ðŸ’¤ Idle (8 peers), best: #14139635 (0x8c41â€¦8df6), finalized #14139632 (0xa9a8â€¦cab9), â¬‡ 32.7kiB/s â¬†
  </span>
</div>

Quando o processo de sincronizaÃ§Ã£o terminar, seu nÃ³ estarÃ¡ pronto para atender solicitaÃ§Ãµes de API.

## Testando Seu NÃ³ {: #testing-your-rpc-node }

Depois de sincronizado, teste o endpoint RPC com uma solicitaÃ§Ã£o simples, por exemplo:

```bash
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method":"chain_getHeader", "params":[]}' http://localhost:9944
```

Se estiver funcionando, vocÃª receberÃ¡ uma resposta JSON com o cabeÃ§alho do bloco mais recente.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/network-node/tanssi/tanssi-node-systemd/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³ Tanssi Usando Systemd
description: Aprenda a configurar e executar um NÃ³ para as redes Tanssi usando Systemd, permitindo fornecer endpoints de API para aplicaÃ§Ãµes e usuÃ¡rios.
icon: simple-linux
categories: RPC-Data-Preservers
---

# Executar um NÃ³ Tanssi Usando Systemd

## IntroduÃ§Ã£o {: #introduction }

Neste guia, vocÃª aprenderÃ¡ a iniciar um NÃ³ Tanssi usando o binÃ¡rio estÃ¡vel mais recente e gerenciar o serviÃ§o com [Systemd](https://systemd.io){target=\_blank} em sistemas Linux. Os nÃ³s fornecem endpoints de API essenciais para que aplicaÃ§Ãµes e usuÃ¡rios interajam com a rede Tanssi.

O artigo segue a boa prÃ¡tica de executar o serviÃ§o com uma conta nÃ£o-root e conceder a essa conta acesso de gravaÃ§Ã£o a um diretÃ³rio especÃ­fico. VocÃª pode adaptar as etapas Ã  sua configuraÃ§Ã£o, preferÃªncias e polÃ­ticas de seguranÃ§a.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para comeÃ§ar, vocÃª precisarÃ¡ de acesso a um computador executando Ubuntu Linux com [Landlock](https://docs.kernel.org/security/landlock.html){target=\_blank} habilitado e privilÃ©gios de root. VocÃª tambÃ©m precisarÃ¡ de:

- **Arquivos binÃ¡rios do NÃ³** - um nÃ³ requer trÃªs binÃ¡rios: `tanssi-relay`, `tanssi-relay-execute-worker` e `tanssi-relay-prepare-worker`
``

As instruÃ§Ãµes executam a [versÃ£o estÃ¡vel mais recente](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank}. VocÃª pode compilar seu prÃ³prio arquivo a partir do [cÃ³digo-fonte](https://github.com/moondance-labs/tanssi){target=\_blank}.

## Verificar Suporte Landlock {: #check-landlock }

Os nÃ³s Tanssi usam o recurso Landlock do kernel Linux como medida de seguranÃ§a para restringir acesso a recursos do sistema, limitando danos caso o aplicativo seja comprometido.

Verifique o suporte Landlock executando:

```bash
sudo dmesg | grep landlock || journalctl -kg landlock
```

SaÃ­da esperada:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>sudo dmesg | grep landlock || journalctl -kg landlock</span>
    <span data-ty>[    0.240344] landlock: Up and running.</span>
</div>

Se o Landlock estiver desabilitado, atualize o kernel para a versÃ£o 5.13 ou superior.

## Baixar a VersÃ£o Mais Recente {: #download-latest-release }

Baixe o binÃ¡rio mais recente e torne-o executÃ¡vel:

!!! note
    Recomenda-se usar as versÃµes binÃ¡rias otimizadas para as arquiteturas [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} da Intel ou [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} da AMD para melhor desempenho.

=== "GenÃ©rico"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "Intel Skylake"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-skylake -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "AMD Zen3"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-znver3 -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

## Configure o serviÃ§o Systemd {: #set-up-systemd-service }

O [Systemd](https://systemd.io){target=\_blank} Ã© um sistema de gerenciamento para Linux que controla serviÃ§os (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas.

Os comandos a seguir criam uma nova conta, o diretÃ³rio e movem os arquivos previamente baixados para o local correto.

1. Crie uma nova conta para executar o serviÃ§o:

    === "Tanssi MainNet"

        ```bash
        adduser tanssi_service --system --no-create-home
        ```

    === "Dancelight TestNet"
        
        ```bash
        adduser dancelight_service --system --no-create-home
        ```

2. Crie um diretÃ³rio para armazenar os arquivos e dados necessÃ¡rios:

    === "Tanssi MainNet"

        ```bash
        mkdir /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        mkdir /var/lib/dancelight-data
        ```

3. Defina a propriedade da pasta para a conta que executarÃ¡ o serviÃ§o, garantindo permissÃ£o de escrita:

    === "Tanssi MainNet"

        ```bash
        chown -R tanssi_service /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        chown -R tanssi_service /var/lib/dancelight-data
        ```

4. Mova os binÃ¡rios para a pasta:

    === "Tanssi MainNet"

        ```bash
        mv ./tanssi-relay* /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        mv ./tanssi-relay* /var/lib/dancelight-data
        ```

### Gerar a chave do nÃ³ {: #generate-node-key }

Para gerar e armazenar em disco as chaves de sessÃ£o que serÃ£o referenciadas no comando de inicializaÃ§Ã£o, execute:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key
    ```

=== "Dancelight TestNet"
    
    ```bash
    /var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key
    ```

!!! note
    Esta etapa poderia ser evitada usando o parÃ¢metro `--unsafe-force-node-key-generation` no comando de inicializaÃ§Ã£o, embora essa nÃ£o seja a prÃ¡tica recomendada.

### Criar o arquivo de configuraÃ§Ã£o do Systemd {: #create-systemd-configuration }

O prÃ³ximo passo Ã© criar o arquivo de configuraÃ§Ã£o do Systemd.

Crie o arquivo executando o comando:

=== "Tanssi MainNet"

    ```bash
    sudo touch /etc/systemd/system/tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    sudo touch /etc/systemd/system/dancelight.service
    ```

Agora abra o arquivo com seu editor favorito (vim, emacs, nano etc.) e adicione a configuraÃ§Ã£o do serviÃ§o, substituindo a tag `INSERT_YOUR_TANSSI_NODE_NAME` por um nome legÃ­vel e `INSERT_YOUR_IP_ADDRESS` pelo seu endereÃ§o IP pÃºblico. Esse nome ajuda a relacionar entradas de log e mÃ©tricas ao nÃ³ que as gera.

=== "Tanssi MainNet"

    ```bash
    [Unit]
    Description="ServiÃ§o systemd Tanssi"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    User=tanssi_service
    Type=simple
    Restart=always
    RestartSec=10
    SyslogIdentifier=tanssi
    SyslogFacility=local7
    KillSignal=SIGHUP
    LimitNOFILE=100000
    ExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \
    --base-path /var/lib/tanssi-data/ \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /var/lib/tanssi-data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'

    [Install]
    WantedBy=multi-user.target
    ```

=== "Dancelight TestNet"

    ```bash
    [Unit]
    Description="ServiÃ§o systemd Dancelight"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    User=dancelight_service
    Type=simple
    Restart=always
    RestartSec=10
    SyslogIdentifier=dancelight
    SyslogFacility=local7
    KillSignal=SIGHUP
    LimitNOFILE=100000
    ExecStart=/var/lib/dancelight-data/tanssi-relay --chain=dancelight \
    --base-path /var/lib/tanssi-data/ \
--name INSERT_YOUR_TANSSI_NODE_NAME \
--node-key-file /var/lib/tanssi-data/node-key \
--database paritydb \
--rpc-port 9944 \
--prometheus-port 9615 \
--prometheus-external \
--listen-addr /ip4/0.0.0.0/tcp/30333 \
--public-addr /ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning archive \
--blocks-pruning archive \
--rpc-cors=all \
--unsafe-rpc-external \
--rpc-methods=safe \
--telemetry-url 'wss://telemetry.polkadot.io/submit/ 0'

    [Install]
    WantedBy=multi-user.target
    ```

### Flags de ExecuÃ§Ã£o {: #run-flags }

As flags usadas no `ExecStart` podem ser ajustadas conforme suas preferÃªncias e hardware. Algumas das principais:

- **--state-pruning=archive** - mantÃ©m todos os dados de estado (necessÃ¡rio para consultas histÃ³ricas)
- **--blocks-pruning=archive** - mantÃ©m todos os blocos (necessÃ¡rio para dados histÃ³ricos de blocos)
- **--database=paritydb** - usa ParityDB como back-end otimizado para desempenho de nÃ³ RPC
- **--unsafe-rpc-external** - permite conexÃµes externas ao RPC; requer medidas adicionais de seguranÃ§a em produÃ§Ã£o (proxy reverso, autenticaÃ§Ã£o, firewall)

!!! warning
    A flag `--unsafe-rpc-external` expÃµe o RPC externamente. Em produÃ§Ã£o, proteja com firewall, proxy reverso, autenticaÃ§Ã£o e limitaÃ§Ã£o de taxa.

VocÃª pode visualizar todas as flags disponÃ­veis executando:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-relay --help
    ```

=== "Dancelight TestNet"

    ```bash
    /var/lib/dancelight-data/tanssi-relay --help
    ```

## Execute o serviÃ§o {: #run-the-service }

Por fim, habilite o serviÃ§o e inicie-o pela primeira vez:

=== "Tanssi MainNet"

    ```bash
    systemctl enable tanssi.service && \
    systemctl start tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    systemctl enable dancelight.service && \
    systemctl start dancelight.service
    ```

VocÃª pode verificar se o serviÃ§o estÃ¡ ativo e rodando corretamente executando:

=== "Tanssi MainNet"

    ```bash
    systemctl status tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    systemctl status dancelight.service
    ```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>systemctl status network.service</span>
  <span data-ty>
    <br> â— network.service - "Network systemd service"
    <br>&nbsp;&nbsp;&nbsp;Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)
    <br>&nbsp;&nbsp;&nbsp;Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago
    <br>&nbsp;&nbsp;Main PID: 4045278 (container-chain)
    <br>&nbsp;&nbsp;&nbsp;&nbsp;Tasks: 44 (limit: 9462)
    <br>&nbsp;&nbsp;&nbsp;Memory: 6.5G
    <br>&nbsp;&nbsp;&nbsp;CGroup: /system.slice/network.service
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â””â”€4045278 4045278 /var/lib/network-data/container-chain- ...
  </span>
</div>

Verifique os logs, se necessÃ¡rio, com o comando a seguir:

=== "Tanssi MainNet"

    ```bash
    journalctl -f -u tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    journalctl -f -u dancelight.service
    ```

## Testando Seu NÃ³ {: #testing-your-rpc-node }

Depois que seu nÃ³ estiver totalmente sincronizado, vocÃª pode verificar se o endpoint RPC estÃ¡ funcionando corretamente fazendo uma solicitaÃ§Ã£o simples. Use curl para testar:

```bash
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method":"chain_getHeader", "params":[]}' http://localhost:9944
```

Se o endpoint RPC estiver funcionando, vocÃª receberÃ¡ uma resposta JSON contendo as informaÃ§Ãµes do cabeÃ§alho do bloco mais recente.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/
--- BEGIN CONTENT ---
---
title: Operators Tanssi
description: Aprenda como configurar, executar e gerenciar operators de rede para participar do protocolo de infraestrutura Tanssi, verificando transaÃ§Ãµes e ganhando recompensas.
icon: octicons-server-24
template: index-page.html
---

# Operators Tanssi

Os operators (tambÃ©m conhecidos como validadores) sÃ£o responsÃ¡veis por manter a seguranÃ§a em todas as redes powered by Tanssi, verificando a integridade e a validade de suas transaÃ§Ãµes. Eles participam de um mecanismo de consenso DPoS (Delegated Proof-of-Stake), que melhora a descentralizaÃ§Ã£o e promove um bom comportamento por meio de incentivos econÃ´micos.

Esta seÃ§Ã£o fornece tudo o que vocÃª precisa para comeÃ§ar, desde a configuraÃ§Ã£o inicial atÃ© as melhores prÃ¡ticas operacionais e o gerenciamento de contas.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/offboarding/
--- BEGIN CONTENT ---
---
title: Desativar Seu NÃ³ Operator
description: Aprenda como desativar corretamente seu operator, incluindo pausar operaÃ§Ãµes, cancelar a participaÃ§Ã£o na rede e remover vocÃª mesmo do registro.
icon: octicons-arrow-down-right-24
template: index-page.html
---

# Desativando um Operator da Tanssi

Deixar de ser um operator requer seguir os procedimentos adequados para garantir uma transiÃ§Ã£o tranquila. Esta seÃ§Ã£o fornece instruÃ§Ãµes claras sobre como desativar seu operator da rede Tanssi.

[timeline left (tanssi-docs/.snippets/text/pt/node-operators/operators/offboarding/offboarding-timeline.json)]

!!! tip "Retornando como Operator"
    Se vocÃª decidir retornar como um validador Tanssi no futuro, poderÃ¡ facilmente se cadastrar novamente seguindo as etapas descritas no guia [Onboarding](/pt/node-operators/operators/onboarding/).

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/offboarding/opt-out-from-tanssi/
--- BEGIN CONTENT ---
---
title: Cancelar a ParticipaÃ§Ã£o na Tanssi
description: Saiba como iniciar o processo de desligamento de uma rede Tanssi, cancelando a participaÃ§Ã£o por vÃ¡rios mÃ©todos e como verificar seu status.
icon: octicons-sign-out-24
template: main.html
categories: Operators
---

# Cancelar a ParticipaÃ§Ã£o na Tanssi

## IntroduÃ§Ã£o {: #introduction }

A capacidade de gerenciar a participaÃ§Ã£o dos node operators no ecossistema Tanssi Ã© crucial. Este guia aborda a etapa inicial do processo de desligamento: cancelar a participaÃ§Ã£o na rede Tanssi. Essa aÃ§Ã£o sinaliza sua intenÃ§Ã£o de retirada e permite que o protocolo Tanssi verifique sua identidade como o operator legÃ­timo.

Durante o processo de onboarding, uma etapa foi fazer opt-in na rede Tanssi para se tornar um operator. Este guia o conduz pelo processo de opt-out. HÃ¡ vÃ¡rias maneiras de interagir com os contratos inteligentes envolvidos. Consulte o [artigo de prÃ©-requisitos](/pt/node-operators/operators/offboarding/prerequisites/){target=\_blank} para avaliar qual alternativa se adapta melhor a vocÃª.

!!! note "ValidaÃ§Ã£o de identidade"
    Ao cancelar a participaÃ§Ã£o, vocÃª assina a transaÃ§Ã£o usando a chave privada ou o dispositivo Ledger associado Ã  sua conta de operator. Essa assinatura serve como prova criptogrÃ¡fica de que vocÃª Ã© o proprietÃ¡rio legÃ­timo da conta do operator, garantindo que apenas operators autorizados possam iniciar o processo de desligamento.

## MÃ©todos para Cancelar a ParticipaÃ§Ã£o de uma Rede Tanssi {: #methods-for-opting-out }

Para cancelar a participaÃ§Ã£o na rede Tanssi, vocÃª deve interagir com um contrato inteligente. A seguir estÃ£o os diferentes mÃ©todos disponÃ­veis para realizar essa aÃ§Ã£o. Escolha o que melhor se adapta Ã  sua configuraÃ§Ã£o e preferÃªncias de seguranÃ§a.

### Usando a CLI Symbiotic {: #opt-out-network-with-cli }

A CLI Symbiotic oferece uma maneira simples de cancelar a participaÃ§Ã£o na rede. Escolha o comando apropriado com base na sua rede e no mÃ©todo de assinatura.

Usando um dispositivo Ledger:

=== "MainNet"

    ```bash
    python3 symb.py opt-out-network {{ networks.symbiotic.contracts.mainnet.tanssi_network }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-out-network {{ networks.symbiotic.contracts.sepolia.tanssi_network }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

Para assinar com uma chave privada:

=== "MainNet"

    ```bash
    python3 symb.py opt-out-network {{ networks.symbiotic.contracts.mainnet.tanssi_network }} --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-out-network {{ networks.symbiotic.contracts.sepolia.tanssi_network }} --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Observe que este mÃ©todo exige expor sua chave privada; portanto, nÃ£o Ã© recomendado.

### Usando Etherscan {: #opt-out-network-with-etherscan }

VocÃª pode interagir diretamente com o contrato inteligente pelo Etherscan usando uma carteira de navegador como a MetaMask.

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.network_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.network_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.network_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.network_registry }}#writeContract){target=\_blank}

Certifique-se de selecionar **Contract** e **Write Contract**, depois clique em **Connect to Web3** e selecione sua carteira preferida (por exemplo, MetaMask):
![Conectar ao Web3](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-1.webp)

1. Expanda a funÃ§Ã£o **optOut**
2. Insira o `TANSSI_NETWORK_ADDRESS` no campo **where**. Se vocÃª estiver cancelando a participaÃ§Ã£o na Tanssi MainNet, use `{{ networks.symbiotic.contracts.mainnet.tanssi_network }}`. Para a TestNet, use `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}`
3. Clique em **Write** e assine a transaÃ§Ã£o

![Cancelar operator](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-2.webp)

!!! warning
    ApÃ³s enviar sua transaÃ§Ã£o de cancelamento, salve o hash da transaÃ§Ã£o. VocÃª precisarÃ¡ desse hash posteriormente para verificaÃ§Ã£o no [formulÃ¡rio de desligamento de operator](https://www.tanssi.network/operator-offboarding){target=\_blank}.

### Usando Safe para ConfiguraÃ§Ãµes Multisig {: #opt-out-network-with-safe }

Para contas [Safe](https://app.safe.global/){target=\_blank}, use o **Transaction Builder** com estes endereÃ§os:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.network_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.network_registry }}

Em seguida, escolha a funÃ§Ã£o optOut, insira o `TANSSI_NETWORK_ADDRESS` no qual seu nÃ³ estÃ¡ registrado (`{{ networks.symbiotic.contracts.mainnet.tanssi_network }}` para Tanssi MainNet e `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}` para TestNet) e assine a transaÃ§Ã£o.

## Verificando Seu Status de Cancelamento {: #verify-opt-out-status }

Depois de enviar a transaÃ§Ã£o de cancelamento, Ã© importante confirmar se a aÃ§Ã£o foi bem-sucedida e se seu operator nÃ£o estÃ¡ mais participando da rede. VocÃª pode verificar esse status usando os mÃ©todos a seguir.

### Usando Etherscan para Verificar {: #verify-opt-out-etherscan }

VocÃª pode verificar seu status de cancelamento no Etherscan consultando o contrato inteligente:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.network_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.network_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.network_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.network_registry }}#readContract){target=\_blank}

Na pÃ¡gina do contrato:

1. Selecione a guia **Read Contract**
2. Localize e expanda a funÃ§Ã£o **isOptedIn**
3. Cole o endereÃ§o da conta do seu operator no campo **who**
4. Insira o `TANSSI_NETWORK_ADDRESS` no campo **where**. Para Tanssi MainNet, use `{{ networks.symbiotic.contracts.mainnet.tanssi_network }}`. Para TestNet, use `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}`
5. Clique em **Query**

![Verifique o status do cadastro](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-3.webp)

VocÃª obterÃ¡ um resultado `false` se o operator tiver cancelado a participaÃ§Ã£o com sucesso e `true` se ainda estiver participando.

### Usando a CLI Symbiotic para Verificar {: #verify-opt-out-cli }

VocÃª tambÃ©m pode verificar seu status de cancelamento usando a CLI Symbiotic:

=== "MainNet"

    ```bash
    python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.mainnet.tanssi_network }}
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.tanssi_network }}
    ```

A saÃ­da mostrarÃ¡ `false` se vocÃª tiver cancelado a participaÃ§Ã£o com sucesso e `true` se ainda estiver participando.

## Entre em Contato com a Equipe Tanssi {: #contact-tanssi-team }

ApÃ³s o opt-out da rede, a prÃ³xima etapa do desligamento do operator Tanssi envolve notificar formalmente a equipe Tanssi. Esta pÃ¡gina orienta vocÃª sobre como enviar o formulÃ¡rio de desligamento necessÃ¡rio e o que esperar durante o processo final de remoÃ§Ã£o.

ApÃ³s cancelar a participaÃ§Ã£o na rede, informe Ã  equipe Tanssi sua intenÃ§Ã£o de parar de operar. Para isso, preencha o [formulÃ¡rio de desligamento do operator](https://www.tanssi.network/operator-offboarding){target=\_blank} e aguarde a confirmaÃ§Ã£o da conclusÃ£o do pedido pela equipe Tanssi.

Ao receber sua solicitaÃ§Ã£o, a remoÃ§Ã£o do seu operator serÃ¡ agendada. Essa etapa Ã© semiautomÃ¡tica e pode levar algum tempo para ser concluÃ­da. VocÃª serÃ¡ notificado por e-mail quando for seguro desativar o nÃ³. NÃ£o desative seu nÃ³ atÃ© receber essa notificaÃ§Ã£o.

!!! note "Fornecer feedback"
    Considere fornecer feedback no [formulÃ¡rio](https://www.tanssi.network/operator-offboarding){target=\_blank} de desligamento sobre sua experiÃªncia para ajudar a melhorar a rede Tanssi.

## Pausar OperaÃ§Ãµes (Opcional) {: #pause-operations }

Depois de receber a confirmaÃ§Ã£o da remoÃ§Ã£o do seu operator pela equipe Tanssi, vocÃª pode parar com seguranÃ§a quaisquer serviÃ§os em execuÃ§Ã£o relacionados ao operator. Se necessÃ¡rio, faÃ§a backup de arquivos de configuraÃ§Ã£o importantes, logs ou quaisquer dados relevantes antes de excluÃ­-los. Em seguida, vocÃª pode reaproveitar, encerrar ou desligar toda a sua infraestrutura.

## PrÃ³ximas Etapas (Opcional) {: #next-steps-vault-opt-out }

ApÃ³s cancelar a participaÃ§Ã£o na rede e informar a equipe Tanssi enviando o formulÃ¡rio de desligamento, vocÃª pode dar um passo opcional adicional e [cancelar a participaÃ§Ã£o em quaisquer cofres especÃ­ficos](/pt/node-operators/operators/offboarding/vault-opt-out/){target=\_blank} com os quais seu operator possa estar associado.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/offboarding/prerequisites/
--- BEGIN CONTENT ---
---
title: PrÃ©-requisitos para Offboarding
description: Antes de remover seu operator Tanssi, garanta que vocÃª tenha acesso Ã  carteira e ETH suficiente para gÃ¡s. Este guia descreve os prÃ©-requisitos cruciais.
icon: octicons-arrow-down-right-24
template: main.html
categories: Operators
---

# PrÃ©-requisitos para Offboarding

## IntroduÃ§Ã£o {: #introduction }

O offboarding de operator Ã© o processo formal pelo qual os node operators saem do protocolo Tanssi de forma segura e transparente. Ele garante a integridade, seguranÃ§a e estabilidade da rede, fornecendo etapas claras para os operators que desejam deixar de participar.

Os operators desempenham um papel crÃ­tico no consenso e nas operaÃ§Ãµes da rede. Desligar abruptamente um nÃ³ sem seguir os procedimentos adequados pode impactar negativamente os operators, potencialmente resultando em slashing.

Este guia descreve os **prÃ©-requisitos** para o offboarding, e guias subsequentes o guiarÃ£o pelo processo.

Se vocÃª tiver dÃºvidas durante qualquer parte do processo de offboarding, a equipe da Tanssi pode te ajudar no [Discord](https://discord.com/invite/Jm2KH8xT7J){target=\_blank}.

## PrÃ©-requisitos {: #prerequisites}

Antes de iniciar o processo de offboarding, certifique-se de ter o seguinte:

- Acesso Ã  carteira Ethereum (EVM) que controla sua conta de operator
- ETH suficiente em sua carteira para cobrir as taxas de gÃ¡s para as transaÃ§Ãµes

### Por que a InteraÃ§Ã£o com Contratos Inteligentes Ã© NecessÃ¡ria {: #why-smart-contracts }

Como muitos sistemas descentralizados, o protocolo Tanssi utiliza contratos inteligentes na blockchain Ethereum para gerenciar operaÃ§Ãµes crÃ­ticas, incluindo registro e staking de operator. Quando um operator decide sair, ele muda seu status e relacionamento com esses contratos principais do protocolo.
As principais etapas de offboarding, como sinalizar sua intenÃ§Ã£o de sair ou cancelar formalmente o registro, envolvem transaÃ§Ãµes que atualizam o estado registrado nesses contratos inteligentes.

### MÃ©todos de InteraÃ§Ã£o

Existem vÃ¡rias formas de interagir com os contratos inteligentes:

- Usando o [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank}
- Usando o [Etherscan](https://etherscan.io/){target=\_blank}
- Usando o [Safe](https://safe.global/){target=\_blank} para configuraÃ§Ãµes multisig

Em todos os casos, vocÃª precisarÃ¡ assinar a transaÃ§Ã£o com a conta que pretende usar para o nÃ³. VocÃª pode fazer isso de diferentes maneiras:

- Usando a chave privada da conta diretamente (nÃ£o recomendado)
- Usando uma hot wallet, como o [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}
- Usando uma cold wallet, como o [Ledger](https://www.ledger.com/){target=\_blank}

A seÃ§Ã£o a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua opÃ§Ã£o.

### Configurar o Symbiotic CLI {: #set-up-the-cli }

O [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank} Ã© uma ferramenta para interagir com os contratos principais do Symbiotic. Ele Ã© escrito em [Python](https://www.python.org/){target=\_blank}, portanto vocÃª precisarÃ¡ instalar o interpretador Python e o [pip](https://pypi.org/project/pip/){target=\_blank}, o instalador de pacotes do Python:

=== "Linux (Ubuntu/Debian)"

    ```bash
     sudo apt-get install python3 && \
     sudo apt install python3-pip
    ```

=== "MacOS"

    ```bash
    brew install python3
    ```

Agora, com o Python instalado, baixe o Symbiotic CLI e suas dependÃªncias:

```bash
git clone https://github.com/symbioticfi/cli.git && \
cd cli && \
pip3 install -r requirements.txt
```

Execute o comando abaixo para verificar se a instalaÃ§Ã£o foi bem-sucedida:

```bash
python3 symb.py --help
```

O terminal deve mostrar uma lista grande dos comandos disponÃ­veis do CLI:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py --help</span>
    <span data-ty>Usage: symb.py [OPTIONS] COMMAND [ARGS]...</span>
    <br>
<span data-ty>Options:</></span>
  <span data-ty>&emsp;--chain CHAIN    Chain ID to use.  [default: mainnet]</span>
  <span data-ty>&emsp;--provider TEXT  Ethereum provider URL [http(s)].</span>
  <span data-ty>&emsp;--help           Show this message and exit.</span>
  <br>
<span data-ty>Commands:
<span data-ty>&emsp;active-balance-of&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Get an active balance of a given account...</span>
<span data-ty>&emsp;check-opt-in-network&emsp;&emsp;&ensp; Check if operator is opted in to a network.</span>
<span data-ty>&emsp;check-opt-in-vault&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Check if operator is opted in to a vault.</span>
<span data-ty>&emsp;claim&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Claim a withdrawal for some epoch at the...</span>
<span data-ty>&emsp;deposit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Deposit to the vault.</span>
<span data-ty>&emsp;.......&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;..........</span>
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/offboarding/vault-opt-out/
--- BEGIN CONTENT ---
---
title: ExclusÃ£o VoluntÃ¡ria de Vault
description: Opcionalmente, cancele sua participaÃ§Ã£o em um vault Tanssi. Aprenda a usar CLI, Etherscan ou Safe e verifique seu status de exclusÃ£o.
icon: octicons-sign-out-24
template: main.html
categories: Operators
---

# ExclusÃ£o VoluntÃ¡ria de Vault (Opcional)

## IntroduÃ§Ã£o {: #introduction }

Esta pÃ¡gina detalha a etapa final opcional no processo de desligamento Tanssi: a exclusÃ£o voluntÃ¡ria de um vault especÃ­fico. Embora nÃ£o seja obrigatÃ³ria, esta aÃ§Ã£o permite que os operators desassocie suas contas de vaults individuais. Antes de prosseguir com esta etapa, certifique-se de ter cumprido todas as condiÃ§Ãµes descritas no guia de [prÃ©-requisitos](/pt/node-operators/operators/offboarding/prerequisites/){target=\_blank}.

Este guia fornece instruÃ§Ãµes sobre como cancelar a participaÃ§Ã£o usando um dos mÃ©todos disponÃ­veis e como verificar a conclusÃ£o bem-sucedida dessa aÃ§Ã£o.

## Cancelamento de ParticipaÃ§Ã£o em um Vault {: #opting-out-of-a-vault }

Para prosseguir com a exclusÃ£o de um vault, use um dos mÃ©todos detalhados nas seÃ§Ãµes a seguir.

### Usando a CLI Symbiotic {: #opt-out-vault-with-cli }

Usando um dispositivo Ledger:

=== "MainNet"

    ```bash
    python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-out-vault {{ networks.symbiotic.contracts.sepolia.vault }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

Para assinar com uma chave privada:

=== "MainNet"

    ```bash
    python3 symb.py opt-out-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-out-vault {{ networks.symbiotic.contracts.sepolia.vault }} --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Observe que este mÃ©todo exige expor sua chave privada; portanto, nÃ£o Ã© recomendado.

### Usando o Etherscan {: #opt-out-vault-with-etherscan }

Acesse o contrato via Etherscan:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.vault_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.vault_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.vault_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.vault_registry }}#writeContract){target=\_blank}

Certifique-se de selecionar **Contract** e **Write Contract**, depois clique em **Connect to Web3** e selecione sua carteira preferida (por exemplo, MetaMask):
![Conectar ao Web3](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-4.webp)

1. Expanda a funÃ§Ã£o **optOut**
2. Insira o `VAULT_ADDRESS` no campo **where** (por exemplo, `{{ networks.symbiotic.contracts.sepolia.vault }}` no Sepolia TestNet)
3. Clique em **Write** e assine a transaÃ§Ã£o

![Cancelar operator](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-5.webp)

### Usando o Safe {: #opt-out-vault-with-safe }

Para contas Safe, use estes endereÃ§os de contrato no **Transaction Builder**:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.vault_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.vault_registry }}

Em seguida, escolha a funÃ§Ã£o optOut, insira o `VAULT_ADDRESS` ao qual seu nÃ³ estÃ¡ registrado (por exemplo, `{{ networks.symbiotic.contracts.sepolia.vault }}` no Sepolia TestNet) e assine a transaÃ§Ã£o.

## Verificar o Status de ExclusÃ£o de Vault {: #verify-vault-opt-out-status }

Depois de enviar a transaÃ§Ã£o de exclusÃ£o de vault, vocÃª pode verificar seu status de exclusÃ£o usando um dos mÃ©todos abaixo.

### Usando o Etherscan

VocÃª pode verificar o status de exclusÃ£o do seu vault no Etherscan:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.vault_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.vault_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.vault_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.vault_registry }}#readContract){target=\_blank}

Na pÃ¡gina do contrato:

Certifique-se de selecionar **Contract** e **Write Contract**, depois clique em **Connect to Web3** e selecione sua carteira preferida (por exemplo, MetaMask):
1. Selecione a guia **Read Contract**
2. Localize e expanda a funÃ§Ã£o **isOptedIn**
3. Cole a conta do seu operator no campo **who**
4. Insira o endereÃ§o do vault no campo **where**
5. Clique em **Query**

VocÃª obterÃ¡ um resultado `false` se o operator tiver cancelado a participaÃ§Ã£o no vault com sucesso e `true` se ainda estiver inscrito.

![Verifique o status do registro](/images/node-operators/operators/offboarding/offboarding-process/offboarding-process-6.webp)

### Usando a CLI Symbiotic

VocÃª tambÃ©m pode verificar o status de exclusÃ£o do seu vault usando a CLI Symbiotic:

=== "MainNet"

    ```bash
    python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.vault }}
    ```

A saÃ­da mostrarÃ¡ `false` se vocÃª tiver cancelado o vault com sucesso e `true` se ainda estiver inscrito.

## PrÃ³ximos Passos

ApÃ³s concluir o processo de desligamento, se planeja retornar no futuro, siga novamente o [processo de onboarding](/pt/node-operators/operators/onboarding/){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/onboarding/account-setup/
--- BEGIN CONTENT ---
---
title: Configure Sua Conta de Operator
description: Aprenda a mapear a conta do seu nÃ³ com sua conta stash, tornando-o elegÃ­vel para proteger o Tanssi e as redes Powered by Tanssi e receber recompensas.
icon: octicons-tools-24
categories: Operators
---

# Configure Sua Conta para Proteger o Ecossistema Tanssi

## IntroduÃ§Ã£o {: #introduction }

Como apresentado na [seÃ§Ã£o de integraÃ§Ã£o](/pt/node-operators/operators/onboarding/){target=\_blank}, assim que vocÃª [optar com sucesso para um cofre habilitado para Tanssi](/pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi-vaults){target=\_blank}, [optar para a rede Tanssi](/pt/node-operators/operators/onboarding/opt-in-to-tanssi/#opt-in-tanssi){target=\_blank}, e [preencher o formulÃ¡rio de inscriÃ§Ã£o](https://www.tanssi.network/node-operators-application){target=\_blank}, esta Ã© a sexta etapa do processo. ApÃ³s esta etapa, seu nÃ³ estarÃ¡ apto a participar do protocolo Tanssi.

Nesta etapa, vocÃª mapearÃ¡ sua conta de stash do Substrate (a que acompanha suas recompensas) para as chaves de sessÃ£o do seu nÃ³ (aquelas utilizadas para comunicaÃ§Ã£o e consenso), permitindo que o protocolo inclua seu nÃ³ no conjunto ativo.

Este guia te orienta na geraÃ§Ã£o de chaves de sessÃ£o para o seu nÃ³, mapeando-as para sua conta atravÃ©s do portal do desenvolvedor Tanssi e verificando se a associaÃ§Ã£o foi estabelecida corretamente.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Antes de configurar sua conta, certifique-se de que:

- VocÃª tem um nÃ³ corretamente [configurado e em execuÃ§Ã£o](/pt/node-operators/operators/onboarding/run-an-operator/){target=\_blank}
- VocÃª [se registrou como operator](/pt/node-operators/operators/onboarding/register-in-symbiotic/){target=\_blank} no registro Symbiotic
- VocÃª [optou pela Rede Tanssi e um cofre habilitado para Tanssi](/pt/node-operators/operators/onboarding/opt-in-to-tanssi/){target=\_blank}

## Mapear uma Conta para Seu NÃ³ {: #map-account }

A primeira etapa Ã© um processo de duas etapas que gera e mapeia as chaves de sessÃ£o para sua conta. Chaves de sessÃ£o podem ser comparadas ao ID do nÃ³, e sÃ£o usadas para executar operaÃ§Ãµes na rede, como assinar provas de validade, enquanto sua conta acompanha seu trabalho e recompensas relacionadas, e pode ter uma identidade na cadeia.

VocÃª precisarÃ¡ criar chaves de sessÃ£o para seus servidores principal e de backup. Cada servidor deve ter suas prÃ³prias chaves exclusivas. Como as chaves nunca saem de seus servidores, vocÃª pode considerÃ¡-las um ID exclusivo para aquele servidor.

### Gerar Chaves de SessÃ£o {: #generate-session-keys }

Para gerar chaves de sessÃ£o, envie uma chamada RPC usando o mÃ©todo `author_rotateKeys` para o endpoint HTTP do seu nÃ³. Para referÃªncia, se o endpoint HTTP do seu nÃ³ estiver na porta `9944`, a chamada JSON-RPC pode ser assim:

```bash
"Content-Type:application/json;charset=utf-8" -d \
  '{  
    "jsonrpc":"2.0",
    "id":1,
    "method":"author_rotateKeys",
    "params": []
  }'
```

Suas chaves de sessÃ£o codificadas em hexadecimal serÃ£o impressas no terminal no campo `"result"`.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>curl http://127.0.0.1:9944 -H \
    <br>  "Content-Type:application/json;charset=utf-8" -d \
    <br>    '{
    <br>        "jsonrpc":"2.0",
    <br>        "id":1,
    <br>        "method":"author_rotateKeys",
    <br>        "params": []
    <br>    }'
  </span>
  <span data-ty>{"jsonrpc":"2.0","id":1,"result":</span>
  <span data-ty>
  "0xca17757962a065eeebec2c6e0d2dc7fb24b56967fd9003e4d22bf4981da86fd4ac7cd701462730a76ab539d5a48f4fd2821acf07743335e56eef84d1544686480ada0ff0f38dfccee43515e619e03b0de95a08c74fcbb2da26af55ad144d5f54829a57d7d77bb9333cf9301eaa5d20c384f67388f36b402e33a03b949148325e80b812699fb22d9e4b4976e1d0e9964034489cb0b5b6b70c37d227fb54ffe50b444434b488361038b8b6949c36f0073c6bd52f2907c0991e32257d96bb946c590320539c343fc1f2e1dd1951a0ff38c6c9ea2f93a263e81ee95da1de0697e47e32"}</span>
</div>

!!! note
    Certifique-se de anotar suas chaves de sessÃ£o. Na prÃ³xima seÃ§Ã£o, vocÃª precisarÃ¡ mapeÃ¡-las para sua conta.

### Mapear Chaves de SessÃ£o {: #map-session-keys }

Para executar a etapa seguinte e mapear suas chaves de sessÃ£o para sua conta, abra o portal do desenvolvedor e vÃ¡ para a aba **Desenvolvedor**, seÃ§Ã£o **Extrinsics**. O seguinte link o levarÃ¡ diretamente para lÃ¡:

=== "Tanssi MainNet"

    [Portal do desenvolvedor da Mainnet](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/extrinsics){target=\_blank}
    

=== "Dancelight TestNet"
    
    [Portal do desenvolvedor da TestNet](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}
    

Agora, siga estas etapas:

1. Selecione sua conta, que deve ser a mesma conta que vocÃª registrou com a Tanssi anteriormente
2. Selecione o mÃ³dulo **session** e a extrÃ­nseca **setKeys**
3. Para **keys**, insira suas chaves de sessÃ£o
4. Para **proof**, insira `0x`
5. Clique em **Enviar TransaÃ§Ã£o** e assine e envie a transaÃ§Ã£o de sua carteira

![Crie e envie uma transaÃ§Ã£o para definir as chaves de sessÃ£o no Polkadot.js Apps](/images/node-operators/operators/onboarding/account-setup/account-setup-1.webp)

## Verifique o Mapeamento das Chaves {: #verify-keys-mapping }

Usar o mÃ©todo `session.keyOwner` permite verificar se suas chaves de sessÃ£o foram mapeadas para sua conta conforme o esperado. Este mÃ©todo Ã© acessÃ­vel atravÃ©s do portal do desenvolvedor, na aba **Desenvolvedor**, seÃ§Ã£o **Chain state**. O link a seguir o levarÃ¡ direto para lÃ¡:

=== "Tanssi MainNet"

    [Portal do desenvolvedor da Mainnet](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/chainstate){target=\_blank}

=== "Dancelight TestNet"

    [Portal do desenvolvedor da TestNet](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}
 

Agora, siga estas etapas:

1. Selecione o mÃ³dulo **session** e o query **keyOwner**
2. Insira `gran` no campo **SpCoreCryptoKeyTypeId**
3. Para **Bytes**, insira os primeiros sessenta e seis caracteres codificados em hexadecimal de suas chaves de sessÃ£o (por exemplo, `0x00a12170e0925a9bf98f31bbdd7988550c1bf587766a2d2735e969aa5b4291dc`)
4. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
5. A conta associada Ã s chaves de sessÃ£o, que deve ser sua conta, serÃ¡ exibida na parte inferior da pÃ¡gina

![Crie e envie uma consulta para verificar as chaves de sessÃ£o no portal do desenvolvedor](/images/node-operators/operators/onboarding/account-setup/account-setup-2.webp)

E Ã© isso! VocÃª mapeou sua conta com sucesso, e seu nÃ³ agora estÃ¡ qualificado para participar do protocolo.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/onboarding/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³ Operator
description: Aprenda como executar um operator (validador) para verificar transaÃ§Ãµes em redes Tanssi, fornecendo seguranÃ§a e ganhando recompensas por sua contribuiÃ§Ã£o.
icon: octicons-arrow-up-right-24
template: index-page.html
---

# Onboarding

Um dos principais pilares da Tanssi para builders Ã© que ela fornece seguranÃ§a econÃ´mica de nÃ­vel Ethereum para cada rede powered by Tanssi, independentemente de seu TVL, base de usuÃ¡rios ou detalhes do caso de uso. O design da Tanssi oferece aos desenvolvedores um Template de seguranÃ§a compartilhado, livrando-os de ter que obter seguranÃ§a econÃ´mica suficiente ou negociar com operators para executar nÃ³s optando por suas redes.

O protocolo Tanssi consegue isso integrando-se a [provedores de seguranÃ§a externos](/pt/learn/tanssi/external-security-providers/){target=\_blank}, como o [Symbiotic](/pt/learn/tanssi/external-security-providers/symbiotic/){target=\_blank}. Nesse Template, diferentes [cofres](/pt/learn/tanssi/external-security-providers/symbiotic/#vaults){target=\_blank} associados Ã  Tanssi fornecem seguranÃ§a econÃ´mica, e operators confiÃ¡veis fornecem serviÃ§os de validaÃ§Ã£o Ã  rede Tanssi.

Siga estas etapas para configurar seu nÃ³ e preparar sua conta para participaÃ§Ã£o ativa no protocolo Tanssi.

[timeline left (tanssi-docs/.snippets/text/pt/node-operators/operators/onboarding/onboarding-timeline.json)]

Depois de totalmente integrado, confira as [tarefas operacionais](/pt/node-operators/operators/operational-tasks/){target=\_blank} relacionadas Ã  manutenÃ§Ã£o do seu nÃ³.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/onboarding/opt-in-to-tanssi/
--- BEGIN CONTENT ---
---
title: Optar pela Tanssi
description: Saiba como fazer opt-in com seu nÃ³ registrado em cofres Symbiotic habilitados para Tanssi e na rede Tanssi para participar do protocolo e ganhar recompensas.
icon: octicons-plus-circle-24
categories: Operators
---

# Optar pela Tanssi

## IntroduÃ§Ã£o {: #introduction }

ApÃ³s [registrar seu nÃ³ no protocolo Symbiotic](/pt/node-operators/operators/onboarding/register-in-symbiotic/){target=\_blank}, as prÃ³ximas etapas sÃ£o fazer opt-in tanto nos cofres habilitados para Tanssi quanto na prÃ³pria rede Tanssi. Como apresentado na [seÃ§Ã£o de onboarding](/pt/node-operators/operators/onboarding/){target=\_blank}, estas sÃ£o a terceira e a quarta etapas.

Este guia percorre as etapas para fazer opt-in com sucesso em um cofre habilitado para Tanssi e na rede Tanssi, permitindo escolher entre vÃ¡rios mÃ©todos, incluindo usar a Symbiotic CLI, interagir diretamente com contratos inteligentes via Etherscan ou utilizar o Safe para configuraÃ§Ãµes multisig.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Antes de fazer opt-in em um cofre habilitado para Tanssi e na rede Tanssi, certifique-se de que:

- VocÃª tem um nÃ³ corretamente [configurado e em execuÃ§Ã£o](/pt/node-operators/operators/onboarding/run-an-operator/){target=\_blank}
- VocÃª [se registrou como operator](/pt/node-operators/operators/onboarding/register-in-symbiotic/){target=\_blank} no registro Symbiotic

Para seguir este guia, vocÃª deve interagir com contratos inteligentes: um do protocolo principal da Symbiotic e outro da integraÃ§Ã£o da Tanssi com a Symbiotic.

Existem vÃ¡rias formas de interagir com os contratos inteligentes:

- Usando o [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank}
- Usando o [Etherscan](https://etherscan.io/){target=\_blank}
- Usando o [Safe](https://safe.global/){target=\_blank} para configuraÃ§Ãµes multisig

Em todos os casos, vocÃª precisarÃ¡ assinar a transaÃ§Ã£o com a conta que pretende usar para o nÃ³. VocÃª pode fazer isso de diferentes maneiras:

- Usando a chave privada da conta diretamente (nÃ£o recomendado)
- Usando uma hot wallet, como o [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}
- Usando uma cold wallet, como o [Ledger](https://www.ledger.com/){target=\_blank}

A seÃ§Ã£o a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua opÃ§Ã£o.

### Configurar o Symbiotic CLI {: #set-up-the-cli }

O [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank} Ã© uma ferramenta para interagir com os contratos principais do Symbiotic. Ele Ã© escrito em [Python](https://www.python.org/){target=\_blank}, portanto vocÃª precisarÃ¡ instalar o interpretador Python e o [pip](https://pypi.org/project/pip/){target=\_blank}, o instalador de pacotes do Python:

=== "Linux (Ubuntu/Debian)"

    ```bash
     sudo apt-get install python3 && \
     sudo apt install python3-pip
    ```

=== "MacOS"

    ```bash
    brew install python3
    ```

Agora, com o Python instalado, baixe o Symbiotic CLI e suas dependÃªncias:

```bash
git clone https://github.com/symbioticfi/cli.git && \
cd cli && \
pip3 install -r requirements.txt
```

Execute o comando abaixo para verificar se a instalaÃ§Ã£o foi bem-sucedida:

```bash
python3 symb.py --help
```

O terminal deve mostrar uma lista grande dos comandos disponÃ­veis do CLI:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py --help</span>
    <span data-ty>Usage: symb.py [OPTIONS] COMMAND [ARGS]...</span>
    <br>
<span data-ty>Options:</></span>
  <span data-ty>&emsp;--chain CHAIN    Chain ID to use.  [default: mainnet]</span>
  <span data-ty>&emsp;--provider TEXT  Ethereum provider URL [http(s)].</span>
  <span data-ty>&emsp;--help           Show this message and exit.</span>
  <br>
<span data-ty>Commands:
<span data-ty>&emsp;active-balance-of&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Get an active balance of a given account...</span>
<span data-ty>&emsp;check-opt-in-network&emsp;&emsp;&ensp; Check if operator is opted in to a network.</span>
<span data-ty>&emsp;check-opt-in-vault&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Check if operator is opted in to a vault.</span>
<span data-ty>&emsp;claim&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Claim a withdrawal for some epoch at the...</span>
<span data-ty>&emsp;deposit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Deposit to the vault.</span>
<span data-ty>&emsp;.......&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;..........</span>
</div>

## Optar por Cofres Habilitados para Tanssi {: #opt-in-tanssi-vaults }

Antes de habilitar seu operator para estar ativo na rede Tanssi, vocÃª deve fazer opt-in em pelo menos um dos cofres habilitados para Tanssi. As seÃ§Ãµes a seguir descrevem vÃ¡rias formas de optar pelos cofres.

### Optar Usando a Symbiotic CLI {: #opt-in-tanssi-vaults-with-cli }

Se vocÃª instalou corretamente a [Symbiotic CLI](#set-up-the-cli) e deseja assinar a transaÃ§Ã£o usando um dispositivo Ledger, execute o comando a seguir, substituindo `INSERT_VAULT_ADDRESS` pelo endereÃ§o especÃ­fico que vocÃª quer ingressar e `INSERT_OPERATOR_ADDRESS` pela sua conta:

=== "MainNet"

    ```bash
    python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-in-vault {{ networks.symbiotic.contracts.sepolia.vault }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

Se quiser assinar a transaÃ§Ã£o diretamente usando a chave privada da conta do operator, execute o comando abaixo, substituindo o parÃ¢metro `INSERT_PRIVATE_KEY`:

=== "MainNet"

    ```bash
    python3 symb.py opt-in-vault INSERT_VAULT_ADDRESS --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-in-vault {{ networks.symbiotic.contracts.sepolia.vault }} --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Observe que este mÃ©todo exige expor sua chave privada; portanto, nÃ£o Ã© recomendado.

### Optar Usando o Etherscan {: #opt-in-tanssi-vaults-with-etherscan }

VocÃª pode interagir com os contratos inteligentes da Symbiotic usando o Etherscan e assinar a transaÃ§Ã£o com uma carteira de navegador ([MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}, por exemplo).

Para abrir a pÃ¡gina do contrato, acesse:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.vault_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.vault_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.vault_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.vault_registry }}#writeContract){target=\_blank}

Clique em **Connect to Web3** e selecione sua carteira preferida (por exemplo, MetaMask):

![Etapa Conectar ao Web3](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-1.webp)

!!! note
    VocÃª pode configurar o MetaMask para usar uma carteira fria.

ApÃ³s a conexÃ£o:

1. Expanda a funÃ§Ã£o **`optin`**
2. Insira o `VAULT_ADDRESS` (`{{ networks.symbiotic.contracts.sepolia.vault }}` no TestNet Sepolia)
3. Clique em **Write** e assine a transaÃ§Ã£o

![Registrar o operator](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-2.webp)

### Optar Usando o Safe para ConfiguraÃ§Ãµes Multisig {: #opt-in-tanssi-vaults-with-safe }

Se vocÃª tiver uma conta [Safe](https://app.safe.global/){target=\_blank}, abra o **Transaction builder** e insira o seguinte endereÃ§o de contrato:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.vault_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.vault_registry }}

Finalmente, escolha a funÃ§Ã£o **`optin`**, insira o `VAULT_ADDRESS` (`{{ networks.symbiotic.contracts.sepolia.vault }}` no TestNet Sepolia) e assine a transaÃ§Ã£o.

### Verificar o Status do Registro {: #check-vault-registration }

VocÃª pode verificar rapidamente seu status de registro no Etherscan. Abra o seguinte link:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.vault_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.vault_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.vault_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.vault_registry }}#readContract){target=\_blank}

Na pÃ¡gina do contrato:

1. Selecione a funÃ§Ã£o **`isOptedIn`**
2. Cole a conta do seu operator no campo **who**
3. Insira o `VAULT_ADDRESS` no campo **where**
4. Clique em **Query**

VocÃª obterÃ¡ um resultado `true` se seu operator foi registrado corretamente e `false` caso contrÃ¡rio.

![Verificar o status do registro](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-3.webp)

VocÃª tambÃ©m pode verificar o status do seu registro usando a Symbiotic CLI executando o comando abaixo, que imprime `true` ou `false` para qualquer endereÃ§o de operator em um cofre habilitado para Tanssi:

=== "MainNet"
    
    ```bash
    python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia check-opt-in-vault INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.vault }}
    ```

E a saÃ­da se parece com:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py check-opt-in-vault INSERT_OPERATOR_ADDRESS INSERT_VAULT_ADDRESS</span>
    <span data-ty>Connected to chain ID 1</span>
    <span data-ty>True</span>
    <br>
</div>

## Optar pela Rede Tanssi {: #opt-in-tanssi }

Antes de habilitar seu operator para estar ativo na rede Tanssi, vocÃª deve fazer opt-in na rede e ser aprovado pela equipe Tanssi. As seÃ§Ãµes a seguir descrevem vÃ¡rias formas de optar pela rede.

!!! note
    O endereÃ§o da Tanssi Network na MainNet serÃ¡ divulgado no lanÃ§amento.

### Optar Usando a Symbiotic CLI {: #opt-in-tanssi-with-cli }

Se vocÃª instalou corretamente a [Symbiotic CLI](#set-up-the-cli) e deseja assinar a transaÃ§Ã£o usando um dispositivo Ledger, execute o seguinte comando, substituindo `INSERT_OPERATOR_ADDRESS`:

=== "MainNet"

    ```bash
    python3 symb.py opt-in-network {{ networks.symbiotic.contracts.mainnet.tanssi_network }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-in-network {{ networks.symbiotic.contracts.sepolia.tanssi_network }} --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

Se vocÃª quiser assinar a transaÃ§Ã£o diretamente usando a chave privada da conta do operator, execute o comando abaixo, substituindo o parÃ¢metro `INSERT_PRIVATE_KEY`:

=== "MainNet"

    ```bash
    python3 symb.py opt-in-network {{ networks.symbiotic.contracts.mainnet.tanssi_network }} --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia opt-in-network {{ networks.symbiotic.contracts.sepolia.tanssi_network }} --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Observe que este mÃ©todo exige expor sua chave privada; portanto, nÃ£o Ã© recomendado.

### Optar Usando o Etherscan {: #opt-in-tanssi-with-etherscan }

VocÃª pode interagir com os contratos inteligentes da Symbiotic usando o Etherscan e assinar a transaÃ§Ã£o com uma carteira de navegador ([MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}, por exemplo).

VÃ¡ para a pÃ¡gina do contrato abrindo o link:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.network_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.network_registry }}#writeContract){target=\_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.network_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.network_registry }}#writeContract){target=\_blank}

Clique em **Connect to Web3** e selecione sua carteira preferida (por exemplo, MetaMask):

![Etapa Conectar ao Web3](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-4.webp)

!!! note
    VocÃª pode configurar o MetaMask para usar uma carteira fria.

ApÃ³s a conexÃ£o:

1. Expanda a funÃ§Ã£o **`optin`**
2. Insira o `TANSSI_NETWORK_ADDRESS`. Se estiver fazendo opt-in para a Tanssi MainNet, use `{{ networks.symbiotic.contracts.mainnet.tanssi_network }}`. Para TestNet, use `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}`
3. Clique em **Write** e assine a transaÃ§Ã£o

![Registrar o operator](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-5.webp)

### Optar Usando o Safe para ConfiguraÃ§Ãµes Multisig {: #opt-in-tanssi-with-safe }

Se vocÃª tiver uma conta [Safe](https://app.safe.global/){target=\_blank}, abra o **Transaction builder** e insira o seguinte endereÃ§o de contrato:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.network_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.network_registry }}

Finalmente, escolha a funÃ§Ã£o **`optin`**, insira o endereÃ§o da Rede Tanssi (`{{ networks.symbiotic.contracts.mainnet.tanssi_network }}` para Tanssi MainNet e `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}` para TestNet) e assine a transaÃ§Ã£o.

### Verificar o Status do Registro {: #check-tanssi-registration }

VocÃª pode verificar rapidamente seu status de registro no Etherscan. Abra o seguinte link:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.network_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.network_registry }}#readContract){target=\_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.network_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.network_registry }}#readContract){target=\_blank}

Na pÃ¡gina do contrato:

1. Selecione a funÃ§Ã£o **`isOptedIn`**
2. Cole a conta do seu operator no campo **who**
3. Insira o `TANSSI_NETWORK_ADDRESS` no campo **where**. Se estiver optando pela Tanssi MainNet, use `{{ networks.symbiotic.contracts.mainnet.tanssi_network }}`. Para TestNet, use `{{ networks.symbiotic.contracts.sepolia.tanssi_network }}`
4. Clique em **Query**

VocÃª obterÃ¡ um resultado `true` se seu operator foi registrado corretamente e `false` caso contrÃ¡rio.

![Verificar o status do registro](/images/node-operators/operators/onboarding/opt-in-to-tanssi/opt-in-to-tanssi-6.webp)

VocÃª tambÃ©m pode verificar o status do seu registro usando a Symbiotic CLI executando o comando a seguir, que imprime `true` ou `false` para qualquer endereÃ§o de operator na Rede Tanssi:

=== "MainNet"
    
    ```bash
    python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.mainnet.tanssi_network }}
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.tanssi_network }} 
    ```

E a saÃ­da se parece com:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py check-opt-in-network INSERT_OPERATOR_ADDRESS {{ networks.symbiotic.contracts.sepolia.tanssi_network }}</span>
    <span data-ty>Connected to chain ID 1</span>
    <span data-ty>True</span>
    <br>
</div>

!!! note
    Fazer opt-in nas Redes Tanssi requer aprovaÃ§Ã£o da equipe Tanssi. As solicitaÃ§Ãµes para participar podem levar atÃ© uma semana.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/onboarding/register-in-symbiotic/
--- BEGIN CONTENT ---
---
title: Registrar no Symbiotic
description: Aprenda como registrar seu nÃ³ no registro Symbiotic como o primeiro passo para participar do protocolo, protegendo as redes Tanssi e ganhando recompensas.
icon: octicons-shield-check-24
categories: Operators
---

# Registrar no Symbiotic

## IntroduÃ§Ã£o {: #introduction }

Como apresentado na [seÃ§Ã£o de integraÃ§Ã£o](/pt/node-operators/operators/onboarding/){target=_blank}, registrar no Symbiotic Ã© o segundo passo do processo. VocÃª jÃ¡ deve ter o nÃ³ sincronizado e em execuÃ§Ã£o, seja usando [Docker](/pt/node-operators/operators/onboarding/run-an-operator/operators-docker/){target=_blank} ou [Systemd](/pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/){target=_blank}.

O protocolo Tanssi fornece Ã s suas appchains seguranÃ§a de nÃ­vel Ethereum desde o inÃ­cio, confiando em provedores externos como o [Symbiotic](/pt/learn/tanssi/external-security-providers/symbiotic/){target=_blank}. Para participar como operator no ecossistema Tanssi, vocÃª deve primeiro registrar seu nÃ³ no protocolo Symbiotic. O processo de registro estabelece seu nÃ³ como operator reconhecido.

Este guia mostra as etapas para registrar seu nÃ³ como operator Symbiotic, permitindo escolher entre vÃ¡rios mÃ©todos: CLI Symbiotic, interaÃ§Ã£o direta via Etherscan ou uso do Safe para configuraÃ§Ãµes multisig.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Antes de se registrar, certifique-se de jÃ¡ ter [configurado o nÃ³](/pt/node-operators/operators/onboarding/run-an-operator/){target=_blank} e que ele esteja em execuÃ§Ã£o.

Para seguir este guia, vocÃª deverÃ¡ interagir com contratos inteligentes.
Existem vÃ¡rias formas de interagir com os contratos inteligentes:

- Usando o [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank}
- Usando o [Etherscan](https://etherscan.io/){target=\_blank}
- Usando o [Safe](https://safe.global/){target=\_blank} para configuraÃ§Ãµes multisig

Em todos os casos, vocÃª precisarÃ¡ assinar a transaÃ§Ã£o com a conta que pretende usar para o nÃ³. VocÃª pode fazer isso de diferentes maneiras:

- Usando a chave privada da conta diretamente (nÃ£o recomendado)
- Usando uma hot wallet, como o [MetaMask](/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=\_blank}
- Usando uma cold wallet, como o [Ledger](https://www.ledger.com/){target=\_blank}

A seÃ§Ã£o a seguir descreve os passos para instalar o Symbiotic CLI, caso essa seja sua opÃ§Ã£o.

### Configurar o Symbiotic CLI {: #set-up-the-cli }

O [Symbiotic CLI](https://github.com/symbioticfi/cli){target=\_blank} Ã© uma ferramenta para interagir com os contratos principais do Symbiotic. Ele Ã© escrito em [Python](https://www.python.org/){target=\_blank}, portanto vocÃª precisarÃ¡ instalar o interpretador Python e o [pip](https://pypi.org/project/pip/){target=\_blank}, o instalador de pacotes do Python:

=== "Linux (Ubuntu/Debian)"

    ```bash
     sudo apt-get install python3 && \
     sudo apt install python3-pip
    ```

=== "MacOS"

    ```bash
    brew install python3
    ```

Agora, com o Python instalado, baixe o Symbiotic CLI e suas dependÃªncias:

```bash
git clone https://github.com/symbioticfi/cli.git && \
cd cli && \
pip3 install -r requirements.txt
```

Execute o comando abaixo para verificar se a instalaÃ§Ã£o foi bem-sucedida:

```bash
python3 symb.py --help
```

O terminal deve mostrar uma lista grande dos comandos disponÃ­veis do CLI:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py --help</span>
    <span data-ty>Usage: symb.py [OPTIONS] COMMAND [ARGS]...</span>
    <br>
<span data-ty>Options:</></span>
  <span data-ty>&emsp;--chain CHAIN    Chain ID to use.  [default: mainnet]</span>
  <span data-ty>&emsp;--provider TEXT  Ethereum provider URL [http(s)].</span>
  <span data-ty>&emsp;--help           Show this message and exit.</span>
  <br>
<span data-ty>Commands:
<span data-ty>&emsp;active-balance-of&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Get an active balance of a given account...</span>
<span data-ty>&emsp;check-opt-in-network&emsp;&emsp;&ensp; Check if operator is opted in to a network.</span>
<span data-ty>&emsp;check-opt-in-vault&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Check if operator is opted in to a vault.</span>
<span data-ty>&emsp;claim&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Claim a withdrawal for some epoch at the...</span>
<span data-ty>&emsp;deposit&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Deposit to the vault.</span>
<span data-ty>&emsp;.......&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;..........</span>
</div>

## Registrar como Operator {: #registering-operator }

O protocolo Symbiotic mantÃ©m um registro de todos os operators. Antes de proteger redes Tanssi, registre-se usando um dos mÃ©todos abaixo.

### Registrar usando a CLI Symbiotic {: #register-with-cli }

Se vocÃª instalou a [CLI Symbiotic](#set-up-the-cli) e quer assinar com um dispositivo Ledger, execute o comando abaixo, substituindo `INSERT_OPERATOR_ADDRESS` pela sua conta:

=== "MainNet"

    ```bash
    python3 symb.py register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia register-operator --ledger --ledger-account INSERT_OPERATOR_ADDRESS
    ```

Se preferir assinar diretamente com a chave privada da conta, execute (substitua `INSERT_PRIVATE_KEY`):

=== "MainNet"

    ```bash
    python3 symb.py register-operator --private-key INSERT_PRIVATE_KEY
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia register-operator --private-key INSERT_PRIVATE_KEY
    ```

!!! warning
    Este mÃ©todo exige expor sua chave privada; nÃ£o Ã© recomendado.

### Registrar usando o Etherscan {: #register-with-etherscan }

VocÃª pode interagir com os contratos do Symbiotic pelo Etherscan e assinar com uma carteira de navegador ([MetaMask](/pt/builders/toolkit/ethereum-api/wallets/metamask/#install-the-metamask-extension){target=_blank}, por exemplo).

Abra a pÃ¡gina do contrato:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.operators_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.operators_registry }}#writeContract){target=_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.operators_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.operators_registry }}#writeContract){target=_blank}

Clique em **Conectar ao Web3** e selecione sua carteira preferida (por exemplo, MetaMask):

![Conectar Ã  etapa Web3](/images/node-operators/operators/onboarding/register-in-symbiotic/register-in-symbiotic-1.webp)

!!! note
    VocÃª pode configurar o MetaMask para usar uma carteira fria.

Depois de conectado:

1. Expanda a funÃ§Ã£o **`registerOperator`**
2. Clique em **Write** e assine a transaÃ§Ã£o

![Registrar o operator](/images/node-operators/operators/onboarding/register-in-symbiotic/register-in-symbiotic-2.webp)

### Registrar Usando o Safe para Multisig {: #register-with-safe }

Se vocÃª tiver uma conta [Safe](https://app.safe.global/){target=_blank}, abra o **Transaction builder** e insira o seguinte endereÃ§o do contrato:

=== "MainNet"

    {{ networks.symbiotic.contracts.mainnet.operators_registry }}

=== "TestNet (Sepolia)"

    {{ networks.symbiotic.contracts.sepolia.operators_registry }}

Por fim, escolha a funÃ§Ã£o **`registerOperator`** e assine a transaÃ§Ã£o.

## Verificar o Status do Registro {: #check-registration }

VocÃª pode verificar rapidamente seu status de registro no Etherscan. Abra:

=== "MainNet"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.mainnet.operators_registry }}](https://etherscan.io/address/{{ networks.symbiotic.contracts.mainnet.operators_registry }}#readContract){target=_blank}

=== "TestNet (Sepolia)"

    [EndereÃ§o do contrato: {{ networks.symbiotic.contracts.sepolia.operators_registry }}](https://sepolia.etherscan.io/address/{{ networks.symbiotic.contracts.sepolia.operators_registry }}#readContract){target=_blank}

Na pÃ¡gina do contrato:

1. Selecione a funÃ§Ã£o **`isEntity`**
2. Cole a conta do seu operator
3. Clique em **Query**

Se o operator foi registrado corretamente, o resultado serÃ¡ `true`; caso contrÃ¡rio, `false`.

![Verificar o status do registro](/images/node-operators/operators/onboarding/register-in-symbiotic/register-in-symbiotic-3.webp)

VocÃª tambÃ©m pode verificar o status via CLI Symbiotic, executando:

=== "MainNet"
    
    ```bash
    python3 symb.py isop INSERT_OPERATOR_ADDRESS
    ```

=== "TestNet (Sepolia)"

    ```bash
    python3 symb.py --chain sepolia isop INSERT_OPERATOR_ADDRESS
    ```

E a saÃ­da se parece com:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>python3 symb.py isop INSERT_OPERATOR_ADDRESS</span>
    <span data-ty>Connected to chain ID 1</span>
    <span data-ty>True</span>
    <br>
</div>

## Enviar Metadados {: #submitting-metadata }

ApÃ³s o registro, vocÃª pode adicionar metadados (por exemplo, logotipo) para melhorar a visibilidade no [site Symbiotic](https://app.symbiotic.fi){target=_blank}.

Para enviar os metadados do operator, acesse o repositÃ³rio de metadados Symbiotic:

=== "MainNet"

    [RepositÃ³rio MainNet](https://github.com/symbioticfi/metadata-mainnet){target=_blank}

Crie um fork do repositÃ³rio e, no diretÃ³rio `operators`, crie uma pasta com o endereÃ§o do seu operator. Dentro dela, adicione `logo.png` e um arquivo `info.json` com os campos abaixo (substitua pelos seus valores):

```json title="info.json"
{
	"name": "INSERIR_SEU_NOME_DO_OPERATOR",
	"description": "INSERIR_SUA_DESCRIÃ‡ÃƒO_DO_OPERATOR",
	"tags": [
		"operator"
	],
	"links": [
		{
			"type": "website",
			"name": "Website",
			"url": "https://INSERIR_SEU_URL_DO_SITE"
		},
		{
			"type": "website",
			"name": "X",
			"url": "https://INSERIR_SEU_URL_X"
		}
	]
}
```

!!! note
    O parÃ¢metro `links` Ã© um array. Adicione quantos links forem necessÃ¡rios.

Por fim, abra um pull request. A equipe Symbiotic revisarÃ¡ e farÃ¡ o merge.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/onboarding/run-an-operator/
--- BEGIN CONTENT ---
---
title: Executar um Operator
description: Aprenda como configurar e executar um node operator (tambÃ©m conhecido como validadores) usando Docker ou Systemd para participar do protocolo que protege o ecossistema.
icon: octicons-server-24
template: index-page.html
---

# Executar um NÃ³ Operator

A configuraÃ§Ã£o de um node operator Ã© um passo importante para participar da rede Tanssi. VocÃª tem duas opÃ§Ãµes de configuraÃ§Ã£o: usar _Docker_ ou _Systemd._ Qualquer que seja o caminho que vocÃª escolher, fornecemos tutoriais passo a passo para guiÃ¡-lo pelo processo e garantir que seu nÃ³ atenda aos requisitos necessÃ¡rios para validar as transaÃ§Ãµes da rede Tanssi e fornecer seguranÃ§a ao ecossistema.

### Requisitos de Hardware

Para executar um node operator com sucesso, hardware de alto desempenho Ã© essencial. ConfiguraÃ§Ãµes subÃ³timas podem levar a atrasos, indisponibilidade e, por fim, perdas de recompensas e/ou penalidades. Como o processo de validaÃ§Ã£o depende muito do desempenho de um Ãºnico thread, Ã© recomendÃ¡vel priorizar CPUs com fortes capacidades de um Ãºnico thread em vez de contagens de nÃºcleos mais altas.

Hardware recomendado:

- **ConfiguraÃ§Ã£o Recomendada** - Hardware bare metal executando linux debian ou ubuntu
- **CPUs Recomendadas** - Intel Ice Lake ou mais recente (sÃ©rie Xeon ou Core) ou AMD Zen3 ou mais recente (EPYC ou Ryzen). Oito nÃºcleos fÃ­sicos @ 3,4 GHz com hyperthreading desativado (SMT para processadores AMD)
- **NVMe Recomendado** - SSD NVMe de 500 GB
- **RAM Recomendada** - 32 GB ECC RAM
- **Rede Recomendada** - ConexÃ£o de 1 Gbps

!!! warning
    Como operator, vocÃª Ã© responsÃ¡vel tanto pelo seu prÃ³prio stake quanto pelo de seus delegadores. Manter o desempenho do seu nÃ³, mantÃª-lo atualizado e garantir sua seguranÃ§a sÃ£o cruciais para maximizar as recompensas e construir uma forte reputaÃ§Ã£o na rede Tanssi.

### Portas de Rede NecessÃ¡rias

Um operator de sucesso deve ser capaz de sincronizar e interagir com uma rede ponto a ponto (P2P). Para garantir a comunicaÃ§Ã£o adequada dentro do ecossistema Tanssi, certifique-se de que a seguinte porta esteja aberta para entrada:

| Rede          | Porta        |
|------------------|-------------|
| Tanssi Chain     | 30333 (TCP) |

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/onboarding/run-an-operator/operators-docker/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³ Operator Usando Docker
description: Aprenda como configurar e executar um operator (tambÃ©m conhecido como validador) para a rede Tanssi usando o Docker, participando do protocolo, protegendo redes e ganhando recompensas.
icon: simple-docker
categories: Operators
---

# Executar um NÃ³ Operator Usando Docker

## IntroduÃ§Ã£o {: #introduction }

Os operators sÃ£o fundamentais no ecossistema Tanssi, fornecendo seguranÃ§a e validaÃ§Ã£o para redes baseadas em Tanssi. Como operator, vocÃª participa do consenso que protege a rede e ganha recompensas.

Conforme apresentado na [seÃ§Ã£o de integraÃ§Ã£o](/pt/node-operators/operators/onboarding/){target=_blank}, executar o nÃ³ Ã© o primeiro passo da sua participaÃ§Ã£o ativa no protocolo.

Este guia mostra como iniciar um operator Tanssi usando a imagem oficial com [Docker](https://www.docker.com){target=_blank} em sistemas Linux.

## Verificando PrÃ©-Requisitos {: #checking-prerequisites }

### Instalando o Docker {: #installing-docker}

Para comeÃ§ar, vocÃª precisarÃ¡ de um computador com Linux e instalar o [Docker](https://docs.docker.com/desktop/setup/install/linux/){target=\blank}.

Execute o comando a seguir para instalar o Docker em um Ubuntu:

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

E o comando abaixo para verificar a instalaÃ§Ã£o:

```bash
sudo docker run hello-world
```

Uma execuÃ§Ã£o bem-sucedida no terminal se parece com isto:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>sudo docker run hello-world</span>
  <span data-ty>
    <br> 
    <br> Hello from Docker!
    <br> This message shows that your installation appears to be working correctly.
    <br> 
    <br> To generate this message, Docker took the following steps:
    <br> 1. The Docker client contacted the Docker daemon.
    <br> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    <br>     (amd64)
    <br> 3. The Docker daemon created a new container from that image which runs the
    <br>     executable that produces the output you are currently reading.
    <br> 4. The Docker daemon streamed that output to the Docker client, which sent it
    <br>     to your terminal.
    <br>
    <br> To try something more ambitious, you can run an Ubuntu container with:
    <br> $ docker run -it ubuntu bash
    <br>
    <br> Share images, automate workflows, and more with a free Docker ID:
    <br> https://hub.docker.com/
    <br>
    <br> For more examples and ideas, visit:
    <br>  https://docs.docker.com/get-started/
  </span>
</div>

### Puxar a Imagem Docker {: #pull-docker-image }

Uma imagem Docker Ã© construÃ­da e publicada em cada versÃ£o, contendo todas as dependÃªncias necessÃ¡rias e o binÃ¡rio do operator.

A imagem combina o binÃ¡rio estÃ¡vel mais recente do [nÃ³ cliente](/pt/learn/framework/architecture/#architecture){target=_blank} com o arquivo de especificaÃ§Ã£o do orquestrador Tanssi.

Execute o comando a seguir para puxar a imagem Docker:

=== "Tanssi MainNet"

    ```bash
    docker pull {{ networks.dancelight.operator_docker_image }}
    ```

=== "Dancelight TestNet"

    ```bash
    docker pull {{ networks.dancelight.operator_docker_image }}
    ```

O comando farÃ¡ download/extrair a imagem e exibirÃ¡ o status apÃ³s a execuÃ§Ã£o:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker pull moondancelabs/starlight</span>
  <span data-ty>
    <br> 
    <br> Using default tag: latest
    <br> latest: Pulling from moondancelabs/starlight
    <br> e1caac4eb9d2: Pull complete 
    <br> 1d4409959e6d: Pull complete 
    <br> b8beed19c122: Pull complete 
    <br> c0fab1f18601: Pull complete 
    <br> Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c
    <br> Status: Downloaded newer image for moondancelabs/starlight
    <br> docker.io/moondancelabs/starlight
  </span>
</div>

### Configure o diretÃ³rio de dados {: #set-up-data-directory }

Executar um nÃ³ requer sincronizar com a cadeia Tanssi e armazenar seu estado.

Crie o diretÃ³rio onde o nÃ³ armazenarÃ¡ os bancos de dados contendo blocos e estados de cadeia:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the Docker image to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    chown INSERT_DOCKER_USER /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    chown INSERT_DOCKER_USER /var/lib/dancelight-data
    ```

Ou execute o comando a seguir se quiser rodar o nÃ³ com o usuÃ¡rio atualmente logado:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"
    
    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data
    ```

!!! note
    O diretÃ³rio Ã© um parÃ¢metro no comando de inicializaÃ§Ã£o do Docker. Se decidir criÃ¡-lo em outro lugar, ajuste o comando.

### Gerar a Chave do NÃ³ {: #generate-node-key }

Para gerar e armazenar as chaves de sessÃ£o em disco (referenciadas no comando de inicializaÃ§Ã£o), execute:

=== "Tanssi MainNet"

    ```bash
    docker run --network="host" -v "/var/lib/tanssi-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ networks.dancelight.operator_docker_image }} key generate-node-key --file /data/node-key
    ```

=== "Dancelight TestNet"

    ```bash
    docker run --network="host" -v "/var/lib/dancelight-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ networks.dancelight.operator_docker_image }} key generate-node-key --file /data/node-key
    ```

!!! note
    Esta etapa poderia ser evitada usando o parÃ¢metro `--unsafe-force-node-key-generation` no comando de inicializaÃ§Ã£o, embora essa nÃ£o seja a prÃ¡tica recomendada.

## Inicie Seu NÃ³ {: #start-your-node }

Para iniciar seu nÃ³, execute a imagem Docker com `docker run`.

Substitua `INSERT_YOUR_TANSSI_NODE_NAME` por um nome legÃ­vel e `INSERT_YOUR_IP_ADDRESS` pelo IP pÃºblico.

!!! note
    Recomenda-se usar as versÃµes binÃ¡rias otimizadas para as arquiteturas [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} da Intel ou [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} da AMD para melhor desempenho.

=== "Tanssi MainNet"

    === "GenÃ©rico"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

=== "Dancelight TestNet"

    === "GenÃ©rico"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

### Flags de ExecuÃ§Ã£o {: #run-flags }

As flags usadas no comando `docker run` podem ser ajustadas conforme suas preferÃªncias e configuraÃ§Ã£o de hardware. Algumas das principais sÃ£o:

- `--name INSERT_NAME` - a human-readable name for this node
- `--rpc-port INSERT_PORT` - specifies the JSON-RPC TCP port the node listens on
- `--unsafe-rpc-external` - exposes the RPC service on all the interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the state), `archive-canonical` (which keeps only the state of finalized blocks), or any `number` (representing the number of blocks whose states are kept)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - specifies how many blocks should be kept in the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the blocks), `archive-canonical` (which keeps only finalized blocks), or any `number` (representing the amount of finalized blocks to keep)
- `--detailed-log-output` - enables detailed log output

!!! warning
    The `--unsafe-rpc-external` enables external access to your nodeâ€™s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.

For a complete list of available flags, their description, and possible values, run the following command:

=== "Tanssi MainNet"

    ```bash
    docker run -ti {{ networks.dancelight.operator_docker_image }} --help
    ```

=== "Dancelight TestNet"

    ```bash
    docker run -ti {{ networks.dancelight.operator_docker_image }} --help
    ```

## Sincronizando Seu NÃ³ {: #syncing-your-node }

Na primeira execuÃ§Ã£o, o processo de sincronizaÃ§Ã£o exibirÃ¡ muitos logs do nÃ³ e da cadeia sendo sincronizada. Alguns erros iniciais sÃ£o esperados e desaparecem quando a cadeia alcanÃ§a o Ãºltimo bloco.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker run ....</span>
  <span data-ty>
    <br> 2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] ðŸ’¤ Idle (0 peers), best: #0 (0x4a2bâ€¦7de3), finalized #0 (0x4a2bâ€¦7de3), â¬‡ 0 â¬† 0
    <br> 2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] âœ¨ Imported #14139635 (0x8c41â€¦8df6)    
    <br> 2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] ðŸ’¤ Idle (8 peers), best: #14139635 (0x8c41â€¦8df6), finalized #14139632 (0xa9a8â€¦cab9), â¬‡ 32.7kiB/s â¬†
  </span>
</div>

Quando a sincronizaÃ§Ã£o terminar, seu nÃ³ estarÃ¡ pronto para as prÃ³ximas etapas.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/
--- BEGIN CONTENT ---
---
title: Executar um NÃ³ Operator Usando Systemd
description: Aprenda como configurar e executar um nÃ³ operator (validador) para as redes Tanssi usando Systemd, permitindo participar do protocolo e ganhar recompensas.
icon: simple-linux
categories: Operators
---

# Executar um NÃ³ Operator Usando Systemd

## IntroduÃ§Ã£o {: #introduction }

Os operators sÃ£o cruciais no ecossistema Tanssi, fornecendo seguranÃ§a e validaÃ§Ã£o para redes baseadas em Tanssi. Como operator, vocÃª participa do consenso que protege a rede e ganha recompensas.

Conforme apresentado na [seÃ§Ã£o de integraÃ§Ã£o](/pt/node-operators/operators/onboarding/){target=\_blank}, executar o nÃ³ Ã© o primeiro passo da sua participaÃ§Ã£o ativa no protocolo.

Neste guia, vocÃª aprenderÃ¡ a iniciar um operator Tanssi usando o binÃ¡rio estÃ¡vel mais recente e gerenciar o serviÃ§o com [Systemd](https://systemd.io){target=\_blank} em sistemas Linux.

O artigo segue a boa prÃ¡tica de executar o serviÃ§o com uma conta nÃ£o-root e conceder a essa conta acesso de gravaÃ§Ã£o a um diretÃ³rio especÃ­fico. Adapte as etapas conforme sua configuraÃ§Ã£o e polÃ­ticas de seguranÃ§a.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

VocÃª precisarÃ¡ de acesso a um computador Ubuntu Linux com [Landlock](https://docs.kernel.org/security/landlock.html){target=\_blank} habilitado e privilÃ©gios de root. TambÃ©m precisarÃ¡ de:

- **Arquivos binÃ¡rios do nÃ³** - o operator precisa de trÃªs binÃ¡rios: `tanssi-relay`, `tanssi-relay-execute-worker` e `tanssi-relay-prepare-worker`

As instruÃ§Ãµes usam a [versÃ£o estÃ¡vel mais recente](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank}. VocÃª pode compilar seu prÃ³prio arquivo a partir do [cÃ³digo fonte](https://github.com/moondance-labs/tanssi){target=\_blank}.

## Verificar Suporte Landlock {: #check-landlock }

Os operators Tanssi usam o recurso Landlock do kernel Linux como medida de seguranÃ§a para restringir o acesso a recursos do sistema.

Verifique o suporte Landlock executando:

```bash
sudo dmesg | grep landlock || journalctl -kg landlock
```

A saÃ­da esperada Ã© similar a:

<div id="termynal" data-termynal>
    <span data-ty="input"><span class="file-path"></span>sudo dmesg | grep landlock || journalctl -kg landlock</span>
    <span data-ty>[    0.240344] landlock: Up and running.</span>
</div>

Se o Landlock estiver desabilitado, atualize o kernel para a versÃ£o 5.13 ou superior.

## Baixar a VersÃ£o Mais Recente {: #download-latest-release }

Baixe os binÃ¡rios mais recentes e torne-os executÃ¡veis:

!!! note
    Recomenda-se usar as versÃµes binÃ¡rias otimizadas para as arquiteturas [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} da Intel ou [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} da AMD para melhor desempenho.

=== "GenÃ©rico"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "Intel Skylake"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-skylake -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "AMD Zen3"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-znver3 -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

## Configure o serviÃ§o Systemd {: #set-up-systemd-service }

O [Systemd](https://systemd.io){target=\_blank} Ã© um sistema de gerenciamento para Linux que controla serviÃ§os (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas.

Os comandos a seguir criam uma nova conta, o diretÃ³rio e movem os arquivos previamente baixados para o local correto.

1. Crie uma nova conta para executar o serviÃ§o:

    === "Tanssi MainNet"

        ```bash
        adduser tanssi_service --system --no-create-home
        ```

    === "Dancelight TestNet"
        
        ```bash
        adduser dancelight_service --system --no-create-home
        ```

2. Crie um diretÃ³rio para armazenar os arquivos e dados necessÃ¡rios:

    === "Tanssi MainNet"

        ```bash
        mkdir /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        mkdir /var/lib/dancelight-data
        ```

3. Defina a propriedade da pasta para a conta que executarÃ¡ o serviÃ§o, garantindo permissÃ£o de escrita:

    === "Tanssi MainNet"

        ```bash
        chown -R tanssi_service /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        chown -R tanssi_service /var/lib/dancelight-data
        ```

4. Mova os binÃ¡rios para a pasta:

    === "Tanssi MainNet"

        ```bash
        mv ./tanssi-relay* /var/lib/tanssi-data
        ```

    === "Dancelight TestNet"
        
        ```bash
        mv ./tanssi-relay* /var/lib/dancelight-data
        ```

### Gerar a chave do nÃ³ {: #generate-node-key }

Para gerar e armazenar em disco as chaves de sessÃ£o que serÃ£o referenciadas no comando de inicializaÃ§Ã£o, execute:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-relay key generate-node-key --file /var/lib/tanssi-data/node-key
    ```

=== "Dancelight TestNet"
    
    ```bash
    /var/lib/dancelight-data/tanssi-relay key generate-node-key --file /var/lib/dancelight-data/node-key
    ```

!!! note
    Esta etapa poderia ser evitada usando o parÃ¢metro `--unsafe-force-node-key-generation` no comando de inicializaÃ§Ã£o, embora essa nÃ£o seja a prÃ¡tica recomendada.

### Criar o arquivo de configuraÃ§Ã£o do Systemd {: #create-systemd-configuration }

O prÃ³ximo passo Ã© criar o arquivo de configuraÃ§Ã£o do Systemd.

Crie o arquivo executando o comando:

=== "Tanssi MainNet"

    ```bash
    sudo touch /etc/systemd/system/tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    sudo touch /etc/systemd/system/dancelight.service
    ```

Agora abra o arquivo com seu editor favorito (vim, emacs, nano etc.) e adicione a configuraÃ§Ã£o do serviÃ§o, substituindo a tag `INSERT_YOUR_TANSSI_NODE_NAME` por um nome legÃ­vel e `INSERT_YOUR_IP_ADDRESS` pelo seu endereÃ§o IP pÃºblico. Esse nome ajuda a relacionar entradas de log e mÃ©tricas ao nÃ³ que as gera.

=== "Tanssi MainNet"

    ```bash
    [Unit]
    Description="ServiÃ§o systemd Tanssi"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    User=tanssi_service
    Type=simple
    Restart=always
    RestartSec=10
    SyslogIdentifier=tanssi
    SyslogFacility=local7
    KillSignal=SIGHUP
    LimitNOFILE=100000
    ExecStart=/var/lib/tanssi-data/tanssi-relay --chain=tanssi \
    --base-path=/var/lib/tanssi-data/ \
--node-key-file /var/lib/tanssi-data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator

    [Install]
    WantedBy=multi-user.target
    ```

=== "Dancelight TestNet"

    ```bash
    [Unit]
    Description="ServiÃ§o systemd Tanssi"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    User=tanssi_service
    Type=simple
    Restart=always
    RestartSec=10
    SyslogIdentifier=tanssi
    SyslogFacility=local7
    KillSignal=SIGHUP
    LimitNOFILE=100000
    ExecStart=/var/lib/tanssi-data/tanssi-relay --chain=dancelight \
    --base-path=/var/lib/tanssi-data/ \
--node-key-file /var/lib/tanssi-data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator

    [Install]
    WantedBy=multi-user.target
    ```

### Flags de ExecuÃ§Ã£o {: #run-flags }

As flags usadas no `ExecStart` podem ser ajustadas conforme preferÃªncias e hardware. Algumas das principais:

- `--name INSERT_NAME` - a human-readable name for this node
- `--rpc-port INSERT_PORT` - specifies the JSON-RPC TCP port the node listens on
- `--unsafe-rpc-external` - exposes the RPC service on all the interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - specifies when the Tanssi-powered network state should be removed from the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the state), `archive-canonical` (which keeps only the state of finalized blocks), or any `number` (representing the number of blocks whose states are kept)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - specifies how many blocks should be kept in the database. The pruning type can be either `archive` (which makes the node behave as a full node keeping all the blocks), `archive-canonical` (which keeps only finalized blocks), or any `number` (representing the amount of finalized blocks to keep)
- `--detailed-log-output` - enables detailed log output

!!! warning
    The `--unsafe-rpc-external` enables external access to your nodeâ€™s RPC interface, making it accessible from any IP address. Make sure that proper security controls are in place.

For a complete list of available flags, their description, and possible values, run the following command:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-relay --help
    ```

=== "Dancelight TestNet"

    ```bash
    /var/lib/dancelight-data/tanssi-relay --help
    ```

## Execute o serviÃ§o {: #run-the-service }

Por fim, habilite o serviÃ§o e inicie-o pela primeira vez:

=== "Tanssi MainNet"

    ```bash
    systemctl enable tanssi.service && \
    systemctl start tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    systemctl enable dancelight.service && \
    systemctl start dancelight.service
    ```

VocÃª pode verificar se o serviÃ§o estÃ¡ ativo e rodando corretamente executando:

=== "Tanssi MainNet"

    ```bash
    systemctl status tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    systemctl status dancelight.service
    ```

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>systemctl status network.service</span>
  <span data-ty>
    <br> â— network.service - "Network systemd service"
    <br>&nbsp;&nbsp;&nbsp;Loaded: loaded (/etc/systemd/system/network.service; enabled; vendor preset: enabled)
    <br>&nbsp;&nbsp;&nbsp;Active: active (running) since Sun 2024-02-18 18:16:40 EST; 14min ago
    <br>&nbsp;&nbsp;Main PID: 4045278 (container-chain)
    <br>&nbsp;&nbsp;&nbsp;&nbsp;Tasks: 44 (limit: 9462)
    <br>&nbsp;&nbsp;&nbsp;Memory: 6.5G
    <br>&nbsp;&nbsp;&nbsp;CGroup: /system.slice/network.service
    <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â””â”€4045278 4045278 /var/lib/network-data/container-chain- ...
  </span>
</div>

Verifique os logs, se necessÃ¡rio, com o comando a seguir:

=== "Tanssi MainNet"

    ```bash
    journalctl -f -u tanssi.service
    ```

=== "Dancelight TestNet"
    
    ```bash
    journalctl -f -u dancelight.service
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/operational-tasks/
--- BEGIN CONTENT ---
---
title: Tarefas Operacionais - Operators
description: Aprenda como gerenciar suas atividades como operator no protocolo de rede Tanssi, incluindo o gerenciamento de sua conta, a atualizaÃ§Ã£o de seu nÃ³ e muito mais.
icon: octicons-arrow-switch-24
template: index-page.html
---

# Tarefas Operacionais

A manutenÃ§Ã£o do seu operator exige manutenÃ§Ã£o regular para garantir desempenho consistente e gerenciamento seguro da conta. AtualizaÃ§Ãµes regulares sÃ£o essenciais para manter seu nÃ³ compatÃ­vel com as Ãºltimas alteraÃ§Ãµes no protocolo Tanssi. Ao mesmo tempo, ferramentas como contas proxy fornecem uma camada extra de seguranÃ§a, permitindo que vocÃª delegue tarefas especÃ­ficas sem expor as credenciais da sua conta principal. Esta seÃ§Ã£o fornece as etapas para manter suas operaÃ§Ãµes suaves, confiÃ¡veis e seguras.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/operational-tasks/proxy-accounts/
--- BEGIN CONTENT ---
---
title: Configurar uma Conta Proxy de Operator
description: Siga este guia passo a passo para habilitar contas proxy e executar tarefas operacionais (como rotaÃ§Ã£o de chaves) em nome da sua conta de operator com seguranÃ§a.
icon: octicons-shield-lock-24
categories: Operators
---

# Configurar uma Conta Proxy de Operator

## IntroduÃ§Ã£o {: #introduction }

Contas proxy podem ser configuradas para executar um nÃºmero limitado de aÃ§Ãµes em nome de contas primÃ¡rias e ajudar a manter as contas subjacentes seguras. Como operator na Tanssi, Ã© benÃ©fico usar contas proxy para interagir com a rede em vez da sua conta.

O tipo de proxy `SessionKeyManagement` permite que a conta gire chaves de sessÃ£o em nome da conta primÃ¡ria. Ele transforma a proxy em uma â€œhot walletâ€ que executa tarefas de manutenÃ§Ã£o regulares em nome da sua â€œcold walletâ€ de operator. Para maior seguranÃ§a, vocÃª pode rotacionar a conta proxy regularmente.

Contas proxy tambÃ©m ajudam a aplicar o princÃ­pio do menor privilÃ©gio para controle de acesso. Por exemplo, se vocÃª tiver vÃ¡rios membros na equipe, pode conceder a eles apenas o acesso mÃ­nimo necessÃ¡rio para executar suas funÃ§Ãµes via uma conta proxy especÃ­fica.

Este tutorial orienta na configuraÃ§Ã£o de uma conta proxy `SessionKeyManagement` no [Dancelight](/pt/builders/tanssi-network/testnet/dancelight/){target=\_blank} especificamente para aÃ§Ãµes de operator e demonstra como rotacionar suas novas chaves usando o proxy.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para acompanhar este tutorial, vocÃª precisarÃ¡:

- Abrir o portal do desenvolvedor

    === "Tanssi MainNet"

        [Portal do desenvolvedor da Mainnet](https://polkadot.js.org/apps/?rpc=wss://{{ networks.mainnet.dns_name }}#/){target=\_blank}

    === "Dancelight TestNet"

        [Portal do desenvolvedor da TestNet](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/){target=\_blank}

- Criar ou ter duas contas acessÃ­veis no portal do desenvolvedor
- Ambas as contas precisam estar financiadas com tokens

Se precisar de ajuda para importar suas contas no portal do desenvolvedor, consulte o guia [Conectando ao Portal do Desenvolvedor](/pt/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs){target=\_blank}.

## Criar uma Conta Proxy {: #create-a-proxy-account }

HÃ¡ algumas maneiras de criar contas proxy no portal do desenvolvedor, seja na pÃ¡gina **Extrinsics** ou na pÃ¡gina **Accounts**. PorÃ©m, Ã© necessÃ¡rio usar a pÃ¡gina **Extrinsics** para criar um proxy com atraso de tempo. O atraso fornece uma camada extra de seguranÃ§a especificando um perÃ­odo baseado no nÃºmero de blocos. Essa configuraÃ§Ã£o impede que a conta proxy execute uma transaÃ§Ã£o atÃ© que o perÃ­odo termine, permitindo que a conta primÃ¡ria que controla o proxy revise ou cancele transaÃ§Ãµes pendentes.

VocÃª tambÃ©m pode criar um proxy do tipo `Any`, que concede controle total e irrestrito da conta primÃ¡ria ao proxy. A conta proxy pode transferir fundos e realizar qualquer aÃ§Ã£o arbitrÃ¡ria. A demonstraÃ§Ã£o a seguir mostra como configurar um proxy `SessionKeyManagement`, mais restritivo do que um proxy `Any`, pois limita a funcionalidade a atividades relacionadas ao mapeamento de chaves de sessÃ£o.

### Usando a SeÃ§Ã£o Extrinsics {: #creating-proxy-account-using-extrinsics }

Para comeÃ§ar a criar sua conta proxy, acesse a aba **Developer** e selecione **Extrinsics** no menu. Em seguida, siga estes passos:

1. Selecione a conta primÃ¡ria
2. No menu **submit the following extrinsic**, selecione **proxy**
3. Escolha o extrÃ­nseco **addProxy**
4. Em **AccountIdLookupOf**, selecione **Id**
5. Selecione a conta **delegate** para o proxy
6. No menu **proxyType**, selecione **SessionKeyManagement**
7. Opcionalmente, adicione um atraso usando um nÃºmero de blocos para fornecer uma camada adicional de seguranÃ§a para a conta primÃ¡ria revisar a transaÃ§Ã£o pendente
8. Clique em **Submit Transaction**

![Adicionar uma conta proxy a partir da pÃ¡gina Extrinsics do portal do desenvolvedor](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-1.webp)

Em seguida, vocÃª serÃ¡ solicitado a autorizar e assinar a transaÃ§Ã£o. Clique em **Sign and Submit** para criar a relaÃ§Ã£o de proxy. Quando a transaÃ§Ã£o for enviada com sucesso, vocÃª receberÃ¡ notificaÃ§Ãµes confirmando a transaÃ§Ã£o.

### Usando a SeÃ§Ã£o Accounts {: #creating-proxy-account-using-accounts }

Outro mÃ©todo para criar um proxy Ã© pela seÃ§Ã£o **Accounts** do portal do desenvolvedor. Para isso, navegue atÃ© a pÃ¡gina **Accounts** e siga estes passos:

1. Selecione os trÃªs pontos verticais ao lado da conta primÃ¡ria
2. Selecione **Add proxy**

![Selecionar a opÃ§Ã£o Add proxy na pÃ¡gina Accounts do portal do desenvolvedor](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-2.webp)

!!! note
    Se a conta jÃ¡ tiver um proxy, **Manage proxies** aparecerÃ¡ como opÃ§Ã£o em vez de **Add proxy**.

Uma janela pop-up aparecerÃ¡ onde vocÃª pode inserir as informaÃ§Ãµes necessÃ¡rias, como a conta primÃ¡ria, a conta proxy e o tipo de proxy, para criar uma conta proxy. Primeiro, clique em **Add proxy**.

![Adicionar uma conta proxy na pÃ¡gina Accounts do portal do desenvolvedor](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-3.webp)

Depois, siga estes passos:

1. Selecione a conta que deseja definir como proxy
2. Selecione o tipo de proxy
3. Clique em **Submit** e assine a transaÃ§Ã£o

![Adicionar os detalhes da conta proxy, incluindo a conta e o tipo](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-4.webp)

Na prÃ³xima seÃ§Ã£o, vocÃª aprenderÃ¡ como verificar se sua conta proxy foi configurada com sucesso.

## Verificar sua Conta Proxy {: #verify-your-proxy-account }

VocÃª pode verificar se sua conta proxy foi configurada com sucesso de duas maneiras: pela pÃ¡gina **Accounts** ou pela pÃ¡gina **Chain state**.

### Usando a SeÃ§Ã£o Chain State {: #verifying-your-proxy-account-chain-state }

Para verificar suas contas proxy na seÃ§Ã£o **Chain state** do portal do desenvolvedor, siga estes passos:

1. No menu **selected state query**, selecione **proxy**
2. Escolha a entrada **proxies**
3. Selecione ou cole sua conta primÃ¡ria/proxy
4. Clique no botÃ£o **+** para enviar a consulta

![Verificar suas contas proxy pela pÃ¡gina Chain state do portal do desenvolvedor](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-5.webp)

O resultado aparecerÃ¡ na pÃ¡gina mostrando informaÃ§Ãµes sobre seus proxies, incluindo o endereÃ§o da conta delegate/proxy, o tipo de proxy, o perÃ­odo de atraso se um foi especificado e o valor total em bond de todos os seus proxies, expresso em Planck.

### Usando a SeÃ§Ã£o Accounts {: #verifying-your-proxy-account-accounts-section }

VocÃª tambÃ©m pode verificar suas contas proxy na seÃ§Ã£o **Accounts** do portal do desenvolvedor. Para isso, navegue atÃ© a pÃ¡gina **Accounts** e siga estes passos:

1. Clique nos trÃªs pontos verticais ao lado da conta primÃ¡ria
2. Selecione **Manage proxy**

!!! note
    Deve haver um sÃ­mbolo de proxy prÃ³ximo Ã  conta primÃ¡ria. Para o mesmo efeito, passe o mouse sobre o Ã­cone e clique em **Manage proxies**.

![Gerenciar seus proxies na pÃ¡gina Accounts do portal do desenvolvedor](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-6.webp)

Uma janela pop-up aparecerÃ¡ onde vocÃª pode ver uma visÃ£o geral das suas contas proxy.

![Revisar suas contas proxy](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-7.webp)

## Executar uma TransaÃ§Ã£o via Proxy {: #execute-a-proxy-transaction }

Agora que vocÃª criou uma conta proxy e verificou que ela foi configurada com sucesso, pode executar uma transaÃ§Ã£o usando o proxy em nome da sua conta primÃ¡ria. O exemplo a seguir define chaves para um nÃ³. A configuraÃ§Ã£o de proxy exibida Ã© um exemplo realista de como vocÃª pode configurar seu prÃ³prio proxy para sua conta primÃ¡ria no portal do desenvolvedor.

Para executar uma transaÃ§Ã£o, volte Ã  pÃ¡gina **Extrinsics** e siga estes passos:

1. Selecione a conta proxy em **using the select account** para enviar a transaÃ§Ã£o
2. No menu **submit the following extrinsic**, selecione **proxy**
3. Escolha o extrÃ­nseco **proxy**
4. Em **AccountIdLookupOf**, selecione **Id**
5. No menu **real**, selecione a conta primÃ¡ria
6. Selecione a chamada **Session**
7. Escolha a entrada **setKeys**
8. Insira as chaves do nÃ³ que deseja mapear para a conta de operator
9. Insira `0x` em **proof**
10. Clique em **Submit Transaction**

![Executar uma transaÃ§Ã£o via proxy na pÃ¡gina Extrinsics do Polkadot.js Apps](/images/node-operators/operators/operational-tasks/proxy-accounts/proxy-accounts-8.webp)

Uma janela pop-up solicitarÃ¡ que vocÃª autorize e assine a transaÃ§Ã£o; clique em **Sign and Submit**.

Pronto! VocÃª executou uma transaÃ§Ã£o usando uma conta proxy em nome da sua conta de operator primÃ¡ria.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/operational-tasks/upgrade-your-node/
--- BEGIN CONTENT ---
---
title: Atualizar um Node Operator
description: Siga estas etapas para atualizar seu nÃ³ para a versÃ£o mais recente do software cliente Tanssi, garantindo operaÃ§Ãµes contÃ­nuas no protocolo de rede Tanssi.
icon: octicons-rocket-24
template: index-page.html
---

# Atualizar um Node Operator

Manter seu nÃ³ atualizado Ã© fundamental para manter a compatibilidade com as Ãºltimas alteraÃ§Ãµes do protocolo Tanssi e garantir o desempenho ideal. NÃ³s desatualizados podem levar Ã  dessincronizaÃ§Ã£o, reduÃ§Ã£o de eficiÃªncia ou atÃ© mesmo Ã  incapacidade de participar do protocolo. Ao se manter atualizado com os lanÃ§amentos de clientes, vocÃª pode garantir que seu nÃ³ opere com seguranÃ§a e confiabilidade dentro da rede.

!!! tip "Assine as notificaÃ§Ãµes de lanÃ§amento"
    Ficar informado sobre novas versÃµes do cliente Ã© essencial para manter o nÃ³ atualizado. Os mantenedores do nÃ³ podem assinar as notificaÃ§Ãµes do GitHub para serem alertados sobre novas versÃµes.

    Para assinar, acesse o repositÃ³rio [Tanssi no GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} e clique em **Watch**. Selecione **Custom notifications** e marque a opÃ§Ã£o **Releases**.

## Explore o Que Esta SeÃ§Ã£o Aborda

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-docker/
--- BEGIN CONTENT ---
---
title: Atualize seu NÃ³ Docker Sequencer
description: Siga estas instruÃ§Ãµes para atualizar seu nÃ³ sequencer Tanssi em execuÃ§Ã£o via Docker para a versÃ£o mais recente do software cliente Tanssi.
icon: simple-docker
categories: Operators
---

# Atualize Seu NÃ³ em ExecuÃ§Ã£o via Docker

## IntroduÃ§Ã£o {: #introduction }

A manutenÃ§Ã£o do seu nÃ³ atualizado Ã© uma parte importante de ser um operator Tanssi. Isso nÃ£o apenas ajuda a garantir que seu nÃ³ permaneÃ§a em bom estado, mas tambÃ©m contribui para manter toda a Rede Tanssi funcionando sem problemas.

Este tutorial aborda a atualizaÃ§Ã£o do seu node operator Tanssi que foi configurado usando o Docker. Ele pressupÃµe que vocÃª jÃ¡ configurou sua conta e lanÃ§ou um [node operator usando o Systemd](/pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/){target=\_blank}.

!!! tip "Assine as notificaÃ§Ãµes de lanÃ§amento"
    Ficar informado sobre novas versÃµes do cliente Ã© essencial para manter o nÃ³ atualizado. Os mantenedores do nÃ³ podem assinar as notificaÃ§Ãµes do GitHub para serem alertados sobre novas versÃµes.

    Para assinar, acesse o repositÃ³rio [Tanssi no GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} e clique em **Watch**. Selecione **Custom notifications** e marque a opÃ§Ã£o **Releases**.

## Atualizando NÃ³s Docker {: #upgrading-docker-nodes }

A atualizaÃ§Ã£o do seu nÃ³ Ã© tÃ£o simples quanto parar o contÃªiner em execuÃ§Ã£o e reiniciÃ¡-lo com a nova tag de versÃ£o.

Primeiro, obtenha o ID do contÃªiner do seu node operator Tanssi com o seguinte comando:

```bash
docker ps -a
```

O ID do contÃªiner Ã© a primeira coluna e, se vocÃª estiver executando vÃ¡rios contÃªineres Docker, poderÃ¡ identificÃ¡-lo pelo nome da imagem `{{ networks.dancelight.operator_docker_image }}`. VocÃª pode executar o comando de parada da seguinte forma:

```bash
docker stop INSERT_YOUR_CONTAINER_ID
```

A sua interaÃ§Ã£o com o terminal se assemelharÃ¡ ao seguinte:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker ps -a</span>
  <span data-ty>
    <br> 
    <br> CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES
    <br> aa751703d6aa moondancelabs/dancelight-chain:2 "/chain-network/tansâ€¦" 56 seconds ago  Up 56 seconds             determined_darwin
    <br> 
    <span data-ty="input"><span class="file-path"></span>docker stop aa751703d6aa</span>
    <br> aa751703d6aa
  </span>
</div>

Para reiniciar o nÃ³, use o mesmo comando que usou ao iniciÃ¡-lo pela primeira vez. O comando farÃ¡ o pull da imagem e o nÃ³ retomarÃ¡ a sincronizaÃ§Ã£o de blocos de onde parou quando o processo Docker foi interrompido.

=== "Tanssi MainNet"

    === "GenÃ©rico"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=tanssi \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

=== "Dancelight TestNet"

    === "GenÃ©rico"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "Intel Skylake"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-skylake" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

    === "AMD Zen3"

        ```bash
        docker run --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        --entrypoint "/tanssi-relay/tanssi-relay-znver3" \
        {{ networks.dancelight.operator_docker_image }} \
        --chain=dancelight \
        --base-path=/data/ \
--node-key-file /data/node-key \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--public-addr=/ip4/INSERT_YOUR_IP_ADDRESS/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--validator
        ```

!!! note
    Recomenda-se usar as versÃµes binÃ¡rias otimizadas para as arquiteturas [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} da Intel ou [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} da AMD para melhor desempenho.

### Especifique uma Tag de VersÃ£o {: #specifying-a-version-tag }

Para usar uma [tag de versÃ£o](https://hub.docker.com/r/moondancelabs/tanssi/tags){target=\_blank} especÃ­fica, anexe-a ao nome da imagem. Por exemplo, para obter a versÃ£o marcada como `latest` (que Ã© o padrÃ£o), anexe `:latest` a `{{ networks.dancelight.operator_docker_image }}`.

E Ã© sÃ³ isso! VocÃª atualizou com sucesso seu nÃ³ Tanssi.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/operators/operational-tasks/upgrade-your-node/upgrade-systemd/
--- BEGIN CONTENT ---
---
title: Atualize seu Node Operator Systemd
description: Siga estas instruÃ§Ãµes para atualizar seu node operator Tanssi em execuÃ§Ã£o via Systemd para a versÃ£o mais recente do software cliente Tanssi.
icon: simple-linux
categories: Operators
---

# Atualize seu NÃ³ em ExecuÃ§Ã£o via Systemd

## IntroduÃ§Ã£o {: #introduction }

A manutenÃ§Ã£o do seu nÃ³ atualizado Ã© uma parte importante de ser um operator Tanssi. Isso nÃ£o sÃ³ ajuda a garantir que seu nÃ³ permaneÃ§a saudÃ¡vel, mas tambÃ©m contribui para manter toda a Rede Tanssi funcionando sem problemas.

Este tutorial aborda a atualizaÃ§Ã£o do seu node operator Tanssi que foi configurado usando o Systemd. Ele pressupÃµe que vocÃª jÃ¡ configurou sua conta e iniciou um [node operator usando Systemd](/pt/node-operators/operators/onboarding/run-an-operator/operators-systemd/){target=\_blank}.

!!! tip "Assine as notificaÃ§Ãµes de lanÃ§amento"
    Ficar informado sobre novas versÃµes do cliente Ã© essencial para manter o nÃ³ atualizado. Os mantenedores do nÃ³ podem assinar as notificaÃ§Ãµes do GitHub para serem alertados sobre novas versÃµes.

    Para assinar, acesse o repositÃ³rio [Tanssi no GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} e clique em **Watch**. Selecione **Custom notifications** e marque a opÃ§Ã£o **Releases**.

## Atualizando Seu NÃ³ Systemd {: #upgrading-your-systemd-node }

Se vocÃª estiver executando seu operator via o serviÃ§o Systemd, vocÃª deve tomar medidas para atualizar seu nÃ³ corretamente. Em resumo, vocÃª precisarÃ¡ parar o serviÃ§o, substituir o binÃ¡rio Tanssi pela versÃ£o atualizada e reiniciar o serviÃ§o.

VocÃª pode parar seu serviÃ§o Tanssi Systemd com o seguinte comando:

```bash
systemctl stop tanssi.service
```

Em seguida, navegue atÃ© o diretÃ³rio onde seus binÃ¡rios Tanssi sÃ£o armazenados e remova-os.

```bash
cd /var/lib/tanssi-data
```

Se vocÃª nÃ£o alterou os nomes de arquivo binÃ¡rios Tanssi, eles serÃ£o nomeados `tanssi-relay`, `tanssi-relay-execute-worker` e `tanssi-relay-prepare-worker`. Caso contrÃ¡rio, vocÃª pode substituir `tanssi-relay*` no comando abaixo pelos nomes corretos de seus arquivos binÃ¡rios Tanssi.

```bash
rm tanssi-relay*
```

Para baixar a versÃ£o mais recente e alterar as permissÃµes para que o serviÃ§o Tanssi possa usÃ¡-la, execute o comando correspondente ao seu ambiente:

=== "GenÃ©rico"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "Intel Skylake"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-skylake -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-skylake -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-skylake -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

=== "AMD Zen3"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-znver3 -O tanssi-relay && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-execute-worker-znver3 -O tanssi-relay-execute-worker && \
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.client_version }}/tanssi-relay-prepare-worker-znver3 -O tanssi-relay-prepare-worker && \
    chmod +x ./tanssi-relay*
    ```

VocÃª pode reiniciar seu serviÃ§o Tanssi Systemd com o seguinte comando:

```bash
systemctl start tanssi.service
```

O nÃ³ retomarÃ¡ a sincronizaÃ§Ã£o de blocos de onde parou quando o serviÃ§o Systemd foi interrompido. Para verificar se estÃ¡ funcionando corretamente, vocÃª pode usar o seguinte comando para verificar os logs:

```bash
systemctl status tanssi.service
```

E Ã© isso! VocÃª atualizou com sucesso seu nÃ³ Tanssi.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/
--- BEGIN CONTENT ---
---
title: Sequencers Tanssi
description: Aprenda a configurar, executar e gerenciar Sequencers (produtores de blocos) para participar do protocolo de infraestrutura Tanssi e ganhar recompensas.
icon: octicons-server-24
template: index-page.html
---

# Sequencers Tanssi

Os Sequencers desempenham um papel fundamental na manutenÃ§Ã£o da atividade e do desempenho do ecossistema Tanssi. Eles sÃ£o responsÃ¡veis por produzir blocos, executar transaÃ§Ãµes e garantir o bom funcionamento da rede. Esta seÃ§Ã£o fornece tudo o que vocÃª precisa para comeÃ§ar, desde a configuraÃ§Ã£o inicial atÃ© as melhores prÃ¡ticas operacionais e o gerenciamento de contas.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/offboarding/account/
--- BEGIN CONTENT ---
---
title: Descomissionando Seu Sequencer
description: Nestas instruÃ§Ãµes passo a passo, aprenda a sair corretamente como um Sequencer Tanssi, incluindo o desmapeamento de suas chaves de sessÃ£o e a reversÃ£o de sua garantia.
icon: octicons-arrow-down-right-24
categories: Sequencers
---

# Sair como um Sequencer Tanssi

## IntroduÃ§Ã£o {: #introduction }

Aos Sequencers, pode chegar o momento de sair graciosamente da rede. A desativaÃ§Ã£o da sua conta envolve um processo de duas etapas para garantir que seu nÃ³ seja devidamente dissociado da sua conta e que vocÃª receba sua garantia de volta.

Este guia mostrarÃ¡ como encerrar suas operaÃ§Ãµes como um Sequencer Tanssi corretamente. Isso inclui a nÃ£o delegaÃ§Ã£o de sua autodelegaÃ§Ã£o para reaver sua garantia e o desmapeamento de suas chaves de sessÃ£o para cortar a conexÃ£o entre seu nÃ³ e sua conta. Naturalmente, este guia assume que vocÃª Ã© um Sequencer Tanssi existente com um [nÃ³ Sequencer](/pt/node-operators/sequencers/onboarding/run-a-sequencer/){target=\_blank} e [chaves de sessÃ£o](https://wiki.polkadot.com/learn/learn-cryptography/#session-keys){target=\_blank} mapeadas.


## Solicitar a NÃ£o DelegaÃ§Ã£o {: #request-undelegation }

Ao configurar seu Sequencer Tanssi, vocÃª precisou enviar uma garantia de delegaÃ§Ã£o (pelo menos `{{ networks.mainnet.sequencers.minimum_self_delegation }}` {{ networks.mainnet.token_symbol }} para Tanssi MainNet). Para recebÃª-la de volta e remover seu Sequencer da lista de candidatos elegÃ­veis, vocÃª precisarÃ¡ seguir etapas semelhantes Ã s do processo de integraÃ§Ã£o.

### Visualizar a ParticipaÃ§Ã£o Existente {: #viewing-existing-stake }

Antes de nÃ£o delegar, Ã© Ãºtil primeiro ver quanto vocÃª apostou, pois precisarÃ¡ fornecer esse valor mais tarde. Para fazer isso, acesse o \[portal do desenvolvedor\](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, clique na aba **Desenvolvedor**, selecione **Estado da Cadeia** no menu suspenso e siga estas etapas:

1. Selecione o mÃ³dulo **pooledStaking**
2. Selecione a consulta **pools**
3. Insira sua conta de Sequencer
4. Certifique-se de que o controle deslizante **include option** esteja ativado
5. No campo **option**, vocÃª seleciona **JoiningShares**
6. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
![Ver participaÃ§Ã£o existente no portal do desenvolvedor](/images/node-operators/sequencers/offboarding/account/account-1.webp)

Observe que **JoiningShares** retorna apenas o valor inicial que vocÃª delegou ao configurar seu Sequencer. Para obter o valor total apostado, vocÃª precisarÃ¡ repetir as etapas acima para **ManualRewardShares** ou **ManualRewardSharesHeldStake** se vocÃª nÃ£o selecionou Autocompounding, e **AutoCompoundingShares** ou **AutoCompoundingSharesHeldStake** se vocÃª configurou Autocompounding. Em seguida, adicione seu valor de aÃ§Ãµes de autocompounding ou manuais ao **JoiningShares** para obter sua delegaÃ§Ã£o total pendente.

Como exemplo, a participaÃ§Ã£o total de um Sequencer de autocompounding pode ser calculada adicionando **JoiningShares** a **AutoCompoundingShares**. Observe esse valor, pois vocÃª precisarÃ¡ dele na prÃ³xima seÃ§Ã£o.


### Enviar SolicitaÃ§Ã£o de NÃ£o DelegaÃ§Ã£o {: #submit-undelegation-request }

Acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, clique na aba **Desenvolvedor**, selecione **ExtrÃ­nsecos** no menu suspenso e siga estas etapas:

1. Selecione a conta de onde vocÃª deseja enviar a transaÃ§Ã£o. Esta conta deve ser sua conta de Sequencer existente que vocÃª inicialmente delegou
2. Selecione o mÃ³dulo **pooledStaking**
3. Selecione o extrÃ­nseco **requestUndelegate**
4. Insira sua conta, que Ã©, novamente, a mesma conta da qual vocÃª estÃ¡ enviando o extrÃ­nseco e a conta que vocÃª deseja desativar como um Sequencer
5. Escolha o pool de destino que vocÃª usou originalmente ao configurar sua delegaÃ§Ã£o ( *Autocompounding* ou *Manual*)
6. Selecione **Stake** ou **Shares** no menu suspenso
7. Insira a quantia a ser removida da aposta. Se vocÃª selecionou **Shares**, basta inserir o nÃºmero de Shares. Se vocÃª selecionou **Stake**, precisarÃ¡ enviar o valor, incluindo as doze casas decimais usadas pela Rede Tanssi. Como lembrete, o valor mÃ­nimo da aposta Ã© `{{ networks.mainnet.sequencers.minimum_self_delegation }}` {{ networks.mainnet.token_symbol }}. Se vocÃª delegou o valor mÃ­nimo e nÃ£o acumulou recompensas adicionais, precisarÃ¡ inserir `{{ networks.mainnet.sequencers.minimum_self_delegation }}000000000000`
8. Clique em **Enviar TransaÃ§Ã£o** e assine e envie a transaÃ§Ã£o de sua carteira

![Criar e enviar um extrÃ­nseco para nÃ£o delegar no portal do desenvolvedor](/images/node-operators/sequencers/offboarding/account/account-2.webp)

### Executar a SolicitaÃ§Ã£o Pendente {: #execute-pending-request }

VocÃª precisarÃ¡ esperar antes de executar a solicitaÃ§Ã£o pendente. No caso da Tanssi MainNet, o perÃ­odo de espera Ã© configurado para pelo menos {{ networks.mainnet.staking.leaving_delay_sessions_text }} sessÃµes. Cada sessÃ£o Ã© composta por `{{ networks.mainnet.session.blocks }}` blocos e se traduz em cerca de {{ networks.mainnet.session.hours }} hora por sessÃ£o. Portanto, {{ networks.mainnet.staking.leaving_delay_sessions_text }} sessÃµes correspondem a aproximadamente {{ networks.mainnet.staking.leaving_delay_hours_text }} horas.

Antes de executar a solicitaÃ§Ã£o pendente, vocÃª precisarÃ¡ recuperar a sessÃ£o na qual enviou a solicitaÃ§Ã£o para delegar. Para fazer isso, acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, clique na aba **Desenvolvedor**, selecione **Estado da cadeia** no menu suspenso e siga estas etapas:

1. Selecione o mÃ³dulo **pooledStaking**
2. Selecione a consulta **pendingOperations**
3. Insira sua conta de Sequencer
4. Desative o controle deslizante **include option**
5. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
6. A solicitaÃ§Ã£o pendente serÃ¡ exibida na parte inferior da pÃ¡gina
![Consultar a solicitaÃ§Ã£o de nÃ£o delegaÃ§Ã£o pendente no portal do desenvolvedor](/images/node-operators/sequencers/offboarding/account/account-3.webp)

No exemplo na imagem acima, a solicitaÃ§Ã£o de nÃ£o delegaÃ§Ã£o para sair do pool de autocompounding foi enviada durante a sessÃ£o `5.037`. Portanto, a solicitaÃ§Ã£o pode ser executada a partir da sessÃ£o `5.039`. Anote a operaÃ§Ã£o e o Ã­ndice da sessÃ£o em que vocÃª enviou a solicitaÃ§Ã£o, pois vocÃª precisarÃ¡ de ambos os valores para executar a solicitaÃ§Ã£o pendente.

VocÃª pode executar outra consulta na pÃ¡gina **Estado da cadeia** para verificar a sessÃ£o atual. Para fazer isso, vocÃª pode:

1. Selecione o mÃ³dulo **session**
2. Selecione a consulta **currentIndex**
3. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
4. A sessÃ£o atual serÃ¡ exibida na parte inferior da pÃ¡gina

![Consultar o Ã­ndice da sessÃ£o atual no portal do desenvolvedor](/images/node-operators/sequencers/offboarding/account/account-4.webp)

Se pelo menos duas sessÃµes se passaram desde a sessÃ£o em que vocÃª enviou o extrÃ­nseco, a solicitaÃ§Ã£o estarÃ¡ pronta para ser executada. Para fazer isso, selecione **ExtrÃ­nsecos** no menu suspenso **Desenvolvedor** e siga estas etapas:

1. Selecione a conta da qual vocÃª deseja enviar o extrÃ­nseco
2. Selecione o mÃ³dulo **pooledStaking**
3. Selecione o extrÃ­nseco **executePendingOperations**
4. Para **delegator**, insira sua conta, que Ã© a mesma conta da qual vocÃª enviou a solicitaÃ§Ã£o de autodelegaÃ§Ã£o
5. Para **operation**, selecione **Leaving**
6. Para **candidate**, insira a mesma conta que vocÃª fez no campo **delegator**
7. Para **at**, insira o Ã­ndice da sessÃ£o em que vocÃª enviou a solicitaÃ§Ã£o de delegado
8. Clique em **Enviar TransaÃ§Ã£o** e assine e envie a transaÃ§Ã£o de sua carteira

![Criar e enviar um extrÃ­nseco para executar a solicitaÃ§Ã£o de autodelegaÃ§Ã£o pendente no portal do desenvolvedor](/images/node-operators/sequencers/offboarding/account/account-5.webp)

### Verifique se Sua Conta NÃ£o EstÃ¡ na Lista de Candidatos ElegÃ­veis {: #verify }

Se vocÃª quiser, pode verificar se seu Sequencer nÃ£o estÃ¡ mais na lista de candidatos elegÃ­veis. Para fazer isso, acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, clique na aba **Desenvolvedor**, selecione **Estado da cadeia** no menu suspenso e siga estas etapas:

1. Selecione o mÃ³dulo **pooledStaking** e a consulta **sortedEligibleCandidates**
2. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
3. Uma lista dos candidatos elegÃ­veis e suas apostas serÃ¡ exibida na parte inferior da pÃ¡gina. VocÃª pode pesquisar seu endereÃ§o para garantir que ele nÃ£o exista na lista
![Consultar a lista atual de candidatos elegÃ­veis no portal do desenvolvedor](/images/node-operators/sequencers/offboarding/account/account-6.webp)

## Desmapear Chaves de SessÃ£o {: #unmap-session-keys }

As chaves de sessÃ£o sÃ£o usadas para realizar operaÃ§Ãµes de rede, como assinar blocos, enquanto sua conta de Sequencer mantÃ©m os fundos apostados e tem uma identidade na cadeia. Ao desmapear a chave de sessÃ£o para sua conta, vocÃª interrompe a associaÃ§Ã£o entre sua conta de Sequencer e seu nÃ³ de Sequencer.

A etapa de desmapeamento Ã© tomada apenas como parte do processo de desativaÃ§Ã£o. Se vocÃª precisar girar/alterar suas chaves de sessÃ£o, precisarÃ¡ seguir a [geraÃ§Ã£o e mapeamento de novas chaves de sessÃ£o](/pt/node-operators/sequencers/onboarding/account-setup/#map-session-keys){target=\_blank}. VocÃª nÃ£o deve remover suas chaves durante o processo de rotaÃ§Ã£o da chave de sessÃ£o.


Para desmapear suas chaves de sessÃ£o, acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, clique na aba **Desenvolvedor**, selecione **ExtrÃ­nsecos** no menu suspenso e siga estas etapas:

1. Selecione sua conta de Sequencer Tanssi
2. Selecione o mÃ³dulo **session**
3. Selecione o extrÃ­nseco **purgeKeys**
4. Clique em **Enviar TransaÃ§Ã£o** e assine e envie a transaÃ§Ã£o de sua carteira

![Desmapear chaves de sessÃ£o no portal do desenvolvedor](/images/node-operators/sequencers/offboarding/account/account-7.webp)

Usando o mÃ©todo `session.keyOwner`, vocÃª pode verificar se suas chaves de sessÃ£o foram desmapeadas de sua conta conforme o esperado. Para fazer isso no [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, clique na aba **Desenvolvedor**, selecione **Estado da cadeia** no menu suspenso e siga estas etapas:

1. Selecione o mÃ³dulo **session**
2. Selecione a consulta **keyOwner**
3. Insira `nmbs` no campo **SpCoreCryptoKeyTypeId**
4. Para **Bytes**, insira suas chaves de sessÃ£o codificadas em hexadecimal
5. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
6. A consulta nÃ£o deve retornar nada

![Verificando se o desmapeamento foi bem-sucedido](/images/node-operators/sequencers/offboarding/account/account-8.webp)


E Ã© isso! VocÃª desativou com sucesso um Sequencer Tanssi. Se mudar de ideia a qualquer momento e quiser se integrar novamente como um Sequencer Tanssi, vocÃª pode seguir as etapas no [guia de integraÃ§Ã£o](/pt/node-operators/sequencers/onboarding/account-setup/){target=\_blank}.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/offboarding/
--- BEGIN CONTENT ---
---
title: Desativar Seu NÃ³ Sequencer
description: Aprenda como desativar corretamente o seu nÃ³ Sequencer (tambÃ©m conhecido como produtores de bloco), incluindo limpar chaves de sessÃ£o e cancelar delegaÃ§Ã£o de fundos.
icon: octicons-arrow-down-right-24
template: index-page.html
---

# DesativaÃ§Ã£o

A desativaÃ§Ã£o como Sequencer requer seguir os procedimentos adequados para garantir uma transiÃ§Ã£o tranquila. Esta seÃ§Ã£o fornece instruÃ§Ãµes claras para remover suas chaves de sessÃ£o e cancelar a delegaÃ§Ã£o de sua participaÃ§Ã£o auto-vinculada, permitindo que vocÃª recupere seus fundos com seguranÃ§a e desconecte sua conta da rede.

O que vocÃª aprenderÃ¡:

- [**Removendo sua autodelegaÃ§Ã£o**](/pt/node-operators/sequencers/offboarding/account/#request-undelegation) - etapas para remover sua participaÃ§Ã£o auto-vinculada e garantir que seu Sequencer nÃ£o seja mais listado como participante elegÃ­vel
- [**Removendo as chaves de sessÃ£o**](/pt/node-operators/sequencers/offboarding/account/#unmap-session-keys) - como remover suas chaves de sessÃ£o, interrompendo adequadamente a conexÃ£o entre seu nÃ³ e sua conta

!!! tip "Retornando como um Sequencer"
    Se vocÃª decidir retornar como um Sequencer Tanssi no futuro, poderÃ¡ embarcar novamente facilmente seguindo as etapas descritas no guia [Onboarding](/pt/node-operators/sequencers/onboarding/).

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/onboarding/account-setup/
--- BEGIN CONTENT ---
---
title: Configurar uma Conta para Produzir Blocos
description: Siga estas instruÃ§Ãµes passo a passo para se tornar elegÃ­vel a produzir blocos em redes Powered by Tanssi e configurar sua conta para receber recompensas.
icon: octicons-person-add-24
categories: Sequencers
---

# Configure Sua Conta para Produzir Blocos na Tanssi

## IntroduÃ§Ã£o {: #introduction }

Antes de comeÃ§ar a produzir blocos em redes powered by Tanssi, vocÃª precisarÃ¡ configurar sua conta e estabelecer sua elegibilidade.

VocÃª deve ter iniciado um [nÃ³ Sequencer](/pt/node-operators/sequencers/onboarding/run-a-sequencer/){target=\_blank} para realizar as etapas de configuraÃ§Ã£o da conta neste guia.

VocÃª precisarÃ¡ configurar sua conta gerando [chaves de sessÃ£o](https://wiki.polkadot.com/learn/learn-cryptography/#session-keys){target=\_blank} e mapeando essas chaves de sessÃ£o para sua conta. Esta conta Ã© aquela para a qual os delegadores escolherÃ£o delegar e onde suas recompensas serÃ£o distribuÃ­das. Opcionalmente, vocÃª pode [configurar uma conta proxy](/pt/node-operators/sequencers/operational-tasks/proxy-accounts/){target=\_blank} para seguranÃ§a adicional.

Para estabelecer a elegibilidade, vocÃª deve se delegar como um Sequencer e atender aos requisitos mÃ­nimos de garantia.

Seguindo as etapas descritas neste guia, vocÃª aprenderÃ¡ tudo o que precisa saber para comeÃ§ar a produzir blocos no ecossistema Tanssi.

## VariÃ¡veis Importantes {: #important-variables }

Ao estabelecer a elegibilidade para produzir blocos, existem algumas variÃ¡veis a serem observadas:

- **AutodelegaÃ§Ã£o mÃ­nima** - hÃ¡ um valor mÃ­nimo que vocÃª deve autodelegar para ser considerado elegÃ­vel
- **SessÃ£o** - um perÃ­odo que tem um conjunto constante de Sequencers
- **Sequencers de rede por sessÃ£o** - o nÃºmero de Sequencers atribuÃ­dos a uma rede powered by Tanssi por sessÃ£o

=== "Tanssi MainNet"
|            VariÃ¡vel            |                                             Valor                                             |
|:------------------------------:|:---------------------------------------------------------------------------------------------:|
|    AutodelegaÃ§Ã£o mÃ­nima     | {{ networks.mainnet.sequencers.minimum_self_delegation }} {{ networks.mainnet.token_symbol }} |
|            SessÃ£o             |                         {{ networks.mainnet.session.blocks }} blocos                          |
| Sequencers de rede por sessÃ£o |    {{ networks.mainnet.sequencers.configuration.block_producer_per_container }} Sequencers    |

=== "Dancelight TestNet"
|            VariÃ¡vel            |                                             Valor                                             |
|:------------------------------:|:---------------------------------------------------------------------------------------------:|
|    AutodelegaÃ§Ã£o mÃ­nima     | {{ networks.dancelight.sequencers.minimum_self_delegation }} {{ networks.dancelight.token_symbol }} |
|            SessÃ£o             |                         {{ networks.dancelight.session.blocks }} blocos                          |
| Sequencers de rede por sessÃ£o |    {{ networks.dancelight.sequencers.configuration.block_producer_per_container }} Sequencers    |

## Mapear uma conta para seu nÃ³ Sequencer {: #map-account }

A primeira etapa Ã© um processo de duas etapas que gera [chaves de sessÃ£o](https://wiki.polkadot.com/learn/learn-cryptography/#session-keys){target=\_blank} e mapeia as chaves de sessÃ£o para sua conta. As chaves de sessÃ£o sÃ£o usadas para realizar operaÃ§Ãµes de rede, como assinar blocos, enquanto sua conta mantÃ©m os fundos apostados e tem uma identidade na cadeia. Ao mapear a chave de sessÃ£o para sua conta, vocÃª cria uma associaÃ§Ã£o entre sua conta e seu Sequencer.

VocÃª precisarÃ¡ criar chaves de sessÃ£o para seus servidores primÃ¡rio e de backup. Cada um de seus servidores, seu primÃ¡rio e de backup, deve ter suas prÃ³prias chaves exclusivas. Como as chaves nunca saem de seus servidores, vocÃª pode considerÃ¡-las um ID exclusivo para aquele servidor.

### Gerar chaves de sessÃ£o {: #generate-session-keys }

Antes de gerar chaves de sessÃ£o, vocÃª deve estar [executando um nÃ³ Sequencer](/pt/node-operators/sequencers/onboarding/run-a-sequencer/){target=\_blank}.

Para gerar chaves de sessÃ£o, vocÃª enviarÃ¡ uma chamada RPC, usando o mÃ©todo `author_rotateKeys`, para o endpoint HTTP do seu nÃ³. Como referÃªncia, se o endpoint HTTP do seu Sequencer estiver na porta `9945`, a chamada JSON-RPC pode ter esta aparÃªncia:

```bash
"Content-Type:application/json;charset=utf-8" -d \
  '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"author_rotateKeys",
    "params": []
  }'
```

Suas chaves de sessÃ£o codificadas em hexadecimal serÃ£o impressas no terminal no campo `"result"`.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>curl http://127.0.0.1:9944 -H \
    <br>  "Content-Type:application/json;charset=utf-8" -d \
    <br>    '{
    <br>        "jsonrpc":"2.0",
    <br>        "id":1,
    <br>        "method":"author_rotateKeys",
    <br>        "params": []
    <br>    }'
  </span>
  <span data-ty>{"jsonrpc":"2.0","result":</span>
  <span data-ty>
  "0x76afaf334bd33b82d0b8fbd6a2845cb3b9b785edf1dce4ccefd4973fa79fed2b","id":1}</span>
</div>

Certifique-se de anotar suas chaves de sessÃ£o; vocÃª precisarÃ¡ mapear suas chaves de sessÃ£o para sua conta na prÃ³xima seÃ§Ã£o.

### Mapear chaves de sessÃ£o {: #map-session-keys }

Para executar a prÃ³xima etapa e mapear suas chaves de sessÃ£o para sua conta, acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, clique na aba **Developer**, selecione **Extrinsics** no menu suspenso e siga as etapas a seguir:

1. Selecione sua conta, que deve ser a mesma conta que vocÃª autodelegou anteriormente
2. Selecione o mÃ³dulo **session** e o extrÃ­nseco **setKeys**
3. Para **keys**, insira suas chaves de sessÃ£o
4. Para **proof**, insira `0x`
5. Clique em **Submit Transaction** e assine e envie a transaÃ§Ã£o de sua carteira

![Criar e enviar uma transaÃ§Ã£o para definir chaves de sessÃ£o no Polkadot.js Apps](/images/node-operators/sequencers/onboarding/account-setup/setup-1.webp)

Usando o mÃ©todo `session.keyOwner`, vocÃª pode verificar se suas chaves de sessÃ£o foram mapeadas para sua conta conforme o esperado. Para fazer isso no [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, clique na aba **Developer**, selecione **Chain state** no menu suspenso e siga as etapas a seguir:

1. Selecione o mÃ³dulo **session** e a consulta **keyOwner**
2. Insira `nmbs` no campo **SpCoreCryptoKeyTypeId**
3. Para **Bytes**, insira suas chaves de sessÃ£o codificadas em hexadecimal
4. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
5. A conta associada Ã s chaves de sessÃ£o, que deve ser sua conta, serÃ¡ exibida na parte inferior da pÃ¡gina

![Criar e enviar consulta para verificar chaves de sessÃ£o no portal do desenvolvedor](/images/node-operators/sequencers/onboarding/account-setup/setup-2.webp)

## Enviar AutodelegaÃ§Ã£o {: #submit-self-delegation }

A prÃ³xima etapa para se tornar elegÃ­vel para produzir blocos em redes powered by Tanssi Ã© delegar Ã  sua prÃ³pria conta. Para fazer isso, vocÃª precisarÃ¡ enviar um mÃ­nimo de tokens, conforme listado na seÃ§Ã£o [variÃ¡veis importantes](#important-variables).

Depois de enviar a solicitaÃ§Ã£o para delegar, vocÃª precisarÃ¡ esperar um mÃ­nimo de sessÃµes antes de poder executar a solicitaÃ§Ã£o pendente. No caso da Tanssi MainNet, o nÃºmero de sessÃµes Ã© configurado para {{ networks.mainnet.staking.joining_delay_sessions_text }}. Existem {{ networks.mainnet.session.blocks }} blocos em uma sessÃ£o. Portanto, {{ networks.mainnet.staking.joining_delay_sessions_text }} sessÃµes sÃ£o {{ networks.mainnet.staking.joining_delay_blocks }} blocos, o que pode levar cerca de {{ networks.mainnet.staking.joining_delay_hours_text }} horas.

Os Sequencers sÃ£o atribuÃ­dos a cada sessÃ£o. Os Sequencers que participam da sessÃ£o sÃ£o escolhidos da lista de candidatos ordenada por participaÃ§Ã£o total atÃ© que o nÃºmero total de Sequencers necessÃ¡rios seja coberto. Portanto, vocÃª precisarÃ¡ garantir que sua participaÃ§Ã£o total seja suficiente para preencher um dos slots, o que pode exigir mais do que a autodelegaÃ§Ã£o mÃ­nima.

### Solicitar Delegado {: #request-delegate }

Acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, clique na aba **Developer**, selecione **Extrinsics** no menu suspenso e siga as etapas a seguir:

1. Selecione a conta da qual vocÃª deseja enviar a transaÃ§Ã£o. Esta conta deve ser a mesma conta para a qual vocÃª estÃ¡ delegando e Ã© a conta que vocÃª deseja se tornar um Sequencer
2. Selecione o mÃ³dulo **pooledStaking** e o extrÃ­nseco **requestDelegate**
3. Insira sua conta, que Ã©, novamente, a mesma conta da qual vocÃª estÃ¡ enviando a transaÃ§Ã£o e a conta que vocÃª deseja se tornar um Sequencer
4. Escolha o pool de destino. O pool pode ser o pool de composiÃ§Ã£o automÃ¡tica, que compÃµe automaticamente as recompensas de delegaÃ§Ã£o, ou o pool de recompensas manuais, no qual todas as aÃ§Ãµes relacionadas Ã s recompensas sÃ£o manuais
5. Insira o valor a ser apostado. Este valor deve atender ao mÃ­nimo, que Ã© {{ networks.mainnet.sequencers.minimum_self_delegation }} {{ networks.mainnet.token_symbol }} tokens para Tanssi MainNet. A Tanssi Network usa doze casas decimais, portanto, ao enviar o valor, certifique-se de adicionar as casas decimais Ã  autodelegaÃ§Ã£o. Para MainNet, o valor seria `{{ networks.mainnet.sequencers.minimum_self_delegation }}000000000000`
6. Clique em **Submit Transaction** e assine e envie a transaÃ§Ã£o de sua carteira
![Criar e enviar uma transaÃ§Ã£o para autodelegar no Polkadot.js Apps](/images/node-operators/sequencers/onboarding/account-setup/setup-3.webp)

### Executar a solicitaÃ§Ã£o pendente {: #execute-pending-request }

Antes de executar a solicitaÃ§Ã£o pendente, vocÃª precisarÃ¡ recuperar a sessÃ£o na qual vocÃª enviou a solicitaÃ§Ã£o para delegar. Para fazer isso, acesse o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, clique na aba **Developer**, selecione **Chain state** no menu suspenso e siga as etapas a seguir:

1. Selecione o mÃ³dulo **pooledStaking** e a consulta **pendingOperations**
2. Insira sua conta
3. Desative o controle deslizante **include option**
4. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
5. A solicitaÃ§Ã£o pendente serÃ¡ exibida na parte inferior da pÃ¡gina

![Consulta da solicitaÃ§Ã£o de autodelegaÃ§Ã£o pendente no portal do desenvolvedor](/images/node-operators/sequencers/onboarding/account-setup/setup-4.webp)

No exemplo da imagem acima, a solicitaÃ§Ã£o de delegaÃ§Ã£o para ingressar no pool de composiÃ§Ã£o automÃ¡tica foi enviada durante a sessÃ£o 4.829. Portanto, a solicitaÃ§Ã£o pode ser executada a partir da sessÃ£o 4.831.

Anote a operaÃ§Ã£o e o nÃºmero da sessÃ£o em que vocÃª enviou a solicitaÃ§Ã£o, pois vocÃª precisarÃ¡ de ambos os valores para executar a solicitaÃ§Ã£o pendente.

VocÃª pode executar outra consulta na pÃ¡gina **Chain state** para verificar a sessÃ£o atual. Para fazer isso, vocÃª pode:

1. Selecione o mÃ³dulo **session** e a consulta **currentIndex**
2. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
3. A sessÃ£o atual serÃ¡ exibida na parte inferior da pÃ¡gina

![Consultar o Ã­ndice da sessÃ£o atual no portal do desenvolvedor](/images/node-operators/sequencers/onboarding/account-setup/setup-5.webp)

Se a solicitaÃ§Ã£o puder ser executada, selecione **Extrinsics** no menu suspenso **Developer** e siga as etapas a seguir:

1. Selecione a conta da qual vocÃª deseja enviar a transaÃ§Ã£o
2. Selecione o mÃ³dulo **pooledStaking** e a transaÃ§Ã£o **executePendingOperations**
3. Para **delegator**, insira sua conta, que Ã© a mesma conta da qual vocÃª enviou a solicitaÃ§Ã£o de autodelegaÃ§Ã£o
4. Para **operation**, selecione o tipo de operaÃ§Ã£o a ser executada. Este deve ser **JoiningAutoCompounding** ou **JoiningManualRewards**, dependendo do pool de destino selecionado no momento do envio da solicitaÃ§Ã£o de autodelegaÃ§Ã£o
5. Para **candidate**, insira a mesma conta que vocÃª fez no campo **delegator**
6. Para **at**, insira o id da sessÃ£o em que vocÃª enviou a solicitaÃ§Ã£o de delegaÃ§Ã£o
7. Clique em **Submit Transaction** e assine e envie a transaÃ§Ã£o de sua carteira

![Criar e enviar uma transaÃ§Ã£o para executar a solicitaÃ§Ã£o de autodelegaÃ§Ã£o pendente no portal do desenvolvedor](/images/node-operators/sequencers/onboarding/account-setup/setup-6.webp)

Agora, vocÃª concluiu toda a configuraÃ§Ã£o da conta necessÃ¡ria para ser elegÃ­vel para produzir blocos!

## Verifique se Sua Conta EstÃ¡ na Lista de Candidatos ElegÃ­veis {: #verify }

Se vocÃª seguiu todas as etapas deste guia e sincronizou totalmente seu Sequencer, agora vocÃª estÃ¡ elegÃ­vel para produzir blocos. Para verificar se vocÃª estÃ¡ na lista de candidatos elegÃ­veis, vocÃª pode acessar o [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss://{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank}, clicar na aba **Developer**, selecionar **Chain state** no menu suspenso e seguir as etapas a seguir:

1. Selecione o mÃ³dulo **pooledStaking** e a consulta **sortedEligibleCandidates**
2. Clique no botÃ£o **+** ao lado do campo extrÃ­nseco
3. Uma lista dos candidatos elegÃ­veis e sua participaÃ§Ã£o serÃ¡ exibida na parte inferior da pÃ¡gina. VocÃª pode pesquisar seu endereÃ§o para garantir que estÃ¡ qualificado para produzir blocos

![Consultar a lista atual de candidatos elegÃ­veis no portal do desenvolvedor](/images/node-operators/sequencers/onboarding/account-setup/setup-7.webp)

Lembre-se que vocÃª precisarÃ¡ estar entre os principais candidatos por participaÃ§Ã£o total para produzir blocos, e isso se baseia no nÃºmero de [Sequencers necessÃ¡rios para cada rede e Tanssi](#important-variables).
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/onboarding/
--- BEGIN CONTENT ---
---
title: Onboarding para Executar um NÃ³ Sequencer
description: Aprenda como comeÃ§ar a executar um Sequencer usando Docker ou Systemd para participar do protocolo, fornecer serviÃ§os de produÃ§Ã£o de blocos e ganhar recompensas.
icon: octicons-arrow-up-right-24
template: index-page.html
---

# Onboarding

A sua jornada como um Sequencer comeÃ§a aqui. Siga estes passos para configurar o seu nÃ³ e preparar a sua conta para a participaÃ§Ã£o ativa na rede Tanssi.

[timeline left (tanssi-docs/.snippets/text/pt/node-operators/sequencers/onboarding/onboarding-timeline.json)]

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/onboarding/run-a-sequencer/
--- BEGIN CONTENT ---
---
title: Executar um Sequencer
description: Aprenda como configurar e executar um nÃ³ de Sequencer usando Docker ou Systemd para participar do protocolo, fornecendo serviÃ§os de produÃ§Ã£o de blocos e ganhando recompensas.
icon: octicons-server-24
template: index-page.html
---

# Executar um NÃ³ Sequencer

A configuraÃ§Ã£o de um nÃ³ Sequencer Ã© um passo importante para participar da rede Tanssi. VocÃª tem duas opÃ§Ãµes: _Docker_ ou _Systemd_. Seja qual for o caminho escolhido, fornecemos tutoriais passo a passo para orientÃ¡-lo durante o processo e garantir que seu nÃ³ atenda aos requisitos necessÃ¡rios para produzir blocos e manter uma conexÃ£o segura com a rede.

### Requisitos de Hardware

Para executar um nÃ³ Sequencer com sucesso, o uso de hardware de alto desempenho Ã© essencial. ConfiguraÃ§Ãµes subÃ³timas podem levar a atrasos, rodadas de autoria perdidas e perda de recompensas. Como a produÃ§Ã£o e o processo de importaÃ§Ã£o de blocos dependem fortemente do desempenho de um Ãºnico thread, recomenda-se priorizar CPUs com fortes capacidades de thread Ãºnico em vez de contagens de nÃºcleos mais altas.

Hardware Recomendado:

- **CPUs Recomendadas** - Intel Xeon E-2386/2388 ou Ryzen 9 5950x/5900x
- **NVMe Recomendado** - 1 TB NVMe
- **RAM Recomendada** - 32 GB RAM

!!! warning
    Como um Sequencer, vocÃª Ã© responsÃ¡vel por sua prÃ³pria participaÃ§Ã£o e pela de seus delegadores. Manter o desempenho do seu nÃ³, mantÃª-lo atualizado e garantir sua seguranÃ§a sÃ£o essenciais para maximizar as recompensas e construir uma forte reputaÃ§Ã£o na rede Tanssi.

### Portas de Rede NecessÃ¡rias

Para produÃ§Ã£o de blocos bem-sucedida, seu nÃ³ deve sincronizar e interagir com duas redes peer-to-peer (P2P). Para garantir a comunicaÃ§Ã£o adequada dentro do ecossistema Tanssi, certifique-se de que as seguintes portas estejam abertas para entrada:

| Rede              | Porta       |
|-------------------|-------------|
| Tanssi Chain      | 30334 (TCP) |
| Rede Designada  | 30333 (TCP) |

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/
--- BEGIN CONTENT ---
---
title: Executar um Sequencer Usando Docker
description: Saiba como configurar e executar um Sequencer (tambÃ©m conhecido como produtor de blocos) para as appchains powered by Tanssi, usando Docker para participar do protocolo e ganhar recompensas.
icon: simple-docker
categories: Sequencers
---

# Executar um Sequencer em Tanssi Usando Docker

## IntroduÃ§Ã£o {: #introduction }

Uma das principais propostas do Tanssi Ã© oferecer produÃ§Ã£o de blocos descentralizada e sem confianÃ§a para suas redes. O runtime do Tanssi gerencia a atribuiÃ§Ã£o de sequenciadores para todas as redes ativas no ecossistema.

O algoritmo de atribuiÃ§Ã£o distribui o conjunto disponÃ­vel de sequenciadores a cada sessÃ£o, designando-os para uma cadeia aleatÃ³ria. Assim, eles produzem blocos para a mesma rede por um perÃ­odo relativamente curto, aumentando a seguranÃ§a geral do ecossistema.

Para isso, o binÃ¡rio do Tanssi (software usado para rodar nÃ³s) jÃ¡ possui um mecanismo embutido que alterna automaticamente a produÃ§Ã£o de blocos para a cadeia designada sem exigir alteraÃ§Ãµes do operador. O binÃ¡rio inclui a lÃ³gica para sincronizar a nova cadeia e produzir blocos quando a sessÃ£o muda. Portanto, os sequenciadores precisam executar o binÃ¡rio do Tanssi, e nÃ£o o das redes individuais (como fazem os nÃ³s completos).

Neste guia, vocÃª aprenderÃ¡ como iniciar um Sequencer Tanssi para fazer parte do pool compartilhado de Sequencers usando [Docker](https://www.docker.com){target=\_blank} em um computador Linux. No entanto, ele pode ser adaptado a outros sistemas operacionais.

## Verificando os PrÃ©-requisitos {: #checking-prerequisites }

### Instalando o Docker {: #installing-docker}

Para comeÃ§ar, vocÃª precisarÃ¡ de um computador com Linux e instalar o [Docker](https://docs.docker.com/desktop/setup/install/linux/){target=\blank}.

Execute o comando a seguir para instalar o Docker em um Ubuntu:

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

E o comando abaixo para verificar a instalaÃ§Ã£o:

```bash
sudo docker run hello-world
```

Uma execuÃ§Ã£o bem-sucedida no terminal se parece com isto:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>sudo docker run hello-world</span>
  <span data-ty>
    <br> 
    <br> Hello from Docker!
    <br> This message shows that your installation appears to be working correctly.
    <br> 
    <br> To generate this message, Docker took the following steps:
    <br> 1. The Docker client contacted the Docker daemon.
    <br> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    <br>     (amd64)
    <br> 3. The Docker daemon created a new container from that image which runs the
    <br>     executable that produces the output you are currently reading.
    <br> 4. The Docker daemon streamed that output to the Docker client, which sent it
    <br>     to your terminal.
    <br>
    <br> To try something more ambitious, you can run an Ubuntu container with:
    <br> $ docker run -it ubuntu bash
    <br>
    <br> Share images, automate workflows, and more with a free Docker ID:
    <br> https://hub.docker.com/
    <br>
    <br> For more examples and ideas, visit:
    <br>  https://docs.docker.com/get-started/
  </span>
</div>

## Puxando a Imagem Docker {: #pulling-docker-image }

Uma imagem Docker Ã© construÃ­da e publicada em cada lanÃ§amento, contendo todas as dependÃªncias necessÃ¡rias que um Sequencer Tanssi precisa e o prÃ³prio arquivo binÃ¡rio.

Uma imagem Docker combina o binÃ¡rio correspondente Ã  versÃ£o estÃ¡vel mais recente do [nÃ³ cliente](/pt/learn/framework/architecture/#architecture){target=\_blank}, junto com o arquivo de especificaÃ§Ã£o do orquestrador Tanssi.

O seguinte comando para puxar a imagem Docker:

=== "Tanssi MainNet"

    ```bash
    docker pull {{ node_versions.docker_sequencer_image_name }}
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    docker pull {{ node_versions.docker_sequencer_image_name }}
    ```

O comando farÃ¡ o download e extrairÃ¡ a imagem e mostrarÃ¡ o status apÃ³s a execuÃ§Ã£o:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker pull moondancelabs/tanssi</span>
  <span data-ty>
    <br> 
    <br> Using default tag: latest
    <br> latest: Pulling from moondancelabs/tanssi
    <br> e1caac4eb9d2: Pull complete 
    <br> 1d4409959e6d: Pull complete 
    <br> b8beed19c122: Pull complete 
    <br> c0fab1f18601: Pull complete 
    <br> d9dcf3cddfc5: Pull complete 
    <br> Digest: sha256:0f717d6cf247bbb1b082f5f9e5761b23c44a0be8b704492a57fdbf8c63c0a91c
    <br> Status: Downloaded newer image for moondancelabs/tanssi
    <br> docker.io/moondancelabs/tanssi
  </span>
</div>

## Baixar o arquivo de especificaÃ§Ã£o da cadeia Tanssi {: #download-tanssi-specs }

O binÃ¡rio do nÃ³ tambÃ©m inclui o cÃ³digo necessÃ¡rio para executar um nÃ³ da cadeia de orquestraÃ§Ã£o do Tanssi. Ao iniciar um sequenciador, Ã© necessÃ¡rio fornecer o arquivo de especificaÃ§Ã£o dessa cadeia como parÃ¢metro.

Baixe o arquivo de especificaÃ§Ã£o da cadeia de orquestraÃ§Ã£o Tanssi executando:

=== "Tanssi MainNet"

    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json
    ```

=== "Dancelight TestNet"
    
    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json
    ```

## Configurar o diretÃ³rio de dados {: #setup-data-directory }

Executar um sequenciador ou um nÃ³ de appchain exige sincronizar duas cadeias: a cadeia de orquestraÃ§Ã£o do Tanssi e a appchain para a qual ele trabalha.

Crie o diretÃ³rio onde o nÃ³ armazenarÃ¡ os bancos de dados contendo blocos e estados de cadeia:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    mkdir /var/lib/dancelight-data
    ```

Set the folder's ownership to the account that will run the Docker image to ensure writing permission:

=== "Tanssi MainNet"

    ```bash
    chown INSERT_DOCKER_USER /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    chown INSERT_DOCKER_USER /var/lib/dancelight-data
    ```

Ou execute o comando abaixo se quiser rodar o sequenciador com o usuÃ¡rio logado:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    sudo chown -R $(id -u):$(id -g) /var/lib/dancelight-data
    ```

Move the chain specification file to the folder:

=== "Tanssi MainNet"

    ```bash
    mv ./starlight-raw-specs.json /var/lib/tanssi-data
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    mv ./dancelight-raw-specs.json /var/lib/dancelight-data
    ```

!!! note
    O diretÃ³rio Ã© um parÃ¢metro no comando de inicializaÃ§Ã£o do Docker. Se optar por criar o diretÃ³rio em outro lugar, ajuste o comando.

## Gerar a Chave do NÃ³ {: #generate-node-key }

A partir da [versÃ£o runtime 700](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank}, os nÃ³s sequenciadores do Tanssi nÃ£o geram as chaves de sessÃ£o automaticamente na inicializaÃ§Ã£o. Para gerar e armazenar em disco as chaves de sessÃ£o que serÃ£o referenciadas no comando de start, execute:


=== "Tanssi MainNet"

    ```bash
    docker run --network="host" -v "/var/lib/tanssi-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ node_versions.docker_sequencer_image_name }} key generate-node-key --file /data/node-key
    ```
    
=== "Dancelight TestNet"
    
    ```bash
    docker run --network="host" -v "/var/lib/dancelight-data:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ node_versions.docker_sequencer_image_name }} key generate-node-key --file /data/node-key
    ```


!!! note
    Esta etapa poderia ser evitada usando o parÃ¢metro `--unsafe-force-node-key-generation` no comando de inicializaÃ§Ã£o, embora essa nÃ£o seja a prÃ¡tica recomendada.

## Comando de InicializaÃ§Ã£o {: #start-up-command }

Para iniciar seu nÃ³, vocÃª deve executar a imagem Docker com o comando `docker run`.

Observe que o comando contÃ©m duas seÃ§Ãµes, divididas por `-- \`:

- **SeÃ§Ã£o do protocolo Tanssi** - contÃ©m os flags para executar o nÃ³ Tanssi
- **SeÃ§Ã£o do Sequencer** - contÃ©m os flags para executar o nÃ³ Sequencer. Ã‰ abstrato o suficiente para ser adaptado dinamicamente em Runtime Ã  cadeia especÃ­fica que o nÃ³ servirÃ¡

DÃª um nome legÃ­vel a cada seÃ§Ã£o, substituindo as tags `INSERT_YOUR_TANSSI_NODE_NAME` e `INSERT_YOUR_SEQUENCER_NODE_NAME` nos flags `--name`. Esses nomes serÃ£o Ãºteis para conectar as entradas de registro e as mÃ©tricas com o nÃ³ que as gera.
    

!!! note
    Recomenda-se usar as versÃµes binÃ¡rias otimizadas para as arquiteturas [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} da Intel ou [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} da AMD para melhor desempenho.

=== "Tanssi MainNet"

    === "Generic"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/starlight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC"
        ```

    === "Intel Skylake"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node-skylake solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/starlight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC"
        ```

    === "AMD Zen3"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/tanssi-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node-znver3 solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/starlight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
--bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
--bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
--bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
--bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC"
        ```

=== "Dancelight TestNet"

    === "Generic"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
        ```

    === "Intel Skylake"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node-skylake solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
        ```

    === "AMD Zen3"

        ```bash
        docker run --entrypoint bash --network="host" -v "/var/lib/dancelight-data:/data" \
        -u $(id -u ${USER}):$(id -g ${USER}) \
        {{ node_versions.docker_sequencer_image_name }} -c "/tanssi/tanssi-node-znver3 solo-chain \
        --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
        ```

### Flags de ExecuÃ§Ã£o {: #run-flags }

Os flags usados no comando `docker run` podem ser ajustados de acordo com suas preferÃªncias e configuraÃ§Ã£o de hardware. Os seguintes sÃ£o alguns dos mais notÃ¡veis:


- `--name INSERT_NAME` - nome legÃ­vel para este nÃ³
- `--rpc-port INSERT_PORT` - define a porta TCP do JSON-RPC na qual o nÃ³ ouve
- `--unsafe-rpc-external` - expÃµe o serviÃ§o RPC em todas as interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser `archive` (nÃ³ atua como completo mantendo todo o estado), `archive-canonical` (mantÃ©m apenas estados de blocos finalizados) ou um `number` (quantidade de blocos cujos estados serÃ£o mantidos)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - define quantos blocos devem ser mantidos no banco de dados. Pode ser `archive` (nÃ³ completo mantendo todos os blocos), `archive-canonical` (mantÃ©m apenas blocos finalizados) ou um `number` (quantidade de blocos finalizados a manter)
- `--detailed-log-output` - habilita saÃ­da detalhada de logs

!!! warning
    O parÃ¢metro `--unsafe-rpc-external` permite acesso externo Ã  interface RPC do seu nÃ³, tornando-a acessÃ­vel de qualquer endereÃ§o IP. Certifique-se de que controles de seguranÃ§a adequados estejam configurados.

Para ver a lista completa de flags disponÃ­veis, descriÃ§Ã£o e valores possÃ­veis, execute:


=== "Tanssi MainNet"

    ```bash
    docker run {{ node_versions.docker_sequencer_image_name }} --help
    ```

=== "Dancelight TestNet"

    ```bash
    docker run {{ node_versions.docker_sequencer_image_name }} --help
    ```

## Sincronizando Seu NÃ³ {: #syncing-your-node }

A primeira vez que seu nÃ³ Ã© iniciado, o processo de sincronizaÃ§Ã£o exibe muitas informaÃ§Ãµes de registro da configuraÃ§Ã£o do nÃ³ e do prÃ³prio nÃ³. Alguns erros devem ser exibidos no inÃ­cio do processo, desaparecendo assim que a cadeia Ã© sincronizada com o Ãºltimo bloco.

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker run ....</span>
  <span data-ty>
    <br> 2024-02-08 18:30:04.093  INFO tokio-runtime-worker substrate: [Parachain] ðŸ’¤ Idle (0 peers), best: #0 (0x4a2bâ€¦7de3), finalized #0 (0x4a2bâ€¦7de3), â¬‡ 0 â¬† 0
    <br> 2024-02-08 18:30:06.368  INFO tokio-runtime-worker substrate: [Relaychain] âœ¨ Imported #14139635 (0x8c41â€¦8df6)    
    <br> 2024-02-08 18:30:08.809  INFO tokio-runtime-worker substrate: [Relaychain] ðŸ’¤ Idle (8 peers), best: #14139635 (0x8c41â€¦8df6), finalized #14139632 (0xa9a8â€¦cab9), â¬‡ 32.7kiB/s â¬†
  </span>
</div>

Quando a sincronizaÃ§Ã£o com o orquestrador Tanssi for concluÃ­da, o nÃ³ ainda precisarÃ¡ ser sincronizado com a rede a que foi designado. A sincronizaÃ§Ã£o com a cadeia servida pelo nÃ³ Sequencer acontecerÃ¡ toda vez que o Sequencer for rotacionado.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/
--- BEGIN CONTENT ---
---
title: Executar um Sequencer com Systemd
description: Saiba como configurar e executar um nÃ³ de Sequencer (produtor de blocos) para as redes Tanssi usando Systemd, permitindo que vocÃª participe do protocolo e ganhe recompensas.
icon: simple-linux
categories: Sequencers
---

# Executar um NÃ³ de Sequencer com Systemd

## IntroduÃ§Ã£o {: #introduction }

Uma das principais propostas do Tanssi Ã© oferecer produÃ§Ã£o de blocos descentralizada e sem confianÃ§a para suas redes. O runtime do Tanssi gerencia a atribuiÃ§Ã£o de sequenciadores para todas as redes ativas no ecossistema.

O algoritmo de atribuiÃ§Ã£o distribui o conjunto disponÃ­vel de sequenciadores a cada sessÃ£o, designando-os para uma cadeia aleatÃ³ria. Assim, eles produzem blocos para a mesma rede por um perÃ­odo relativamente curto, aumentando a seguranÃ§a geral do ecossistema.

Para isso, o binÃ¡rio do Tanssi (software usado para rodar nÃ³s) jÃ¡ possui um mecanismo embutido que alterna automaticamente a produÃ§Ã£o de blocos para a cadeia designada sem exigir alteraÃ§Ãµes do operador. O binÃ¡rio inclui a lÃ³gica para sincronizar a nova cadeia e produzir blocos quando a sessÃ£o muda. Portanto, os sequenciadores precisam executar o binÃ¡rio do Tanssi, e nÃ£o o das redes individuais (como fazem os nÃ³s completos).

Neste guia, vocÃª aprenderÃ¡ como iniciar um Sequencer Tanssi para fazer parte do pool compartilhado de Sequencers usando o binÃ¡rio estÃ¡vel mais recente e gerenciando o serviÃ§o com [Systemd](https://systemd.io){target=\_blank} em sistemas Linux.

O artigo segue a boa prÃ¡tica de executar o serviÃ§o com uma conta nÃ£o root e conceder a essa conta acesso de escrita a um diretÃ³rio especÃ­fico. VocÃª pode adaptar as etapas e instruÃ§Ãµes deste artigo Ã  configuraÃ§Ã£o da sua infraestrutura, preferÃªncias e polÃ­ticas de seguranÃ§a.

## Verificando os PrÃ©-requisitos {: #checking-prerequisites }

Para comeÃ§ar, vocÃª precisarÃ¡ de um computador executando Ubuntu Linux com privilÃ©gios de root. VocÃª tambÃ©m precisarÃ¡ de:

- **Arquivo binÃ¡rio do nÃ³** - as instruÃ§Ãµes neste guia executam a versÃ£o estÃ¡vel [mais recente](https://github.com/moondance-labs/tanssi/releases/latest){target=\_blank} oficial do `tanssi-node`. No entanto, vocÃª pode compilar seu prÃ³prio arquivo a partir do [cÃ³digo-fonte](https://github.com/moondance-labs/tanssi){target=\_blank}
- **Arquivo de especificaÃ§Ã£o da rede Tanssi** - o arquivo de especificaÃ§Ã£o pode ser baixado deste [repositÃ³rio pÃºblico do GitHub](https://github.com/papermoonio/external-files/blob/main/Tanssi/Dancelight){target=\_blank}

## Baixar a Ãšltima VersÃ£o {: #download-latest-release }

Para comeÃ§ar, faÃ§a o download e torne executÃ¡vel a versÃ£o mais recente do binÃ¡rio executando o seguinte comando:

!!! note
    Recomenda-se usar as versÃµes binÃ¡rias otimizadas para as arquiteturas [Skylake](https://www.intel.com/content/www/us/en/products/platforms/details/skylake-u-y.html){target=\_blank} da Intel ou [Zen3](https://www.amd.com/en/technologies/zen-core.html){target=\_blank} da AMD para melhor desempenho.

=== "Tanssi MainNet"

    === "GenÃ©rico"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node && \
        chmod +x ./tanssi-node
        ```

    === "Intel Skylake"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-skylake -O tanssi-node && \
        chmod +x ./tanssi-node
        ```

    === "AMD Zen3"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-znver3 -O tanssi-node && \
        chmod +x ./tanssi-node
        ```
    
=== "Dancelight TestNet"
    
    === "GenÃ©rico"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node && \
        chmod +x ./tanssi-node
        ```

    === "Intel Skylake"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-skylake -O tanssi-node && \
        chmod +x ./tanssi-node
        ```

    === "AMD Zen3"

        ```bash
        wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-znver3 -O tanssi-node && \
        chmod +x ./tanssi-node
        ```

## Baixar o arquivo de especificaÃ§Ã£o da cadeia Tanssi {: #download-tanssi-specs }

O binÃ¡rio do nÃ³ tambÃ©m inclui o cÃ³digo necessÃ¡rio para executar um nÃ³ da cadeia de orquestraÃ§Ã£o do Tanssi. Ao iniciar um sequenciador, Ã© necessÃ¡rio fornecer o arquivo de especificaÃ§Ã£o dessa cadeia como parÃ¢metro.

Baixe o arquivo de especificaÃ§Ã£o da cadeia de orquestraÃ§Ã£o Tanssi executando:

=== "Tanssi MainNet"

    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/starlight-raw-specs.json
    ```

=== "Dancelight TestNet"
    
    ```bash
    wget https://raw.githubusercontent.com/moondance-labs/tanssi/75e576add204abd321c48cded556c8de14d65618/chains/orchestrator-relays/node/tanssi-relay-service/chain-specs/dancelight-raw-specs.json
    ```

## Configurar o serviÃ§o Systemd {: #setup-systemd-service }

O [Systemd](https://systemd.io){target=\_blank} Ã© um sistema de gerenciamento para Linux que controla serviÃ§os (daemons), iniciando-os automaticamente quando o computador liga ou reinicia, ou reiniciando-os em caso de falhas inesperadas.

Os comandos a seguir configuram uma nova conta, o diretÃ³rio e movem os arquivos baixados para o local correto.

Crie uma nova conta para executar o serviÃ§o:

=== "Tanssi MainNet"

    ```bash
    adduser tanssi_service --system --no-create-home
    ```

=== "Dancelight TestNet"

    ```bash
    adduser dancelight_service --system --no-create-home
    ```

Crie um diretÃ³rio para armazenar os arquivos e dados necessÃ¡rios:

=== "Tanssi MainNet"

    ```bash
    mkdir /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mkdir /var/lib/dancelight-data
    ```

Defina a propriedade da pasta para a conta que executarÃ¡ o serviÃ§o, garantindo permissÃ£o de escrita:

=== "Tanssi MainNet"

    ```bash
    sudo chown -R tanssi_service /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    sudo chown -R dancelight_service /var/lib/dancelight-data
    ```

Mova o arquivo de especificaÃ§Ã£o da cadeia para a pasta:

=== "Tanssi MainNet"

    ```bash
    mv ./starlight-raw-specs.json /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mv ./dancelight-raw-specs.json /var/lib/dancelight-data
    ```

Por fim, mova o binÃ¡rio para a pasta:

=== "Tanssi MainNet"

    ```bash
    mv ./tanssi-node /var/lib/tanssi-data
    ```

=== "Dancelight TestNet"

    ```bash
    mv ./tanssi-node /var/lib/dancelight-data
    ```

### Gerar a Chave do NÃ³ {: #generate-node-key }

A partir da [versÃ£o runtime 700](https://github.com/moondance-labs/tanssi/releases/tag/runtime-700){target=\_blank}, os nÃ³s sequenciadores do Tanssi nÃ£o geram as chaves de sessÃ£o automaticamente na inicializaÃ§Ã£o. Para gerar e armazenar em disco as chaves de sessÃ£o que serÃ£o referenciadas no comando de start, execute:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-node key generate-node-key --file /var/lib/tanssi-data/node-key
    ```

=== "Dancelight TestNet"

    ```bash
    /var/lib/dancelight-data/tanssi-node key generate-node-key --file /var/lib/dancelight-data/node-key
    ```

!!! note
    Esta etapa poderia ser evitada usando o parÃ¢metro `--unsafe-force-node-key-generation` no comando de inicializaÃ§Ã£o, embora essa nÃ£o seja a prÃ¡tica recomendada.

### Criar o Arquivo de ConfiguraÃ§Ã£o do Systemd {: #create-systemd-configuration }

O prÃ³ximo passo Ã© criar o arquivo de configuraÃ§Ã£o do Systemd.

VocÃª pode criar o arquivo executando o comando:

=== "Tanssi MainNet"

    ```bash
    sudo touch /etc/systemd/system/tanssi.service
    ```

=== "Dancelight TestNet"

    ```bash
    sudo touch /etc/systemd/system/dancelight.service
    ```

Agora abra o arquivo com seu editor de texto favorito (vim, emacs, nano etc.) e adicione a configuraÃ§Ã£o do serviÃ§o, substituindo as tags `INSERT_YOUR_TANSSI_NODE_NAME` e `INSERT_YOUR_SEQUENCER_NODE_NAME` por nomes legÃ­veis nos flags `--name`. Esses nomes ajudam a conectar entradas de log e mÃ©tricas ao nÃ³ que as gera.

=== "Tanssi MainNet"

    ```bash
    [Unit]
    Description="Tanssi systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    Type=simple
    Restart=on-failure
    RestartSec=10
    User=tanssi_service
    SyslogIdentifier=tanssi
    SyslogFacility=local7
    KillSignal=SIGHUP
    ExecStart=/var/lib/tanssi-data/tanssi-node solo-chain \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
    --base-path=/var/lib/tanssi-data/container \
    --node-key-file=/var/lib/tanssi-data/node-key \
    --telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
    --pool-type=fork-aware \
    --database=paritydb \
    --rpc-port=9944 \
    --prometheus-port=9615 \
    --prometheus-external \
    --listen-addr=/ip4/0.0.0.0/tcp/30333 \
    --state-pruning=2000 \
    --blocks-pruning=2000 \
    --db-cache=1024 \
    --trie-cache-size=1073741824 \
    --collator \
    --in-peers=100 \
    --detailed-log-output \
    -- \
    --chain=/var/lib/tanssi-data/starlight-raw-specs.json \
    --name=INSERT_YOUR_TANSSI_NODE_NAME \
    --sync=fast \
    --base-path=/var/lib/tanssi-data/relay \
    --node-key-file=/var/lib/tanssi-data/node-key \
    --keystore-path=/var/lib/tanssi-data/session \
    --database=paritydb \
    --rpc-port=9945 \
    --prometheus-port=9616 \
    --prometheus-external \
    --listen-addr=/ip4/0.0.0.0/tcp/30334 \
    --pool-limit=0 \
    --db-cache=128 \
    --out-peers=15 \
    --state-pruning=2000 \
    --blocks-pruning=2000 \
    --telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
    --bootnodes=/dns4/deo-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWNQ1cddxwvnZZUBG2gtByn9hirVGEn2yR37ztnGSi1VHu \
    --bootnodes=/dns4/fro-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWS3kv4PyNTxKS8CBxZsVrhMcNcXgxqVUHLrXixuz4DaSR \
    --bootnodes=/dns4/qcl-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWFDUJ1QZn18tmeJJZU4e6JbyQrLiAp4Xz7ongKzoSjadg \
    --bootnodes=/dns4/qco-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWBzJzAdAKNVXcsvfL3nHH8BSocNvxz7A8PkRAAJhTuQNm \
    --bootnodes=/dns4/uko-tanssi-boot-1.rv.tanssi.network/tcp/30334/p2p/12D3KooWAexWR4uyhVPyxqPBNhhepJ5jRqUa885mu5dKPPVHSfpC

    [Install]
    WantedBy=multi-user.target
    ```

=== "Dancelight TestNet"

    ```bash
    [Unit]
    Description="Dancelight systemd service"
    After=network.target
    StartLimitIntervalSec=0

    [Service]
    Type=simple
    Restart=on-failure
    RestartSec=10
    User=dancelight_service
    SyslogIdentifier=dancelight
    SyslogFacility=local7
    KillSignal=SIGHUP
    ExecStart=/var/lib/dancelight-data/tanssi-node solo-chain \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
    --base-path=/var/lib/dancelight-data/container \
    --node-key-file=/var/lib/dancelight-data/node-key \
    --telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
    --pool-type=fork-aware \
    --database=paritydb \
    --rpc-port=9944 \
    --prometheus-port=9615 \
    --prometheus-external \
    --listen-addr=/ip4/0.0.0.0/tcp/30333 \
    --state-pruning=2000 \
    --blocks-pruning=2000 \
    --db-cache=1024 \
    --trie-cache-size=1073741824 \
    --collator \
    --in-peers=100 \
    --detailed-log-output \
    -- \
    --chain=/var/lib/dancelight-data/dancelight-raw-specs.json \
    --name=INSERT_YOUR_TANSSI_NODE_NAME \
    --sync=fast \
    --base-path=/var/lib/dancelight-data/relay \
    --node-key-file=/var/lib/dancelight-data/node-key \
    --keystore-path=/var/lib/dancelight-data/session \
    --database=paritydb \
    --rpc-port=9945 \
    --prometheus-port=9616 \
    --prometheus-external \
    --listen-addr=/ip4/0.0.0.0/tcp/30334 \
    --pool-limit=0 \
    --db-cache=128 \
    --out-peers=15 \
    --state-pruning=2000 \
    --blocks-pruning=2000 \
    --telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
    --bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
    --bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
    --bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT

    [Install]
    WantedBy=multi-user.target
    ```

### Flags de ExecuÃ§Ã£o {: #run-flags }

Os flags usados no comando `ExecStart` podem ser ajustados conforme suas preferÃªncias e configuraÃ§Ã£o de hardware. Alguns dos mais importantes sÃ£o:

- `--name INSERT_NAME` - nome legÃ­vel para este nÃ³
- `--rpc-port INSERT_PORT` - define a porta TCP do JSON-RPC na qual o nÃ³ ouve
- `--unsafe-rpc-external` - expÃµe o serviÃ§o RPC em todas as interfaces
- `--state-pruning INSERT_STATE_PRUNING_TYPE` - define quando o estado da rede alimentada pelo Tanssi deve ser removido do banco de dados. Pode ser `archive` (nÃ³ atua como completo mantendo todo o estado), `archive-canonical` (mantÃ©m apenas estados de blocos finalizados) ou um `number` (quantidade de blocos cujos estados serÃ£o mantidos)
- `--blocks-pruning INSERT_BLOCKS_PRUNING_TYPE` - define quantos blocos devem ser mantidos no banco de dados. Pode ser `archive` (nÃ³ completo mantendo todos os blocos), `archive-canonical` (mantÃ©m apenas blocos finalizados) ou um `number` (quantidade de blocos finalizados a manter)
- `--detailed-log-output` - habilita saÃ­da detalhada de logs

!!! warning
    O parÃ¢metro `--unsafe-rpc-external` permite acesso externo Ã  interface RPC do seu nÃ³, tornando-a acessÃ­vel de qualquer endereÃ§o IP. Certifique-se de que controles de seguranÃ§a adequados estejam configurados.

Para ver a lista completa de flags disponÃ­veis, descriÃ§Ã£o e valores possÃ­veis, execute:

=== "Tanssi MainNet"

    ```bash
    /var/lib/tanssi-data/tanssi-node  --help
    ```

=== "Dancelight TestNet"

    ```bash
    /var/lib/dancelight-data/tanssi-node  --help
    ```

## Executar o ServiÃ§o {: #run-the-service }

Por fim, habilite o serviÃ§o e inicie-o pela primeira vez:

=== "Tanssi MainNet"

    ```bash
    systemctl enable tanssi.service && \
    systemctl start tanssi.service
    ```

=== "Dancelight TestNet"

    ```bash
    systemctl enable dancelight.service && \
    systemctl start dancelight.service
    ```

VocÃª pode verificar se o serviÃ§o estÃ¡ em execuÃ§Ã£o corretamente:

=== "Tanssi MainNet"

    ```bash
    systemctl status tanssi.service
    ```

=== "Dancelight TestNet"

    ```bash
    systemctl status dancelight.service
    ```

tanssi-docs/.snippets/code/node-operators/network-node/rpc-systemd/terminal/check-status.md

Se precisar verificar os logs, use:

=== "Tanssi MainNet"

    ```bash
    journalctl -f -u tanssi.service
    ```

=== "Dancelight TestNet"

    ```bash
    journalctl -f -u dancelight.service
    ```
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/operational-tasks/
--- BEGIN CONTENT ---
---
title: Tarefas Operacionais dos Sequencers
description: Aprenda a gerenciar suas atividades como um Sequencer no protocolo de rede Tanssi, incluindo o gerenciamento de sua conta, a atualizaÃ§Ã£o de seu nÃ³ e muito mais.
icon: octicons-arrow-switch-24
template: index-page.html
---

# Tarefa Operacional

Manter seu Sequencer em funcionamento Ã© mais do que apenas a configuraÃ§Ã£o - requer manutenÃ§Ã£o regular para garantir desempenho consistente e gerenciamento seguro de suas contas. As atualizaÃ§Ãµes regulares sÃ£o essenciais para manter seu nÃ³ compatÃ­vel com as Ãºltimas mudanÃ§as do protocolo Tanssi, enquanto ferramentas como contas proxy fornecem uma camada extra de seguranÃ§a, permitindo que vocÃª delegue certas tarefas sem expor suas credenciais de conta primÃ¡rias. Esta seÃ§Ã£o fornece os passos necessÃ¡rios para manter suas operaÃ§Ãµes tranquilas, confiÃ¡veis e seguras.

## Explore Esta SeÃ§Ã£o

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/operational-tasks/proxy-accounts/
--- BEGIN CONTENT ---
---
title: Configurar uma Conta Proxy Sequencera
description: Siga estas instruÃ§Ãµes passo a passo para configurar uma conta proxy para gerenciar as atividades do Sequencer em nome de sua conta Sequencera primÃ¡ria.
icon: octicons-shield-lock-24
categories: Sequencers
---

# Configurar uma Conta Proxy

## IntroduÃ§Ã£o {: #introduction }

Contas proxy podem ser configuradas para realizar um nÃºmero limitado de aÃ§Ãµes em nome de contas primÃ¡rias e ajudar a manter as contas subjacentes seguras. Como Sequencer na Tanssi, Ã© uma boa ideia aproveitar as contas proxy para interagir com a rede em vez de sua conta Sequencera.

O tipo de proxy de staking permite convenientemente que a conta proxy gerencie atividades de staking, como delegar e rotacionar chaves de sessÃ£o, em nome da conta Sequencera primÃ¡ria, transformando-a efetivamente em uma "hot wallet" para realizar tarefas regulares de manutenÃ§Ã£o em nome de sua conta Sequencera "cold wallet". Para maior seguranÃ§a, vocÃª pode rotacionar regularmente a conta proxy.

Contas proxy tambÃ©m podem ajudÃ¡-lo a implementar o princÃ­pio de privilÃ©gio mÃ­nimo para controle de acesso. Por exemplo, se vocÃª tiver vÃ¡rios membros da equipe, poderÃ¡ fornecer a eles o acesso mÃ­nimo necessÃ¡rio para realizar suas tarefas por meio de uma conta proxy especÃ­fica.

Este tutorial irÃ¡ guiÃ¡-lo pela configuraÃ§Ã£o de uma conta proxy de staking no [Dancelight](/pt/builders/tanssi-network/testnet/dancelight/){target=\_blank} especificamente para operaÃ§Ãµes como um Sequencer. Em seguida, demonstrarÃ¡ como iniciar uma delegaÃ§Ã£o usando o novo proxy de staking criado.

## Verificando PrÃ©-requisitos {: #checking-prerequisites }

Para acompanhar este tutorial, vocÃª precisarÃ¡ ter:

- O [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank} aberto e conectado Ã  Dancelight
- Criar ou ter duas contas acessÃ­veis no portal do desenvolvedor
- Ambas as contas precisarÃ£o ser financiadas, e a conta do Sequencer precisarÃ¡ de pelo menos a autodelegaÃ§Ã£o mÃ­nima necessÃ¡ria para se tornar um Sequencer ativo ({{ networks.dancelight.sequencers.minimum_self_delegation }} {{ networks.dancelight.token_symbol }} para Dancelight)

Se vocÃª precisar de ajuda para importar suas contas para o portal do desenvolvedor, consulte o guia [Conectando-se ao Portal do Desenvolvedor](/pt/builders/toolkit/substrate-api/wallets/talisman/#connecting-to-polkadotjs){target=\_blank}.
## Criando uma Conta Proxy de Staking {: #creating-a-staking-proxy-account }

HÃ¡ algumas maneiras de criar contas proxy no [portal do desenvolvedor](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/accounts){target=\_blank}, seja na pÃ¡gina **Extrinsics** ou na pÃ¡gina **Accounts**. No entanto, para criar um proxy com atraso de tempo, vocÃª precisarÃ¡ usar a pÃ¡gina **Extrinsics**. Um atraso de tempo fornece uma camada adicional de seguranÃ§a aos proxies, especificando um perÃ­odo de atraso com base no nÃºmero de blocos. Isso impedirÃ¡ que a conta proxy execute uma transaÃ§Ã£o atÃ© que o perÃ­odo de atraso termine. O atraso dÃ¡ tempo para que a conta primÃ¡ria que controla o proxy revise as transaÃ§Ãµes pendentes e fornece um perÃ­odo limitado de tempo para cancelar quaisquer aÃ§Ãµes.

VocÃª tambÃ©m tem a opÃ§Ã£o de criar um proxy do tipo **Any**, que concede Ã  conta proxy controle total e irrestrito sobre a conta primÃ¡ria. Isso significa que a conta proxy pode transferir fundos e realizar qualquer aÃ§Ã£o arbitrÃ¡ria. A demonstraÃ§Ã£o a seguir mostrarÃ¡ como configurar um proxy **Staking**, que Ã© mais restritivo do que um proxy **Any**, pois limita as funÃ§Ãµes Ã s atividades relacionadas ao staking, como delegar, nÃ£o delegar e mapear chaves de sessÃ£o.

Para comeÃ§ar a criar sua conta proxy, vÃ¡ para a aba **Developer** e selecione [**Extrinsics**](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank} no menu suspenso. Em seguida, vocÃª precisarÃ¡ seguir as seguintes etapas:

1. Selecione a conta primÃ¡ria
2. No menu suspenso **submit the following extrinsic**, selecione **proxy**
3. Escolha a extrÃ­nseca **addProxy**
4. Escolha **Id** no menu suspenso **AccountIdLookupOf**
5. Selecione a conta de **delegate** para o proxy
6. No menu suspenso **proxyType**, escolha **Staking**
7. Opcionalmente, vocÃª pode adicionar um atraso de tempo usando um nÃºmero especificado de blocos para adicionar uma camada adicional de seguranÃ§a para que a conta primÃ¡ria revise a transaÃ§Ã£o pendente
8. Clique em **Submit Transaction**

![Adicionar uma conta proxy na pÃ¡gina Extrinsics do portal do desenvolvedor](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-1.webp)

VocÃª serÃ¡ solicitado a autorizar e assinar a transaÃ§Ã£o. Clique em **Sign and Submit** para criar o relacionamento proxy. Depois que a transaÃ§Ã£o for enviada com sucesso, vocÃª receberÃ¡ algumas notificaÃ§Ãµes confirmando a transaÃ§Ã£o.

Como mencionado anteriormente, vocÃª tambÃ©m pode criar um proxy na pÃ¡gina **Accounts**. Para fazer isso, navegue atÃ© a pÃ¡gina **Accounts** e siga as seguintes etapas:

1. Selecione os trÃªs pontos verticais prÃ³ximos Ã  conta primÃ¡ria
2. Selecione **Add proxy**

![Selecione o item de menu Add proxy na pÃ¡gina Accounts do portal do desenvolvedor](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-2.webp)

!!! note
    Se a conta jÃ¡ tiver um proxy, **Manage proxies** serÃ¡ exibido como uma opÃ§Ã£o em vez de **Add proxy**.

Uma janela pop-up aparecerÃ¡ e vocÃª poderÃ¡ inserir as informaÃ§Ãµes necessÃ¡rias, como a conta proxy/primÃ¡ria, a conta proxy e o tipo de proxy para criar uma conta proxy. Primeiro, clique em **Add proxy**.

![Adicionar uma conta proxy na pÃ¡gina Accounts do portal do desenvolvedor](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-3.webp)

Em seguida, siga as seguintes etapas:

1. Selecione a conta que vocÃª gostaria de definir como um proxy
2. Selecione o tipo de proxy
3. Clique em **Submit** e assine a transaÃ§Ã£o

![Adicionar os detalhes da conta proxy, incluindo a conta proxy e o tipo](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-4.webp)

Na prÃ³xima seÃ§Ã£o, vocÃª aprenderÃ¡ como verificar se sua conta proxy foi configurada com sucesso.

## Verificando Sua Conta Proxy {: #verifying-your-proxy-account }

VocÃª pode verificar se sua conta proxy foi configurada com sucesso de algumas maneiras: ou na pÃ¡gina **Accounts** ou na pÃ¡gina **Chain state**.

Para verificar suas contas proxy na pÃ¡gina [**Chain state**](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/chainstate){target=\_blank}, vocÃª pode seguir as seguintes etapas:

1. No menu suspenso **selected state query**, selecione **proxy**
2. Escolha a extrÃ­nseca **proxies**
3. Selecione sua conta primÃ¡ria/proxy
4. Clique no botÃ£o **+** para enviar a consulta

![Verifique suas contas proxy na pÃ¡gina Extrinsics do portal do desenvolvedor](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-5.webp)

O resultado aparecerÃ¡ na pÃ¡gina mostrando informaÃ§Ãµes sobre todos os seus proxies, incluindo o endereÃ§o da conta delegate/proxy, o tipo de proxy, o perÃ­odo de atraso, se um foi especificado, e o valor total da garantia para todos os seus proxies em Planck.

VocÃª tambÃ©m pode verificar suas contas proxy na pÃ¡gina **Accounts**. Para fazer isso, navegue atÃ© a pÃ¡gina **Accounts** e deve haver um sÃ­mbolo de Proxy ao lado da conta primÃ¡ria. Passe o mouse sobre o Ã­cone e clique em **Manage proxies** para revisar seus proxies.

![Passe o mouse sobre o Ã­cone do proxy para gerenciar seus proxies na pÃ¡gina Accounts dos Polkadot.js Apps](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-6.webp)

Uma janela pop-up aparecerÃ¡ onde vocÃª pode ver uma visÃ£o geral de todas as suas contas proxy.

![Revise suas contas proxy](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-7.webp)

## Executando uma TransaÃ§Ã£o Proxy {: #executing-a-proxy-transaction }

Agora que vocÃª criou uma conta proxy e verificou que ela foi configurada com sucesso, vocÃª pode executar uma transaÃ§Ã£o usando a conta proxy de staking em nome de sua conta Sequencera, tambÃ©m conhecida como conta primÃ¡ria ou conta que estÃ¡ sendo proxyada. O exemplo a seguir demonstrarÃ¡ como iniciar uma autodelegaÃ§Ã£o. A configuraÃ§Ã£o de proxy mostrada Ã© um exemplo realista de como vocÃª pode ter seu prÃ³prio proxy configurado para sua conta primÃ¡ria do portal do desenvolvedor.

Para executar uma transaÃ§Ã£o, vocÃª pode navegar de volta para a [pÃ¡gina **Extrinsics**](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2F{{ networks.dancelight.dns_name }}#/extrinsics){target=\_blank} e seguir as seguintes etapas:

1. Selecione a conta proxy para enviar a transaÃ§Ã£o no menu suspenso **using the select account**
2. No menu **submit the following extrinsic**, selecione **proxy**
3. Escolha a extrÃ­nseca **proxy**
4. Escolha **Id** no menu suspenso **AccountIdLookupOf**
5. Selecione a conta primÃ¡ria no menu suspenso **real**
6. Selecione a chamada **pooledStaking**
7. Escolha a extrÃ­nseca **requestDelegate**
8. Digite o endereÃ§o do **candidate**, que Ã© a conta do Sequencer
9. Selecione **AutoCompounding** ou **ManualRewards** no campo **pool**
10. Digite o valor a ser apostado. Esse valor deve atender ao mÃ­nimo, que, para Dancelight, Ã© {{ networks.dancelight.sequencers.minimum_self_delegation }} {{ networks.dancelight.token_symbol }} tokens. VocÃª precisarÃ¡ enviar o valor incluindo as doze casas decimais que a Tanssi Network usa, portanto, para um valor de {{ networks.dancelight.sequencers.minimum_self_delegation }}, vocÃª precisarÃ¡ digitar `{{ networks.dancelight.sequencers.minimum_self_delegation }}000000000000`
11. Clique em **Submit Transaction**

![Execute uma transaÃ§Ã£o proxy na pÃ¡gina Extrinsics dos Polkadot.js Apps](/images/node-operators/sequencers/operational-tasks/proxy-accounts/proxy-8.webp)

Uma janela pop-up aparecerÃ¡ para que vocÃª autorize e assine a transaÃ§Ã£o. Digite sua senha para a conta proxy e clique em **Sign and Submit**. Para confirmar a solicitaÃ§Ã£o de delegaÃ§Ã£o, vocÃª precisarÃ¡ executar a solicitaÃ§Ã£o pendente apÃ³s duas sessÃµes. Consulte as instruÃ§Ãµes para [executar solicitaÃ§Ãµes pendentes](/pt/node-operators/sequencers/onboarding/account-setup/#execute-pending-request){target=\_blank} para obter um guia passo a passo. VocÃª tambÃ©m pode [mapear suas chaves de sessÃ£o para sua conta de Sequencer](/pt/node-operators/sequencers/onboarding/account-setup/#map-session-keys){target=\_blank} via proxy.

Depois de mapear suas chaves de sessÃ£o e executar a solicitaÃ§Ã£o de delegaÃ§Ã£o pendente, vocÃª pode [verificar se seu Sequencer estÃ¡ na lista de candidatos elegÃ­veis](/pt/node-operators/sequencers/onboarding/account-setup/#verify){target=\_blank}.

Ã‰ isso! VocÃª executou com sucesso uma transaÃ§Ã£o usando uma conta proxy em nome de sua conta Sequencera primÃ¡ria.

<div class="page-disclaimer">
  {{ trans("disclaimer.third_party") }}
</div>
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/operational-tasks/upgrade-your-node/
--- BEGIN CONTENT ---
---
title: Atualizar NÃ³ de Sequencer
description: Siga estas etapas para atualizar seu nÃ³ para a versÃ£o mais recente do software cliente Tanssi, garantindo a produÃ§Ã£o contÃ­nua de blocos no protocolo de rede Tanssi.
icon: octicons-rocket-24
template: index-page.html
---

# Atualizar NÃ³ de Sequencers

A manutenÃ§Ã£o do seu nÃ³ atualizado Ã© fundamental para manter a compatibilidade com as Ãºltimas alteraÃ§Ãµes do protocolo Tanssi e garantir o desempenho ideal. NÃ³s desatualizados podem levar Ã  dessincronizaÃ§Ã£o, reduÃ§Ã£o da eficiÃªncia ou atÃ© mesmo Ã  incapacidade de participar da produÃ§Ã£o de blocos. Ao manter-se atualizado com os lanÃ§amentos de clientes, vocÃª pode garantir que seu nÃ³ opere de forma segura e confiÃ¡vel na rede.

!!! tip "Assine as notificaÃ§Ãµes de lanÃ§amento"
    Ficar informado sobre novas versÃµes do cliente Ã© essencial para manter o nÃ³ atualizado. Os mantenedores do nÃ³ podem assinar as notificaÃ§Ãµes do GitHub para serem alertados sobre novas versÃµes.

    Para assinar, acesse o repositÃ³rio [Tanssi no GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} e clique em **Watch**. Selecione **Custom notifications** e marque a opÃ§Ã£o **Releases**.

## Explore o Que Esta SeÃ§Ã£o Cobre

:::INSERT_GENERATED_CARDS:::
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-docker/
--- BEGIN CONTENT ---
---
title: Atualize seu NÃ³ Docker Sequencer
description: Siga estas instruÃ§Ãµes para atualizar seu nÃ³ sequencer Tanssi em execuÃ§Ã£o via Docker para a versÃ£o mais recente do software cliente Tanssi.
icon: simple-docker
categories: Sequencers
---

# Atualize seu NÃ³ em ExecuÃ§Ã£o via Docker

## IntroduÃ§Ã£o {: #introduction }

Manter seu nÃ³ atualizado Ã© uma parte importante de ser um sequencer Tanssi. NÃ£o sÃ³ ajuda a garantir que seu nÃ³ sequencer permaneÃ§a saudÃ¡vel, mas tambÃ©m contribui para manter toda a Rede Tanssi funcionando sem problemas.

Este tutorial aborda a atualizaÃ§Ã£o do seu sequencer Tanssi que foi configurado usando o Docker. Ele pressupÃµe que vocÃª jÃ¡ configurou sua conta e lanÃ§ou um [sequencer usando Docker](/pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-docker/){target=\_blank}.

!!! tip "Assine as notificaÃ§Ãµes de lanÃ§amento"
    Ficar informado sobre novas versÃµes do cliente Ã© essencial para manter o nÃ³ atualizado. Os mantenedores do nÃ³ podem assinar as notificaÃ§Ãµes do GitHub para serem alertados sobre novas versÃµes.

    Para assinar, acesse o repositÃ³rio [Tanssi no GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} e clique em **Watch**. Selecione **Custom notifications** e marque a opÃ§Ã£o **Releases**.

## Atualizando NÃ³s Docker {: #upgrading-docker-nodes }

Se vocÃª estiver executando seu sequencer com o Docker, atualizar seu nÃ³ Ã© tÃ£o simples quanto parar o contÃªiner em execuÃ§Ã£o e reiniciÃ¡-lo com a nova tag de versÃ£o.

Primeiro, obtenha a ID do contÃªiner do seu nÃ³ sequencer Tanssi com o seguinte comando:

```bash
docker ps -a
```

A ID do contÃªiner Ã© a primeira coluna e, se vocÃª estiver executando vÃ¡rios contÃªineres Docker, pode identificÃ¡-lo pelo nome da imagem de `{{ node_versions.docker_sequencer_image_name }}`. VocÃª pode executar o comando de parada da seguinte forma:

```bash
docker stop INSERT_YOUR_CONTAINER_ID
```

A sua interaÃ§Ã£o com o terminal serÃ¡ semelhante ao seguinte:

<div id="termynal" data-termynal>
  <span data-ty="input"><span class="file-path"></span>docker ps -a</span>
  <span data-ty>
    <br> 
    <br> CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS  PORTS    NAMES
    <br> aa751703d6aa moondancelabs/tanssi:v0.6.1 "/tanssi/tanssi-nodeâ€¦" 56 seconds ago  Up 56 seconds             focused_chaum
    <br> 
    <span data-ty="input"><span class="file-path"></span>docker stop aa751703d6aa</span>
    <br> aa751703d6aa
  </span>
</div>

Para reiniciar o nÃ³, vocÃª pode usar o mesmo comando que usou ao iniciar seu nÃ³ pela primeira vez. O comando extrai a imagem e o nÃ³ retomarÃ¡ a sincronizaÃ§Ã£o de blocos de onde parou quando o processo Docker foi interrompido.

=== "GenÃ©rico"

    ```bash
    docker run --network="host" -v "/var/lib/dancebox:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    {{ node_versions.docker_sequencer_image_name }} \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
    ```

=== "Intel Skylake"

    ```bash
    docker run --network="host" -v "/var/lib/dancebox:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    --entrypoint "/tanssi/tanssi-node-skylake" \
    {{ node_versions.docker_sequencer_image_name }} \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
    ```

=== "AMD Zen3"

    ```bash
    docker run --network="host" -v "/var/lib/dancebox:/data" \
    -u $(id -u ${USER}):$(id -g ${USER}) \
    --entrypoint "/tanssi/tanssi-node-znver3" \
    {{ node_versions.docker_sequencer_image_name }} \
    --name=INSERT_YOUR_SEQUENCER_NODE_NAME \
--base-path=/data/container \
--node-key-file=/data/node-key \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--pool-type=fork-aware \
--database=paritydb \
--rpc-port=9944 \
--prometheus-port=9615 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30333 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--db-cache=1024 \
--trie-cache-size=1073741824 \
--collator \
--in-peers=100 \
--detailed-log-output \
-- \
--chain=/data/dancelight-raw-specs.json \
--name=INSERT_YOUR_TANSSI_NODE_NAME \
--sync=fast \
--base-path=/data/relay \
--node-key-file=/data/node-key \
--keystore-path=/data/keys/session \
--database=paritydb \
--rpc-port=9945 \
--prometheus-port=9616 \
--prometheus-external \
--listen-addr=/ip4/0.0.0.0/tcp/30334 \
--pool-limit=0 \
--db-cache=128 \
--out-peers=15 \
--state-pruning=2000 \
--blocks-pruning=2000 \
--telemetry-url='wss://telemetry.polkadot.io/submit/ 0' \
--bootnodes=/dns4/qco-dancelight-boot-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWCekAqk5hv2fZprhqVz8povpUKdJEiHSd3MALVDWNPFzY \
--bootnodes=/dns4/qco-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWEwhUb3tVR5VhRBEqyH7S5hMpFoGJ9Anf31hGw7gpqoQY \
--bootnodes=/dns4/ukl-dancelight-rpc-1.rv.dancelight.tanssi.network/tcp/30334/p2p/12D3KooWPbVtdaGhcuDTTQ8giTUtGTEcUVWRg8SDWGdJEeYeyZcT"
    ```
    
### Especificando uma Tag de VersÃ£o {: #specifying-a-version-tag }

Se vocÃª quiser especificar uma [tag de versÃ£o especÃ­fica](https://hub.docker.com/r/moondancelabs/tanssi/tags){target=\_blank}, vocÃª pode fazer isso substituindo a tag de versÃ£o anexada ao nome da imagem. Por exemplo, se vocÃª quisesse buscar a versÃ£o `3`, vocÃª substituiria o `2` em `{{ node_versions.docker_sequencer_image_name }}`.

E Ã© isso! VocÃª atualizou com sucesso seu nÃ³ Tanssi.
--- END CONTENT ---

Doc-Content: https://docs.tanssi.network/pt/node-operators/sequencers/operational-tasks/upgrade-your-node/upgrade-systemd/
--- BEGIN CONTENT ---
---
title: Atualize Seu NÃ³ Systemd Sequencer
description: Siga estas instruÃ§Ãµes para atualizar seu nÃ³ sequencer Tanssi em execuÃ§Ã£o via Systemd para a versÃ£o mais recente do software cliente Tanssi.
icon: simple-linux
categories: Sequencers
---

# Atualize Seu NÃ³ em ExecuÃ§Ã£o via Systemd

## IntroduÃ§Ã£o {: #introduction }

Manter seu nÃ³ atualizado Ã© uma parte importante de ser um sequencer Tanssi. Isso nÃ£o sÃ³ ajuda a garantir que seu nÃ³ sequencer permaneÃ§a saudÃ¡vel, como tambÃ©m contribui para manter toda a Rede Tanssi funcionando sem problemas.

Este tutorial aborda a atualizaÃ§Ã£o do seu nÃ³ sequencer Tanssi que foi configurado usando o Systemd. Ele pressupÃµe que vocÃª jÃ¡ configurou sua conta e lanÃ§ou um [nÃ³ sequencer usando Systemd](/pt/node-operators/sequencers/onboarding/run-a-sequencer/sequencers-systemd/){target=\_blank}.

!!! tip "Assine as notificaÃ§Ãµes de lanÃ§amento"
    Ficar informado sobre novas versÃµes do cliente Ã© essencial para manter o nÃ³ atualizado. Os mantenedores do nÃ³ podem assinar as notificaÃ§Ãµes do GitHub para serem alertados sobre novas versÃµes.

    Para assinar, acesse o repositÃ³rio [Tanssi no GitHub](https://github.com/moondance-labs/tanssi){target=\_blank} e clique em **Watch**. Selecione **Custom notifications** e marque a opÃ§Ã£o **Releases**.

## Atualizando Seu NÃ³ Systemd {: #upgrading-your-systemd-node }

Se vocÃª estiver executando seu sequencer atravÃ©s do serviÃ§o Systemd, vocÃª precisarÃ¡ seguir algumas etapas para atualizar corretamente seu nÃ³. Em suma, vocÃª precisarÃ¡ parar o serviÃ§o, substituir o binÃ¡rio Tanssi pela versÃ£o atualizada e, em seguida, iniciar o serviÃ§o.

VocÃª pode parar seu serviÃ§o Tanssi Systemd com o seguinte comando:

```bash
systemctl stop tanssi.service
```

Em seguida, navegue atÃ© o diretÃ³rio onde seu binÃ¡rio Tanssi estÃ¡ armazenado e remova-o.

```bash
cd /var/lib/tanssi-data
```

Seu arquivo binÃ¡rio Tanssi provavelmente serÃ¡ nomeado `tanssi-node`. Caso contrÃ¡rio, vocÃª pode substituir `tanssi-node` abaixo pelo nome correto do seu arquivo binÃ¡rio Tanssi.

```bash
rm tanssi-node
```

Para baixar a versÃ£o mais recente e alterar as permissÃµes para que o serviÃ§o Tanssi possa usÃ¡-la, execute o seguinte comando que corresponde ao seu ambiente:

=== "GenÃ©rico"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node && \
    chmod +x ./tanssi-node
    ```

=== "Intel Skylake"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-skylake -O tanssi-node && \
    chmod +x ./tanssi-node
    ```

=== "AMD Zen3"

    ```bash
    wget https://github.com/moondance-labs/tanssi/releases/download/{{ node_versions.para_client_version }}/tanssi-node-znver3 -O tanssi-node && \
    chmod +x ./tanssi-node
    ```

VocÃª pode reiniciar seu serviÃ§o Tanssi Systemd com o seguinte comando:

```bash
systemctl start tanssi.service
```

O nÃ³ retomarÃ¡ a sincronizaÃ§Ã£o de blocos de onde parou quando o serviÃ§o Systemd foi interrompido. Para verificar se estÃ¡ funcionando corretamente, vocÃª pode usar o seguinte comando para verificar os logs:

```bash
systemctl status tanssi.service
```

E Ã© isso! VocÃª atualizou seu nÃ³ Tanssi com sucesso.
--- END CONTENT ---

