---
title: Core Runtime Features
description: Learn about the core features of a Tanssi network, the transactions types, how they are executed and included in a block, and the forkless runtime upgrades.
icon: octicons-package-24
categories: Basics
---

````json
{
  "source_path": "learn/decentralized-networks/runtime-features.md",
  "source_language": "EN",
  "target_language": "PT",
  "checksum": "9255de19647159b6451e8a8f72f8985f6602c3101e328d31a97c10bd78eb80b6",
  "content": "---\ntitle: Core Runtime Features\ndescription: Learn about the core features of a Tanssi network, the transactions types, how they are executed and included in a block, and the forkless runtime upgrades.\nicon: octicons-package-24\ncategories: Basics\n---\n\n# Core Runtime Features {: #core-runtime-features }\n\n## Introduction {: #introduction}\n\nAs redes implantadas através do Tanssi têm [muitos benefícios](/learn/tanssi/overview/#what-tanssi-provides){target=\\_blank} devido à sua [arquitetura](/learn/tanssi/overview/#tanssi-architecture){target=\\_blank} única.\n\nNo entanto, as redes baseadas no Tanssi também são únicas devido à [estrutura](/learn/framework/){target=\\_blank} (Substrate) em que são construídas, que fornece algumas características únicas que os desenvolvedores podem aproveitar para ajustar comportamentos específicos em seu tempo de execução.\n\nEsta seção aborda algumas dessas características específicas do tempo de execução do núcleo da rede Tanssi, incluindo as diferentes origens que uma transação pode ter, os diferentes tipos de transações e como elas são executadas e incluídas em um bloco, a conta especial conhecida como _SUDO_ e a característica bastante exclusiva das redes Tanssi: as atualizações de tempo de execução sem bifurcação.\n\n## Origins {: #origins}\n\nDe modo geral, todas as chamadas em uma rede Tanssi têm uma origem. Mas o que é uma origem? Os desenvolvedores do reino EVM podem estar familiarizados com o conceito de _msg.sender_ em transações EVM. As origens são para as redes Tanssi o que _msg.sender_ é para uma transação EVM, mas superalimentadas com muitas funcionalidades extras.\n\nUma origem define de onde a chamada está vindo. Em contraste com as cadeias compatíveis com Ethereum, pode haver muitas origens nas redes Tanssi. Por exemplo, o _msg.sender_ de uma transação EVM é conhecido como uma _origem assinada_, o que significa que a chamada é uma transação que foi assinada pela chave privada de uma conta na cadeia. Isso permite que o tempo de execução autentique a fonte da chamada e, por exemplo, cobre taxas de transação da conta associada.\n\nNo entanto, as origens podem fazer muito mais do que representar um par de chave privada/chave pública. As origens também têm diferentes níveis de privilégio. Por exemplo, uma _origem assinada_ pode enviar uma transação que é despachada pelo par de chave privada/chave pública, mas não deve ser capaz de autorizar uma atualização de tempo de execução.\n\nAlguns dos tipos mais comuns de origens são:\n\n- **Root** - uma origem em nível de sistema com o nível de privilégio mais alto. Pode ser pensado como um superusuário da cadeia, que pode executar qualquer chamada\n- **Signed** - como mencionado anteriormente, a origem de uma transação assinada pela chave privada de uma conta na cadeia, que inclui o identificador da conta (endereço) como o signatário\n- **None** - uma falta de origem. Usado em ações específicas que devem ser acordadas em nível de tempo de execução. Por exemplo, você pode programar seu tempo de execução para que uma transação com origem _none_ possa promulgar uma atualização de tempo de execução pré-autorizada, o que significa que a transação não tem taxa associada\n- **Custom** - os desenvolvedores também podem criar origens personalizadas para casos de uso específicos. Por exemplo, a [governança on-chain do Moonbeam](https://docs.moonbeam.network/learn/features/governance){target=\\_blank} tem origens específicas para cada tipo de voto de governança, chamadas _faixas_. Consequentemente, cada faixa pode ser configurada para executar apenas chamadas com níveis de privilégio específicos. Uma faixa é _Root_, cuja origem é a origem _Root_ mencionada antes, e tem uma configuração muito restritiva para que os votos passem. Mas outras faixas têm níveis de privilégio muito mais baixos para fazer algumas operações de rede menos críticas\n\n## Transaction Types {: #transaction-types}\n\nAs redes Tanssi têm três tipos principais de transações:\n\n- **Signed Transactions** - incluem uma carga assinada solicitando a execução de alguma chamada de tempo de execução. Geralmente, a assinatura está associada a um par de chave privada/chave pública. Dependendo da lógica de tempo de execução, a conta associada à assinatura paga uma taxa de transação\n- **Unsigned Transactions** - incluem uma carga não assinada solicitando a execução de alguma chamada de tempo de execução. Como essas transações não são assinadas, não há uma conta associada a elas. Consequentemente, os tempos de execução precisam definir condições específicas que impeçam o spam da rede ou ataques de repetição porque não há um mecanismo de taxa para evitar tais comportamentos maliciosos. Um exemplo de uma transação não assinada é a execução de ações pré-aprovadas, como uma atualização de tempo de execução\n- **Inherent Transactions** - uma transação não assinada que um sequenciador insere em um bloco ao inicializar sua construção. Essas transações fazem parte do bloco e não são armazenadas no pool de transações ou compartilhadas entre os participantes da rede. Além disso, os dados inseridos por meio de transações inerentes podem pular a validação do tempo de execução, e pode depender dos operadores aceitá-los. Um exemplo é o carimbo de data/hora do bloco. Isso é injetado no bloco por uma transação inerente, e os operadores podem aceitar ou rejeitar o bloco com base em se o carimbo de data/hora está dentro de uma faixa aceitável\n\n## Transaction Execution {: #transaction-execution}\n\nQuando um usuário ou aplicativo envia uma transação assinada para uma rede Tanssi, a transação é validada em um nível de nó completo usando regras definidas no tempo de execução e, em seguida, é enfileirada em um pool de transações. Isso garante que apenas as transações que estão em conformidade com determinadas condições específicas da cadeia sejam consideradas para serem incluídas em um bloco.\n\n!!! note\n    O tipo de transação mais comum é uma transação assinada. No entanto, as transações não assinadas também são validadas antes de serem enfileiradas no pool de transações.\n\nA fila de transações válidas compreende dois pools: pronto e futuro. A fila pronta contém todas as transações que podem ser incluídas em um novo bloco pendente. A fila futura é para transações que não atendem a todos os critérios para serem incluídas agora, mas podem se tornar válidas. Por exemplo, transações com um nonce futuro. Transações inválidas são diretamente rejeitadas.\n\nDurante o processo de construção do bloco, um sequenciador usa um [sistema de prioridade](https://github.com/paritytech/substrate/blob/fb24fda76d613305ebb2e5728c75362c94b64aa1/frame/transaction-payment/src/lib.rs#L614-L681){target=\\_blank} por meio de um módulo de orquestração de transação para ordenar as transações para o próximo bloco, até que o bloco atinja sua capacidade máxima. A ordem de construção e execução do bloco tem as seguintes operações:\n\n- **Initializing a Block** - conhecido como `on_initialize`, permite que você defina a lógica de tempo de execução executada antes que qualquer outra transação seja contabilizada. Por exemplo, transações inerentes, como o carimbo de data/hora no exemplo anterior, são comumente executadas ao inicializar um bloco. Assim que a lógica de inicialização for concluída, o módulo de orquestração da transação verifica o hash pai no cabeçalho do bloco e a raiz da trie para garantir que as informações estejam corretas\n- **Transaction Execution** - com o bloco já inicializado, o módulo de orquestração da transação executa cada transação válida de acordo com sua prioridade. O estado inicial não é armazenado em cache antes da execução, o que significa que, se uma das transações falhar no meio da execução, quaisquer alterações de estado confirmadas até aquele momento não podem ser revertidas, e o bloco subsequente será inválido. Consequentemente, a lógica de tempo de execução deve realizar todas as verificações necessárias para garantir que todas as transações válidas tenham sucesso\n- **Finalizing a Block** - depois que todas as transações válidas enfileiradas forem executadas ou o limite do bloco for atingido, o módulo de orquestração chama em cada módulo de tempo de execução as funções `on_idle` e `on_finalize`. Essas duas funções permitem a definição de lógica de negócios extra que é executada automaticamente no processo de finalização do bloco. Depois que a última função `on_finalize` é chamada, o módulo de orquestração garante que o resumo do bloco e a raiz de armazenamento correspondam ao que foi calculado quando o bloco foi inicializado\n\n## Forkless Upgrades {: #forkless-upgrades}\n\nAs redes implantadas através do Tanssi têm um recurso emocionante: [atualizações sem bifurcação](https://docs.polkadot.com/develop/parachains/maintenance/runtime-upgrades/){target=\\_blank}. As atualizações sem bifurcação permitem que os desenvolvedores alterem a função de transição de estado que governa a cadeia sem criar uma bifurcação de rede, como visto no Ethereum várias vezes. Além disso, se a rede Tanssi for configurada com um sistema de governança on-chain, as atualizações para a rede podem acontecer de uma forma verdadeiramente descentralizada e sem confiança.\n\nAs atualizações sem bifurcação são possíveis ao armazenar a função de transição de estado como um blob WebAssembly (Wasm) na própria rede Tanssi e na rede com tecnologia Tanssi. Quando um novo tempo de execução é agendado por meio de uma chamada de função na rede com tecnologia Tanssi, a rede Tanssi valida este bloco, para que ele seja notificado e se prepare para validar os blocos recebidos usando a função de transição de estado mais recente. Após um período de atraso de atualização de tempo de execução especificado, um sequenciador Tanssi na rede com tecnologia Tanssi constrói um bloco que faz referência a um bloco de rede Tanssi, sinalizando para a rede Tanssi que ela agora pode aplicar o novo tempo de execução. Consequentemente, esta nova função de transição de estado é utilizada para esse bloco específico. Como todos os participantes da infraestrutura no nível da rede empregam o blob Wasm on-chain, todo operador de nó de rede Tanssi pode validar novos blocos usando a função de transição de estado mais recente.\n\nUm resumo de alto nível do processo de atualização do tempo de execução é mostrado no diagrama a seguir:\n\n![Runtime Upgrade Process Tanssi Networks](/images/learn/decentralized-networks/runtime-features/runtime-features-1.webp)\n\n## SUDO Account {: #sudo-account}\n\nAs redes Tanssi podem usar um módulo específico chamado [SUDO](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/pallet/struct.Pallet.html){target=\\_blank}. Este módulo introduz um novo tipo de conta, também chamado _SUDO_, que pode executar transações com a origem [_Root_](#origins).\n\nConsequentemente, a conta SUDO pode realizar **qualquer** ação que o tempo de execução permita que a origem _Root_ execute. Isso pode incluir:\n\n- Cunhar novos tokens nativos da rede Tanssi\n- Executar [atualizações de tempo de execução sem bifurcação](#forkless-upgrades)\n- Enviar transações personificando outros [tipos de origem](#origins). Portanto, SUDO pode enviar transações em nome de outros usuários sem acessar sua chave privada\n\n_SUDO_ é recomendado para TestNets, pois permite que eles façam alterações rapidamente sem a necessidade de passar por um longo processo de governança on-chain. É uma boa prática ter chaves _SUDO_ armazenadas com segurança e conceder acesso a chamadas _SUDO_ via contas proxy. No entanto, ter _SUDO_ habilitado em um ambiente de produção pode levar a consequências indesejadas.\n\n**Compreender os riscos de centralização de ter _SUDO_ em um ambiente de produção é fundamental.**\n",
  "translated_content": "```json\n{\n  \"source_path\": \"learn/decentralized-networks/runtime-features.md\",\n  \"source_language\": \"EN\",\n  \"target_language\": \"PT\",\n  \"checksum\": \"9255de19647159b6451e8a8f72f8985f6602c3101e328d31a97c10bd78eb80b6\",\n  \"content\": \"---\\ntitle: Core Runtime Features\\ndescription: Learn about the core features of a Tanssi network, the transactions types, how they are executed and included in a block, and the forkless runtime upgrades.\\nicon: octicons-package-24\\ncategories: Basics\\n---\\n\\n# Core Runtime Features {: #core-runtime-features }\\n\\n## Introduction {: #introduction}\\n\\nAs redes implantadas através do Tanssi têm [muitos benefícios](/learn/tanssi/overview/#what-tanssi-provides){target=\\_blank} devido à sua [arquitetura](/learn/tanssi/overview/#tanssi-architecture){target=\\_blank} única.\\n\\nNo entanto, as redes baseadas no Tanssi também são únicas devido à [estrutura](/learn/framework/){target=\\_blank} (Substrate) em que são construídas, que fornece algumas características únicas que os desenvolvedores podem aproveitar para ajustar comportamentos específicos em seu tempo de execução.\\n\\nEsta seção aborda algumas dessas características específicas do tempo de execução do núcleo da rede Tanssi, incluindo as diferentes origens que uma transação pode ter, os diferentes tipos de transações e como elas são executadas e incluídas em um bloco, a conta especial conhecida como _SUDO_ e a característica bastante exclusiva das redes Tanssi: as atualizações de tempo de execução sem bifurcação.\\n\\n## Origins {: #origins}\\n\\nDe modo geral, todas as chamadas em uma rede Tanssi têm uma origem. Mas o que é uma origem? Os desenvolvedores do reino EVM podem estar familiarizados com o conceito de _msg.sender_ em transações EVM. As origens são para as redes Tanssi o que _msg.sender_ é para uma transação EVM, mas superalimentadas com muitas funcionalidades extras.\\n\\nUma origem define de onde a chamada está vindo. Em contraste com as cadeias compatíveis com Ethereum, pode haver muitas origens nas redes Tanssi. Por exemplo, o _msg.sender_ de uma transação EVM é conhecido como uma _origem assinada_, o que significa que a chamada é uma transação que foi assinada pela chave privada de uma conta na cadeia. Isso permite que o tempo de execução autentique a fonte da chamada e, por exemplo, cobre taxas de transação da conta associada.\\n\\nNo entanto, as origens podem fazer muito mais do que representar um par de chave privada/chave pública. As origens também têm diferentes níveis de privilégio. Por exemplo, uma _origem assinada_ pode enviar uma transação que é despachada pelo par de chave privada/chave pública, mas não deve ser capaz de autorizar uma atualização de tempo de execução.\\n\\nAlguns dos tipos mais comuns de origens são:\\n\\n- **Root** - uma origem em nível de sistema com o nível de privilégio mais alto. Pode ser pensado como um superusuário da cadeia, que pode executar qualquer chamada\\n- **Signed** - como mencionado anteriormente, a origem de uma transação assinada pela chave privada de uma conta na cadeia, que inclui o identificador da conta (endereço) como o signatário\\n- **None** - uma falta de origem. Usado em ações específicas que devem ser acordadas em nível de tempo de execução. Por exemplo, você pode programar seu tempo de execução para que uma transação com origem _none_ possa promulgar uma atualização de tempo de execução pré-autorizada, o que significa que a transação não tem taxa associada\\n- **Custom** - os desenvolvedores também podem criar origens personalizadas para casos de uso específicos. Por exemplo, a [governança on-chain do Moonbeam](https://docs.moonbeam.network/learn/features/governance){target=\\_blank} tem origens específicas para cada tipo de voto de governança, chamadas _faixas_. Consequentemente, cada faixa pode ser configurada para executar apenas chamadas com níveis de privilégio específicos. Uma faixa é _Root_, cuja origem é a origem _Root_ mencionada antes, e tem uma configuração muito restritiva para que os votos passem. Mas outras faixas têm níveis de privilégio muito mais baixos para fazer algumas operações de rede menos críticas\\n\\n## Transaction Types {: #transaction-types}\\n\\nAs redes Tanssi têm três tipos principais de transações:\\n\\n- **Signed Transactions** - incluem uma carga assinada solicitando a execução de alguma chamada de tempo de execução. Geralmente, a assinatura está associada a um par de chave privada/chave pública. Dependendo da lógica de tempo de execução, a conta associada à assinatura paga uma taxa de transação\\n- **Unsigned Transactions** - incluem uma carga não assinada solicitando a execução de alguma chamada de tempo de execução. Como essas transações não são assinadas, não há uma conta associada a elas. Consequentemente, os tempos de execução precisam definir condições específicas que impeçam o spam da rede ou ataques de repetição porque não há um mecanismo de taxa para evitar tais comportamentos maliciosos. Um exemplo de uma transação não assinada é a execução de ações pré-aprovadas, como uma atualização de tempo de execução\\n- **Inherent Transactions** - uma transação não assinada que um sequenciador insere em um bloco ao inicializar sua construção. Essas transações fazem parte do bloco e não são armazenadas no pool de transações ou compartilhadas entre os participantes da rede. Além disso, os dados inseridos por meio de transações inerentes podem pular a validação do tempo de execução, e pode depender dos operadores aceitá-los. Um exemplo é o carimbo de data/hora do bloco. Isso é injetado no bloco por uma transação inerente, e os operadores podem aceitar ou rejeitar o bloco com base em se o carimbo de data/hora está dentro de uma faixa aceitável\\n\\n## Transaction Execution {: #transaction-execution}\\n\\nQuando um usuário ou aplicativo envia uma transação assinada para uma rede Tanssi, a transação é validada em um nível de nó completo usando regras definidas no tempo de execução e, em seguida, é enfileirada em um pool de transações. Isso garante que apenas as transações que estão em conformidade com determinadas condições específicas da cadeia sejam consideradas para serem incluídas em um bloco.\\n\\n!!! note\\n    O tipo de transação mais comum é uma transação assinada. No entanto, as transações não assinadas também são validadas antes de serem enfileiradas no pool de transações.\\n\\nA fila de transações válidas compreende dois pools: pronto e futuro. A fila pronta contém todas as transações que podem ser incluídas em um novo bloco pendente. A fila futura é para transações que não atendem a todos os critérios para serem incluídas agora, mas podem se tornar válidas. Por exemplo, transações com um nonce futuro. Transações inválidas são diretamente rejeitadas.\\n\\nDurante o processo de construção do bloco, um sequenciador usa um [sistema de prioridade](https://github.com/paritytech/substrate/blob/fb24fda76d613305ebb2e5728c75362c94b64aa1/frame/transaction-payment/src/lib.rs#L614-L681){target=\\_blank} por meio de um módulo de orquestração de transação para ordenar as transações para o próximo bloco, até que o bloco atinja sua capacidade máxima. A ordem de construção e execução do bloco tem as seguintes operações:\\n\\n- **Initializing a Block** - conhecido como `on_initialize`, permite que você defina a lógica de tempo de execução executada antes que qualquer outra transação seja contabilizada. Por exemplo, transações inerentes, como o carimbo de data/hora no exemplo anterior, são comumente executadas ao inicializar um bloco. Assim que a lógica de inicialização for concluída, o módulo de orquestração da transação verifica o hash pai no cabeçalho do bloco e a raiz da trie para garantir que as informações estejam corretas\\n- **Transaction Execution** - com o bloco já inicializado, o módulo de orquestração da transação executa cada transação válida de acordo com sua prioridade. O estado inicial não é armazenado em cache antes da execução, o que significa que, se uma das transações falhar no meio da execução, quaisquer alterações de estado confirmadas até aquele momento não podem ser revertidas, e o bloco subsequente será inválido. Consequentemente, a lógica de tempo de execução deve realizar todas as verificações necessárias para garantir que todas as transações válidas tenham sucesso\\n- **Finalizing a Block** - depois que todas as transações válidas enfileiradas forem executadas ou o limite do bloco for atingido, o módulo de orquestração chama em cada módulo de tempo de execução as funções `on_idle` e `on_finalize`. Essas duas funções permitem a definição de lógica de negócios extra que é executada automaticamente no processo de finalização do bloco. Depois que a última função `on_finalize` é chamada, o módulo de orquestração garante que o resumo do bloco e a raiz de armazenamento correspondam ao que foi calculado quando o bloco foi inicializado\\n\\n## Forkless Upgrades {: #forkless-upgrades}\\n\\nAs redes implantadas através do Tanssi têm um recurso emocionante: [atualizações sem bifurcação](https://docs.polkadot.com/develop/parachains/maintenance/runtime-upgrades/){target=\\_blank}. As atualizações sem bifurcação permitem que os desenvolvedores alterem a função de transição de estado que governa a cadeia sem criar uma bifurcação de rede, como visto no Ethereum várias vezes. Além disso, se a rede Tanssi for configurada com um sistema de governança on-chain, as atualizações para a rede podem acontecer de uma forma verdadeiramente descentralizada e sem confiança.\\n\\nAs atualizações sem bifurcação são possíveis ao armazenar a função de transição de estado como um blob WebAssembly (Wasm) na própria rede Tanssi e na rede com tecnologia Tanssi. Quando um novo tempo de execução é agendado por meio de uma chamada de função na rede com tecnologia Tanssi, a rede Tanssi valida este bloco, para que ele seja notificado e se prepare para validar os blocos recebidos usando a função de transição de estado mais recente. Após um período de atraso de atualização de tempo de execução especificado, um sequenciador Tanssi na rede com tecnologia Tanssi constrói um bloco que faz referência a um bloco de rede Tanssi, sinalizando para a rede Tanssi que ela agora pode aplicar o novo tempo de execução. Consequentemente, esta nova função de transição de estado é utilizada para esse bloco específico. Como todos os participantes da infraestrutura no nível da rede empregam o blob Wasm on-chain, todo operador de nó de rede Tanssi pode validar novos blocos usando a função de transição de estado mais recente.\\n\\nUm resumo de alto nível do processo de atualização do tempo de execução é mostrado no diagrama a seguir:\\n\\n![Runtime Upgrade Process Tanssi Networks](/images/learn/decentralized-networks/runtime-features/runtime-features-1.webp)\\n\\n## SUDO Account {: #sudo-account}\\n\\nAs redes Tanssi podem usar um módulo específico chamado [SUDO](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/pallet/struct.Pallet.html){target=\\_blank}. Este módulo introduz um novo tipo de conta, também chamado _SUDO_, que pode executar transações com a origem [_Root_](#origins).\\n\\nConsequentemente, a conta SUDO pode realizar **qualquer** ação que o tempo de execução permita que a origem _Root_ execute. Isso pode incluir:\\n\\n- Cunhar novos tokens nativos da rede Tanssi\\n- Executar [atualizações de tempo de execução sem bifurcação](#forkless-upgrades)\\n- Enviar transações personificando outros [tipos de origem](#origins). Portanto, SUDO pode enviar transações em nome de outros usuários sem acessar sua chave privada\\n\\n_SUDO_ é recomendado para TestNets, pois permite que eles façam alterações rapidamente sem a necessidade de passar por um longo processo de governança on-chain. É uma boa prática ter chaves _SUDO_ armazenadas com segurança e conceder acesso a chamadas _SUDO_ via contas proxy. No entanto, ter _SUDO_ habilitado em um ambiente de produção pode levar a consequências indesejadas.\\n\\n**Compreender os riscos de centralização de ter _SUDO_ em um ambiente de produção é fundamental.**\\n",
  "translated_content": "```json\n{\n  \"source_path\": \"learn/decentralized-networks/runtime-features.md\",\n  \"source_language\": \"EN\",\n  \"target_language\": \"PT\",\n  \"checksum\": \"9255de19647159b6451e8a8f72f8985f6602c3101e328d31a97c10bd78eb80b6\",\n  \"content\": \"---\\ntitle: Core Runtime Features\\ndescription: Learn about the core features of a Tanssi network, the transactions types, how they are executed and included in a block, and the forkless runtime upgrades.\\nicon: octicons-package-24\\ncategories: Basics\\n---\\n\\n# Core Runtime Features {: #core-runtime-features }\\n\\n## Introduction {: #introduction}\\n\\nAs redes implantadas através do Tanssi têm [muitos benefícios](/learn/tanssi/overview/#what-tanssi-provides){target=\\_blank} devido à sua [arquitetura](/learn/tanssi/overview/#tanssi-architecture){target=\\_blank} única.\\n\\nNo entanto, as redes baseadas no Tanssi também são únicas devido à [estrutura](/learn/framework/){target=\\_blank} (Substrate) em que são construídas, que fornece algumas características únicas que os desenvolvedores podem aproveitar para ajustar comportamentos específicos em seu tempo de execução.\\n\\nEsta seção aborda algumas dessas características específicas do tempo de execução do núcleo da rede Tanssi, incluindo as diferentes origens que uma transação pode ter, os diferentes tipos de transações e como elas são executadas e incluídas em um bloco, a conta especial conhecida como _SUDO_ e a característica bastante exclusiva das redes Tanssi: as atualizações de tempo de execução sem bifurcação.\\n\\n## Origins {: #origins}\\n\\nDe modo geral, todas as chamadas em uma rede Tanssi têm uma origem. Mas o que é uma origem? Os desenvolvedores do reino EVM podem estar familiarizados com o conceito de _msg.sender_ em transações EVM. As origens são para as redes Tanssi o que _msg.sender_ é para uma transação EVM, mas superalimentadas com muitas funcionalidades extras.\\n\\nUma origem define de onde a chamada está vindo. Em contraste com as cadeias compatíveis com Ethereum, pode haver muitas origens nas redes Tanssi. Por exemplo, o _msg.sender_ de uma transação EVM é conhecido como uma _origem assinada_, o que significa que a chamada é uma transação que foi assinada pela chave privada de uma conta na cadeia. Isso permite que o tempo de execução autentique a fonte da chamada e, por exemplo, cobre taxas de transação da conta associada.\\n\\nNo entanto, as origens podem fazer muito mais do que representar um par de chave privada/chave pública. As origens também têm diferentes níveis de privilégio. Por exemplo, uma _origem assinada_ pode enviar uma transação que é despachada pelo par de chave privada/chave pública, mas não deve ser capaz de autorizar uma atualização de tempo de execução.\\n\\nAlguns dos tipos mais comuns de origens são:\\n\\n- **Root** - uma origem em nível de sistema com o nível de privilégio mais alto. Pode ser pensado como um superusuário da cadeia, que pode executar qualquer chamada\\n- **Signed** - como mencionado anteriormente, a origem de uma transação assinada pela chave privada de uma conta na cadeia, que inclui o identificador da conta (endereço) como o signatário\\n- **None** - uma falta de origem. Usado em ações específicas que devem ser acordadas em nível de tempo de execução. Por exemplo, você pode programar seu tempo de execução para que uma transação com origem _none_ possa promulgar uma atualização de tempo de execução pré-autorizada, o que significa que a transação não tem taxa associada\\n- **Custom** - os desenvolvedores também podem criar origens personalizadas para casos de uso específicos. Por exemplo, a [governança on-chain do Moonbeam](https://docs.moonbeam.network/learn/features/governance){target=\\_blank} tem origens específicas para cada tipo de voto de governança, chamadas _faixas_. Consequentemente, cada faixa pode ser configurada para executar apenas chamadas com níveis de privilégio específicos. Uma faixa é _Root_, cuja origem é a origem _Root_ mencionada antes, e tem uma configuração muito restritiva para que os votos passem. Mas outras faixas têm níveis de privilégio muito mais baixos para fazer algumas operações de rede menos críticas\\n\\n## Transaction Types {: #transaction-types}\\n\\nAs redes Tanssi têm três tipos principais de transações:\\n\\n- **Signed Transactions** - incluem uma carga assinada solicitando a execução de alguma chamada de tempo de execução. Geralmente, a assinatura está associada a um par de chave privada/chave pública. Dependendo da lógica de tempo de execução, a conta associada à assinatura paga uma taxa de transação\\n- **Unsigned Transactions** - incluem uma carga não assinada solicitando a execução de alguma chamada de tempo de execução. Como essas transações não são assinadas, não há uma conta associada a elas. Consequentemente, os tempos de execução precisam definir condições específicas que impeçam o spam da rede ou ataques de repetição porque não há um mecanismo de taxa para evitar tais comportamentos maliciosos. Um exemplo de uma transação não assinada é a execução de ações pré-aprovadas, como uma atualização de tempo de execução\\n- **Inherent Transactions** - uma transação não assinada que um sequenciador insere em um bloco ao inicializar sua construção. Essas transações fazem parte do bloco e não são armazenadas no pool de transações ou compartilhadas entre os participantes da rede. Além disso, os dados inseridos por meio de transações inerentes podem pular a validação do tempo de execução, e pode depender dos operadores aceitá-los. Um exemplo é o carimbo de data/hora do bloco. Isso é injetado no bloco por uma transação inerente, e os operadores podem aceitar ou rejeitar o bloco com base em se o carimbo de data/hora está dentro de uma faixa aceitável\\n\\n## Transaction Execution {: #transaction-execution}\\n\\nQuando um usuário ou aplicativo envia uma transação assinada para uma rede Tanssi, a transação é validada em um nível de nó completo usando regras definidas no tempo de execução e, em seguida, é enfileirada em um pool de transações. Isso garante que apenas as transações que estão em conformidade com determinadas condições específicas da cadeia sejam consideradas para serem incluídas em um bloco.\\n\\n!!! note\\n    O tipo de transação mais comum é uma transação assinada. No entanto, as transações não assinadas também são validadas antes de serem enfileiradas no pool de transações.\\n\\nA fila de transações válidas compreende dois pools: pronto e futuro. A fila pronta contém todas as transações que podem ser incluídas em um novo bloco pendente. A fila futura é para transações que não atendem a todos os critérios para serem incluídas agora, mas podem se tornar válidas. Por exemplo, transações com um nonce futuro. Transações inválidas são diretamente rejeitadas.\\n\\nDurante o processo de construção do bloco, um sequenciador usa um [sistema de prioridade](https://github.com/paritytech/substrate/blob/fb24fda76d613305ebb2e5728c75362c94b64aa1/frame/transaction-payment/src/lib.rs#L614-L681){target=\\_blank} por meio de um módulo de orquestração de transação para ordenar as transações para o próximo bloco, até que o bloco atinja sua capacidade máxima. A ordem de construção e execução do bloco tem as seguintes operações:\\n\\n- **Initializing a Block** - conhecido como `on_initialize`, permite que você defina a lógica de tempo de execução executada antes que qualquer outra transação seja contabilizada. Por exemplo, transações inerentes, como o carimbo de data/hora no exemplo anterior, são comumente executadas ao inicializar um bloco. Assim que a lógica de inicialização for concluída, o módulo de orquestração da transação verifica o hash pai no cabeçalho do bloco e a raiz da trie para garantir que as informações estejam corretas\\n- **Transaction Execution** - com o bloco já inicializado, o módulo de orquestração da transação executa cada transação válida de acordo com sua prioridade. O estado inicial não é armazenado em cache antes da execução, o que significa que, se uma das transações falhar no meio da execução, quaisquer alterações de estado confirmadas até aquele momento não podem ser revertidas, e o bloco subsequente será inválido. Consequentemente, a lógica de tempo de execução deve realizar todas as verificações necessárias para garantir que todas as transações válidas tenham sucesso\\n- **Finalizing a Block** - depois que todas as transações válidas enfileiradas forem executadas ou o limite do bloco for atingido, o módulo de orquestração chama em cada módulo de tempo de execução as funções `on_idle` e `on_finalize`. Essas duas funções permitem a definição de lógica de negócios extra que é executada automaticamente no processo de finalização do bloco. Depois que a última função `on_finalize` é chamada, o módulo de orquestração garante que o resumo do bloco e a raiz de armazenamento correspondam ao que foi calculado quando o bloco foi inicializado\\n\\n## Forkless Upgrades {: #forkless-upgrades}\\n\\nAs redes implantadas através do Tanssi têm um recurso emocionante: [atualizações sem bifurcação](https://docs.polkadot.com/develop/parachains/maintenance/runtime-upgrades/){target=\\_blank}. As atualizações sem bifurcação permitem que os desenvolvedores alterem a função de transição de estado que governa a cadeia sem criar uma bifurcação de rede, como visto no Ethereum várias vezes. Além disso, se a rede Tanssi for configurada com um sistema de governança on-chain, as atualizações para a rede podem acontecer de uma forma verdadeiramente descentralizada e sem confiança.\\n\\nAs atualizações sem bifurcação são possíveis ao armazenar a função de transição de estado como um blob WebAssembly (Wasm) na própria rede Tanssi e na rede com tecnologia Tanssi. Quando um novo tempo de execução é agendado por meio de uma chamada de função na rede com tecnologia Tanssi, a rede Tanssi valida este bloco, para que ele seja notificado e se prepare para validar os blocos recebidos usando a função de transição de estado mais recente. Após um
````
