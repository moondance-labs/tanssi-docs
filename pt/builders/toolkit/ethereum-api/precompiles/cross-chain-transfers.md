---
title: Native Cross-Chain Token Transfers
description: Learn how to use the XCM interface precompile to transfer tokens from any Tanssi-powered EVM network, leveraging their inherent native cross-chain capabilities.
categories: EVM-Template
---

````json
{
  "source_path": "builders/toolkit/ethereum-api/precompiles/cross-chain-transfers.md",
  "source_language": "EN",
  "target_language": "PT",
  "checksum": "a140cba99275b4cd3b6b63d8a7d40889904657d8c5a8005383fbd72899d33090",
  "content": "--- \ntitle: Native Cross-Chain Token Transfers\ndescription: Learn how to use the XCM interface precompile to transfer tokens from any Tanssi-powered EVM network, leveraging their inherent native cross-chain capabilities.\ncategories: EVM-Template\n---\n\n# Native Cross-Chain Token Transfers\n\n## Introduction {: #introduction }\n\nAs presented in the [Native Cross-Chain Communication](/learn/framework/xcm/){target=\\_blank} article from the Learn section, Tanssi-powered networks benefit from an inherent capability to communicate and interoperate with any other network in the ecosystem. This native cross-chain communication allows safe and fast token transfers leveraging the Cross-Consensus Message format (XCM for short), which facilitates communication between different consensus systems.\n\nThe communication protocol enabling token transfers is built on [Substrate](/learn/framework/overview/#substrate-framework){target=\\_blank} and runs on a lower level than the EVM, making it harder for EVM developers to access.\n\nNevertheless, EVM networks have an XCM precompile that fills the gap between execution layers, exposing a smart contract interface that abstracts away the underlying complexities, making the execution of cross-chain token transfers as easy as any other smart contract call.\n\nThis guide will show you how to interact with the [XCM Interface](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\\_blank} precompile to execute cross-chain token transfers through the Ethereum API.\n\nThe XCM precompile is located at the following address:\n\n```text\n{{networks.demo_evm.precompiles.xcm_interface }}\n```\n\n--8<-- 'text/builders/toolkit/ethereum-api/precompiles/security-note.md'\n\n## The XCM Solidity Interface {: #the-xcm-solidity-interface }\n\nThe [`XCMInterface.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\\_blank} interface on Tanssi EVM networks is a Solidity interface that allows developers to interact with the precompile's functions.\n\n??? code \"XCMInterface.sol\"\n\n    ```solidity\n    --8<-- 'code/builders/toolkit/ethereum-api/precompiles/xcm-interface/XcmInterface.sol'\n    ```\n\nThe interface includes the necessary data structures along with the following functions:\n\n???+ function \"**transferAssetsToPara20**(_paraId, beneficiary, assets, feeAssetItem, weight_) — sends assets to another EVM-compatible network using the underlying `transfer_assets()` transaction included in the XCM pallet module\"\n\n    === \"Parameters\"\n\n        - `paraId` ++\"uint32\"++ - the destination's network ID\n        - `beneficiary` ++\"address\"++ - the ECDSA-type account in the destination chain that will receive the tokens\n        - `assets` ++\"AssetAddressInfo[] memory\"++ - an array of assets to send\n        - `feeAssetItem` ++\"uint32\"++ - the index of the asset that will be used to pay fees\n        - `weight` ++\"Weight memory\"++- the maximum gas to use in the whole operation. Setting uint64::MAX to `refTime` acts in practice as *unlimited weight*\n\n    === \"Example\"\n\n        - `paraId` - 888\n        - `beneficiary` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217\n        - `assets` - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]\n        - `feeAssetItem` - 0\n        - `weight` - [9223372036854775807, 9223372036854775807]\n\n??? function \"**transferAssetsToPara32**(_paraId, beneficiary, assets,feeAssetItem, weight_) — sends assets to a Substrate network using the underlying `transfer_assets()` transaction included in the XCM pallet module\"\n\n    === \"Parameters\"\n\n        - `paraId` ++\"uint32\"++ - the destination's network ID\n        - `beneficiary` ++\"bytes32\"++ - the Substrate's SR25519-type account in the destination chain that will receive the tokens\n        - `assets` ++\"AssetAddressInfo[] memory\"++ - an array of assets to send\n        - `feeAssetItem` ++\"uint32\"++ - the index of the asset that will be used to pay fees\n        - `weight` ++\"Weight memory\"++ - the maximum gas to use in the whole operation. Setting uint64::MAX to `refTime` acts in practice as *unlimited weight*\n\n    === \"Example\"\n\n        - `paraId` - 888\n        - `beneficiary` - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06\n        - `assets` - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]\n        - `feeAssetItem` - 0\n        - `weight` - [9223372036854775807, 9223372036854775807]\n\n??? function \"**transferAssetsToRelay**(_beneficiary, assets, feeAssetItem, weight_) — sends assets to the relay chain using the underlying `transfer_assets()` transaction included in the XCM pallet module\"\n\n    === \"Parameters\"\n\n        - `beneficiary` ++\"bytes32\"++ - the Substrate's sr25519-type account in the relay chain that will receive the tokens\n        - `assets` ++\"AssetAddressInfo[] memory\"++ - an array of assets to send\n        - `feeAssetItem` ++\"uint32\"++ - the index of the asset that will be used to pay fees\n        - `weight` ++\"Weight memory\"++ - the maximum gas to use in the whole operation. Setting uint64::MAX to `refTime` acts in practice as *unlimited weight*\n\n    === \"Example\"\n\n        - `beneficiary` - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06\n        - `assets` - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]\n        - `feeAssetItem` - 0\n        - `weight` - [9223372036854775807, 9223372036854775807]\n\n??? function \"**transferAssetsLocation**(_dest, beneficiary, assets, feeAssetItem, weight_) — sends assets using the underlying `transfer_assets()` transaction included in the XCM pallet module\"\n\n    === \"Parameters\"\n        - `dest` ++\"Location memory\"++ - the destination chain\n        - `beneficiary` ++\"Location memory\"++ - the account in the destination chain that will receive the tokens\n        - `assets` ++\"AssetLocationInfo[] memory\"++ - an array of assets to send\n        - `feeAssetItem` ++\"uint32\"++ - the index of the asset that will be used to pay fees\n        - `weight` ++\"Weight memory\"++ - the maximum gas to use in the whole operation. Setting uint64::MAX to `refTime` acts in practice as *unlimited weight*\n\n    === \"Example\"\n        - `dest` - [\"1\",[]]\n        - `beneficiary` - [0, [\"0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600\"]]\n        - `assets` - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]\n        - `feeAssetItem` - 0\n        - `weight` - [9223372036854775807, 9223372036854775807]\n    \n## Interact with the Solidity Interface {: #interact-with-the-solidity-interface }\n\n### Checking Prerequisites {: #checking-prerequisites }\n\nTo follow along with this tutorial, you will need to have your wallet configured to work with your EVM network and an account funded with native tokens. You can add your EVM network to MetaMask with one click on the [Tanssi dApp](https://apps.tanssi.network){target=\\_blank}. Or, you can [configure MetaMask for Tanssi with the demo EVM network](/builders/toolkit/ethereum-api/wallets/metamask/){target=\\_blank}.\n\n!!! note\n    It is necessary to have previously established communication channels with the destination chain before using this precompile's functionality. To do so, refer to the [Manage Cross-Chain Communication Channels](/builders/manage/dapp/xcm-channels/){target=\\_blank} guide.\n    Also, if the token being transferred is native to your network, the destination chain must have registered the foreign asset.\n\n### Remix Set Up {: #remix-set-up }\n\nYou can interact with the XCM Interface precompile using [Remix](https://remix.ethereum.org){target=\\_blank}. To add the precompile to Remix, you will need to:\n\n1. Get a copy of [`XCMInterface.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\\_blank}\n2. Paste the file contents into a Remix file named `XcmInterface.sol`\n\n### Compile the Contract {: #compile-the-contract }\n\nNext, you will need to compile the interface in Remix:\n\n1. Click on the **Compile** tab, second from top\n2. Compile the interface by clicking on **Compile XCMInterface.sol**\n\n![Compiling XcmInterface.sol](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-1.webp)\n\nWhen the compilation is completed, you will see a green checkmark next to the **Compile** tab.\n\n### Access the Contract {: #access-the-contract }\n\nInstead of deploying the precompile, you will access the interface given the address of the precompiled contract:\n\n1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix. Please note that the precompiled contracts are already accessible at their respective addresses. Therefore, there is no deployment step\n2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** dropdown. Once you select **Injected Provider - Metamask**, you may be prompted by MetaMask to connect your account to Remix if it's not already connected\n3. Make sure the correct account is displayed under **ACCOUNT**\n4. Ensure **XCM - XCMInterface.sol** is selected in the **CONTRACT** dropdown. Given that it is a precompiled contract, there is no deployment step. Instead, you are going to provide the address of the precompile in the **At Address** field\n5. Provide the address of the precompile: `{{networks.demo_evm.precompiles.xcm_interface}}` and click **At Address**\n\n![Access the address](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-2.webp)\n\nThe **XCM Interface** precompile will appear in the list of **Deployed Contracts**.\n\n### Send Tokens Over to Another EVM-Compatible Network {: #transfer-to-evm-chains }\n\nTo send tokens over to an account in another EVM-compatible network, please follow these steps:\n\n1. Expand the **transferAssetsToPara20** function\n2. Enter the network ID (paraId)\n3. Enter the 20-bytes (Ethereum-like) destination account (beneficiary)\n4. Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer\n\n    --8<-- 'text/builders/toolkit/ethereum-api/precompiles/xcm-interface/erc-20-note.md'\n\n5. Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is `0`, the second is `1`, and so on \n6. Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (`refTime`) and the proof size (`proofSize`). In practice, setting refTime to `uint64::MAX` is equal to *unlimited weight*\n7. Click **transact**\n8. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction\n\n![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-3.webp)\n\nAfter the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.\n\n### Send Tokens Over to a Substrate Network {: #transfer-to-substrate-chains }\n\nTo send tokens over to an account in a Substrate network, please follow these steps:\n\n1. Expand the **transferAssetsToPara32** function\n2. Enter the network ID (`paraId`)\n3. Enter the sr25519-type destination account (beneficiary)\n4. Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer\n    \n    --8<-- 'text/builders/toolkit/ethereum-api/precompiles/xcm-interface/erc-20-note.md'\n\n5. Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is `0`, the second is `1`, and so on \n6. Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to `uint64::MAX` is equal to *unlimited weight*\n7. Click **transact**\n8. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction\n\n![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-4.webp)\n\nAfter the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.\n\n### Send Tokens Over to the Relay Chain {: #transfer-to-relay-chain }\n\nTo send tokens over to an account in the relay chain, please follow these steps:\n\n1. Expand the **transferAssetsToRelay** function\n2. Enter the sr25519-type destination account (beneficiary)\n3. Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset. Each asset is specified by its address and the total amount to transfer\n    \n    --8<-- 'text/builders/toolkit/ethereum-api/precompiles/xcm-interface/erc-20-note.md'\n\n4. Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is `0`, the second is `1`, and so on \n5. Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to `uint64::MAX` is equal to *unlimited weight*\n6. Click **transact**\n7. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction\n\n![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-5.webp)\n\nAfter the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.\n\n### Send Tokens Over Specific Locations {: #transfer-locations }\n\nThis function is more generic than the others, allowing the destination chain, destination account, and assets to be specified using [XCM Multilocations](/learn/framework/xcm/#message-destinations){target=\\_blank}.\nTo send tokens to specific locations, please follow these steps:\n\n1. Expand the **transferAssetsLocation** function\n2. Enter the multilocation that specifies the destination chain. Note that any chain can be specified, regardless of its configuration or type\n3. Enter the Multilocation that specifies the destination account. Note that any account can be specified, regardless of its type (ECDSA, sr25519, or any other)\n4. Specify the tokens to be transferred. Note that this parameter is an array that contains at least one asset and each asset is specified by its Multilocation and the total amount to transfer\n    \n    --8<-- 'text/builders/toolkit/ethereum-api/precompiles/xcm-interface/erc-20-note.md'\n\n5. Enter the index of the asset that will be used to pay the fees. This index is zero-based, so the first element is `0`, the second is `1`, and so on \n6. Enter the maximum gas to pay for the transaction. This gas is derived from two parameters, the processing time (refTime) and the proof size (proofSize). In practice, setting refTime to `uint64::MAX` is equal to *unlimited weight*\n7. Click **transact**\n8. MetaMask will pop up, and you will be prompted to review the transaction details. Click **Confirm** to send the transaction\n\n![Confirm Approve Transaction](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-6.webp)\n\nAfter the transaction is confirmed, wait for a few blocks for the transfer to reach the destination chain and reflect the new balance.\n\n--8<-- 'text/_disclaimers/third-party-content.md'\n",
  "translated_content": "--- \ntitle: Transferências de Tokens Cross-Chain Nativas\ndescription: Aprenda como usar a pré-compilação da interface XCM para transferir tokens de qualquer rede EVM com tecnologia Tanssi, aproveitando seus recursos nativos de cross-chain.\ncategories: EVM-Template\n---\n\n# Transferências de Tokens Cross-Chain Nativas\n\n## Introdução {: #introduction }\n\nComo apresentado no artigo [Comunicação Cross-Chain Nativa](/learn/framework/xcm/){target=\\_blank} da seção Aprender, as redes com tecnologia Tanssi se beneficiam de uma capacidade inerente de se comunicar e interoperar com qualquer outra rede no ecossistema. Essa comunicação cross-chain nativa permite transferências de tokens seguras e rápidas, aproveitando o formato de Mensagem Cross-Consensus (XCM, em resumo), que facilita a comunicação entre diferentes sistemas de consenso.\n\nO protocolo de comunicação que permite as transferências de tokens é construído em [Substrate](/learn/framework/overview/#substrate-framework){target=\\_blank} e é executado em um nível inferior ao da EVM, tornando-o mais difícil de ser acessado por desenvolvedores EVM.\n\nNo entanto, as redes EVM possuem uma pré-compilação XCM que preenche a lacuna entre as camadas de execução, expondo uma interface de contrato inteligente que abstrai as complexidades subjacentes, tornando a execução de transferências de tokens cross-chain tão fácil quanto qualquer outra chamada de contrato inteligente.\n\nEste guia mostrará como interagir com a pré-compilação [Interface XCM](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\\_blank} para executar transferências de tokens cross-chain por meio da API Ethereum.\n\nA pré-compilação XCM está localizada no seguinte endereço:\n\n```text\n{{networks.demo_evm.precompiles.xcm_interface }}\n```\n\n--8<-- 'text/builders/toolkit/ethereum-api/precompiles/security-note.md'\n\n## A Interface Solidity XCM {: #the-xcm-solidity-interface }\n\nA interface [`XCMInterface.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\\_blank} em redes EVM Tanssi é uma interface Solidity que permite aos desenvolvedores interagir com as funções da pré-compilação.\n\n??? code \"XCMInterface.sol\"\n\n    ```solidity\n    --8<-- 'code/builders/toolkit/ethereum-api/precompiles/xcm-interface/XcmInterface.sol'\n    ```\n\nA interface inclui as estruturas de dados necessárias, juntamente com as seguintes funções:\n\n???+ function \"**transferAssetsToPara20**(_paraId, beneficiary, assets, feeAssetItem, weight_) — envia ativos para outra rede compatível com EVM usando a transação `transfer_assets()` subjacente incluída no módulo de palete XCM\"\n\n    === \"Parâmetros\"\n\n        - `paraId` ++\"uint32\"++ - o ID da rede de destino\n        - `beneficiary` ++\"address\"++ - a conta do tipo ECDSA na cadeia de destino que receberá os tokens\n        - `assets` ++\"AssetAddressInfo[] memory\"++ - uma matriz de ativos a serem enviados\n        - `feeAssetItem` ++\"uint32\"++ - o índice do ativo que será usado para pagar as taxas\n        - `weight` ++\"Weight memory\"++- o gás máximo a ser usado em toda a operação. Definir uint64::MAX para `refTime` atua na prática como *peso ilimitado*\n\n    === \"Exemplo\"\n\n        - `paraId` - 888\n        - `beneficiary` - 0x3f0Aef9Bd799F1291b80376aD57530D353ab0217\n        - `assets` - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]\n        - `feeAssetItem` - 0\n        - `weight` - [9223372036854775807, 9223372036854775807]\n\n??? function \"**transferAssetsToPara32**(_paraId, beneficiary, assets,feeAssetItem, weight_) — envia ativos para uma rede Substrate usando a transação `transfer_assets()` subjacente incluída no módulo de palete XCM\"\n\n    === \"Parâmetros\"\n\n        - `paraId` ++\"uint32\"++ - o ID da rede de destino\n        - `beneficiary` ++\"bytes32\"++ - a conta do tipo SR25519 da Substrate na cadeia de destino que receberá os tokens\n        - `assets` ++\"AssetAddressInfo[] memory\"++ - uma matriz de ativos a serem enviados\n        - `feeAssetItem` ++\"uint32\"++ - o índice do ativo que será usado para pagar as taxas\n        - `weight` ++\"Weight memory\"++ - o gás máximo a ser usado em toda a operação. Definir uint64::MAX para `refTime` atua na prática como *peso ilimitado*\n\n    === \"Exemplo\"\n\n        - `paraId` - 888\n        - `beneficiary` - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06\n        - `assets` - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]\n        - `feeAssetItem` - 0\n        - `weight` - [9223372036854775807, 9223372036854775807]\n\n??? function \"**transferAssetsToRelay**(_beneficiary, assets, feeAssetItem, weight_) — envia ativos para a cadeia de retransmissão usando a transação `transfer_assets()` subjacente incluída no módulo de palete XCM\"\n\n    === \"Parâmetros\"\n\n        - `beneficiary` ++\"bytes32\"++ - a conta do tipo sr25519 da Substrate na cadeia de retransmissão que receberá os tokens\n        - `assets` ++\"AssetAddressInfo[] memory\"++ - uma matriz de ativos a serem enviados\n        - `feeAssetItem` ++\"uint32\"++ - o índice do ativo que será usado para pagar as taxas\n        - `weight` ++\"Weight memory\"++ - o gás máximo a ser usado em toda a operação. Definir uint64::MAX para `refTime` atua na prática como *peso ilimitado*\n\n    === \"Exemplo\"\n\n        - `beneficiary` - 0xf831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a06\n        - `assets` - [[\"0x0000000000000000000000000000000000000800\", 1000000000000000000]]\n        - `feeAssetItem` - 0\n        - `weight` - [9223372036854775807, 9223372036854775807]\n\n??? function \"**transferAssetsLocation**(_dest, beneficiary, assets, feeAssetItem, weight_) — envia ativos usando a transação `transfer_assets()` subjacente incluída no módulo de palete XCM\"\n\n    === \"Parâmetros\"\n        - `dest` ++\"Location memory\"++ - a cadeia de destino\n        - `beneficiary` ++\"Location memory\"++ - a conta na cadeia de destino que receberá os tokens\n        - `assets` ++\"AssetLocationInfo[] memory\"++ - uma matriz de ativos a serem enviados\n        - `feeAssetItem` ++\"uint32\"++ - o índice do ativo que será usado para pagar as taxas\n        - `weight` ++\"Weight memory\"++ - o gás máximo a ser usado em toda a operação. Definir uint64::MAX para `refTime` atua na prática como *peso ilimitado*\n\n    === \"Exemplo\"\n        - `dest` - [\"1\",[]]\n        - `beneficiary` - [0, [\"0x01f831d83025f527daeed39a644d64d335a4e627b5f4becc78fb67f05976889a0600\"]]\n        - `assets` - [[[1, [\"0x010000000000000000000000000000000000000800\"]], 1000000000000000000]]\n        - `feeAssetItem` - 0\n        - `weight` - [9223372036854775807, 9223372036854775807]\n    \n## Interaja com a Interface Solidity {: #interact-with-the-solidity-interface }\n\n### Verificando os Pré-requisitos {: #checking-prerequisites }\n\nPara acompanhar este tutorial, você precisará ter sua carteira configurada para funcionar com sua rede EVM e uma conta financiada com tokens nativos. Você pode adicionar sua rede EVM ao MetaMask com um clique no [Tanssi dApp](https://apps.tanssi.network){target=\\_blank}. Ou, você pode [configurar o MetaMask para Tanssi com a rede EVM de demonstração](/builders/toolkit/ethereum-api/wallets/metamask/){target=\\_blank}.\n\n!!! note\n    É necessário ter estabelecido previamente canais de comunicação com a cadeia de destino antes de usar a funcionalidade desta pré-compilação. Para fazer isso, consulte o guia [Gerenciar Canais de Comunicação Cross-Chain](/builders/manage/dapp/xcm-channels/){target=\\_blank}.\n    Além disso, se o token a ser transferido for nativo da sua rede, a cadeia de destino deve ter registrado o ativo estrangeiro.\n\n### Configuração do Remix {: #remix-set-up }\n\nVocê pode interagir com a pré-compilação da Interface XCM usando o [Remix](https://remix.ethereum.org){target=\\_blank}. Para adicionar a pré-compilação ao Remix, você precisará:\n\n1. Obter uma cópia de [`XCMInterface.sol`](https://github.com/moondance-labs/tanssi/blob/master/test/contracts/solidity/XcmInterface.sol){target=\\_blank}\n2. Cole o conteúdo do arquivo em um arquivo do Remix chamado `XcmInterface.sol`\n\n### Compile o Contrato {: #compile-the-contract }\n\nEm seguida, você precisará compilar a interface no Remix:\n\n1. Clique na guia **Compilar**, a segunda de cima\n2. Compile a interface clicando em **Compilar XCMInterface.sol**\n\n![Compilando XcmInterface.sol](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-1.webp)\n\nQuando a compilação for concluída, você verá uma marca de seleção verde ao lado da guia **Compilar**.\n\n### Acesse o Contrato {: #access-the-contract }\n\nEm vez de implantar a pré-compilação, você acessará a interface, dado o endereço do contrato pré-compilado:\n\n1. Clique na guia **Implantar e Executar** diretamente abaixo da guia **Compilar** no Remix. Observe que os contratos pré-compilados já estão acessíveis em seus respectivos endereços. Portanto, não há etapa de implantação\n2. Certifique-se de que **Provedor Injetado - Metamask** esteja selecionado no menu suspenso **AMBIENTE**. Depois de selecionar **Provedor Injetado - Metamask**, você pode ser solicitado pelo MetaMask a conectar sua conta ao Remix, caso ela ainda não esteja conectada\n3. Certifique-se de que a conta correta seja exibida em **CONTA**\n4. Certifique-se de que **XCM - XCMInterface.sol** esteja selecionado no menu suspenso **CONTRATO**. Dado que é um contrato pré-compilado, não há etapa de implantação. Em vez disso, você fornecerá o endereço da pré-compilação no campo **No Endereço**\n5. Forneça o endereço da pré-compilação: `{{networks.demo_evm.precompiles.xcm_interface}}` e clique em **No Endereço**\n\n![Acesse o endereço](/images/builders/toolkit/ethereum-api/precompiles/xcm-interface/xcm-interface-2.webp)\n\nA pré-compilação da **Interface XCM** aparecerá na lista de **Contratos Implantados**.\n\n### Envie Tokens para Outra Rede Compatível com EVM {: #transfer-to-evm-chains }\n\nPara enviar tokens para uma conta em outra rede compatível com EVM, siga estas etapas:\n\n1. Expanda a função **transferAssetsToPara20**\n2. Insira o ID







```text

```

````

```solidity

```

````



    ```solidity

    ```
